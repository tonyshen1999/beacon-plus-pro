{"ast":null,"code":"/**\r\n * DevExtreme (esm/viz/axes/tick.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { isDefined } from \"../../core/utils/type\";\nimport { extend } from \"../../core/utils/extend\";\nimport { Deferred } from \"../../core/utils/deferred\";\n\nfunction getPathStyle(options) {\n  return {\n    stroke: options.color,\n    \"stroke-width\": options.width,\n    \"stroke-opacity\": options.opacity,\n    opacity: 1\n  };\n}\n\nfunction createTick(axis, renderer, tickOptions, gridOptions, skippedCategory, skipLabels, offset) {\n  var tickOffset = offset || axis._tickOffset;\n  var lineGroup = axis._axisLineGroup;\n  var elementsGroup = axis._axisElementsGroup;\n  var tickStyle = getPathStyle(tickOptions);\n  var gridStyle = getPathStyle(gridOptions);\n  var emptyStrRegExp = /^\\s+$/;\n  var axisOptions = axis.getOptions();\n  var labelOptions = axisOptions.label;\n  var labelStyle = axis._textOptions;\n\n  function getLabelFontStyle(tick) {\n    var fontStyle = axis._textFontStyles;\n    var customizeColor = labelOptions.customizeColor;\n\n    if (customizeColor && customizeColor.call) {\n      fontStyle = extend({}, axis._textFontStyles, {\n        fill: customizeColor.call(tick, tick)\n      });\n    }\n\n    return fontStyle;\n  }\n\n  function createLabelHint(tick, range) {\n    var labelHint = axis.formatHint(tick.value, labelOptions, range);\n\n    if (isDefined(labelHint) && \"\" !== labelHint) {\n      tick.getContentContainer().setTitle(labelHint);\n    }\n  }\n\n  return function (value) {\n    var tick = {\n      value: value,\n      updateValue: function updateValue(newValue) {\n        this.value = value = newValue;\n      },\n      initCoords: function initCoords() {\n        this.coords = axis._getTranslatedValue(value, tickOffset);\n        this.labelCoords = axis._getTranslatedValue(value);\n      },\n      saveCoords: function saveCoords() {\n        this._lastStoredCoordinates = {\n          coords: this._storedCoords,\n          labelCoords: this._storedLabelsCoords\n        };\n        this._storedCoords = this.coords;\n        this._storedLabelsCoords = this.templateContainer ? this._getTemplateCoords() : this.labelCoords;\n      },\n      resetCoordinates: function resetCoordinates() {\n        if (this._lastStoredCoordinates) {\n          this._storedCoords = this._lastStoredCoordinates.coords;\n          this._storedLabelsCoords = this._lastStoredCoordinates.labelCoords;\n        }\n      },\n      drawMark: function drawMark(options) {\n        if (!tickOptions.visible || skippedCategory === value) {\n          return;\n        }\n\n        if (axis.areCoordsOutsideAxis(this.coords)) {\n          return;\n        }\n\n        if (this.mark) {\n          this.mark.append(lineGroup);\n          axis.sharp(this.mark, axis.getSharpDirectionByCoords(this.coords));\n          this.updateTickPosition(options);\n        } else {\n          this.mark = axis._createPathElement([], tickStyle, axis.getSharpDirectionByCoords(this.coords)).append(lineGroup);\n          this.updateTickPosition(options);\n        }\n      },\n      setSkippedCategory: function setSkippedCategory(category) {\n        skippedCategory = category;\n      },\n      _updateLine: function _updateLine(lineElement, settings, storedSettings, animate, isGridLine) {\n        if (!lineElement) {\n          return;\n        }\n\n        if (null === settings.points || null === settings.r) {\n          lineElement.remove();\n          return;\n        }\n\n        if (animate && storedSettings && null !== storedSettings.points) {\n          settings.opacity = 1;\n          lineElement.attr(storedSettings);\n          lineElement.animate(settings);\n        } else {\n          settings.opacity = animate ? 0 : 1;\n          lineElement.attr(settings);\n          animate && lineElement.animate({\n            opacity: 1\n          }, {\n            delay: .5,\n            partitionDuration: .5\n          });\n        }\n\n        this.coords.angle && axis._rotateTick(lineElement, this.coords, isGridLine);\n      },\n      updateTickPosition: function updateTickPosition(options, animate) {\n        this._updateLine(this.mark, {\n          points: axis._getTickMarkPoints(tick.coords, tickOptions.length, options)\n        }, this._storedCoords && {\n          points: axis._getTickMarkPoints(tick._storedCoords, tickOptions.length, options)\n        }, animate, false);\n      },\n      drawLabel: function drawLabel(range, template) {\n        var _this = this;\n\n        if (this.templateContainer && axis.isRendered()) {\n          this.updateLabelPosition();\n          return;\n        }\n\n        var labelIsVisible = labelOptions.visible && !skipLabels && !axis.getTranslator().getBusinessRange().isEmpty() && !axis.areCoordsOutsideAxis(this.labelCoords);\n\n        if (!labelIsVisible) {\n          if (this.label) {\n            this.removeLabel();\n          }\n\n          return;\n        }\n\n        var templateOption = labelOptions.template;\n        var text = axis.formatLabel(value, labelOptions, range);\n\n        if (this.label) {\n          this.label.attr({\n            text: text,\n            rotate: 0\n          }).append(elementsGroup);\n          createLabelHint(this, range);\n          this.updateLabelPosition();\n          return;\n        }\n\n        if (templateOption) {\n          this.templateContainer = renderer.g().append(elementsGroup);\n          this._templateDef && this._templateDef.reject();\n          this._templateDef = new Deferred();\n          template.render({\n            model: {\n              valueText: text,\n              value: this.value,\n              labelFontStyle: getLabelFontStyle(this),\n              labelStyle: labelStyle\n            },\n            container: this.templateContainer.element,\n            onRendered: function onRendered() {\n              _this.updateLabelPosition();\n\n              _this._templateDef && _this._templateDef.resolve();\n            }\n          });\n        } else if (isDefined(text) && \"\" !== text && !emptyStrRegExp.test(text)) {\n          this.label = renderer.text(text).css(getLabelFontStyle(this)).attr(labelStyle).append(elementsGroup);\n          this.updateLabelPosition();\n          createLabelHint(this, range);\n        }\n\n        var containerForData = this.getContentContainer();\n        containerForData && containerForData.data(\"chart-data-argument\", this.value);\n        this.templateContainer && createLabelHint(this, range);\n      },\n      getTemplateDeferred: function getTemplateDeferred() {\n        return this._templateDef;\n      },\n      getContentContainer: function getContentContainer() {\n        return this.templateContainer || this.label;\n      },\n      fadeOutElements: function fadeOutElements() {\n        var startSettings = {\n          opacity: 1\n        };\n        var endSettings = {\n          opacity: 0\n        };\n        var animationSettings = {\n          partitionDuration: .5\n        };\n\n        if (this.getContentContainer()) {\n          this._fadeOutLabel();\n        }\n\n        if (this.grid) {\n          this.grid.append(axis._axisGridGroup).attr(startSettings).animate(endSettings, animationSettings);\n        }\n\n        if (this.mark) {\n          this.mark.append(axis._axisLineGroup).attr(startSettings).animate(endSettings, animationSettings);\n        }\n      },\n      _fadeInLabel: function _fadeInLabel() {\n        var group = axis._renderer.g().attr({\n          opacity: 0\n        }).append(axis._axisElementsGroup).animate({\n          opacity: 1\n        }, {\n          delay: .5,\n          partitionDuration: .5\n        });\n\n        this.getContentContainer().append(group);\n      },\n      _fadeOutLabel: function _fadeOutLabel() {\n        var group = axis._renderer.g().attr({\n          opacity: 1\n        }).animate({\n          opacity: 0\n        }, {\n          partitionDuration: .5\n        }).append(axis._axisElementsGroup).toBackground();\n\n        this.getContentContainer().append(group);\n      },\n      _getTemplateCoords: function _getTemplateCoords() {\n        return axis._getLabelAdjustedCoord(this, (axis._constantLabelOffset || 0) + (tick.labelOffset || 0));\n      },\n      updateLabelPosition: function updateLabelPosition(animate) {\n        var templateContainer = this.templateContainer;\n\n        if (!this.getContentContainer()) {\n          return;\n        }\n\n        if (animate && this._storedLabelsCoords) {\n          if (templateContainer) {\n            templateContainer.attr(this._storedLabelsCoords);\n\n            var lCoords = this._getTemplateCoords();\n\n            templateContainer.animate(lCoords);\n          } else {\n            this.label.attr({\n              x: this._storedLabelsCoords.x,\n              y: this._storedLabelsCoords.y\n            });\n            this.label.animate({\n              x: this.labelCoords.x,\n              y: this.labelCoords.y\n            });\n          }\n        } else {\n          if (templateContainer) {\n            var _lCoords = this._getTemplateCoords();\n\n            templateContainer.attr(_lCoords);\n          } else {\n            this.label.attr({\n              x: this.labelCoords.x,\n              y: this.labelCoords.y\n            });\n          }\n\n          if (animate) {\n            this._fadeInLabel();\n          }\n        }\n      },\n      updateMultilineTextAlignment: function updateMultilineTextAlignment() {\n        if (labelOptions.template || !this.label) {\n          return;\n        }\n\n        this.label.attr({\n          textsAlignment: this.labelAlignment || axis.getOptions().label.alignment\n        });\n      },\n      drawGrid: function drawGrid(drawLine) {\n        if (gridOptions.visible && skippedCategory !== this.value) {\n          if (this.grid) {\n            this.grid.append(axis._axisGridGroup);\n            axis.sharp(this.grid, axis.getSharpDirectionByCoords(this.coords));\n            this.updateGridPosition();\n          } else {\n            this.grid = drawLine(this, gridStyle);\n            this.grid && this.grid.append(axis._axisGridGroup);\n          }\n        }\n      },\n      updateGridPosition: function updateGridPosition(animate) {\n        this._updateLine(this.grid, axis._getGridPoints(tick.coords), this._storedCoords && axis._getGridPoints(this._storedCoords), animate, true);\n      },\n      removeLabel: function removeLabel() {\n        var contentContainer = this.getContentContainer();\n        contentContainer && contentContainer.remove();\n        this._templateDef && this._templateDef.reject();\n        this._templateDef = this.templateContainer = this.label = null;\n      }\n    };\n    return tick;\n  };\n}\n\nexport { createTick as tick };","map":null,"metadata":{},"sourceType":"module"}