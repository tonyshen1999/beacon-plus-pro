{"ast":null,"code":"/**\r\n * DevExtreme (esm/viz/pie_chart.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport consts from \"./components/consts\";\nimport { normalizeAngle, getVerticallyShiftedAngularCoords as _getVerticallyShiftedAngularCoords, patchFontOptions } from \"./core/utils\";\nimport { extend as _extend } from \"../core/utils/extend\";\nimport { isNumeric } from \"../core/utils/type\";\nimport { each as _each } from \"../core/utils/iterator\";\nimport { Range } from \"./translators/range\";\nimport registerComponent from \"../core/component_registrator\";\nimport { BaseChart, overlapping } from \"./chart_components/base_chart\";\nimport { noop as _noop } from \"../core/utils/common\";\nimport { Translator1D } from \"./translators/translator1d\";\nvar states = consts.states;\nvar seriesSpacing = consts.pieSeriesSpacing;\nvar OPTIONS_FOR_REFRESH_SERIES = [\"startAngle\", \"innerRadius\", \"segmentsDirection\", \"type\"];\nvar NORMAL_STATE = states.normalMark;\nvar HOVER_STATE = states.hoverMark;\nvar SELECTED_STATE = states.selectedMark;\nvar MAX_RESOLVE_ITERATION_COUNT = 5;\nvar LEGEND_ACTIONS = [states.resetItem, states.applyHover, states.applySelected, states.applySelected];\n\nfunction getLegendItemAction(points) {\n  var state = NORMAL_STATE;\n  points.forEach(function (point) {\n    var _point$series;\n\n    var seriesOptions = null === (_point$series = point.series) || void 0 === _point$series ? void 0 : _point$series.getOptions();\n    var pointState = point.fullState;\n\n    if (\"none\" === (null === seriesOptions || void 0 === seriesOptions ? void 0 : seriesOptions.hoverMode)) {\n      pointState &= ~HOVER_STATE;\n    }\n\n    if (\"none\" === (null === seriesOptions || void 0 === seriesOptions ? void 0 : seriesOptions.selectionMode)) {\n      pointState &= ~SELECTED_STATE;\n    }\n\n    state |= pointState;\n  });\n  return LEGEND_ACTIONS[state];\n}\n\nfunction correctPercentValue(value) {\n  if (isNumeric(value)) {\n    if (value > 1) {\n      value = 1;\n    } else if (value < 0) {\n      value = 0;\n    }\n  } else {\n    value = void 0;\n  }\n\n  return value;\n}\n\nvar pieSizeEqualizer = function () {\n  function removeFromList(list, item) {\n    return list.filter(function (li) {\n      return li !== item;\n    });\n  }\n\n  var pies = [];\n  var timers = {};\n  return {\n    queue: function queue(pie) {\n      var group = pie.getSizeGroup();\n      pies = (list = pies, item = pie, removeFromList(list, item).concat(item));\n      var list, item;\n      clearTimeout(timers[group]);\n      timers[group] = setTimeout(function () {\n        !function (group, allPies) {\n          var pies = allPies.filter(function (p) {\n            return p._isVisible() && p.getSizeGroup() === group;\n          });\n          var minRadius = Math.min.apply(null, pies.map(function (p) {\n            return p.getSizeGroupLayout().radius;\n          }));\n          var minPie = pies.filter(function (p) {\n            return p.getSizeGroupLayout().radius === minRadius;\n          });\n          pies.forEach(function (p) {\n            return p.render({\n              force: true,\n              sizeGroupLayout: minPie.length ? minPie[0].getSizeGroupLayout() : {}\n            });\n          });\n        }(group, pies);\n      });\n    },\n    remove: function remove(pie) {\n      pies = removeFromList(pies, pie);\n\n      if (!pies.length) {\n        timers = {};\n      }\n    }\n  };\n}();\n\nvar dxPieChart = BaseChart.inherit({\n  _themeSection: \"pie\",\n  _layoutManagerOptions: function _layoutManagerOptions() {\n    return _extend(true, {}, this.callBase(), {\n      piePercentage: correctPercentValue(this._themeManager.getOptions(\"diameter\")),\n      minPiePercentage: correctPercentValue(this._themeManager.getOptions(\"minDiameter\"))\n    });\n  },\n  _customChangesOrder: [\"CENTER_TEMPLATE\"],\n  _optionChangesMap: {\n    diameter: \"REINIT\",\n    minDiameter: \"REINIT\",\n    sizeGroup: \"REINIT\",\n    centerTemplate: \"CENTER_TEMPLATE\"\n  },\n  _change_CENTER_TEMPLATE: function _change_CENTER_TEMPLATE() {\n    this._renderCenterTemplate();\n  },\n  _disposeCore: function _disposeCore() {\n    pieSizeEqualizer.remove(this);\n    this.callBase();\n\n    this._centerTemplateGroup.linkOff().dispose();\n  },\n  _groupSeries: function _groupSeries() {\n    var series = this.series;\n    this._groupsData = {\n      groups: [{\n        series: series,\n        valueOptions: {\n          valueType: \"numeric\"\n        }\n      }],\n      argumentOptions: series[0] && series[0].getOptions()\n    };\n  },\n  getArgumentAxis: function getArgumentAxis() {\n    return null;\n  },\n  _getValueAxis: function _getValueAxis() {\n    var translator = new Translator1D().setCodomain(360, 0);\n    return {\n      getTranslator: function getTranslator() {\n        return translator;\n      },\n      setBusinessRange: function setBusinessRange(range) {\n        translator.setDomain(range.min, range.max);\n      }\n    };\n  },\n  _populateBusinessRange: function _populateBusinessRange() {\n    this.series.map(function (series) {\n      var range = new Range();\n      range.addRange(series.getRangeData().val);\n      series.getValueAxis().setBusinessRange(range);\n      return range;\n    });\n  },\n  _specialProcessSeries: function _specialProcessSeries() {\n    _each(this.series, function (_, singleSeries) {\n      singleSeries.arrangePoints();\n    });\n  },\n  _checkPaneName: function _checkPaneName() {\n    return true;\n  },\n  _processSingleSeries: function _processSingleSeries(singleSeries) {\n    this.callBase(singleSeries);\n    singleSeries.arrangePoints();\n  },\n  _handleSeriesDataUpdated: function _handleSeriesDataUpdated() {\n    var maxPointCount = 0;\n    this.series.forEach(function (s) {\n      maxPointCount = Math.max(s.getPointsCount(), maxPointCount);\n    });\n    this.series.forEach(function (s) {\n      s.setMaxPointsCount(maxPointCount);\n    });\n    this.callBase();\n  },\n  _getLegendOptions: function _getLegendOptions(item) {\n    var legendItem = this.callBase(item);\n    var legendData = legendItem.legendData;\n    legendData.argument = item.argument;\n    legendData.argumentIndex = item.argumentIndex;\n    legendData.points = [item];\n    return legendItem;\n  },\n  _getLegendTargets: function _getLegendTargets() {\n    var that = this;\n    var itemsByArgument = {};\n    (that.series || []).forEach(function (series) {\n      series.getPoints().forEach(function (point) {\n        var argument = point.argument.valueOf();\n        var index = series.getPointsByArg(argument).indexOf(point);\n        var key = argument.valueOf().toString() + index;\n        itemsByArgument[key] = itemsByArgument[key] || [];\n        var argumentCount = itemsByArgument[key].push(point);\n        point.index = itemsByArgument[key][argumentCount - 2] ? itemsByArgument[key][argumentCount - 2].index : Object.keys(itemsByArgument).length - 1;\n        point.argumentIndex = index;\n      });\n    });\n    var items = [];\n\n    _each(itemsByArgument, function (_, points) {\n      points.forEach(function (point, index) {\n        if (0 === index) {\n          items.push(that._getLegendOptions(point));\n          return;\n        }\n\n        var item = items[items.length - 1];\n        item.legendData.points.push(point);\n\n        if (!item.visible) {\n          item.visible = point.isVisible();\n        }\n      });\n    });\n\n    return items;\n  },\n  _getLayoutTargets: function _getLayoutTargets() {\n    return [{\n      canvas: this._canvas\n    }];\n  },\n  _getLayoutSeries: function _getLayoutSeries(series, drawOptions) {\n    var layout;\n    var canvas = this._canvas;\n    var drawnLabels = false;\n    layout = this.layoutManager.applyPieChartSeriesLayout(canvas, series, true);\n    series.forEach(function (singleSeries) {\n      singleSeries.correctPosition(layout, canvas);\n      drawnLabels = singleSeries.drawLabelsWOPoints() || drawnLabels;\n    });\n\n    if (drawnLabels) {\n      layout = this.layoutManager.applyPieChartSeriesLayout(canvas, series, drawOptions.hideLayoutLabels);\n    }\n\n    series.forEach(function (singleSeries) {\n      singleSeries.hideLabels();\n    });\n    this._sizeGroupLayout = {\n      x: layout.centerX,\n      y: layout.centerY,\n      radius: layout.radiusOuter,\n      drawOptions: drawOptions\n    };\n    return layout;\n  },\n  _getLayoutSeriesForEqualPies: function _getLayoutSeriesForEqualPies(series, sizeGroupLayout) {\n    var canvas = this._canvas;\n    var layout = this.layoutManager.applyEqualPieChartLayout(series, sizeGroupLayout);\n    series.forEach(function (s) {\n      s.correctPosition(layout, canvas);\n      s.drawLabelsWOPoints();\n    });\n    this.layoutManager.correctPieLabelRadius(series, layout, canvas);\n    return layout;\n  },\n  _updateSeriesDimensions: function _updateSeriesDimensions(drawOptions) {\n    var visibleSeries = this._getVisibleSeries();\n\n    var lengthVisibleSeries = visibleSeries.length;\n    var innerRad;\n    var delta;\n    var layout;\n    var sizeGroupLayout = drawOptions.sizeGroupLayout;\n\n    if (lengthVisibleSeries) {\n      layout = sizeGroupLayout ? this._getLayoutSeriesForEqualPies(visibleSeries, sizeGroupLayout) : this._getLayoutSeries(visibleSeries, drawOptions);\n      delta = (layout.radiusOuter - layout.radiusInner - seriesSpacing * (lengthVisibleSeries - 1)) / lengthVisibleSeries;\n      innerRad = layout.radiusInner;\n\n      this._setGeometry(layout);\n\n      visibleSeries.forEach(function (singleSeries) {\n        singleSeries.correctRadius({\n          radiusInner: innerRad,\n          radiusOuter: innerRad + delta\n        });\n        innerRad += delta + seriesSpacing;\n      });\n    }\n  },\n  _renderSeries: function _renderSeries(drawOptions, isRotated, isLegendInside) {\n    this._calculateSeriesLayout(drawOptions, isRotated);\n\n    if (!drawOptions.sizeGroupLayout && this.getSizeGroup()) {\n      pieSizeEqualizer.queue(this);\n\n      this._clearCanvas();\n\n      return;\n    }\n\n    this._renderSeriesElements(drawOptions, isLegendInside);\n  },\n  _createHtmlStructure: function _createHtmlStructure() {\n    this.callBase();\n    this._centerTemplateGroup = this._renderer.g().attr({\n      class: \"dxc-hole-template\"\n    }).linkOn(this._renderer.root, \"center-template\").css(patchFontOptions(this._themeManager._font)).linkAppend();\n  },\n  _renderExtraElements: function _renderExtraElements() {\n    this._requestChange([\"CENTER_TEMPLATE\"]);\n  },\n  _renderCenterTemplate: function _renderCenterTemplate() {\n    var _this = this;\n\n    var template = this.option(\"centerTemplate\");\n\n    var centerTemplateGroup = this._centerTemplateGroup.clear();\n\n    if (!template) {\n      return;\n    }\n\n    centerTemplateGroup.attr({\n      visibility: \"hidden\"\n    });\n    template = this._getTemplate(template);\n    template.render({\n      model: this,\n      container: centerTemplateGroup.element,\n      onRendered: function onRendered() {\n        var group = centerTemplateGroup;\n        var bBox = group.getBBox();\n        group.move(_this._center.x - (bBox.x + bBox.width / 2), _this._center.y - (bBox.y + bBox.height / 2));\n        group.attr({\n          visibility: \"visible\"\n        });\n      }\n    });\n  },\n  getInnerRadius: function getInnerRadius() {\n    return this._innerRadius;\n  },\n  _getLegendCallBack: function _getLegendCallBack() {\n    var that = this;\n    var legend = this._legend;\n\n    var items = this._getLegendTargets().map(function (i) {\n      return i.legendData;\n    });\n\n    return function (target) {\n      items.forEach(function (data) {\n        var points = [];\n        var callback = legend.getActionCallback({\n          index: data.id\n        });\n        that.series.forEach(function (series) {\n          var seriesPoints = series.getPointsByKeys(data.argument, data.argumentIndex);\n          points.push.apply(points, seriesPoints);\n        });\n\n        if (target && target.argument === data.argument && target.argumentIndex === data.argumentIndex) {\n          points.push(target);\n        }\n\n        callback(getLegendItemAction(points));\n      });\n    };\n  },\n  _locateLabels: function _locateLabels(resolveLabelOverlapping) {\n    var iterationCount = 0;\n    var labelsWereOverlapped;\n    var wordWrapApplied;\n\n    do {\n      wordWrapApplied = this._adjustSeriesLabels(\"shift\" === resolveLabelOverlapping);\n      labelsWereOverlapped = this._resolveLabelOverlapping(resolveLabelOverlapping);\n    } while ((labelsWereOverlapped || wordWrapApplied) && ++iterationCount < MAX_RESOLVE_ITERATION_COUNT);\n  },\n  _adjustSeriesLabels: function _adjustSeriesLabels(moveLabelsFromCenter) {\n    return this.series.reduce(function (r, s) {\n      return s.adjustLabels(moveLabelsFromCenter) || r;\n    }, false);\n  },\n  _applyExtraSettings: _noop,\n  _resolveLabelOverlappingShift: function _resolveLabelOverlappingShift() {\n    var that = this;\n    var inverseDirection = \"anticlockwise\" === that.option(\"segmentsDirection\");\n    var seriesByPosition = that.series.reduce(function (r, s) {\n      (r[s.getOptions().label.position] || r.outside).push(s);\n      return r;\n    }, {\n      inside: [],\n      columns: [],\n      outside: []\n    });\n    var labelsOverlapped = false;\n\n    if (seriesByPosition.inside.length > 0) {\n      labelsOverlapped = resolve(seriesByPosition.inside.reduce(function (r, singleSeries) {\n        return singleSeries.getVisiblePoints().reduce(function (r, point) {\n          r.left.push(point);\n          return r;\n        }, r);\n      }, {\n        left: [],\n        right: []\n      }), shiftInColumnFunction) || labelsOverlapped;\n    }\n\n    labelsOverlapped = seriesByPosition.columns.reduce(function (r, singleSeries) {\n      return resolve(dividePoints(singleSeries), shiftInColumnFunction) || r;\n    }, labelsOverlapped);\n\n    if (seriesByPosition.outside.length > 0) {\n      labelsOverlapped = resolve(seriesByPosition.outside.reduce(function (r, singleSeries) {\n        return dividePoints(singleSeries, r);\n      }, null), function (box, length) {\n        return _getVerticallyShiftedAngularCoords(box, -length, that._center);\n      }) || labelsOverlapped;\n    }\n\n    return labelsOverlapped;\n\n    function dividePoints(series, points) {\n      return series.getVisiblePoints().reduce(function (r, point) {\n        var angle = normalizeAngle(point.middleAngle);\n        (angle <= 90 || angle >= 270 ? r.right : r.left).push(point);\n        return r;\n      }, points || {\n        left: [],\n        right: []\n      });\n    }\n\n    function resolve(points, shiftCallback) {\n      var overlapped;\n\n      if (inverseDirection) {\n        points.left.reverse();\n        points.right.reverse();\n      }\n\n      overlapped = overlapping.resolveLabelOverlappingInOneDirection(points.left, that._canvas, false, false, shiftCallback);\n      return overlapping.resolveLabelOverlappingInOneDirection(points.right, that._canvas, false, false, shiftCallback) || overlapped;\n    }\n\n    function shiftInColumnFunction(box, length) {\n      return {\n        x: box.x,\n        y: box.y - length\n      };\n    }\n  },\n  _setGeometry: function _setGeometry(_ref) {\n    var x = _ref.centerX,\n        y = _ref.centerY,\n        radiusInner = _ref.radiusInner;\n    this._center = {\n      x: x,\n      y: y\n    };\n    this._innerRadius = radiusInner;\n  },\n  _disposeSeries: function _disposeSeries(seriesIndex) {\n    this.callBase.apply(this, arguments);\n    this._abstractSeries = null;\n  },\n  _legendDataField: \"point\",\n  _legendItemTextField: \"argument\",\n  _applyPointMarkersAutoHiding: _noop,\n  _renderTrackers: _noop,\n  _trackerType: \"PieTracker\",\n  _createScrollBar: _noop,\n  _updateAxesLayout: _noop,\n  _applyClipRects: _noop,\n  _appendAdditionalSeriesGroups: _noop,\n  _prepareToRender: _noop,\n  _isLegendInside: _noop,\n  _renderAxes: _noop,\n  _shrinkAxes: _noop,\n  _isRotated: _noop,\n  _seriesPopulatedHandlerCore: _noop,\n  _reinitAxes: _noop,\n  _correctAxes: _noop,\n  _getExtraOptions: function _getExtraOptions() {\n    return {\n      startAngle: this.option(\"startAngle\"),\n      innerRadius: this.option(\"innerRadius\"),\n      segmentsDirection: this.option(\"segmentsDirection\"),\n      type: this.option(\"type\")\n    };\n  },\n  getSizeGroup: function getSizeGroup() {\n    return this._themeManager.getOptions(\"sizeGroup\");\n  },\n  getSizeGroupLayout: function getSizeGroupLayout() {\n    return this._sizeGroupLayout || {};\n  }\n});\n\n_each(OPTIONS_FOR_REFRESH_SERIES, function (_, name) {\n  dxPieChart.prototype._optionChangesMap[name] = \"REFRESH_SERIES_DATA_INIT\";\n});\n\nimport { plugins } from \"./core/annotations\";\ndxPieChart.addPlugin(plugins.core);\ndxPieChart.addPlugin(plugins.pieChart);\nregisterComponent(\"dxPieChart\", dxPieChart);\nexport default dxPieChart;","map":null,"metadata":{},"sourceType":"module"}