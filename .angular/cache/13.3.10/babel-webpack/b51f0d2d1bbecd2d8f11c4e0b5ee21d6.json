{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/tree_list/ui.tree_list.selection.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport $ from \"../../core/renderer\";\nimport treeListCore from \"./ui.tree_list.core\";\nimport { noop, equalByValue } from \"../../core/utils/common\";\nimport { selectionModule } from \"../grid_core/ui.grid_core.selection\";\nimport { extend } from \"../../core/utils/extend\";\nimport { isDefined } from \"../../core/utils/type\";\nvar TREELIST_SELECT_ALL_CLASS = \"dx-treelist-select-all\";\nvar CELL_FOCUS_DISABLED_CLASS = \"dx-cell-focus-disabled\";\nvar SELECT_CHECKBOX_CLASS = \"dx-select-checkbox\";\nvar originalRowClick = selectionModule.extenders.views.rowsView._rowClick;\nvar originalHandleDataChanged = selectionModule.extenders.controllers.data._handleDataChanged;\n\nvar nodeExists = function nodeExists(array, currentKey) {\n  return !!array.filter(function (key) {\n    return key === currentKey;\n  }).length;\n};\n\ntreeListCore.registerModule(\"selection\", extend(true, {}, selectionModule, {\n  defaultOptions: function defaultOptions() {\n    return extend(true, selectionModule.defaultOptions(), {\n      selection: {\n        showCheckBoxesMode: \"always\",\n        recursive: false\n      }\n    });\n  },\n  extenders: {\n    controllers: {\n      data: {\n        _handleDataChanged: function _handleDataChanged(e) {\n          var selectionController = this.getController(\"selection\");\n          var isRecursiveSelection = selectionController.isRecursiveSelection();\n\n          if (isRecursiveSelection && (!e || \"updateSelectionState\" !== e.changeType)) {\n            selectionController.updateSelectionState({\n              selectedItemKeys: this.option(\"selectedRowKeys\")\n            });\n          }\n\n          originalHandleDataChanged.apply(this, arguments);\n        },\n        loadDescendants: function loadDescendants() {\n          var that = this;\n          var d = that.callBase.apply(that, arguments);\n          var selectionController = that.getController(\"selection\");\n          var isRecursiveSelection = selectionController.isRecursiveSelection();\n\n          if (isRecursiveSelection) {\n            d.done(function () {\n              selectionController.updateSelectionState({\n                selectedItemKeys: that.option(\"selectedRowKeys\")\n              });\n            });\n          }\n\n          return d;\n        }\n      },\n      selection: {\n        init: function init() {\n          this.callBase.apply(this, arguments);\n          this._selectionStateByKey = {};\n        },\n        _getSelectionConfig: function _getSelectionConfig() {\n          var _arguments = arguments,\n              _this = this;\n\n          var config = this.callBase.apply(this, arguments);\n          var plainItems = config.plainItems;\n\n          config.plainItems = function (all) {\n            if (all) {\n              return _this._dataController.getCachedStoreData() || [];\n            }\n\n            return plainItems.apply(_this, _arguments).map(function (item) {\n              return item.data;\n            });\n          };\n\n          config.isItemSelected = function (item) {\n            var key = _this._dataController.keyOf(item);\n\n            return _this.isRowSelected(key);\n          };\n\n          config.isSelectableItem = function () {\n            return true;\n          };\n\n          config.getItemData = function (item) {\n            return item;\n          };\n\n          config.allowLoadByRange = function () {\n            return false;\n          };\n\n          return config;\n        },\n        renderSelectCheckBoxContainer: function renderSelectCheckBoxContainer($container, model) {\n          var rowsView = this.component.getView(\"rowsView\");\n          $container.addClass(CELL_FOCUS_DISABLED_CLASS);\n\n          var $checkbox = rowsView._renderSelectCheckBox($container, {\n            value: model.row.isSelected,\n            row: model.row,\n            column: model.column\n          });\n\n          rowsView._attachCheckBoxClickEvent($checkbox);\n        },\n        _updateSelectColumn: noop,\n        _getSelectAllNodeKeys: function _getSelectAllNodeKeys() {\n          var component = this.component;\n          var root = component.getRootNode();\n          var cache = {};\n          var keys = [];\n          var isRecursiveSelection = this.isRecursiveSelection();\n          root && treeListCore.foreachNodes(root.children, function (node) {\n            if (void 0 !== node.key && (node.visible || isRecursiveSelection)) {\n              keys.push(node.key);\n            }\n\n            if (!node.visible) {\n              return true;\n            }\n\n            return isRecursiveSelection ? false : component.isRowExpanded(node.key, cache);\n          });\n          return keys;\n        },\n        isSelectAll: function isSelectAll() {\n          var selectedRowKeys = this.option(\"selectedRowKeys\") || [];\n\n          if (0 === selectedRowKeys.length) {\n            return false;\n          }\n\n          var component = this.component;\n\n          var visibleKeys = this._getSelectAllNodeKeys();\n\n          var isRecursiveSelection = this.isRecursiveSelection();\n          var hasIndeterminateState = false;\n          var selectedVisibleKeys = visibleKeys.filter(function (key) {\n            var isRowSelected = component.isRowSelected(key, isRecursiveSelection);\n\n            if (void 0 === isRowSelected) {\n              hasIndeterminateState = true;\n            }\n\n            return isRowSelected;\n          });\n\n          if (!selectedVisibleKeys.length) {\n            return hasIndeterminateState ? void 0 : false;\n          } else if (selectedVisibleKeys.length === visibleKeys.length) {\n            return true;\n          }\n        },\n        selectAll: function selectAll() {\n          var _this2 = this;\n\n          var visibleKeys = this._getSelectAllNodeKeys().filter(function (key) {\n            return !_this2.isRowSelected(key);\n          });\n\n          this.focusedItemIndex(-1);\n          return this.selectRows(visibleKeys, true);\n        },\n        deselectAll: function deselectAll() {\n          var visibleKeys = this._getSelectAllNodeKeys();\n\n          this.focusedItemIndex(-1);\n          return this.deselectRows(visibleKeys);\n        },\n        selectedItemKeys: function selectedItemKeys(value, preserve, isDeselect, isSelectAll) {\n          var that = this;\n          var selectedRowKeys = that.option(\"selectedRowKeys\");\n          var isRecursiveSelection = this.isRecursiveSelection();\n\n          var normalizedArgs = isRecursiveSelection && that._normalizeSelectionArgs({\n            keys: isDefined(value) ? value : []\n          }, preserve, !isDeselect);\n\n          if (normalizedArgs && !equalByValue(normalizedArgs.selectedRowKeys, selectedRowKeys)) {\n            that._isSelectionNormalizing = true;\n            return this.callBase(normalizedArgs.selectedRowKeys, false, false, false).always(function () {\n              that._isSelectionNormalizing = false;\n            }).done(function (items) {\n              normalizedArgs.selectedRowsData = items;\n\n              that._fireSelectionChanged(normalizedArgs);\n            });\n          }\n\n          return this.callBase(value, preserve, isDeselect, isSelectAll);\n        },\n        changeItemSelection: function changeItemSelection(itemIndex, keyboardKeys) {\n          var isRecursiveSelection = this.isRecursiveSelection();\n\n          if (isRecursiveSelection && !keyboardKeys.shift) {\n            var key = this._dataController.getKeyByRowIndex(itemIndex);\n\n            return this.selectedItemKeys(key, true, this.isRowSelected(key));\n          }\n\n          return this.callBase.apply(this, arguments);\n        },\n        _updateParentSelectionState: function _updateParentSelectionState(node, isSelected) {\n          var that = this;\n          var state = isSelected;\n          var parentNode = node.parent;\n\n          if (parentNode) {\n            if (parentNode.children.length > 1) {\n              if (false === isSelected) {\n                var hasSelectedState = parentNode.children.some(function (childNode, index, children) {\n                  return that._selectionStateByKey[childNode.key];\n                });\n                state = hasSelectedState ? void 0 : false;\n              } else if (true === isSelected) {\n                var hasNonSelectedState = parentNode.children.some(function (childNode) {\n                  return !that._selectionStateByKey[childNode.key];\n                });\n                state = hasNonSelectedState ? void 0 : true;\n              }\n            }\n\n            this._selectionStateByKey[parentNode.key] = state;\n\n            if (parentNode.parent && parentNode.parent.level >= 0) {\n              this._updateParentSelectionState(parentNode, state);\n            }\n          }\n        },\n        _updateChildrenSelectionState: function _updateChildrenSelectionState(node, isSelected) {\n          var that = this;\n          var children = node.children;\n          children && children.forEach(function (childNode) {\n            that._selectionStateByKey[childNode.key] = isSelected;\n\n            if (childNode.children.length > 0) {\n              that._updateChildrenSelectionState(childNode, isSelected);\n            }\n          });\n        },\n        _updateSelectionStateCore: function _updateSelectionStateCore(keys, isSelected) {\n          var dataController = this._dataController;\n\n          for (var i = 0; i < keys.length; i++) {\n            this._selectionStateByKey[keys[i]] = isSelected;\n            var node = dataController.getNodeByKey(keys[i]);\n\n            if (node) {\n              this._updateParentSelectionState(node, isSelected);\n\n              this._updateChildrenSelectionState(node, isSelected);\n            }\n          }\n        },\n        _getSelectedParentKeys: function _getSelectedParentKeys(key, selectedItemKeys, useCash) {\n          var selectedParentNode;\n\n          var node = this._dataController.getNodeByKey(key);\n\n          var parentNode = node && node.parent;\n          var result = [];\n\n          while (parentNode && parentNode.level >= 0) {\n            result.unshift(parentNode.key);\n            var isSelected = useCash ? !nodeExists(selectedItemKeys, parentNode.key) && this.isRowSelected(parentNode.key) : selectedItemKeys.indexOf(parentNode.key) >= 0;\n\n            if (isSelected) {\n              selectedParentNode = parentNode;\n              result = this._getSelectedParentKeys(selectedParentNode.key, selectedItemKeys, useCash).concat(result);\n              break;\n            } else if (useCash) {\n              break;\n            }\n\n            parentNode = parentNode.parent;\n          }\n\n          return selectedParentNode && result || [];\n        },\n        _getSelectedChildKeys: function _getSelectedChildKeys(key, keysToIgnore) {\n          var _this3 = this;\n\n          var childKeys = [];\n\n          var node = this._dataController.getNodeByKey(key);\n\n          node && treeListCore.foreachNodes(node.children, function (childNode) {\n            var ignoreKeyIndex = keysToIgnore.indexOf(childNode.key);\n\n            if (ignoreKeyIndex < 0) {\n              childKeys.push(childNode.key);\n            }\n\n            return ignoreKeyIndex > 0 || ignoreKeyIndex < 0 && void 0 === _this3._selectionStateByKey[childNode.key];\n          });\n          return childKeys;\n        },\n        _normalizeParentKeys: function _normalizeParentKeys(key, args) {\n          var keysToIgnore = [key];\n\n          var parentNodeKeys = this._getSelectedParentKeys(key, args.selectedRowKeys);\n\n          if (parentNodeKeys.length) {\n            keysToIgnore = keysToIgnore.concat(parentNodeKeys);\n            keysToIgnore.forEach(function (key) {\n              var index = args.selectedRowKeys.indexOf(key);\n\n              if (index >= 0) {\n                args.selectedRowKeys.splice(index, 1);\n              }\n            });\n\n            var childKeys = this._getSelectedChildKeys(parentNodeKeys[0], keysToIgnore);\n\n            args.selectedRowKeys = args.selectedRowKeys.concat(childKeys);\n          }\n        },\n        _normalizeChildrenKeys: function _normalizeChildrenKeys(key, args) {\n          var _this4 = this;\n\n          var node = this._dataController.getNodeByKey(key);\n\n          node && node.children.forEach(function (childNode) {\n            var index = args.selectedRowKeys.indexOf(childNode.key);\n\n            if (index >= 0) {\n              args.selectedRowKeys.splice(index, 1);\n            }\n\n            _this4._normalizeChildrenKeys(childNode.key, args);\n          });\n        },\n        _normalizeSelectedRowKeysCore: function _normalizeSelectedRowKeysCore(keys, args, preserve, isSelect) {\n          var that = this;\n          keys.forEach(function (key) {\n            if (preserve && that.isRowSelected(key) === isSelect) {\n              return;\n            }\n\n            that._normalizeChildrenKeys(key, args);\n\n            var index = args.selectedRowKeys.indexOf(key);\n\n            if (isSelect) {\n              if (index < 0) {\n                args.selectedRowKeys.push(key);\n              }\n\n              args.currentSelectedRowKeys.push(key);\n            } else {\n              if (index >= 0) {\n                args.selectedRowKeys.splice(index, 1);\n              }\n\n              args.currentDeselectedRowKeys.push(key);\n\n              that._normalizeParentKeys(key, args);\n            }\n          });\n        },\n        _normalizeSelectionArgs: function _normalizeSelectionArgs(args, preserve, isSelect) {\n          var result;\n          var keys = Array.isArray(args.keys) ? args.keys : [args.keys];\n          var selectedRowKeys = this.option(\"selectedRowKeys\") || [];\n\n          if (keys.length) {\n            result = {\n              currentSelectedRowKeys: [],\n              currentDeselectedRowKeys: [],\n              selectedRowKeys: preserve ? selectedRowKeys.slice(0) : []\n            };\n\n            this._normalizeSelectedRowKeysCore(keys, result, preserve, isSelect);\n          }\n\n          return result;\n        },\n        _updateSelectedItems: function _updateSelectedItems(args) {\n          this.updateSelectionState(args);\n          this.callBase(args);\n        },\n        _fireSelectionChanged: function _fireSelectionChanged() {\n          if (!this._isSelectionNormalizing) {\n            this.callBase.apply(this, arguments);\n          }\n        },\n        _isModeLeavesOnly: function _isModeLeavesOnly(mode) {\n          return \"leavesOnly\" === mode;\n        },\n        _removeDuplicatedKeys: function _removeDuplicatedKeys(keys) {\n          var result = [];\n          var processedKeys = {};\n          keys.forEach(function (key) {\n            if (!processedKeys[key]) {\n              processedKeys[key] = true;\n              result.push(key);\n            }\n          });\n          return result;\n        },\n        _getAllChildKeys: function _getAllChildKeys(key) {\n          var childKeys = [];\n\n          var node = this._dataController.getNodeByKey(key);\n\n          node && treeListCore.foreachNodes(node.children, function (childNode) {\n            childKeys.push(childNode.key);\n          }, true);\n          return childKeys;\n        },\n        _getAllSelectedRowKeys: function _getAllSelectedRowKeys(keys) {\n          var _this5 = this;\n\n          var result = [];\n          keys.forEach(function (key) {\n            var parentKeys = _this5._getSelectedParentKeys(key, [], true);\n\n            var childKeys = _this5._getAllChildKeys(key);\n\n            result.push.apply(result, parentKeys.concat([key], childKeys));\n          });\n          result = this._removeDuplicatedKeys(result);\n          return result;\n        },\n        _getParentSelectedRowKeys: function _getParentSelectedRowKeys(keys) {\n          var that = this;\n          var result = [];\n          keys.forEach(function (key) {\n            var parentKeys = that._getSelectedParentKeys(key, keys);\n\n            !parentKeys.length && result.push(key);\n          });\n          return result;\n        },\n        _getLeafSelectedRowKeys: function _getLeafSelectedRowKeys(keys) {\n          var result = [];\n          var dataController = this._dataController;\n          keys.forEach(function (key) {\n            var node = dataController.getNodeByKey(key);\n            node && !node.hasChildren && result.push(key);\n          });\n          return result;\n        },\n        isRecursiveSelection: function isRecursiveSelection() {\n          var selectionMode = this.option(\"selection.mode\");\n          var isRecursive = this.option(\"selection.recursive\");\n          return \"multiple\" === selectionMode && isRecursive;\n        },\n        updateSelectionState: function updateSelectionState(options) {\n          var removedItemKeys = options.removedItemKeys || [];\n          var selectedItemKeys = options.selectedItemKeys || [];\n\n          if (this.isRecursiveSelection()) {\n            this._updateSelectionStateCore(removedItemKeys, false);\n\n            this._updateSelectionStateCore(selectedItemKeys, true);\n          }\n        },\n        isRowSelected: function isRowSelected(key, isRecursiveSelection) {\n          var _isRecursiveSelection;\n\n          var result = this.callBase.apply(this, arguments);\n          isRecursiveSelection = null !== (_isRecursiveSelection = isRecursiveSelection) && void 0 !== _isRecursiveSelection ? _isRecursiveSelection : this.isRecursiveSelection();\n\n          if (!result && isRecursiveSelection) {\n            if (key in this._selectionStateByKey) {\n              return this._selectionStateByKey[key];\n            }\n\n            return false;\n          }\n\n          return result;\n        },\n        getSelectedRowKeys: function getSelectedRowKeys(mode) {\n          if (!this._dataController) {\n            return [];\n          }\n\n          var selectedRowKeys = this.callBase.apply(this, arguments);\n\n          if (mode) {\n            if (this.isRecursiveSelection()) {\n              selectedRowKeys = this._getAllSelectedRowKeys(selectedRowKeys);\n            }\n\n            if (\"all\" !== mode) {\n              if (\"excludeRecursive\" === mode) {\n                selectedRowKeys = this._getParentSelectedRowKeys(selectedRowKeys);\n              } else if (this._isModeLeavesOnly(mode)) {\n                selectedRowKeys = this._getLeafSelectedRowKeys(selectedRowKeys);\n              }\n            }\n          }\n\n          return selectedRowKeys;\n        },\n        getSelectedRowsData: function getSelectedRowsData(mode) {\n          var dataController = this._dataController;\n          var selectedKeys = this.getSelectedRowKeys(mode) || [];\n          var selectedRowsData = [];\n          selectedKeys.forEach(function (key) {\n            var node = dataController.getNodeByKey(key);\n            node && selectedRowsData.push(node.data);\n          });\n          return selectedRowsData;\n        },\n        refresh: function refresh() {\n          this._selectionStateByKey = {};\n          return this.callBase.apply(this, arguments);\n        }\n      }\n    },\n    views: {\n      columnHeadersView: {\n        _processTemplate: function _processTemplate(template, options) {\n          var that = this;\n          var resultTemplate;\n          var renderingTemplate = this.callBase(template, options);\n\n          var firstDataColumnIndex = that._columnsController.getFirstDataColumnIndex();\n\n          if (renderingTemplate && \"header\" === options.rowType && options.column.index === firstDataColumnIndex) {\n            resultTemplate = {\n              render: function render(options) {\n                if (\"multiple\" === that.option(\"selection.mode\")) {\n                  that.renderSelectAll(options.container, options.model);\n                }\n\n                renderingTemplate.render(options);\n              }\n            };\n          } else {\n            resultTemplate = renderingTemplate;\n          }\n\n          return resultTemplate;\n        },\n        renderSelectAll: function renderSelectAll($cell, options) {\n          $cell.addClass(TREELIST_SELECT_ALL_CLASS);\n\n          this._renderSelectAllCheckBox($cell);\n        },\n        _isSortableElement: function _isSortableElement($target) {\n          return this.callBase($target) && !$target.closest(\".\" + SELECT_CHECKBOX_CLASS).length;\n        }\n      },\n      rowsView: {\n        _renderIcons: function _renderIcons($iconContainer, options) {\n          this.callBase.apply(this, arguments);\n\n          if (!options.row.isNewRow && \"multiple\" === this.option(\"selection.mode\")) {\n            this.getController(\"selection\").renderSelectCheckBoxContainer($iconContainer, options);\n          }\n\n          return $iconContainer;\n        },\n        _rowClick: function _rowClick(e) {\n          var $targetElement = $(e.event.target);\n\n          if (this.isExpandIcon($targetElement)) {\n            this.callBase.apply(this, arguments);\n          } else {\n            originalRowClick.apply(this, arguments);\n          }\n        }\n      }\n    }\n  }\n}));","map":null,"metadata":{},"sourceType":"module"}