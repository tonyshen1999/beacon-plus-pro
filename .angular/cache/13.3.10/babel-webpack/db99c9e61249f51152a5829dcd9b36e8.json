{"ast":null,"code":"/**\r\n * DevExtreme (esm/viz/series/line_series.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { chart as chartScatterSeries, polar as polarScatterSeries } from \"./scatter_series\";\nimport { clone } from \"../../core/utils/object\";\nimport { extend } from \"../../core/utils/extend\";\nimport { each } from \"../../core/utils/iterator\";\nimport { map, normalizeAngle, getCosAndSin } from \"../core/utils\";\nimport { solveCubicEquation, trunc } from \"../../core/utils/math\";\nvar DISCRETE = \"discrete\";\nvar round = Math.round,\n    sqrt = Math.sqrt,\n    pow = Math.pow,\n    min = Math.min,\n    max = Math.max,\n    abs = Math.abs;\nvar chart = {};\nvar polar = {};\n\nfunction clonePoint(point, newX, newY, newAngle) {\n  var p = clone(point);\n  p.x = newX;\n  p.y = newY;\n  p.angle = newAngle;\n  return p;\n}\n\nfunction getTangentPoint(point, prevPoint, centerPoint, tan, nextStepAngle) {\n  var correctAngle = point.angle + nextStepAngle;\n  var cosSin = getCosAndSin(correctAngle);\n  var x = centerPoint.x + (point.radius + tan * nextStepAngle) * cosSin.cos;\n  var y = centerPoint.y - (point.radius + tan * nextStepAngle) * cosSin.sin;\n  return clonePoint(prevPoint, x, y, correctAngle);\n}\n\nfunction obtainCubicBezierTCoef(p, p0, p1, p2, p3) {\n  var d = p0 - p;\n  var c = 3 * p1 - 3 * p0;\n  var b = 3 * p2 - 6 * p1 + 3 * p0;\n  var a = p3 - 3 * p2 + 3 * p1 - p0;\n  return solveCubicEquation(a, b, c, d);\n}\n\nvar lineMethods = {\n  autoHidePointMarkersEnabled: function autoHidePointMarkersEnabled() {\n    return true;\n  },\n  _applyGroupSettings: function _applyGroupSettings(style, settings, group) {\n    settings = extend(settings, style);\n\n    this._applyElementsClipRect(settings);\n\n    group.attr(settings);\n  },\n  _setGroupsSettings: function _setGroupsSettings(animationEnabled) {\n    var style = this._styles.normal;\n\n    this._applyGroupSettings(style.elements, {\n      class: \"dxc-elements\"\n    }, this._elementsGroup);\n\n    this._bordersGroup && this._applyGroupSettings(style.border, {\n      class: \"dxc-borders\"\n    }, this._bordersGroup);\n\n    chartScatterSeries._setGroupsSettings.call(this, animationEnabled);\n\n    animationEnabled && this._markersGroup && this._markersGroup.attr({\n      opacity: .001\n    });\n  },\n  _createGroups: function _createGroups() {\n    this._createGroup(\"_elementsGroup\", this, this._group);\n\n    this._areBordersVisible() && this._createGroup(\"_bordersGroup\", this, this._group);\n\n    chartScatterSeries._createGroups.call(this);\n  },\n  _areBordersVisible: function _areBordersVisible() {\n    return false;\n  },\n  _getDefaultSegment: function _getDefaultSegment(segment) {\n    return {\n      line: map(segment.line || [], function (pt) {\n        return pt.getDefaultCoords();\n      })\n    };\n  },\n  _prepareSegment: function _prepareSegment(points) {\n    return {\n      line: points\n    };\n  },\n  _parseLineOptions: function _parseLineOptions(options, defaultColor) {\n    return {\n      stroke: options.color || defaultColor,\n      \"stroke-width\": options.width,\n      dashStyle: options.dashStyle || \"solid\"\n    };\n  },\n  _parseStyle: function _parseStyle(options, defaultColor) {\n    return {\n      elements: this._parseLineOptions(options, defaultColor)\n    };\n  },\n  _applyStyle: function _applyStyle(style) {\n    this._elementsGroup && this._elementsGroup.attr(style.elements);\n    each(this._graphics || [], function (_, graphic) {\n      graphic.line && graphic.line.attr({\n        \"stroke-width\": style.elements[\"stroke-width\"]\n      }).sharp();\n    });\n  },\n  _drawElement: function _drawElement(segment, group) {\n    return {\n      line: this._createMainElement(segment.line, {\n        \"stroke-width\": this._styles.normal.elements[\"stroke-width\"]\n      }).append(group)\n    };\n  },\n  _removeElement: function _removeElement(element) {\n    element.line.remove();\n  },\n  _updateElement: function _updateElement(element, segment, animate, animationComplete) {\n    var params = {\n      points: segment.line\n    };\n    var lineElement = element.line;\n    animate ? lineElement.animate(params, {}, animationComplete) : lineElement.attr(params);\n  },\n  _animateComplete: function _animateComplete() {\n    chartScatterSeries._animateComplete.call(this);\n\n    this._markersGroup && this._markersGroup.animate({\n      opacity: 1\n    }, {\n      duration: this._defaultDuration\n    });\n  },\n  _animate: function _animate() {\n    var that = this;\n    var lastIndex = that._graphics.length - 1;\n    each(that._graphics || [], function (i, elem) {\n      var complete;\n\n      if (i === lastIndex) {\n        complete = function complete() {\n          that._animateComplete();\n        };\n      }\n\n      that._updateElement(elem, that._segments[i], true, complete);\n    });\n  },\n  _drawPoint: function _drawPoint(options) {\n    chartScatterSeries._drawPoint.call(this, {\n      point: options.point,\n      groups: options.groups\n    });\n  },\n  _createMainElement: function _createMainElement(points, settings) {\n    return this._renderer.path(points, \"line\").attr(settings);\n  },\n  _sortPoints: function _sortPoints(points, rotated) {\n    return rotated ? points.sort(function (p1, p2) {\n      return p2.y - p1.y;\n    }) : points.sort(function (p1, p2) {\n      return p1.x - p2.x;\n    });\n  },\n  _drawSegment: function _drawSegment(points, animationEnabled, segmentCount, lastSegment) {\n    var rotated = this._options.rotated;\n\n    var segment = this._prepareSegment(points, rotated, lastSegment);\n\n    this._segments.push(segment);\n\n    if (!this._graphics[segmentCount]) {\n      this._graphics[segmentCount] = this._drawElement(animationEnabled ? this._getDefaultSegment(segment) : segment, this._elementsGroup);\n    } else if (!animationEnabled) {\n      this._updateElement(this._graphics[segmentCount], segment);\n    }\n  },\n  _getTrackerSettings: function _getTrackerSettings() {\n    var defaultTrackerWidth = this._defaultTrackerWidth;\n    var strokeWidthFromElements = this._styles.normal.elements[\"stroke-width\"];\n    return {\n      \"stroke-width\": strokeWidthFromElements > defaultTrackerWidth ? strokeWidthFromElements : defaultTrackerWidth,\n      fill: \"none\"\n    };\n  },\n  _getMainPointsFromSegment: function _getMainPointsFromSegment(segment) {\n    return segment.line;\n  },\n  _drawTrackerElement: function _drawTrackerElement(segment) {\n    return this._createMainElement(this._getMainPointsFromSegment(segment), this._getTrackerSettings(segment));\n  },\n  _updateTrackerElement: function _updateTrackerElement(segment, element) {\n    var settings = this._getTrackerSettings(segment);\n\n    settings.points = this._getMainPointsFromSegment(segment);\n    element.attr(settings);\n  },\n  checkSeriesViewportCoord: function checkSeriesViewportCoord(axis, coord) {\n    if (!chartScatterSeries.checkSeriesViewportCoord.call(this)) {\n      return false;\n    }\n\n    var range = axis.isArgumentAxis ? this.getArgumentRange() : this.getViewport();\n    var min = axis.getTranslator().translate(range.categories ? range.categories[0] : range.min);\n    var max = axis.getTranslator().translate(range.categories ? range.categories[range.categories.length - 1] : range.max);\n    var rotated = this.getOptions().rotated;\n    var inverted = axis.getOptions().inverted;\n    return axis.isArgumentAxis && (!rotated && !inverted || rotated && inverted) || !axis.isArgumentAxis && (rotated && !inverted || !rotated && inverted) ? coord >= min && coord <= max : coord >= max && coord <= min;\n  }\n};\nvar lineSeries = chart.line = extend({}, chartScatterSeries, lineMethods, {\n  getPointCenterByArg: function getPointCenterByArg(arg) {\n    var value = this.getArgumentAxis().getTranslator().translate(arg);\n    return {\n      x: value,\n      y: value\n    };\n  },\n  getSeriesPairCoord: function getSeriesPairCoord(coord, isArgument) {\n    var oppositeCoord = null;\n\n    var nearestPoints = this._getNearestPointsByCoord(coord, isArgument);\n\n    var needValueCoord = isArgument && !this._options.rotated || !isArgument && this._options.rotated;\n\n    for (var i = 0; i < nearestPoints.length; i++) {\n      var p = nearestPoints[i];\n      var k = (p[1].vy - p[0].vy) / (p[1].vx - p[0].vx);\n      var b = p[0].vy - p[0].vx * k;\n      var tmpCoord = void 0;\n\n      if (p[1].vx - p[0].vx === 0) {\n        tmpCoord = needValueCoord ? p[0].vy : p[0].vx;\n      } else {\n        tmpCoord = needValueCoord ? k * coord + b : (coord - b) / k;\n      }\n\n      if (this._checkAxisVisibleAreaCoord(!isArgument, tmpCoord)) {\n        oppositeCoord = tmpCoord;\n        break;\n      }\n    }\n\n    return oppositeCoord;\n  }\n});\nchart.stepline = extend({}, lineSeries, {\n  _calculateStepLinePoints: function _calculateStepLinePoints(points) {\n    var segment = [];\n    var coordName = this._options.rotated ? \"x\" : \"y\";\n    each(points, function (i, pt) {\n      var point;\n\n      if (!i) {\n        segment.push(pt);\n        return;\n      }\n\n      var step = segment[segment.length - 1][coordName];\n\n      if (step !== pt[coordName]) {\n        point = clone(pt);\n        point[coordName] = step;\n        segment.push(point);\n      }\n\n      segment.push(pt);\n    });\n    return segment;\n  },\n  _prepareSegment: function _prepareSegment(points) {\n    return lineSeries._prepareSegment(this._calculateStepLinePoints(points));\n  },\n  getSeriesPairCoord: function getSeriesPairCoord(coord, isArgument) {\n    var oppositeCoord;\n    var rotated = this._options.rotated;\n    var isOpposite = !isArgument && !rotated || isArgument && rotated;\n    var coordName = !isOpposite ? \"vx\" : \"vy\";\n    var oppositeCoordName = !isOpposite ? \"vy\" : \"vx\";\n\n    var nearestPoints = this._getNearestPointsByCoord(coord, isArgument);\n\n    for (var i = 0; i < nearestPoints.length; i++) {\n      var p = nearestPoints[i];\n      var tmpCoord = void 0;\n\n      if (isArgument) {\n        tmpCoord = coord !== p[1][coordName] ? p[0][oppositeCoordName] : p[1][oppositeCoordName];\n      } else {\n        tmpCoord = coord === p[0][coordName] ? p[0][oppositeCoordName] : p[1][oppositeCoordName];\n      }\n\n      if (this._checkAxisVisibleAreaCoord(!isArgument, tmpCoord)) {\n        oppositeCoord = tmpCoord;\n        break;\n      }\n    }\n\n    return oppositeCoord;\n  }\n});\nchart.spline = extend({}, lineSeries, {\n  _calculateBezierPoints: function _calculateBezierPoints(src, rotated) {\n    var bezierPoints = [];\n    var pointsCopy = src;\n\n    var checkExtremum = function checkExtremum(otherPointCoord, pointCoord, controlCoord) {\n      return otherPointCoord > pointCoord && controlCoord > otherPointCoord || otherPointCoord < pointCoord && controlCoord < otherPointCoord ? otherPointCoord : controlCoord;\n    };\n\n    if (1 !== pointsCopy.length) {\n      pointsCopy.forEach(function (curPoint, i) {\n        var leftControlX;\n        var leftControlY;\n        var rightControlX;\n        var rightControlY;\n        var prevPoint = pointsCopy[i - 1];\n        var nextPoint = pointsCopy[i + 1];\n        var x1;\n        var x2;\n        var y1;\n        var y2;\n        var a;\n        var b;\n        var c;\n        var xc;\n        var yc;\n        var shift;\n\n        if (!i || i === pointsCopy.length - 1) {\n          bezierPoints.push(curPoint, curPoint);\n          return;\n        }\n\n        var xCur = curPoint.x;\n        var yCur = curPoint.y;\n        x1 = prevPoint.x;\n        x2 = nextPoint.x;\n        y1 = prevPoint.y;\n        y2 = nextPoint.y;\n        var curIsExtremum = !!(!rotated && (yCur <= prevPoint.y && yCur <= nextPoint.y || yCur >= prevPoint.y && yCur >= nextPoint.y) || rotated && (xCur <= prevPoint.x && xCur <= nextPoint.x || xCur >= prevPoint.x && xCur >= nextPoint.x));\n\n        if (curIsExtremum) {\n          if (!rotated) {\n            rightControlY = leftControlY = yCur;\n            rightControlX = (xCur + nextPoint.x) / 2;\n            leftControlX = (xCur + prevPoint.x) / 2;\n          } else {\n            rightControlX = leftControlX = xCur;\n            rightControlY = (yCur + nextPoint.y) / 2;\n            leftControlY = (yCur + prevPoint.y) / 2;\n          }\n        } else {\n          a = y2 - y1;\n          b = x1 - x2;\n          c = y1 * x2 - x1 * y2;\n\n          if (!rotated) {\n            if (!b) {\n              bezierPoints.push(curPoint, curPoint, curPoint);\n              return;\n            }\n\n            xc = xCur;\n            yc = -1 * (a * xc + c) / b;\n            shift = yc - yCur;\n            y1 -= shift;\n            y2 -= shift;\n          } else {\n            if (!a) {\n              bezierPoints.push(curPoint, curPoint, curPoint);\n              return;\n            }\n\n            yc = yCur;\n            xc = -1 * (b * yc + c) / a;\n            shift = xc - xCur;\n            x1 -= shift;\n            x2 -= shift;\n          }\n\n          rightControlX = (xCur + .5 * x2) / 1.5;\n          rightControlY = (yCur + .5 * y2) / 1.5;\n          leftControlX = (xCur + .5 * x1) / 1.5;\n          leftControlY = (yCur + .5 * y1) / 1.5;\n        }\n\n        if (!rotated) {\n          leftControlY = checkExtremum(prevPoint.y, yCur, leftControlY);\n          rightControlY = checkExtremum(nextPoint.y, yCur, rightControlY);\n        } else {\n          leftControlX = checkExtremum(prevPoint.x, xCur, leftControlX);\n          rightControlX = checkExtremum(nextPoint.x, xCur, rightControlX);\n        }\n\n        var leftPoint = clonePoint(curPoint, leftControlX, leftControlY);\n        var rightPoint = clonePoint(curPoint, rightControlX, rightControlY);\n        bezierPoints.push(leftPoint, curPoint, rightPoint);\n      });\n    } else {\n      bezierPoints.push(pointsCopy[0]);\n    }\n\n    return bezierPoints;\n  },\n  _prepareSegment: function _prepareSegment(points, rotated) {\n    return lineSeries._prepareSegment(this._calculateBezierPoints(points, rotated));\n  },\n  _createMainElement: function _createMainElement(points, settings) {\n    return this._renderer.path(points, \"bezier\").attr(settings);\n  },\n  getSeriesPairCoord: function getSeriesPairCoord(coord, isArgument) {\n    var oppositeCoord = null;\n    var isOpposite = !isArgument && !this._options.rotated || isArgument && this._options.rotated;\n    var coordName = !isOpposite ? \"vx\" : \"vy\";\n    var bezierCoordName = !isOpposite ? \"x\" : \"y\";\n    var oppositeCoordName = !isOpposite ? \"vy\" : \"vx\";\n    var bezierOppositeCoordName = !isOpposite ? \"y\" : \"x\";\n    var axis = !isArgument ? this.getArgumentAxis() : this.getValueAxis();\n    var visibleArea = axis.getVisibleArea();\n\n    var nearestPoints = this._getNearestPointsByCoord(coord, isArgument);\n\n    var _loop = function _loop(i) {\n      var p = nearestPoints[i];\n\n      if (1 === p.length) {\n        visibleArea[0] <= p[0][oppositeCoordName] && visibleArea[1] >= p[0][oppositeCoordName] && (oppositeCoord = p[0][oppositeCoordName]);\n      } else {\n        var ts = obtainCubicBezierTCoef(coord, p[0][coordName], p[1][bezierCoordName], p[2][bezierCoordName], p[3][coordName]);\n        ts.forEach(function (t) {\n          if (t >= 0 && t <= 1) {\n            var tmpCoord = Math.pow(1 - t, 3) * p[0][oppositeCoordName] + 3 * Math.pow(1 - t, 2) * t * p[1][bezierOppositeCoordName] + 3 * (1 - t) * t * t * p[2][bezierOppositeCoordName] + t * t * t * p[3][oppositeCoordName];\n\n            if (visibleArea[0] <= tmpCoord && visibleArea[1] >= tmpCoord) {\n              oppositeCoord = tmpCoord;\n            }\n          }\n        });\n      }\n\n      if (null !== oppositeCoord) {\n        return \"break\";\n      }\n    };\n\n    for (var i = 0; i < nearestPoints.length; i++) {\n      var _ret = _loop(i);\n\n      if (\"break\" === _ret) {\n        break;\n      }\n    }\n\n    return oppositeCoord;\n  },\n  _getNearestPoints: function _getNearestPoints(point, nextPoint, bezierPoints) {\n    var index = bezierPoints.indexOf(point);\n    return [point, bezierPoints[index + 1], bezierPoints[index + 2], nextPoint];\n  },\n  _getBezierPoints: function _getBezierPoints() {\n    return this._segments.length > 0 ? this._segments.reduce(function (a, seg) {\n      return a.concat(seg.line);\n    }, []) : [];\n  }\n});\npolar.line = extend({}, polarScatterSeries, lineMethods, {\n  _sortPoints: function _sortPoints(points) {\n    return points;\n  },\n  _prepareSegment: function _prepareSegment(points, rotated, lastSegment) {\n    var preparedPoints = [];\n    var centerPoint = this.getValueAxis().getCenter();\n    var i;\n    lastSegment && this._closeSegment(points);\n\n    if (this.argumentAxisType !== DISCRETE && this.valueAxisType !== DISCRETE) {\n      for (i = 1; i < points.length; i++) {\n        preparedPoints = preparedPoints.concat(this._getTangentPoints(points[i], points[i - 1], centerPoint));\n      }\n\n      if (!preparedPoints.length) {\n        preparedPoints = points;\n      }\n    } else {\n      return lineSeries._prepareSegment.call(this, points);\n    }\n\n    return {\n      line: preparedPoints\n    };\n  },\n  _getRemainingAngle: function _getRemainingAngle(angle) {\n    var normAngle = normalizeAngle(angle);\n    return angle >= 0 ? 360 - normAngle : -normAngle;\n  },\n  _closeSegment: function _closeSegment(points) {\n    var point;\n\n    if (this._segments.length) {\n      point = this._segments[0].line[0];\n    } else {\n      point = clonePoint(points[0], points[0].x, points[0].y, points[0].angle);\n    }\n\n    point = this._modifyReflectedPoint(point, points[points.length - 1]);\n\n    if (point) {\n      points.push(point);\n    }\n  },\n  _modifyReflectedPoint: function _modifyReflectedPoint(point, lastPoint) {\n    if (lastPoint.angle === point.angle) {\n      return;\n    }\n\n    if (normalizeAngle(round(lastPoint.angle)) === normalizeAngle(round(point.angle))) {\n      point.angle = lastPoint.angle;\n    } else {\n      var differenceAngle = lastPoint.angle - point.angle;\n      point.angle = lastPoint.angle + this._getRemainingAngle(differenceAngle);\n    }\n\n    return point;\n  },\n  _getTangentPoints: function _getTangentPoints(point, prevPoint, centerPoint) {\n    var tangentPoints = [];\n    var betweenAngle = Math.round(prevPoint.angle - point.angle);\n    var tan = (prevPoint.radius - point.radius) / betweenAngle;\n    var i;\n\n    if (0 === betweenAngle) {\n      tangentPoints = [prevPoint, point];\n    } else if (betweenAngle > 0) {\n      for (i = betweenAngle; i >= 0; i--) {\n        tangentPoints.push(getTangentPoint(point, prevPoint, centerPoint, tan, i));\n      }\n    } else {\n      for (i = 0; i >= betweenAngle; i--) {\n        tangentPoints.push(getTangentPoint(point, prevPoint, centerPoint, tan, betweenAngle - i));\n      }\n    }\n\n    return tangentPoints;\n  },\n  getSeriesPairCoord: function getSeriesPairCoord(params, isArgument) {\n    var argAxis = this.getArgumentAxis();\n    var paramName = isArgument ? \"angle\" : \"radius\";\n    var coordParam = params[paramName];\n    var centerPoint = argAxis.getCenter();\n\n    var isInsideInterval = function isInsideInterval(prevPoint, point, _ref) {\n      var x = _ref.x,\n          y = _ref.y;\n      return (p1 = {\n        x: x,\n        y: y\n      }, p2 = centerPoint, sqrt(pow(p1.x - p2.x, 2) + pow(p1.y - p2.y, 2))) <= argAxis.getRadius() && min(prevPoint.x, point.x) <= x && max(prevPoint.x, point.x) >= x && min(prevPoint.y, point.y) <= y && max(prevPoint.y, point.y) >= y;\n      var p1, p2;\n    };\n\n    var coords;\n    var neighborPoints = this.getNeighborPoints(coordParam, paramName);\n\n    if (1 === neighborPoints.length) {\n      coords = neighborPoints[0];\n    } else if (neighborPoints.length > 1) {\n      var prevPoint = neighborPoints[0];\n      var point = neighborPoints[1];\n\n      if (this.argumentAxisType !== DISCRETE && this.valueAxisType !== DISCRETE) {\n        var tan;\n        var stepAngle;\n\n        if (isArgument) {\n          tan = (prevPoint.radius - point.radius) / (prevPoint.angle - point.angle);\n          stepAngle = coordParam - point.angle;\n        } else {\n          tan = (prevPoint.radius - point.radius) / (prevPoint.angle - point.angle);\n          stepAngle = (coordParam - point.radius) / tan;\n        }\n\n        coords = getTangentPoint(point, prevPoint, centerPoint, tan, stepAngle);\n      } else if (isArgument) {\n        var cosSin = getCosAndSin(-coordParam);\n        var k1 = (point.y - prevPoint.y) / (point.x - prevPoint.x);\n        var b1 = prevPoint.y - prevPoint.x * k1;\n        var k2 = cosSin.sin / cosSin.cos;\n        var b2 = centerPoint.y - k2 * centerPoint.x;\n        var x = (b2 - b1) / (k1 - k2);\n        var y = k1 * x + b1;\n\n        if (isInsideInterval(prevPoint, point, {\n          x: x,\n          y: y\n        })) {\n          var quarter = abs(trunc((360 + coordParam) / 90) % 4);\n\n          if (0 === quarter && x >= centerPoint.x && y <= centerPoint.y || 1 === quarter && x <= centerPoint.x && y <= centerPoint.y || 2 === quarter && x <= centerPoint.x && y >= centerPoint.y || 3 === quarter && x >= centerPoint.x && y >= centerPoint.y) {\n            coords = {\n              x: x,\n              y: y\n            };\n          }\n        }\n      } else {\n        var k = (point.y - prevPoint.y) / (point.x - prevPoint.x);\n        var y0 = prevPoint.y - prevPoint.x * k;\n        var a = 1 + k * k;\n        var b = -2 * centerPoint.x + 2 * k * y0 - 2 * k * centerPoint.y;\n        var c = -pow(coordParam, 2) + pow(y0 - centerPoint.y, 2) + pow(centerPoint.x, 2);\n        var d = b * b - 4 * a * c;\n\n        if (d >= 0) {\n          var x1 = (-b - sqrt(d)) / (2 * a);\n          var x2 = (-b + sqrt(d)) / (2 * a);\n          var y1 = k * x1 + y0;\n          var y2 = k * x2 + y0;\n          coords = isInsideInterval(prevPoint, point, {\n            x: x1,\n            y: y1\n          }) ? {\n            x: x1,\n            y: y1\n          } : isInsideInterval(prevPoint, point, {\n            x: x2,\n            y: y2\n          }) ? {\n            x: x2,\n            y: y2\n          } : void 0;\n        }\n      }\n    }\n\n    return coords;\n  },\n  getNeighborPoints: function getNeighborPoints(param, paramName) {\n    var points = this.getPoints();\n    var neighborPoints = [];\n\n    if (this.getOptions().closed) {\n      points = extend(true, [], points);\n      var lastPoint = points[points.length - 1];\n      var firstPointCopy = clonePoint(points[0], points[0].x, points[0].y, points[0].angle);\n      var lastPointCopy = clonePoint(lastPoint, lastPoint.x, lastPoint.y, lastPoint.angle);\n\n      var rearwardRefPoint = this._modifyReflectedPoint(firstPointCopy, lastPoint);\n\n      var forwardRefPoint = this._modifyReflectedPoint(lastPointCopy, points[0]);\n\n      if (forwardRefPoint) {\n        points.unshift(forwardRefPoint);\n      }\n\n      if (rearwardRefPoint) {\n        points.push(rearwardRefPoint);\n      }\n    }\n\n    for (var i = 1; i < points.length; i++) {\n      if (points[i - 1][paramName] === param) {\n        neighborPoints.push(points[i - 1]);\n      } else if (points[i][paramName] === param) {\n        neighborPoints.push(points[i]);\n      } else if (points[i][paramName] > param && points[i - 1][paramName] < param || points[i - 1][paramName] > param && points[i][paramName] < param) {\n        neighborPoints.push(points[i - 1]);\n        neighborPoints.push(points[i]);\n      }\n\n      if (neighborPoints.length > 0) {\n        break;\n      }\n    }\n\n    return neighborPoints;\n  }\n});\nexport { chart, polar };","map":null,"metadata":{},"sourceType":"module"}