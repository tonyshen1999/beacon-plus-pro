{"ast":null,"code":"/**\r\n * DevExtreme (esm/viz/gauges/circular_indicators.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { BaseIndicator, BaseTextCloudMarker, BaseRangeBar } from \"./base_indicators\";\nimport { getCosAndSin, convertAngleToRendererSpace, normalizeAngle } from \"../core/utils\";\nvar _Number = Number;\nvar _getCosAndSin = getCosAndSin;\nvar _convertAngleToRendererSpace = convertAngleToRendererSpace;\n\nfunction correctRadius(layout, size) {\n  if (layout && layout.radius - size <= 0) {\n    layout.radius = size + 1;\n  }\n\n  return layout;\n}\n\nvar SimpleIndicator = BaseIndicator.inherit({\n  _move: function _move() {\n    var options = this._options;\n\n    var angle = _convertAngleToRendererSpace(this._actualPosition);\n\n    this._rootElement.rotate(angle, options.x, options.y);\n\n    this._trackerElement && this._trackerElement.rotate(angle, options.x, options.y);\n  },\n  _isEnabled: function _isEnabled() {\n    return this._options.width > 0;\n  },\n  _isVisible: function _isVisible(layout) {\n    return layout.radius - _Number(this._options.indentFromCenter) > 0;\n  },\n  _getTrackerSettings: function _getTrackerSettings() {\n    var options = this._options;\n\n    var radius = this._getRadius();\n\n    var indentFromCenter = this._getIndentFromCenter();\n\n    var x = options.x;\n    var y = options.y - (radius + indentFromCenter) / 2;\n    var width = options.width / 2;\n    var length = (radius - indentFromCenter) / 2;\n    width > 10 || (width = 10);\n    length > 10 || (length = 10);\n    return {\n      points: [x - width, y - length, x - width, y + length, x + width, y + length, x + width, y - length]\n    };\n  },\n  _render: function _render() {\n    this._renderPointer();\n  },\n  _clearPointer: function _clearPointer() {\n    delete this._element;\n  },\n  _clear: function _clear() {\n    this._clearPointer();\n  },\n  _getIndentFromCenter: function _getIndentFromCenter(radius) {\n    return Number(this._options.indentFromCenter) || 0;\n  },\n  _getRadius: function _getRadius() {\n    return 0;\n  },\n  measure: function measure(layout) {\n    var result = {\n      max: layout.radius\n    };\n\n    if (this._options.indentFromCenter < 0) {\n      result.inverseHorizontalOffset = result.inverseVerticalOffset = -_Number(this._options.indentFromCenter);\n    }\n\n    return result;\n  },\n  getTooltipParameters: function getTooltipParameters() {\n    var options = this._options;\n\n    var cosSin = _getCosAndSin(this._actualPosition);\n\n    var r = (this._getRadius() + this._getIndentFromCenter()) / 2;\n    return {\n      x: options.x + cosSin.cos * r,\n      y: options.y - cosSin.sin * r,\n      value: this._currentValue,\n      color: options.color,\n      offset: options.width / 2\n    };\n  }\n});\nvar NeedleIndicator = SimpleIndicator.inherit({\n  _isVisible: function _isVisible(layout) {\n    var indentFromCenter = this._adjustOffset(Number(this._options.indentFromCenter), layout.radius);\n\n    var offset = this._adjustOffset(Number(this._options.offset), layout.radius);\n\n    return layout.radius - indentFromCenter - offset > 0;\n  },\n  getOffset: function getOffset() {\n    return 0;\n  },\n  _adjustOffset: function _adjustOffset(value, radius) {\n    var minRadius = Number(this._options.beginAdaptingAtRadius);\n    var diff = radius / minRadius;\n\n    if (diff < 1) {\n      value = Math.floor(value * diff);\n    }\n\n    return value || 0;\n  },\n  _getIndentFromCenter: function _getIndentFromCenter(radius) {\n    return this._adjustOffset(Number(this._options.indentFromCenter), this._options.radius);\n  },\n  _getRadius: function _getRadius() {\n    var options = this._options;\n    return options.radius - this._adjustOffset(Number(options.offset), options.radius);\n  },\n  _renderSpindle: function _renderSpindle() {\n    var options = this._options;\n    var radius = options.radius;\n\n    var spindleSize = 2 * this._adjustOffset(_Number(options.spindleSize) / 2, radius);\n\n    var gapSize = 2 * this._adjustOffset(_Number(options.spindleGapSize) / 2, radius) || 0;\n\n    if (gapSize > 0) {\n      gapSize = gapSize <= spindleSize ? gapSize : spindleSize;\n    }\n\n    if (spindleSize > 0) {\n      this._spindleOuter = this._spindleOuter || this._renderer.circle().append(this._rootElement);\n      this._spindleInner = this._spindleInner || this._renderer.circle().append(this._rootElement);\n\n      this._spindleOuter.attr({\n        class: \"dxg-spindle-border\",\n        cx: options.x,\n        cy: options.y,\n        r: spindleSize / 2\n      });\n\n      this._spindleInner.attr({\n        class: \"dxg-spindle-hole\",\n        cx: options.x,\n        cy: options.y,\n        r: gapSize / 2,\n        fill: options.containerBackgroundColor\n      });\n    }\n  },\n  _render: function _render() {\n    this.callBase();\n\n    this._renderSpindle();\n  },\n  _clear: function _clear() {\n    this.callBase();\n    delete this._spindleOuter;\n    delete this._spindleInner;\n  }\n});\nvar rectangleNeedle = NeedleIndicator.inherit({\n  _renderPointer: function _renderPointer() {\n    var options = this._options;\n\n    var y2 = options.y - this._getRadius();\n\n    var y1 = options.y - this._getIndentFromCenter();\n\n    var x1 = options.x - options.width / 2;\n\n    var x2 = x1 + _Number(options.width);\n\n    this._element = this._element || this._renderer.path([], \"area\").append(this._rootElement);\n\n    this._element.attr({\n      points: [x1, y1, x1, y2, x2, y2, x2, y1]\n    });\n  }\n});\nvar triangleNeedle = NeedleIndicator.inherit({\n  _renderPointer: function _renderPointer() {\n    var options = this._options;\n\n    var y2 = options.y - this._getRadius();\n\n    var y1 = options.y - this._getIndentFromCenter();\n\n    var x1 = options.x - options.width / 2;\n    var x2 = options.x + options.width / 2;\n    this._element = this._element || this._renderer.path([], \"area\").append(this._rootElement);\n\n    this._element.attr({\n      points: [x1, y1, options.x, y2, x2, y1]\n    });\n  }\n});\nvar twoColorNeedle = NeedleIndicator.inherit({\n  _renderPointer: function _renderPointer() {\n    var options = this._options;\n    var x1 = options.x - options.width / 2;\n    var x2 = options.x + options.width / 2;\n\n    var y4 = options.y - this._getRadius();\n\n    var y1 = options.y - this._getIndentFromCenter();\n\n    var fraction = _Number(options.secondFraction) || 0;\n    var y2;\n    var y3;\n\n    if (fraction >= 1) {\n      y2 = y3 = y1;\n    } else if (fraction <= 0) {\n      y2 = y3 = y4;\n    } else {\n      y3 = y4 + (y1 - y4) * fraction;\n      y2 = y3 + _Number(options.space);\n    }\n\n    this._firstElement = this._firstElement || this._renderer.path([], \"area\").append(this._rootElement);\n    this._spaceElement = this._spaceElement || this._renderer.path([], \"area\").append(this._rootElement);\n    this._secondElement = this._secondElement || this._renderer.path([], \"area\").append(this._rootElement);\n\n    this._firstElement.attr({\n      points: [x1, y1, x1, y2, x2, y2, x2, y1]\n    });\n\n    this._spaceElement.attr({\n      points: [x1, y2, x1, y3, x2, y3, x2, y2],\n      class: \"dxg-hole\",\n      fill: options.containerBackgroundColor\n    });\n\n    this._secondElement.attr({\n      points: [x1, y3, x1, y4, x2, y4, x2, y3],\n      class: \"dxg-part\",\n      fill: options.secondColor\n    });\n  },\n  _clearPointer: function _clearPointer() {\n    delete this._firstElement;\n    delete this._secondElement;\n    delete this._spaceElement;\n  }\n});\nvar triangleMarker = SimpleIndicator.inherit({\n  _isEnabled: function _isEnabled() {\n    return this._options.length > 0 && this._options.width > 0;\n  },\n  _isVisible: function _isVisible(layout) {\n    return true;\n  },\n  resize: function resize(layout) {\n    return this.callBase(correctRadius(layout, 0));\n  },\n  _render: function _render() {\n    var options = this._options;\n    var x = options.x;\n    var y1 = options.y - options.radius;\n    var dx = options.width / 2 || 0;\n\n    var y2 = y1 - _Number(options.length);\n\n    this._element = this._element || this._renderer.path([], \"area\").append(this._rootElement);\n    var settings = {\n      points: [x, y1, x - dx, y2, x + dx, y2],\n      stroke: \"none\",\n      \"stroke-width\": 0,\n      \"stroke-linecap\": \"square\"\n    };\n\n    if (options.space > 0) {\n      settings[\"stroke-width\"] = Math.min(options.space, options.width / 4) || 0;\n      settings.stroke = settings[\"stroke-width\"] > 0 ? options.containerBackgroundColor || \"none\" : \"none\";\n    }\n\n    this._element.attr(settings).sharp();\n  },\n  _clear: function _clear() {\n    delete this._element;\n  },\n  _getTrackerSettings: function _getTrackerSettings() {\n    var options = this._options;\n    var x = options.x;\n    var y = options.y - options.radius - options.length / 2;\n    var width = options.width / 2;\n    var length = options.length / 2;\n    width > 10 || (width = 10);\n    length > 10 || (length = 10);\n    return {\n      points: [x - width, y - length, x - width, y + length, x + width, y + length, x + width, y - length]\n    };\n  },\n  measure: function measure(layout) {\n    return {\n      min: layout.radius,\n      max: layout.radius + _Number(this._options.length)\n    };\n  },\n  getTooltipParameters: function getTooltipParameters() {\n    var options = this._options;\n\n    var cosSin = _getCosAndSin(this._actualPosition);\n\n    var r = options.radius + options.length / 2;\n    var parameters = this.callBase();\n    parameters.x = options.x + cosSin.cos * r;\n    parameters.y = options.y - cosSin.sin * r;\n    parameters.offset = options.length / 2;\n    return parameters;\n  }\n});\nvar textCloud = BaseTextCloudMarker.inherit({\n  _isEnabled: function _isEnabled() {\n    return true;\n  },\n  _isVisible: function _isVisible(layout) {\n    return true;\n  },\n  resize: function resize(layout) {\n    return this.callBase(correctRadius(layout, 0));\n  },\n  _getTextCloudOptions: function _getTextCloudOptions() {\n    var cosSin = _getCosAndSin(this._actualPosition);\n\n    var nAngle = normalizeAngle(this._actualPosition);\n    return {\n      x: this._options.x + cosSin.cos * this._options.radius,\n      y: this._options.y - cosSin.sin * this._options.radius,\n      type: nAngle > 270 ? \"left-top\" : nAngle > 180 ? \"top-right\" : nAngle > 90 ? \"right-bottom\" : \"bottom-left\"\n    };\n  },\n  measure: function measure(layout) {\n    var arrowLength = _Number(this._options.arrowLength) || 0;\n\n    this._measureText();\n\n    var verticalOffset = this._textFullHeight + arrowLength;\n    var horizontalOffset = this._textFullWidth + arrowLength;\n    return {\n      min: layout.radius,\n      max: layout.radius,\n      horizontalOffset: horizontalOffset,\n      verticalOffset: verticalOffset,\n      inverseHorizontalOffset: horizontalOffset,\n      inverseVerticalOffset: verticalOffset\n    };\n  }\n});\nvar rangeBar = BaseRangeBar.inherit({\n  _isEnabled: function _isEnabled() {\n    return this._options.size > 0;\n  },\n  _isVisible: function _isVisible(layout) {\n    return true;\n  },\n  resize: function resize(layout) {\n    return this.callBase(correctRadius(layout, _Number(this._options.size)));\n  },\n  _createBarItem: function _createBarItem() {\n    return this._renderer.arc().attr({\n      \"stroke-linejoin\": \"round\"\n    }).append(this._rootElement);\n  },\n  _createTracker: function _createTracker() {\n    return this._renderer.arc().attr({\n      \"stroke-linejoin\": \"round\"\n    });\n  },\n  _setBarSides: function _setBarSides() {\n    this._maxSide = this._options.radius;\n    this._minSide = this._maxSide - _Number(this._options.size);\n  },\n  _getSpace: function _getSpace() {\n    var options = this._options;\n    return options.space > 0 ? 180 * options.space / options.radius / Math.PI : 0;\n  },\n  _isTextVisible: function _isTextVisible() {\n    var options = this._options.text || {};\n    return options.indent > 0;\n  },\n  _setTextItemsSides: function _setTextItemsSides() {\n    var options = this._options;\n\n    var indent = _Number(options.text.indent);\n\n    this._lineFrom = options.y - options.radius;\n    this._lineTo = this._lineFrom - indent;\n    this._textRadius = options.radius + indent;\n  },\n  _getPositions: function _getPositions() {\n    var basePosition = this._basePosition;\n    var actualPosition = this._actualPosition;\n    var mainPosition1;\n    var mainPosition2;\n\n    if (basePosition >= actualPosition) {\n      mainPosition1 = basePosition;\n      mainPosition2 = actualPosition;\n    } else {\n      mainPosition1 = actualPosition;\n      mainPosition2 = basePosition;\n    }\n\n    return {\n      start: this._startPosition,\n      end: this._endPosition,\n      main1: mainPosition1,\n      main2: mainPosition2,\n      back1: Math.min(mainPosition1 + this._space, this._startPosition),\n      back2: Math.max(mainPosition2 - this._space, this._endPosition)\n    };\n  },\n  _buildItemSettings: function _buildItemSettings(from, to) {\n    return {\n      x: this._options.x,\n      y: this._options.y,\n      innerRadius: this._minSide,\n      outerRadius: this._maxSide,\n      startAngle: to,\n      endAngle: from\n    };\n  },\n  _updateTextPosition: function _updateTextPosition() {\n    var cosSin = _getCosAndSin(this._actualPosition);\n\n    var x = this._options.x + this._textRadius * cosSin.cos;\n    var y = this._options.y - this._textRadius * cosSin.sin;\n    x += cosSin.cos * this._textWidth * .6;\n    y -= cosSin.sin * this._textHeight * .6;\n\n    this._text.attr({\n      x: x,\n      y: y + this._textVerticalOffset\n    });\n  },\n  _updateLinePosition: function _updateLinePosition() {\n    var x = this._options.x;\n    var x1;\n    var x2;\n\n    if (this._basePosition > this._actualPosition) {\n      x1 = x - 2;\n      x2 = x;\n    } else if (this._basePosition < this._actualPosition) {\n      x1 = x;\n      x2 = x + 2;\n    } else {\n      x1 = x - 1;\n      x2 = x + 1;\n    }\n\n    this._line.attr({\n      points: [x1, this._lineFrom, x1, this._lineTo, x2, this._lineTo, x2, this._lineFrom]\n    }).rotate(_convertAngleToRendererSpace(this._actualPosition), x, this._options.y).sharp();\n  },\n  _getTooltipPosition: function _getTooltipPosition() {\n    var cosSin = _getCosAndSin((this._basePosition + this._actualPosition) / 2);\n\n    var r = (this._minSide + this._maxSide) / 2;\n    return {\n      x: this._options.x + cosSin.cos * r,\n      y: this._options.y - cosSin.sin * r\n    };\n  },\n  measure: function measure(layout) {\n    var result = {\n      min: layout.radius - _Number(this._options.size),\n      max: layout.radius\n    };\n\n    this._measureText();\n\n    if (this._hasText) {\n      result.max += _Number(this._options.text.indent);\n      result.horizontalOffset = this._textWidth;\n      result.verticalOffset = this._textHeight;\n    }\n\n    return result;\n  }\n});\nexport { rectangleNeedle as _default, rectangleNeedle as rectangleneedle, triangleNeedle as triangleneedle, twoColorNeedle as twocolorneedle, triangleMarker as trianglemarker, textCloud as textcloud, rangeBar as rangebar };","map":null,"metadata":{},"sourceType":"module"}