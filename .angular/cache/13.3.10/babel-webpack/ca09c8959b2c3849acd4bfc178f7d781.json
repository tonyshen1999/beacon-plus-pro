{"ast":null,"code":"/**\r\n * DevExtreme (esm/viz/series/base_series.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nvar seriesNS = {};\nimport { isFunction, isDefined as _isDefined, isEmptyObject as _isEmptyObject } from \"../../core/utils/type\";\nimport { extend as _extend } from \"../../core/utils/extend\";\nimport { each as _each } from \"../../core/utils/iterator\";\nimport { Point } from \"./points/base_point\";\nimport { normalizeEnum as _normalizeEnum } from \"../core/utils\";\nimport { noop as _noop } from \"../../core/utils/common\";\nimport consts from \"../components/consts\";\nvar states = consts.states;\nimport rangeCalculator from \"./helpers/range_data_calculator\";\nimport * as scatterSeries from \"./scatter_series\";\nimport * as lineSeries from \"./line_series\";\nimport * as areaSeries from \"./area_series\";\nimport * as barSeries from \"./bar_series\";\nimport { chart as rangeSeriesChart } from \"./range_series\";\nimport { chart as bubbleSeriesChart } from \"./bubble_series\";\nimport * as pieSeries from \"./pie_series\";\nimport * as financialSeries from \"./financial_series\";\nimport * as stackedSeries from \"./stacked_series\";\nvar DISCRETE = \"discrete\";\nvar SELECTED_STATE = states.selectedMark;\nvar HOVER_STATE = states.hoverMark;\nvar HOVER = states.hover;\nvar NORMAL = states.normal;\nvar SELECTION = states.selection;\nvar APPLY_SELECTED = states.applySelected;\nvar APPLY_HOVER = states.applyHover;\nvar RESET_ITEM = states.resetItem;\nvar NONE_MODE = \"none\";\nvar INCLUDE_POINTS = \"includepoints\";\nvar NEAREST_POINT = \"nearestpoint\";\nvar SERIES_SELECTION_CHANGED = \"seriesSelectionChanged\";\nvar POINT_SELECTION_CHANGED = \"pointSelectionChanged\";\nvar SERIES_HOVER_CHANGED = \"seriesHoverChanged\";\nvar POINT_HOVER_CHANGED = \"pointHoverChanged\";\nvar ALL_SERIES_POINTS = \"allseriespoints\";\nvar ALL_ARGUMENT_POINTS = \"allargumentpoints\";\nvar POINT_HOVER = \"pointHover\";\nvar CLEAR_POINT_HOVER = \"clearPointHover\";\nvar SERIES_SELECT = \"seriesSelect\";\nvar POINT_SELECT = \"pointSelect\";\nvar POINT_DESELECT = \"pointDeselect\";\n\nvar getEmptyBusinessRange = function getEmptyBusinessRange() {\n  return {\n    arg: {},\n    val: {}\n  };\n};\n\nfunction triggerEvent(element, event, point) {\n  element && element.trigger(event, point);\n}\n\nseriesNS.mixins = {\n  chart: {},\n  pie: {},\n  polar: {}\n};\nseriesNS.mixins.chart.scatter = scatterSeries.chart;\nseriesNS.mixins.polar.scatter = scatterSeries.polar;\n\n_extend(seriesNS.mixins.pie, pieSeries);\n\n_extend(seriesNS.mixins.chart, lineSeries.chart, areaSeries.chart, barSeries.chart, rangeSeriesChart, bubbleSeriesChart, financialSeries, stackedSeries.chart);\n\n_extend(seriesNS.mixins.polar, lineSeries.polar, areaSeries.polar, barSeries.polar, stackedSeries.polar);\n\nfunction includePointsMode(mode) {\n  mode = _normalizeEnum(mode);\n  return mode === INCLUDE_POINTS || mode === ALL_SERIES_POINTS;\n}\n\nfunction getLabelOptions(labelOptions, defaultColor) {\n  var opt = labelOptions || {};\n  var labelFont = _extend({}, opt.font) || {};\n  var labelBorder = opt.border || {};\n  var labelConnector = opt.connector || {};\n  var backgroundAttr = {\n    fill: opt.backgroundColor || defaultColor,\n    \"stroke-width\": labelBorder.visible ? labelBorder.width || 0 : 0,\n    stroke: labelBorder.visible && labelBorder.width ? labelBorder.color : \"none\",\n    dashStyle: labelBorder.dashStyle\n  };\n  var connectorAttr = {\n    stroke: labelConnector.visible && labelConnector.width ? labelConnector.color || defaultColor : \"none\",\n    \"stroke-width\": labelConnector.visible ? labelConnector.width || 0 : 0\n  };\n  labelFont.color = \"none\" === opt.backgroundColor && \"#ffffff\" === _normalizeEnum(labelFont.color) && \"inside\" !== opt.position ? defaultColor : labelFont.color;\n  return {\n    alignment: opt.alignment,\n    format: opt.format,\n    argumentFormat: opt.argumentFormat,\n    customizeText: isFunction(opt.customizeText) ? opt.customizeText : void 0,\n    attributes: {\n      font: labelFont\n    },\n    visible: 0 !== labelFont.size ? opt.visible : false,\n    showForZeroValues: opt.showForZeroValues,\n    horizontalOffset: opt.horizontalOffset,\n    verticalOffset: opt.verticalOffset,\n    radialOffset: opt.radialOffset,\n    background: backgroundAttr,\n    position: opt.position,\n    connector: connectorAttr,\n    rotationAngle: opt.rotationAngle,\n    wordWrap: opt.wordWrap,\n    textOverflow: opt.textOverflow,\n    cssClass: opt.cssClass\n  };\n}\n\nfunction setPointHoverState(point, legendCallback) {\n  point.fullState |= HOVER_STATE;\n  point.applyView(legendCallback);\n}\n\nfunction releasePointHoverState(point, legendCallback) {\n  point.fullState &= ~HOVER_STATE;\n  point.applyView(legendCallback);\n  point.releaseHoverState();\n}\n\nfunction setPointSelectedState(point, legendCallback) {\n  point.fullState |= SELECTED_STATE;\n  point.applyView(legendCallback);\n}\n\nfunction releasePointSelectedState(point, legendCallback) {\n  point.fullState &= ~SELECTED_STATE;\n  point.applyView(legendCallback);\n}\n\nfunction mergePointOptionsCore(base, extra) {\n  var options = _extend({}, base, extra);\n\n  options.border = _extend({}, base && base.border, extra && extra.border);\n  return options;\n}\n\nfunction mergePointOptions(base, extra) {\n  var options = mergePointOptionsCore(base, extra);\n  options.image = _extend(true, {}, base.image, extra.image);\n  options.selectionStyle = mergePointOptionsCore(base.selectionStyle, extra.selectionStyle);\n  options.hoverStyle = mergePointOptionsCore(base.hoverStyle, extra.hoverStyle);\n  return options;\n}\n\nexport function Series(settings, options) {\n  this.fullState = 0;\n  this._extGroups = settings;\n  this._renderer = settings.renderer;\n  this._group = settings.renderer.g().attr({\n    class: \"dxc-series\"\n  });\n  this._eventTrigger = settings.eventTrigger;\n  this._eventPipe = settings.eventPipe;\n  this._incidentOccurred = settings.incidentOccurred;\n  this._legendCallback = _noop;\n  this.updateOptions(options, settings);\n}\n\nfunction getData(pointData) {\n  return pointData.data;\n}\n\nfunction getValueChecker(axisType, axis) {\n  if (!axis || \"logarithmic\" !== axisType || false !== axis.getOptions().allowNegatives) {\n    return function () {\n      return true;\n    };\n  } else {\n    return function (value) {\n      return value > 0;\n    };\n  }\n}\n\nSeries.prototype = {\n  constructor: Series,\n  _createLegendState: _noop,\n  getLegendStyles: function getLegendStyles() {\n    return this._styles.legendStyles;\n  },\n  _createStyles: function _createStyles(options) {\n    var mainSeriesColor = options.mainSeriesColor;\n    this._styles = {\n      normal: this._parseStyle(options, mainSeriesColor, mainSeriesColor),\n      hover: this._parseStyle(options.hoverStyle || {}, mainSeriesColor, mainSeriesColor),\n      selection: this._parseStyle(options.selectionStyle || {}, mainSeriesColor, mainSeriesColor),\n      legendStyles: {\n        normal: this._createLegendState(options, mainSeriesColor),\n        hover: this._createLegendState(options.hoverStyle || {}, mainSeriesColor),\n        selection: this._createLegendState(options.selectionStyle || {}, mainSeriesColor)\n      }\n    };\n  },\n  setClippingParams: function setClippingParams(baseId, wideId, forceClipping) {\n    var clipLabels = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : true;\n    this._paneClipRectID = baseId;\n    this._widePaneClipRectID = wideId;\n    this._forceClipping = forceClipping;\n    this._clipLabels = clipLabels;\n  },\n  applyClip: function applyClip() {\n    this._group.attr({\n      \"clip-path\": this._paneClipRectID\n    });\n  },\n  resetClip: function resetClip() {\n    this._group.attr({\n      \"clip-path\": null\n    });\n  },\n  getTagField: function getTagField() {\n    return this._options.tagField || \"tag\";\n  },\n  getValueFields: _noop,\n  getSizeField: _noop,\n  getArgumentField: _noop,\n  getPoints: function getPoints() {\n    return this._points;\n  },\n  getPointsInViewPort: function getPointsInViewPort() {\n    return rangeCalculator.getPointsInViewPort(this);\n  },\n  _createPoint: function _createPoint(data, index, oldPoint) {\n    data.index = index;\n    var pointsByArgument = this.pointsByArgument;\n\n    var options = this._getCreatingPointOptions(data);\n\n    var arg = data.argument.valueOf();\n    var point = oldPoint;\n\n    if (point) {\n      point.update(data, options);\n    } else {\n      point = new Point(this, data, options);\n\n      if (this.isSelected() && includePointsMode(this.lastSelectionMode)) {\n        point.setView(SELECTION);\n      }\n    }\n\n    var pointByArgument = pointsByArgument[arg];\n\n    if (pointByArgument) {\n      pointByArgument.push(point);\n    } else {\n      pointsByArgument[arg] = [point];\n    }\n\n    if (point.hasValue()) {\n      this.customizePoint(point, data);\n    }\n\n    return point;\n  },\n  getRangeData: function getRangeData() {\n    return this._visible ? this._getRangeData() : getEmptyBusinessRange();\n  },\n  getArgumentRange: function getArgumentRange() {\n    return this._visible ? rangeCalculator.getArgumentRange(this) : getEmptyBusinessRange();\n  },\n  getViewport: function getViewport() {\n    return rangeCalculator.getViewport(this);\n  },\n  _deleteGroup: function _deleteGroup(groupName) {\n    var group = this[groupName];\n\n    if (group) {\n      group.dispose();\n      this[groupName] = null;\n    }\n  },\n  updateOptions: function updateOptions(newOptions, settings) {\n    var widgetType = newOptions.widgetType;\n    var oldType = this.type;\n    var newType = newOptions.type;\n    this.type = newType && _normalizeEnum(newType.toString());\n\n    if (!this._checkType(widgetType) || this._checkPolarBarType(widgetType, newOptions)) {\n      this.dispose();\n      this.isUpdated = false;\n      return;\n    }\n\n    if (oldType !== this.type) {\n      this._firstDrawing = true;\n\n      this._resetType(oldType, widgetType);\n\n      this._setType(this.type, widgetType);\n    } else {\n      this._defineDrawingState();\n    }\n\n    this._options = newOptions;\n    this._pointOptions = null;\n    this.name = newOptions.name;\n    this.pane = newOptions.pane;\n    this.tag = newOptions.tag;\n\n    if (settings) {\n      this._seriesModes = settings.commonSeriesModes || this._seriesModes;\n      this._valueAxis = settings.valueAxis || this._valueAxis;\n      this.axis = this._valueAxis && this._valueAxis.name;\n      this._argumentAxis = settings.argumentAxis || this._argumentAxis;\n    }\n\n    this._createStyles(newOptions);\n\n    this._stackName = null;\n\n    this._updateOptions(newOptions);\n\n    this._visible = newOptions.visible;\n    this.isUpdated = true;\n    this.stack = newOptions.stack;\n    this.barOverlapGroup = newOptions.barOverlapGroup;\n\n    this._createGroups();\n\n    this._processEmptyValue = newOptions.ignoreEmptyPoints ? function (x) {\n      return null === x ? void 0 : x;\n    } : function (x) {\n      return x;\n    };\n  },\n  _defineDrawingState: function _defineDrawingState() {\n    this._firstDrawing = true;\n  },\n  _disposePoints: function _disposePoints(points) {\n    _each(points || [], function (_, p) {\n      p.dispose();\n    });\n  },\n  updateDataType: function updateDataType(settings) {\n    this.argumentType = settings.argumentType;\n    this.valueType = settings.valueType;\n    this.argumentAxisType = settings.argumentAxisType;\n    this.valueAxisType = settings.valueAxisType;\n    this.showZero = settings.showZero;\n    this._argumentChecker = getValueChecker(settings.argumentAxisType, this.getArgumentAxis());\n    this._valueChecker = getValueChecker(settings.valueAxisType, this.getValueAxis());\n    return this;\n  },\n  _argumentChecker: function _argumentChecker() {\n    return true;\n  },\n  _valueChecker: function _valueChecker() {\n    return true;\n  },\n  getOptions: function getOptions() {\n    return this._options;\n  },\n  _getOldPoint: function _getOldPoint(data, oldPointsByArgument, index) {\n    var arg = data.argument && data.argument.valueOf();\n    var point = (oldPointsByArgument[arg] || [])[0];\n\n    if (point) {\n      oldPointsByArgument[arg].splice(0, 1);\n    }\n\n    return point;\n  },\n  updateData: function updateData(data) {\n    var options = this._options;\n    var nameField = options.nameField;\n    data = data || [];\n\n    if (data.length) {\n      this._canRenderCompleteHandle = true;\n    }\n\n    var dataSelector = this._getPointDataSelector();\n\n    var itemsWithoutArgument = 0;\n    this._data = data.reduce(function (data, dataItem, index) {\n      var pointDataItem = dataSelector(dataItem);\n\n      if (_isDefined(pointDataItem.argument)) {\n        if (!nameField || dataItem[nameField] === options.nameFieldValue) {\n          pointDataItem.index = index;\n          data.push(pointDataItem);\n        }\n      } else {\n        itemsWithoutArgument++;\n      }\n\n      return data;\n    }, []);\n\n    if (itemsWithoutArgument && itemsWithoutArgument === data.length) {\n      this._incidentOccurred(\"W2002\", [this.name, this.getArgumentField()]);\n    }\n\n    this._endUpdateData();\n  },\n  _getData: function _getData() {\n    var data = this._data || [];\n\n    if (this.useAggregation()) {\n      data = this._resample(this.getArgumentAxis().getAggregationInfo(this._useAllAggregatedPoints, this.argumentAxisType !== DISCRETE ? this.getArgumentRange() : {}), data);\n    }\n\n    return data;\n  },\n  useAggregation: function useAggregation() {\n    var aggregation = this.getOptions().aggregation;\n    return aggregation && aggregation.enabled;\n  },\n  autoHidePointMarkersEnabled: _noop,\n  usePointsToDefineAutoHiding: _noop,\n  createPoints: function createPoints(useAllAggregatedPoints) {\n    this._normalizeUsingAllAggregatedPoints(useAllAggregatedPoints);\n\n    this._createPoints();\n  },\n  _normalizeUsingAllAggregatedPoints: function _normalizeUsingAllAggregatedPoints(useAllAggregatedPoints) {\n    this._useAllAggregatedPoints = this.useAggregation() && (this.argumentAxisType === DISCRETE || (this._data || []).length > 1 && !!useAllAggregatedPoints);\n  },\n  _createPoints: function _createPoints() {\n    var that = this;\n    var oldPointsByArgument = that.pointsByArgument || {};\n\n    var data = that._getData();\n\n    that.pointsByArgument = {};\n\n    that._calculateErrorBars(data);\n\n    var skippedFields = {};\n    var points = data.reduce(function (points, pointDataItem) {\n      if (that._checkData(pointDataItem, skippedFields)) {\n        var pointIndex = points.length;\n\n        var oldPoint = that._getOldPoint(pointDataItem, oldPointsByArgument, pointIndex);\n\n        var point = that._createPoint(pointDataItem, pointIndex, oldPoint);\n\n        points.push(point);\n      }\n\n      return points;\n    }, []);\n\n    for (var field in skippedFields) {\n      if (skippedFields[field] === data.length) {\n        that._incidentOccurred(\"W2002\", [that.name, field]);\n      }\n    }\n\n    Object.keys(oldPointsByArgument).forEach(function (key) {\n      return that._disposePoints(oldPointsByArgument[key]);\n    });\n    that._points = points;\n  },\n  _removeOldSegments: function _removeOldSegments() {\n    var that = this;\n    var startIndex = that._segments.length;\n\n    _each(that._graphics.splice(startIndex, that._graphics.length) || [], function (_, elem) {\n      that._removeElement(elem);\n    });\n\n    if (that._trackers) {\n      _each(that._trackers.splice(startIndex, that._trackers.length) || [], function (_, elem) {\n        elem.remove();\n      });\n    }\n  },\n  _drawElements: function _drawElements(animationEnabled, firstDrawing, translateAllPoints) {\n    var that = this;\n    var points = that._points || [];\n\n    var closeSegment = points[0] && points[0].hasValue() && that._options.closed;\n\n    var groupForPoint = {\n      markers: that._markersGroup,\n      errorBars: that._errorBarGroup\n    };\n    that._drawnPoints = [];\n    that._graphics = that._graphics || [];\n    that._segments = [];\n    var segments = points.reduce(function (segments, p) {\n      var segment = segments[segments.length - 1];\n\n      if (!p.translated || translateAllPoints) {\n        p.translate();\n        !translateAllPoints && p.setDefaultCoords();\n      }\n\n      if (p.hasValue() && p.hasCoords()) {\n        translateAllPoints && that._drawPoint({\n          point: p,\n          groups: groupForPoint,\n          hasAnimation: animationEnabled,\n          firstDrawing: firstDrawing\n        });\n        segment.push(p);\n      } else if (!p.hasValue()) {\n        segment.length && segments.push([]);\n      } else {\n        p.setInvisibility();\n      }\n\n      return segments;\n    }, [[]]);\n    segments.forEach(function (segment, index) {\n      if (segment.length) {\n        that._drawSegment(segment, animationEnabled, index, closeSegment && index === this.length - 1);\n      }\n    }, segments);\n    that._firstDrawing = !points.length;\n\n    that._removeOldSegments();\n\n    animationEnabled && that._animate(firstDrawing);\n  },\n  draw: function draw(animationEnabled, hideLayoutLabels, legendCallback) {\n    var firstDrawing = this._firstDrawing;\n    this._legendCallback = legendCallback || this._legendCallback;\n\n    if (!this._visible) {\n      this._group.remove();\n\n      return;\n    }\n\n    this._appendInGroup();\n\n    this._applyVisibleArea();\n\n    this._setGroupsSettings(animationEnabled, firstDrawing);\n\n    !firstDrawing && !this._resetApplyingAnimation && this._drawElements(false, firstDrawing, false);\n\n    this._drawElements(animationEnabled, firstDrawing, true);\n\n    hideLayoutLabels && this.hideLabels();\n\n    if (this.isSelected()) {\n      this._changeStyle(this.lastSelectionMode, void 0, true);\n    } else if (this.isHovered()) {\n      this._changeStyle(this.lastHoverMode, void 0, true);\n    } else {\n      this._applyStyle(this._styles.normal);\n    }\n\n    this._resetApplyingAnimation = false;\n  },\n  _setLabelGroupSettings: function _setLabelGroupSettings(animationEnabled) {\n    var settings = {\n      class: \"dxc-labels\",\n      \"pointer-events\": \"none\"\n    };\n    this._clipLabels && this._applyElementsClipRect(settings);\n\n    this._applyClearingSettings(settings);\n\n    animationEnabled && (settings.opacity = .001);\n\n    this._labelsGroup.attr(settings).append(this._extGroups.labelsGroup);\n  },\n  _checkType: function _checkType(widgetType) {\n    return !!seriesNS.mixins[widgetType][this.type];\n  },\n  _checkPolarBarType: function _checkPolarBarType(widgetType, options) {\n    return \"polar\" === widgetType && options.spiderWidget && -1 !== this.type.indexOf(\"bar\");\n  },\n  _resetType: function _resetType(seriesType, widgetType) {\n    var methodName;\n    var methods;\n\n    if (seriesType) {\n      methods = seriesNS.mixins[widgetType][seriesType];\n\n      for (methodName in methods) {\n        delete this[methodName];\n      }\n    }\n  },\n  _setType: function _setType(seriesType, widgetType) {\n    var methodName;\n    var methods = seriesNS.mixins[widgetType][seriesType];\n\n    for (methodName in methods) {\n      this[methodName] = methods[methodName];\n    }\n  },\n  _setPointsView: function _setPointsView(view, target) {\n    this.getPoints().forEach(function (point) {\n      if (target !== point) {\n        point.setView(view);\n      }\n    });\n  },\n  _resetPointsView: function _resetPointsView(view, target) {\n    this.getPoints().forEach(function (point) {\n      if (target !== point) {\n        point.resetView(view);\n      }\n    });\n  },\n  _resetNearestPoint: function _resetNearestPoint() {\n    this._nearestPoint && null !== this._nearestPoint.series && this._nearestPoint.resetView(HOVER);\n    this._nearestPoint = null;\n  },\n  _setSelectedState: function _setSelectedState(mode) {\n    this.lastSelectionMode = _normalizeEnum(mode || this._options.selectionMode);\n    this.fullState = this.fullState | SELECTED_STATE;\n\n    this._resetNearestPoint();\n\n    this._changeStyle(this.lastSelectionMode);\n\n    if (this.lastSelectionMode !== NONE_MODE && this.isHovered() && includePointsMode(this.lastHoverMode)) {\n      this._resetPointsView(HOVER);\n    }\n  },\n  _releaseSelectedState: function _releaseSelectedState() {\n    this.fullState = this.fullState & ~SELECTED_STATE;\n\n    this._changeStyle(this.lastSelectionMode, SELECTION);\n\n    if (this.lastSelectionMode !== NONE_MODE && this.isHovered() && includePointsMode(this.lastHoverMode)) {\n      this._setPointsView(HOVER);\n    }\n  },\n  isFullStackedSeries: function isFullStackedSeries() {\n    return 0 === this.type.indexOf(\"fullstacked\");\n  },\n  isStackedSeries: function isStackedSeries() {\n    return 0 === this.type.indexOf(\"stacked\");\n  },\n  resetApplyingAnimation: function resetApplyingAnimation(isFirstDrawing) {\n    this._resetApplyingAnimation = true;\n\n    if (isFirstDrawing) {\n      this._firstDrawing = true;\n    }\n  },\n  isFinancialSeries: function isFinancialSeries() {\n    return \"stock\" === this.type || \"candlestick\" === this.type;\n  },\n  _canChangeView: function _canChangeView() {\n    return !this.isSelected() && _normalizeEnum(this._options.hoverMode) !== NONE_MODE;\n  },\n  _changeStyle: function _changeStyle(mode, resetView, skipPoints) {\n    var state = this.fullState;\n    var styles = [NORMAL, HOVER, SELECTION, SELECTION];\n\n    if (\"none\" === this.lastHoverMode) {\n      state &= ~HOVER_STATE;\n    }\n\n    if (\"none\" === this.lastSelectionMode) {\n      state &= ~SELECTED_STATE;\n    }\n\n    if (includePointsMode(mode) && !skipPoints) {\n      if (!resetView) {\n        this._setPointsView(styles[state]);\n      } else {\n        this._resetPointsView(resetView);\n      }\n    }\n\n    this._legendCallback([RESET_ITEM, APPLY_HOVER, APPLY_SELECTED, APPLY_SELECTED][state]);\n\n    this._applyStyle(this._styles[styles[state]]);\n  },\n  updateHover: function updateHover(x, y) {\n    var currentNearestPoint = this._nearestPoint;\n    var point = this.isHovered() && this.lastHoverMode === NEAREST_POINT && this.getNeighborPoint(x, y);\n\n    if (point !== currentNearestPoint && !(this.isSelected() && this.lastSelectionMode !== NONE_MODE)) {\n      this._resetNearestPoint();\n\n      if (point) {\n        point.setView(HOVER);\n        this._nearestPoint = point;\n      }\n    }\n  },\n  _getMainAxisName: function _getMainAxisName() {\n    return this._options.rotated ? \"X\" : \"Y\";\n  },\n  areLabelsVisible: function areLabelsVisible() {\n    return !_isDefined(this._options.maxLabelCount) || this._points.length <= this._options.maxLabelCount;\n  },\n  getLabelVisibility: function getLabelVisibility() {\n    return this.areLabelsVisible() && this._options.label && this._options.label.visible;\n  },\n  customizePoint: function customizePoint(point, pointData) {\n    var options = this._options;\n    var customizePoint = options.customizePoint;\n    var customizeObject;\n    var pointOptions;\n    var customLabelOptions;\n    var customOptions;\n    var customizeLabel = options.customizeLabel;\n    var useLabelCustomOptions;\n    var usePointCustomOptions;\n\n    if (customizeLabel && customizeLabel.call) {\n      customizeObject = _extend({\n        seriesName: this.name\n      }, pointData);\n      customizeObject.series = this;\n      customLabelOptions = customizeLabel.call(customizeObject, customizeObject);\n      useLabelCustomOptions = customLabelOptions && !_isEmptyObject(customLabelOptions);\n      customLabelOptions = useLabelCustomOptions ? _extend(true, {}, options.label, customLabelOptions) : null;\n    }\n\n    if (customizePoint && customizePoint.call) {\n      customizeObject = customizeObject || _extend({\n        seriesName: this.name\n      }, pointData);\n      customizeObject.series = this;\n      customOptions = customizePoint.call(customizeObject, customizeObject);\n      usePointCustomOptions = customOptions && !_isEmptyObject(customOptions);\n    }\n\n    if (useLabelCustomOptions || usePointCustomOptions) {\n      pointOptions = this._parsePointOptions(this._preparePointOptions(customOptions), customLabelOptions || options.label, pointData, point);\n      pointOptions.styles.useLabelCustomOptions = useLabelCustomOptions;\n      pointOptions.styles.usePointCustomOptions = usePointCustomOptions;\n      point.updateOptions(pointOptions);\n    }\n  },\n  show: function show() {\n    if (!this._visible) {\n      this._changeVisibility(true);\n    }\n  },\n  hide: function hide() {\n    if (this._visible) {\n      this._changeVisibility(false);\n    }\n  },\n  _changeVisibility: function _changeVisibility(visibility) {\n    this._visible = this._options.visible = visibility;\n\n    this._updatePointsVisibility();\n\n    this.hidePointTooltip();\n\n    this._options.visibilityChanged(this);\n  },\n  _updatePointsVisibility: _noop,\n  hideLabels: function hideLabels() {\n    _each(this._points, function (_, point) {\n      point._label.draw(false);\n    });\n  },\n  _parsePointOptions: function _parsePointOptions(pointOptions, labelOptions, data, point) {\n    var options = this._options;\n\n    var styles = this._createPointStyles(pointOptions, data, point);\n\n    var parsedOptions = _extend({}, pointOptions, {\n      type: options.type,\n      rotated: options.rotated,\n      styles: styles,\n      widgetType: options.widgetType,\n      visibilityChanged: options.visibilityChanged\n    });\n\n    parsedOptions.label = getLabelOptions(labelOptions, styles.normal.fill);\n\n    if (this.areErrorBarsVisible()) {\n      parsedOptions.errorBars = options.valueErrorBar;\n    }\n\n    return parsedOptions;\n  },\n  _preparePointOptions: function _preparePointOptions(customOptions) {\n    var pointOptions = this._getOptionsForPoint();\n\n    return customOptions ? mergePointOptions(pointOptions, customOptions) : pointOptions;\n  },\n  _getMarkerGroupOptions: function _getMarkerGroupOptions() {\n    return _extend(false, {}, this._getOptionsForPoint(), {\n      hoverStyle: {},\n      selectionStyle: {}\n    });\n  },\n  _getAggregationMethod: function _getAggregationMethod(isDiscrete, aggregateByCategory) {\n    var options = this.getOptions().aggregation;\n\n    var method = _normalizeEnum(options.method);\n\n    var customAggregator = \"custom\" === method && options.calculate;\n    var aggregator;\n\n    if (isDiscrete && !aggregateByCategory) {\n      aggregator = function aggregator(_ref) {\n        var data = _ref.data;\n        return data[0];\n      };\n    } else {\n      aggregator = this._aggregators[method] || this._aggregators[this._defaultAggregator];\n    }\n\n    return customAggregator || aggregator;\n  },\n  _resample: function _resample(_ref2, data) {\n    var interval = _ref2.interval,\n        ticks = _ref2.ticks,\n        aggregateByCategory = _ref2.aggregateByCategory;\n    var that = this;\n    var isDiscrete = that.argumentAxisType === DISCRETE || that.valueAxisType === DISCRETE;\n    var dataIndex = 0;\n\n    var dataSelector = this._getPointDataSelector();\n\n    var options = that.getOptions();\n\n    var addAggregatedData = function addAggregatedData(target, data, aggregationInfo) {\n      if (!data) {\n        return;\n      }\n\n      var processData = function processData(d) {\n        var pointData = d && dataSelector(d, options);\n\n        if (pointData && that._checkData(pointData)) {\n          pointData.aggregationInfo = aggregationInfo;\n          target.push(pointData);\n        }\n      };\n\n      if (Array.isArray(data)) {\n        data.forEach(processData);\n      } else {\n        processData(data);\n      }\n    };\n\n    var aggregationMethod = this._getAggregationMethod(isDiscrete, aggregateByCategory);\n\n    if (isDiscrete) {\n      if (aggregateByCategory) {\n        var categories = this.getArgumentAxis().getTranslator().getBusinessRange().categories;\n        var groups = categories.reduce(function (g, category) {\n          g[category.valueOf()] = [];\n          return g;\n        }, {});\n        data.forEach(function (dataItem) {\n          groups[dataItem.argument.valueOf()].push(dataItem);\n        });\n        return categories.reduce(function (result, c) {\n          addAggregatedData(result, aggregationMethod({\n            aggregationInterval: null,\n            intervalStart: c,\n            intervalEnd: c,\n            data: groups[c.valueOf()].map(getData)\n          }, that));\n          return result;\n        }, []);\n      } else {\n        return data.reduce(function (result, dataItem, index, data) {\n          result[1].push(dataItem);\n\n          if (index === data.length - 1 || (index + 1) % interval === 0) {\n            var dataInInterval = result[1];\n            var aggregationInfo = {\n              aggregationInterval: interval,\n              data: dataInInterval.map(getData)\n            };\n            addAggregatedData(result[0], aggregationMethod(aggregationInfo, that));\n            result[1] = [];\n          }\n\n          return result;\n        }, [[], []])[0];\n      }\n    }\n\n    var aggregatedData = [];\n\n    if (1 === ticks.length) {\n      var aggregationInfo = {\n        intervalStart: ticks[0],\n        intervalEnd: ticks[0],\n        aggregationInterval: null,\n        data: data.map(getData)\n      };\n      addAggregatedData(aggregatedData, aggregationMethod(aggregationInfo, that), aggregationInfo);\n    } else {\n      for (var i = 1; i < ticks.length; i++) {\n        var intervalEnd = ticks[i];\n        var intervalStart = ticks[i - 1];\n        var dataInInterval = [];\n\n        while (data[dataIndex] && data[dataIndex].argument < intervalEnd) {\n          if (data[dataIndex].argument >= intervalStart) {\n            dataInInterval.push(data[dataIndex]);\n          }\n\n          dataIndex++;\n        }\n\n        var _aggregationInfo = {\n          intervalStart: intervalStart,\n          intervalEnd: intervalEnd,\n          aggregationInterval: interval,\n          data: dataInInterval.map(getData)\n        };\n        addAggregatedData(aggregatedData, aggregationMethod(_aggregationInfo, that), _aggregationInfo);\n      }\n    }\n\n    that._endUpdateData();\n\n    return aggregatedData;\n  },\n  canRenderCompleteHandle: function canRenderCompleteHandle() {\n    var result = this._canRenderCompleteHandle;\n    delete this._canRenderCompleteHandle;\n    return !!result;\n  },\n  isHovered: function isHovered() {\n    return !!(1 & this.fullState);\n  },\n  isSelected: function isSelected() {\n    return !!(2 & this.fullState);\n  },\n  isVisible: function isVisible() {\n    return this._visible;\n  },\n  getAllPoints: function getAllPoints() {\n    this._createAllAggregatedPoints();\n\n    return (this._points || []).slice();\n  },\n  getPointByPos: function getPointByPos(pos) {\n    this._createAllAggregatedPoints();\n\n    return (this._points || [])[pos];\n  },\n  getVisiblePoints: function getVisiblePoints() {\n    return (this._drawnPoints || []).slice();\n  },\n  selectPoint: function selectPoint(point) {\n    if (!point.isSelected()) {\n      setPointSelectedState(point, this._legendCallback);\n\n      this._eventPipe({\n        action: POINT_SELECT,\n        target: point\n      });\n\n      this._eventTrigger(POINT_SELECTION_CHANGED, {\n        target: point\n      });\n    }\n  },\n  deselectPoint: function deselectPoint(point) {\n    if (point.isSelected()) {\n      releasePointSelectedState(point, this._legendCallback);\n\n      this._eventPipe({\n        action: POINT_DESELECT,\n        target: point\n      });\n\n      this._eventTrigger(POINT_SELECTION_CHANGED, {\n        target: point\n      });\n    }\n  },\n  hover: function hover(mode) {\n    var eventTrigger = this._eventTrigger;\n\n    if (this.isHovered()) {\n      return;\n    }\n\n    this.lastHoverMode = _normalizeEnum(mode || this._options.hoverMode);\n    this.fullState = this.fullState | HOVER_STATE;\n\n    this._changeStyle(this.lastHoverMode, void 0, this.isSelected() && this.lastSelectionMode !== NONE_MODE);\n\n    eventTrigger(SERIES_HOVER_CHANGED, {\n      target: this\n    });\n  },\n  clearHover: function clearHover() {\n    var eventTrigger = this._eventTrigger;\n\n    if (!this.isHovered()) {\n      return;\n    }\n\n    this._resetNearestPoint();\n\n    this.fullState = this.fullState & ~HOVER_STATE;\n\n    this._changeStyle(this.lastHoverMode, HOVER, this.isSelected() && this.lastSelectionMode !== NONE_MODE);\n\n    eventTrigger(SERIES_HOVER_CHANGED, {\n      target: this\n    });\n  },\n  hoverPoint: function hoverPoint(point) {\n    if (!point.isHovered()) {\n      point.clearHover();\n      setPointHoverState(point, this._legendCallback);\n      this._canChangeView() && this._applyStyle(this._styles.hover);\n\n      this._eventPipe({\n        action: POINT_HOVER,\n        target: point\n      });\n\n      this._eventTrigger(POINT_HOVER_CHANGED, {\n        target: point\n      });\n    }\n  },\n  clearPointHover: function clearPointHover() {\n    var that = this;\n    that.getPoints().some(function (currentPoint) {\n      if (currentPoint.isHovered()) {\n        releasePointHoverState(currentPoint, that._legendCallback);\n        that._canChangeView() && that._applyStyle(that._styles.normal);\n\n        that._eventPipe({\n          action: CLEAR_POINT_HOVER,\n          target: currentPoint\n        });\n\n        that._eventTrigger(POINT_HOVER_CHANGED, {\n          target: currentPoint\n        });\n\n        return true;\n      }\n\n      return false;\n    });\n  },\n  showPointTooltip: function showPointTooltip(point) {\n    triggerEvent(this._extGroups.seriesGroup, \"showpointtooltip\", point);\n  },\n  hidePointTooltip: function hidePointTooltip(point) {\n    triggerEvent(this._extGroups.seriesGroup, \"hidepointtooltip\", point);\n  },\n  select: function select() {\n    if (!this.isSelected()) {\n      this._setSelectedState(this._options.selectionMode);\n\n      this._eventPipe({\n        action: SERIES_SELECT,\n        target: this\n      });\n\n      this._group.toForeground();\n\n      this._eventTrigger(SERIES_SELECTION_CHANGED, {\n        target: this\n      });\n    }\n  },\n  clearSelection: function clearSelection() {\n    if (this.isSelected()) {\n      this._releaseSelectedState();\n\n      this._eventTrigger(SERIES_SELECTION_CHANGED, {\n        target: this\n      });\n    }\n  },\n  getPointsByArg: function getPointsByArg(arg, skipPointsCreation) {\n    var argValue = arg.valueOf();\n    var points = this.pointsByArgument[argValue];\n\n    if (!points && !skipPointsCreation && this._createAllAggregatedPoints()) {\n      points = this.pointsByArgument[argValue];\n    }\n\n    return points || [];\n  },\n  _createAllAggregatedPoints: function _createAllAggregatedPoints() {\n    if (this.useAggregation() && !this._useAllAggregatedPoints) {\n      this.createPoints(true);\n      return true;\n    }\n\n    return false;\n  },\n  getPointsByKeys: function getPointsByKeys(arg) {\n    return this.getPointsByArg(arg);\n  },\n  notify: function notify(data) {\n    var that = this;\n    var action = data.action;\n    var seriesModes = that._seriesModes;\n    var target = data.target;\n    var targetOptions = target.getOptions();\n\n    var pointHoverMode = _normalizeEnum(targetOptions.hoverMode);\n\n    var selectionModeOfPoint = _normalizeEnum(targetOptions.selectionMode);\n\n    if (action === POINT_HOVER) {\n      that._hoverPointHandler(target, pointHoverMode, data.notifyLegend);\n    } else if (action === CLEAR_POINT_HOVER) {\n      that._clearPointHoverHandler(target, pointHoverMode, data.notifyLegend);\n    } else if (action === SERIES_SELECT) {\n      target !== that && \"single\" === seriesModes.seriesSelectionMode && that.clearSelection();\n    } else if (action === POINT_SELECT) {\n      if (\"single\" === seriesModes.pointSelectionMode) {\n        that.getPoints().some(function (currentPoint) {\n          if (currentPoint !== target && currentPoint.isSelected()) {\n            that.deselectPoint(currentPoint);\n            return true;\n          }\n\n          return false;\n        });\n      }\n\n      that._selectPointHandler(target, selectionModeOfPoint);\n    } else if (action === POINT_DESELECT) {\n      that._deselectPointHandler(target, selectionModeOfPoint);\n    }\n  },\n  _selectPointHandler: function _selectPointHandler(target, mode) {\n    if (mode === ALL_SERIES_POINTS) {\n      target.series === this && this._setPointsView(SELECTION, target);\n    } else if (mode === ALL_ARGUMENT_POINTS) {\n      this.getPointsByKeys(target.argument, target.argumentIndex).forEach(function (currentPoint) {\n        currentPoint !== target && currentPoint.setView(SELECTION);\n      });\n    }\n  },\n  _deselectPointHandler: function _deselectPointHandler(target, mode) {\n    if (mode === ALL_SERIES_POINTS) {\n      target.series === this && this._resetPointsView(SELECTION, target);\n    } else if (mode === ALL_ARGUMENT_POINTS) {\n      this.getPointsByKeys(target.argument, target.argumentIndex).forEach(function (currentPoint) {\n        currentPoint !== target && currentPoint.resetView(SELECTION);\n      });\n    }\n  },\n  _hoverPointHandler: function _hoverPointHandler(target, mode, notifyLegend) {\n    if (target.series !== this && mode === ALL_ARGUMENT_POINTS) {\n      this.getPointsByKeys(target.argument, target.argumentIndex).forEach(function (currentPoint) {\n        currentPoint.setView(HOVER);\n      });\n      notifyLegend && this._legendCallback(target);\n    } else if (mode === ALL_SERIES_POINTS && target.series === this) {\n      this._setPointsView(HOVER, target);\n    }\n  },\n  _clearPointHoverHandler: function _clearPointHoverHandler(target, mode, notifyLegend) {\n    if (mode === ALL_ARGUMENT_POINTS) {\n      target.series !== this && this.getPointsByKeys(target.argument, target.argumentIndex).forEach(function (currentPoint) {\n        currentPoint.resetView(HOVER);\n      });\n      notifyLegend && this._legendCallback(target);\n    } else if (mode === ALL_SERIES_POINTS && target.series === this) {\n      this._resetPointsView(HOVER, target);\n    }\n  },\n  _deletePoints: function _deletePoints() {\n    this._disposePoints(this._points);\n\n    this._points = this._drawnPoints = null;\n  },\n  _deleteTrackers: function _deleteTrackers() {\n    _each(this._trackers || [], function (_, tracker) {\n      tracker.remove();\n    });\n\n    this._trackersGroup && this._trackersGroup.dispose();\n    this._trackers = this._trackersGroup = null;\n  },\n  dispose: function dispose() {\n    this._deletePoints();\n\n    this._group.dispose();\n\n    this._labelsGroup && this._labelsGroup.dispose();\n    this._errorBarGroup && this._errorBarGroup.dispose();\n\n    this._deleteTrackers();\n\n    this._group = this._extGroups = this._markersGroup = this._elementsGroup = this._bordersGroup = this._labelsGroup = this._errorBarGroup = this._graphics = this._rangeData = this._renderer = this._styles = this._options = this._pointOptions = this._drawnPoints = this.pointsByArgument = this._segments = this._prevSeries = null;\n  },\n  correctPosition: _noop,\n  drawTrackers: _noop,\n  getNeighborPoint: _noop,\n  areErrorBarsVisible: _noop,\n  getMarginOptions: function getMarginOptions() {\n    return this._patchMarginOptions({\n      percentStick: this.isFullStackedSeries()\n    });\n  },\n  getColor: function getColor() {\n    return this.getLegendStyles().normal.fill;\n  },\n  getOpacity: function getOpacity() {\n    return this._options.opacity;\n  },\n  getStackName: function getStackName() {\n    return this._stackName;\n  },\n  getBarOverlapGroup: function getBarOverlapGroup() {\n    return this._options.barOverlapGroup;\n  },\n  getPointByCoord: function getPointByCoord(x, y) {\n    var point = this.getNeighborPoint(x, y);\n    return null !== point && void 0 !== point && point.coordsIn(x, y) ? point : null;\n  },\n  getValueAxis: function getValueAxis() {\n    return this._valueAxis;\n  },\n  getArgumentAxis: function getArgumentAxis() {\n    return this._argumentAxis;\n  },\n  getMarkersGroup: function getMarkersGroup() {\n    return this._markersGroup;\n  },\n  getRenderer: function getRenderer() {\n    return this._renderer;\n  },\n  removePointElements: function removePointElements() {\n    if (this._markersGroup) {\n      _each(this._points, function (_, p) {\n        return p.deleteMarker();\n      });\n\n      this._markersGroup.dispose();\n\n      this._markersGroup = null;\n    }\n  },\n  removeGraphicElements: function removeGraphicElements() {\n    var that = this;\n\n    if (that._elementsGroup) {\n      that._elementsGroup.dispose();\n\n      that._elementsGroup = null;\n    }\n\n    _each(that._graphics || [], function (_, elem) {\n      that._removeElement(elem);\n    });\n\n    that._graphics = null;\n  },\n  removeBordersGroup: function removeBordersGroup() {\n    if (this._bordersGroup) {\n      this._bordersGroup.dispose();\n\n      this._bordersGroup = null;\n    }\n  }\n};\nexport var mixins = seriesNS.mixins;","map":null,"metadata":{},"sourceType":"module"}