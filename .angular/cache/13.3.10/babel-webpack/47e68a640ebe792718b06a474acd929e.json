{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/scheduler/appointments/dataProvider/utils.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport dateUtils from \"../../../../core/utils/date\";\nimport timeZoneUtils from \"../../utils.timeZone\";\nimport dateSerialization from \"../../../../core/utils/date_serialization\";\nimport { ExpressionUtils } from \"../../expressionUtils\";\nvar toMs = dateUtils.dateToMilliseconds;\nvar FULL_DATE_FORMAT = \"yyyyMMddTHHmmss\";\nexport var compareDateWithStartDayHour = function compareDateWithStartDayHour(startDate, endDate, startDayHour, allDay, severalDays) {\n  var startTime = dateUtils.dateTimeFromDecimal(startDayHour);\n  var result = startDate.getHours() >= startTime.hours && startDate.getMinutes() >= startTime.minutes || endDate.getHours() === startTime.hours && endDate.getMinutes() > startTime.minutes || endDate.getHours() > startTime.hours || severalDays || allDay;\n  return result;\n};\nexport var compareDateWithEndDayHour = function compareDateWithEndDayHour(options) {\n  var startDate = options.startDate,\n      endDate = options.endDate,\n      startDayHour = options.startDayHour,\n      endDayHour = options.endDayHour,\n      viewStartDayHour = options.viewStartDayHour,\n      viewEndDayHour = options.viewEndDayHour,\n      allDay = options.allDay,\n      severalDays = options.severalDays,\n      min = options.min,\n      max = options.max,\n      checkIntersectViewport = options.checkIntersectViewport;\n  var hiddenInterval = (24 - viewEndDayHour + viewStartDayHour) * toMs(\"hour\");\n  var apptDuration = endDate.getTime() - startDate.getTime();\n  var delta = (hiddenInterval - apptDuration) / toMs(\"hour\");\n  var apptStartHour = startDate.getHours();\n  var apptStartMinutes = startDate.getMinutes();\n  var result;\n  var endTime = dateUtils.dateTimeFromDecimal(endDayHour);\n  var startTime = dateUtils.dateTimeFromDecimal(startDayHour);\n  var apptIntersectViewport = startDate < max && endDate > min;\n  result = checkIntersectViewport && apptIntersectViewport || apptStartHour < endTime.hours || apptStartHour === endTime.hours && apptStartMinutes < endTime.minutes || allDay && startDate <= max || severalDays && apptIntersectViewport && (apptStartHour < endTime.hours || 60 * endDate.getHours() + endDate.getMinutes() > 60 * startTime.hours);\n\n  if (apptDuration < hiddenInterval) {\n    if (apptStartHour > endTime.hours && apptStartMinutes > endTime.minutes && delta <= apptStartHour - endDayHour) {\n      result = false;\n    }\n  }\n\n  return result;\n};\nexport var getTrimDates = function getTrimDates(min, max) {\n  var newMin = dateUtils.trimTime(min);\n  var newMax = dateUtils.trimTime(max);\n  newMax.setDate(newMax.getDate() + 1);\n  return [newMin, newMax];\n};\nexport var _getAppointmentDurationInHours = function _getAppointmentDurationInHours(startDate, endDate) {\n  return (endDate.getTime() - startDate.getTime()) / toMs(\"hour\");\n};\nexport var getAppointmentTakesSeveralDays = function getAppointmentTakesSeveralDays(adapter) {\n  return !dateUtils.sameDate(adapter.startDate, adapter.endDate);\n};\nexport var _appointmentHasShortDayDuration = function _appointmentHasShortDayDuration(startDate, endDate, startDayHour, endDayHour) {\n  var appointmentDurationInHours = _getAppointmentDurationInHours(startDate, endDate);\n\n  var shortDayDurationInHours = endDayHour - startDayHour;\n  return appointmentDurationInHours >= shortDayDurationInHours && startDate.getHours() === startDayHour && endDate.getHours() === endDayHour;\n};\nexport var _isEndDateWrong = function _isEndDateWrong(startDate, endDate) {\n  return !endDate || isNaN(endDate.getTime()) || startDate.getTime() > endDate.getTime();\n};\nexport var _appointmentHasAllDayDuration = function _appointmentHasAllDayDuration(startDate, endDate, startDayHour, endDayHour) {\n  startDate = new Date(startDate);\n  endDate = new Date(endDate);\n\n  var appointmentDurationInHours = _getAppointmentDurationInHours(startDate, endDate);\n\n  return appointmentDurationInHours >= 24 || _appointmentHasShortDayDuration(startDate, endDate, startDayHour, endDayHour);\n};\nexport var _appointmentPartInInterval = function _appointmentPartInInterval(startDate, endDate, startDayHour, endDayHour) {\n  var apptStartDayHour = startDate.getHours();\n  var apptEndDayHour = endDate.getHours();\n  return apptStartDayHour <= startDayHour && apptEndDayHour <= endDayHour && apptEndDayHour >= startDayHour || apptEndDayHour >= endDayHour && apptStartDayHour <= endDayHour && apptStartDayHour >= startDayHour;\n};\nexport var getRecurrenceException = function getRecurrenceException(appointmentAdapter, timeZoneCalculator, timeZone) {\n  var recurrenceException = appointmentAdapter.recurrenceException;\n\n  if (recurrenceException) {\n    var exceptions = recurrenceException.split(\",\");\n\n    for (var i = 0; i < exceptions.length; i++) {\n      exceptions[i] = _convertRecurrenceException(exceptions[i], appointmentAdapter.startDate, timeZoneCalculator, timeZone);\n    }\n\n    return exceptions.join();\n  }\n\n  return recurrenceException;\n};\nexport var _convertRecurrenceException = function _convertRecurrenceException(exceptionString, startDate, timeZoneCalculator, timeZone) {\n  exceptionString = exceptionString.replace(/\\s/g, \"\");\n\n  var getConvertedToTimeZone = function getConvertedToTimeZone(date) {\n    return timeZoneCalculator.createDate(date, {\n      path: \"toGrid\"\n    });\n  };\n\n  var exceptionDate = dateSerialization.deserializeDate(exceptionString);\n  var convertedStartDate = getConvertedToTimeZone(startDate);\n  var convertedExceptionDate = getConvertedToTimeZone(exceptionDate);\n  convertedExceptionDate = timeZoneUtils.correctRecurrenceExceptionByTimezone(convertedExceptionDate, convertedStartDate, timeZone);\n  exceptionString = dateSerialization.serializeDate(convertedExceptionDate, FULL_DATE_FORMAT);\n  return exceptionString;\n};\nexport var getAppointmentTakesAllDay = function getAppointmentTakesAllDay(appointment, startDayHour, endDayHour) {\n  return appointment.allDay || _appointmentHasAllDayDuration(appointment.startDate, appointment.endDate, startDayHour, endDayHour);\n};\nexport var replaceWrongEndDate = function replaceWrongEndDate(appointment, startDate, endDate, appointmentDuration, dataAccessors) {\n  if (_isEndDateWrong(startDate, endDate)) {\n    var calculatedEndDate = function (isAllDay, startDate) {\n      if (isAllDay) {\n        return dateUtils.setToDayEnd(new Date(startDate));\n      }\n\n      return new Date(startDate.getTime() + appointmentDuration * toMs(\"minute\"));\n    }(appointment.allDay, startDate);\n\n    dataAccessors.setter.endDate(appointment, calculatedEndDate);\n  }\n};\nexport var sortAppointmentsByStartDate = function sortAppointmentsByStartDate(appointments, dataAccessors) {\n  appointments.sort(function (a, b) {\n    var firstDate = new Date(ExpressionUtils.getField(dataAccessors, \"startDate\", a.settings || a));\n    var secondDate = new Date(ExpressionUtils.getField(dataAccessors, \"startDate\", b.settings || b));\n    return Math.sign(firstDate.getTime() - secondDate.getTime());\n  });\n};","map":null,"metadata":{},"sourceType":"module"}