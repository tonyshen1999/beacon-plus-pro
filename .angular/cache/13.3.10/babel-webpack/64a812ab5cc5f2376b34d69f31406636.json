{"ast":null,"code":"import _defineProperty from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\n\n/**\r\n * DevExtreme (esm/viz/axes/base_axis.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { smartFormatter as _format, formatRange as _formatRange } from \"./smart_formatter\";\nimport { patchFontOptions, getVizRangeObject, getLogExt as getLog, raiseToExt as raiseTo, valueOf, rotateBBox, getCategoriesInfo, adjustVisualRange, getAddFunction, convertVisualRangeObject } from \"../core/utils\";\nimport { isDefined, isFunction, isPlainObject, type } from \"../../core/utils/type\";\nimport constants from \"./axes_constants\";\nimport { extend } from \"../../core/utils/extend\";\nimport { inArray } from \"../../core/utils/array\";\nimport formatHelper from \"../../format_helper\";\nimport { getParser } from \"../components/parse_utils\";\nimport { tickGenerator } from \"./tick_generator\";\nimport { Translator2D } from \"../translators/translator2d\";\nimport { Range } from \"../translators/range\";\nimport { tick } from \"./tick\";\nimport { adjust } from \"../../core/utils/math\";\nimport dateUtils from \"../../core/utils/date\";\nimport { noop as _noop } from \"../../core/utils/common\";\nimport xyMethods from \"./xy_axes\";\nimport * as polarMethods from \"./polar_axes\";\nimport createConstantLine from \"./constant_line\";\nimport createStrip from \"./strip\";\nimport { Deferred, when } from \"../../core/utils/deferred\";\nimport { calculateCanvasMargins, measureLabels } from \"./axes_utils\";\nvar convertTicksToValues = constants.convertTicksToValues;\nvar _math = Math;\nvar _abs = _math.abs;\nvar _max = _math.max;\nvar _min = _math.min;\nvar _isArray = Array.isArray;\nvar DEFAULT_AXIS_LABEL_SPACING = 5;\nvar MAX_GRID_BORDER_ADHENSION = 4;\nvar TOP = constants.top;\nvar BOTTOM = constants.bottom;\nvar LEFT = constants.left;\nvar RIGHT = constants.right;\nvar CENTER = constants.center;\nvar KEEP = \"keep\";\nvar SHIFT = \"shift\";\nvar RESET = \"reset\";\nvar ROTATE = \"rotate\";\nvar DEFAULT_AXIS_DIVISION_FACTOR = 50;\nvar DEFAULT_MINOR_AXIS_DIVISION_FACTOR = 15;\nvar SCROLL_THRESHOLD = 5;\nvar MIN_BAR_MARGIN = 5;\nvar MAX_MARGIN_VALUE = .8;\nvar dateIntervals = {\n  day: 864e5,\n  week: 6048e5\n};\n\nfunction getTickGenerator(options, incidentOccurred, skipTickGeneration, rangeIsEmpty, adjustDivisionFactor, _ref) {\n  var _options$workWeek;\n\n  var allowNegatives = _ref.allowNegatives,\n      linearThreshold = _ref.linearThreshold;\n  return tickGenerator({\n    axisType: options.type,\n    dataType: options.dataType,\n    logBase: options.logarithmBase,\n    allowNegatives: allowNegatives,\n    linearThreshold: linearThreshold,\n    axisDivisionFactor: adjustDivisionFactor(options.axisDivisionFactor || DEFAULT_AXIS_DIVISION_FACTOR),\n    minorAxisDivisionFactor: adjustDivisionFactor(options.minorAxisDivisionFactor || DEFAULT_MINOR_AXIS_DIVISION_FACTOR),\n    numberMultipliers: options.numberMultipliers,\n    calculateMinors: options.minorTick.visible || options.minorGrid.visible || options.calculateMinors,\n    allowDecimals: options.allowDecimals,\n    endOnTick: options.endOnTick,\n    incidentOccurred: incidentOccurred,\n    firstDayOfWeek: null === (_options$workWeek = options.workWeek) || void 0 === _options$workWeek ? void 0 : _options$workWeek[0],\n    skipTickGeneration: skipTickGeneration,\n    skipCalculationLimits: options.skipCalculationLimits,\n    generateExtraTick: options.generateExtraTick,\n    minTickInterval: options.minTickInterval,\n    rangeIsEmpty: rangeIsEmpty\n  });\n}\n\nfunction createMajorTick(axis, renderer, skippedCategory) {\n  var options = axis.getOptions();\n  return tick(axis, renderer, options.tick, options.grid, skippedCategory, false);\n}\n\nfunction createMinorTick(axis, renderer) {\n  var options = axis.getOptions();\n  return tick(axis, renderer, options.minorTick, options.minorGrid);\n}\n\nfunction createBoundaryTick(axis, renderer, isFirst) {\n  var options = axis.getOptions();\n  return tick(axis, renderer, extend({}, options.tick, {\n    visible: options.showCustomBoundaryTicks\n  }), options.grid, void 0, false, isFirst ? -1 : 1);\n}\n\nfunction callAction(elements, action, actionArgument1, actionArgument2) {\n  (elements || []).forEach(function (e) {\n    return e[action](actionArgument1, actionArgument2);\n  });\n}\n\nfunction initTickCoords(ticks) {\n  callAction(ticks, \"initCoords\");\n}\n\nfunction drawTickMarks(ticks, options) {\n  callAction(ticks, \"drawMark\", options);\n}\n\nfunction drawGrids(ticks, drawLine) {\n  callAction(ticks, \"drawGrid\", drawLine);\n}\n\nfunction updateTicksPosition(ticks, options, animate) {\n  callAction(ticks, \"updateTickPosition\", options, animate);\n}\n\nfunction updateGridsPosition(ticks, animate) {\n  callAction(ticks, \"updateGridPosition\", animate);\n}\n\nfunction cleanUpInvalidTicks(ticks) {\n  var i = ticks.length - 1;\n\n  for (i; i >= 0; i--) {\n    if (!removeInvalidTick(ticks, i)) {\n      break;\n    }\n  }\n\n  for (i = 0; i < ticks.length; i++) {\n    if (removeInvalidTick(ticks, i)) {\n      i--;\n    } else {\n      break;\n    }\n  }\n}\n\nfunction removeInvalidTick(ticks, i) {\n  if (null === ticks[i].coords.x || null === ticks[i].coords.y) {\n    ticks.splice(i, 1);\n    return true;\n  }\n\n  return false;\n}\n\nfunction validateAxisOptions(options) {\n  var _labelOptions$minSpac;\n\n  var labelOptions = options.label;\n  var position = options.position;\n  var defaultPosition = options.isHorizontal ? BOTTOM : LEFT;\n  var secondaryPosition = options.isHorizontal ? TOP : RIGHT;\n  var labelPosition = labelOptions.position;\n\n  if (position !== defaultPosition && position !== secondaryPosition) {\n    position = defaultPosition;\n  }\n\n  if (!labelPosition || \"outside\" === labelPosition) {\n    labelPosition = position;\n  } else if (\"inside\" === labelPosition) {\n    var _TOP$BOTTOM$LEFT$RIGH;\n\n    labelPosition = (_TOP$BOTTOM$LEFT$RIGH = {}, _defineProperty(_TOP$BOTTOM$LEFT$RIGH, TOP, BOTTOM), _defineProperty(_TOP$BOTTOM$LEFT$RIGH, BOTTOM, TOP), _defineProperty(_TOP$BOTTOM$LEFT$RIGH, LEFT, RIGHT), _defineProperty(_TOP$BOTTOM$LEFT$RIGH, RIGHT, LEFT), _TOP$BOTTOM$LEFT$RIGH)[position];\n  }\n\n  if (labelPosition !== defaultPosition && labelPosition !== secondaryPosition) {\n    labelPosition = position;\n  }\n\n  if (labelOptions.alignment !== CENTER && !labelOptions.userAlignment) {\n    var _TOP$BOTTOM$LEFT$RIGH2;\n\n    labelOptions.alignment = (_TOP$BOTTOM$LEFT$RIGH2 = {}, _defineProperty(_TOP$BOTTOM$LEFT$RIGH2, TOP, CENTER), _defineProperty(_TOP$BOTTOM$LEFT$RIGH2, BOTTOM, CENTER), _defineProperty(_TOP$BOTTOM$LEFT$RIGH2, LEFT, RIGHT), _defineProperty(_TOP$BOTTOM$LEFT$RIGH2, RIGHT, LEFT), _TOP$BOTTOM$LEFT$RIGH2)[labelPosition];\n  }\n\n  options.position = position;\n  labelOptions.position = labelPosition;\n  options.hoverMode = options.hoverMode ? options.hoverMode.toLowerCase() : \"none\";\n  labelOptions.minSpacing = null !== (_labelOptions$minSpac = labelOptions.minSpacing) && void 0 !== _labelOptions$minSpac ? _labelOptions$minSpac : DEFAULT_AXIS_LABEL_SPACING;\n  options.type && (options.type = options.type.toLowerCase());\n  options.argumentType && (options.argumentType = options.argumentType.toLowerCase());\n  options.valueType && (options.valueType = options.valueType.toLowerCase());\n}\n\nfunction getOptimalAngle(boxes, labelOpt) {\n  var angle = 180 * _math.asin((boxes[0].height + labelOpt.minSpacing) / (boxes[1].x - boxes[0].x)) / _math.PI;\n\n  return angle < 45 ? -45 : -90;\n}\n\nfunction updateLabels(ticks, step, func) {\n  ticks.forEach(function (tick, index) {\n    if (tick.getContentContainer()) {\n      if (index % step !== 0) {\n        tick.removeLabel();\n      } else if (func) {\n        func(tick, index);\n      }\n    }\n  });\n}\n\nfunction getZoomBoundValue(optionValue, dataValue) {\n  if (void 0 === optionValue) {\n    return dataValue;\n  } else if (null === optionValue) {\n    return;\n  } else {\n    return optionValue;\n  }\n}\n\nfunction configureGenerator(options, axisDivisionFactor, viewPort, screenDelta, minTickInterval) {\n  var tickGeneratorOptions = extend({}, options, {\n    endOnTick: true,\n    axisDivisionFactor: axisDivisionFactor,\n    skipCalculationLimits: true,\n    generateExtraTick: true,\n    minTickInterval: minTickInterval\n  });\n  return function (tickInterval, skipTickGeneration, min, max, breaks) {\n    return getTickGenerator(tickGeneratorOptions, _noop, skipTickGeneration, viewPort.isEmpty(), function (v) {\n      return v;\n    }, viewPort)({\n      min: min,\n      max: max,\n      categories: viewPort.categories,\n      isSpacedMargin: viewPort.isSpacedMargin\n    }, screenDelta, tickInterval, isDefined(tickInterval), void 0, void 0, void 0, breaks);\n  };\n}\n\nfunction getConstantLineSharpDirection(coord, axisCanvas) {\n  return Math.max(axisCanvas.start, axisCanvas.end) !== coord ? 1 : -1;\n}\n\nexport var Axis = function Axis(renderSettings) {\n  this._renderer = renderSettings.renderer;\n  this._incidentOccurred = renderSettings.incidentOccurred;\n  this._eventTrigger = renderSettings.eventTrigger;\n  this._stripsGroup = renderSettings.stripsGroup;\n  this._stripLabelAxesGroup = renderSettings.stripLabelAxesGroup;\n  this._labelsAxesGroup = renderSettings.labelsAxesGroup;\n  this._constantLinesGroup = renderSettings.constantLinesGroup;\n  this._scaleBreaksGroup = renderSettings.scaleBreaksGroup;\n  this._axesContainerGroup = renderSettings.axesContainerGroup;\n  this._gridContainerGroup = renderSettings.gridGroup;\n  this._axisCssPrefix = renderSettings.widgetClass + \"-\" + (renderSettings.axisClass ? renderSettings.axisClass + \"-\" : \"\");\n\n  this._setType(renderSettings.axisType, renderSettings.drawingType);\n\n  this._createAxisGroups();\n\n  this._translator = this._createTranslator();\n  this.isArgumentAxis = renderSettings.isArgumentAxis;\n  this._viewport = {};\n  this._prevDataInfo = {};\n  this._firstDrawing = true;\n  this._initRange = {};\n  this._getTemplate = renderSettings.getTemplate;\n};\nAxis.prototype = {\n  constructor: Axis,\n  _drawAxis: function _drawAxis() {\n    var options = this._options;\n\n    if (!options.visible) {\n      return;\n    }\n\n    this._axisElement = this._createAxisElement();\n\n    this._updateAxisElementPosition();\n\n    this._axisElement.attr({\n      \"stroke-width\": options.width,\n      stroke: options.color,\n      \"stroke-opacity\": options.opacity\n    }).sharp(this._getSharpParam(true), this.getAxisSharpDirection()).append(this._axisLineGroup);\n  },\n  _createPathElement: function _createPathElement(points, attr, sharpDirection) {\n    return this.sharp(this._renderer.path(points, \"line\").attr(attr), sharpDirection);\n  },\n  sharp: function sharp(svgElement) {\n    var sharpDirection = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;\n    return svgElement.sharp(this._getSharpParam(), sharpDirection);\n  },\n  customPositionIsAvailable: function customPositionIsAvailable() {\n    return false;\n  },\n  getOrthogonalAxis: _noop,\n  getCustomPosition: _noop,\n  getCustomBoundaryPosition: _noop,\n  resolveOverlappingForCustomPositioning: _noop,\n  hasNonBoundaryPosition: function hasNonBoundaryPosition() {\n    return false;\n  },\n  customPositionIsBoundaryOrthogonalAxis: function customPositionIsBoundaryOrthogonalAxis() {\n    return false;\n  },\n  getResolvedBoundaryPosition: function getResolvedBoundaryPosition() {\n    return this.getOptions().position;\n  },\n  getAxisSharpDirection: function getAxisSharpDirection() {\n    var position = this.getResolvedBoundaryPosition();\n    return this.hasNonBoundaryPosition() || position !== BOTTOM && position !== RIGHT ? 1 : -1;\n  },\n  getSharpDirectionByCoords: function getSharpDirectionByCoords(coords) {\n    var canvas = this._getCanvasStartEnd();\n\n    var maxCoord = Math.max(canvas.start, canvas.end);\n    return this.getRadius ? 0 : maxCoord !== coords[this._isHorizontal ? \"x\" : \"y\"] ? 1 : -1;\n  },\n  _getGridLineDrawer: function _getGridLineDrawer() {\n    var that = this;\n    return function (tick, gridStyle) {\n      var grid = that._getGridPoints(tick.coords);\n\n      if (grid.points) {\n        return that._createPathElement(grid.points, gridStyle, that.getSharpDirectionByCoords(tick.coords));\n      }\n\n      return null;\n    };\n  },\n  _getGridPoints: function _getGridPoints(coords) {\n    var isHorizontal = this._isHorizontal;\n    var tickPositionField = isHorizontal ? \"x\" : \"y\";\n    var orthogonalPositions = this._orthogonalPositions;\n    var positionFrom = orthogonalPositions.start;\n    var positionTo = orthogonalPositions.end;\n    var borderOptions = this.borderOptions;\n    var canvasStart = isHorizontal ? LEFT : TOP;\n    var canvasEnd = isHorizontal ? RIGHT : BOTTOM;\n    var axisCanvas = this.getCanvas();\n    var canvas = {\n      left: axisCanvas.left,\n      right: axisCanvas.width - axisCanvas.right,\n      top: axisCanvas.top,\n      bottom: axisCanvas.height - axisCanvas.bottom\n    };\n    var firstBorderLinePosition = borderOptions.visible && borderOptions[canvasStart] ? canvas[canvasStart] : void 0;\n    var lastBorderLinePosition = borderOptions.visible && borderOptions[canvasEnd] ? canvas[canvasEnd] : void 0;\n    var minDelta = MAX_GRID_BORDER_ADHENSION + firstBorderLinePosition;\n    var maxDelta = lastBorderLinePosition - MAX_GRID_BORDER_ADHENSION;\n\n    if (this.areCoordsOutsideAxis(coords) || void 0 === coords[tickPositionField] || coords[tickPositionField] < minDelta || coords[tickPositionField] > maxDelta) {\n      return {\n        points: null\n      };\n    }\n\n    return {\n      points: isHorizontal ? null !== coords[tickPositionField] ? [coords[tickPositionField], positionFrom, coords[tickPositionField], positionTo] : null : null !== coords[tickPositionField] ? [positionFrom, coords[tickPositionField], positionTo, coords[tickPositionField]] : null\n    };\n  },\n  _getConstantLinePos: function _getConstantLinePos(parsedValue, canvasStart, canvasEnd) {\n    var value = this._getTranslatedCoord(parsedValue);\n\n    if (!isDefined(value) || value < _min(canvasStart, canvasEnd) || value > _max(canvasStart, canvasEnd)) {\n      return;\n    }\n\n    return value;\n  },\n  _getConstantLineGraphicAttributes: function _getConstantLineGraphicAttributes(value) {\n    var positionFrom = this._orthogonalPositions.start;\n    var positionTo = this._orthogonalPositions.end;\n    return {\n      points: this._isHorizontal ? [value, positionFrom, value, positionTo] : [positionFrom, value, positionTo, value]\n    };\n  },\n  _createConstantLine: function _createConstantLine(value, attr) {\n    return this._createPathElement(this._getConstantLineGraphicAttributes(value).points, attr, getConstantLineSharpDirection(value, this._getCanvasStartEnd()));\n  },\n  _drawConstantLineLabelText: function _drawConstantLineLabelText(text, x, y, _ref2, group) {\n    var font = _ref2.font,\n        cssClass = _ref2.cssClass;\n    return this._renderer.text(text, x, y).css(patchFontOptions(extend({}, this._options.label.font, font))).attr({\n      align: \"center\",\n      class: cssClass\n    }).append(group);\n  },\n  _drawConstantLineLabels: function _drawConstantLineLabels(parsedValue, lineLabelOptions, value, group) {\n    var _text;\n\n    var text = lineLabelOptions.text;\n    var options = this._options;\n    var labelOptions = options.label;\n\n    this._checkAlignmentConstantLineLabels(lineLabelOptions);\n\n    text = null !== (_text = text) && void 0 !== _text ? _text : this.formatLabel(parsedValue, labelOptions);\n\n    var coords = this._getConstantLineLabelsCoords(value, lineLabelOptions);\n\n    return this._drawConstantLineLabelText(text, coords.x, coords.y, lineLabelOptions, group);\n  },\n  _getStripPos: function _getStripPos(startValue, endValue, canvasStart, canvasEnd, range) {\n    var isContinuous = !!(range.minVisible || range.maxVisible);\n    var categories = (range.categories || []).reduce(function (result, cat) {\n      result.push(cat.valueOf());\n      return result;\n    }, []);\n    var start;\n    var end;\n    var swap;\n    var startCategoryIndex;\n    var endCategoryIndex;\n\n    if (!isContinuous) {\n      if (isDefined(startValue) && isDefined(endValue)) {\n        var parsedStartValue = this.parser(startValue);\n        var parsedEndValue = this.parser(endValue);\n        startCategoryIndex = inArray(isDefined(parsedStartValue) ? parsedStartValue.valueOf() : void 0, categories);\n        endCategoryIndex = inArray(isDefined(parsedEndValue) ? parsedEndValue.valueOf() : void 0, categories);\n\n        if (-1 === startCategoryIndex || -1 === endCategoryIndex) {\n          return {\n            from: 0,\n            to: 0,\n            outOfCanvas: true\n          };\n        }\n\n        if (startCategoryIndex > endCategoryIndex) {\n          swap = endValue;\n          endValue = startValue;\n          startValue = swap;\n        }\n      }\n    }\n\n    if (isDefined(startValue)) {\n      startValue = this.validateUnit(startValue, \"E2105\", \"strip\");\n      start = this._getTranslatedCoord(startValue, -1);\n    } else {\n      start = canvasStart;\n    }\n\n    if (isDefined(endValue)) {\n      endValue = this.validateUnit(endValue, \"E2105\", \"strip\");\n      end = this._getTranslatedCoord(endValue, 1);\n    } else {\n      end = canvasEnd;\n    }\n\n    var stripPosition = start < end ? {\n      from: start,\n      to: end\n    } : {\n      from: end,\n      to: start\n    };\n    var visibleArea = this.getVisibleArea();\n\n    if (stripPosition.from <= visibleArea[0] && stripPosition.to <= visibleArea[0] || stripPosition.from >= visibleArea[1] && stripPosition.to >= visibleArea[1]) {\n      stripPosition.outOfCanvas = true;\n    }\n\n    return stripPosition;\n  },\n  _getStripGraphicAttributes: function _getStripGraphicAttributes(fromPoint, toPoint) {\n    var x;\n    var y;\n    var width;\n    var height;\n    var orthogonalPositions = this._orthogonalPositions;\n    var positionFrom = orthogonalPositions.start;\n    var positionTo = orthogonalPositions.end;\n\n    if (this._isHorizontal) {\n      x = fromPoint;\n      y = _min(positionFrom, positionTo);\n      width = toPoint - fromPoint;\n      height = _abs(positionFrom - positionTo);\n    } else {\n      x = _min(positionFrom, positionTo);\n      y = fromPoint;\n      width = _abs(positionFrom - positionTo);\n      height = _abs(fromPoint - toPoint);\n    }\n\n    return {\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    };\n  },\n  _createStrip: function _createStrip(attrs) {\n    return this._renderer.rect(attrs.x, attrs.y, attrs.width, attrs.height);\n  },\n  _adjustStripLabels: function _adjustStripLabels() {\n    var that = this;\n\n    this._strips.forEach(function (strip) {\n      if (strip.label) {\n        strip.label.attr(that._getAdjustedStripLabelCoords(strip));\n      }\n    });\n  },\n  _adjustLabelsCoord: function _adjustLabelsCoord(offset, maxWidth, checkCanvas) {\n    var _this = this;\n\n    var getContainerAttrs = function getContainerAttrs(tick) {\n      return _this._getLabelAdjustedCoord(tick, offset + (tick.labelOffset || 0), maxWidth, checkCanvas);\n    };\n\n    this._majorTicks.forEach(function (tick) {\n      if (tick.label) {\n        tick.updateMultilineTextAlignment();\n        tick.label.attr(getContainerAttrs(tick));\n      } else {\n        tick.templateContainer && tick.templateContainer.attr(getContainerAttrs(tick));\n      }\n    });\n  },\n  _adjustLabels: function _adjustLabels(offset) {\n    var options = this.getOptions();\n    var positionsAreConsistent = options.position === options.label.position;\n\n    var maxSize = this._majorTicks.reduce(function (size, tick) {\n      if (!tick.getContentContainer()) {\n        return size;\n      }\n\n      var bBox = tick.labelRotationAngle ? rotateBBox(tick.labelBBox, [tick.labelCoords.x, tick.labelCoords.y], -tick.labelRotationAngle) : tick.labelBBox;\n      return {\n        width: _max(size.width || 0, bBox.width),\n        height: _max(size.height || 0, bBox.height),\n        offset: _max(size.offset || 0, tick.labelOffset || 0)\n      };\n    }, {});\n\n    var additionalOffset = positionsAreConsistent ? this._isHorizontal ? maxSize.height : maxSize.width : 0;\n\n    this._adjustLabelsCoord(offset, maxSize.width);\n\n    return offset + additionalOffset + (additionalOffset && this._options.label.indentFromAxis) + (positionsAreConsistent ? maxSize.offset : 0);\n  },\n  _getLabelAdjustedCoord: function _getLabelAdjustedCoord(tick, offset, maxWidth) {\n    offset = offset || 0;\n    var options = this._options;\n    var templateBox = tick.templateContainer && tick.templateContainer.getBBox();\n    var box = templateBox || rotateBBox(tick.labelBBox, [tick.labelCoords.x, tick.labelCoords.y], -tick.labelRotationAngle || 0);\n    var textAlign = tick.labelAlignment || options.label.alignment;\n    var isDiscrete = \"discrete\" === this._options.type;\n    var isFlatLabel = tick.labelRotationAngle % 90 === 0;\n    var indentFromAxis = options.label.indentFromAxis;\n    var labelPosition = options.label.position;\n    var axisPosition = this._axisPosition;\n    var labelCoords = tick.labelCoords;\n    var labelX = labelCoords.x;\n    var translateX;\n    var translateY;\n\n    if (this._isHorizontal) {\n      if (labelPosition === BOTTOM) {\n        translateY = axisPosition + indentFromAxis - box.y + offset;\n      } else {\n        translateY = axisPosition - indentFromAxis - (box.y + box.height) - offset;\n      }\n\n      if (textAlign === RIGHT) {\n        translateX = isDiscrete && isFlatLabel ? tick.coords.x - (box.x + box.width) : labelX - box.x - box.width;\n      } else if (textAlign === LEFT) {\n        translateX = isDiscrete && isFlatLabel ? labelX - box.x - (tick.coords.x - labelX) : labelX - box.x;\n      } else {\n        translateX = labelX - box.x - box.width / 2;\n      }\n    } else {\n      translateY = labelCoords.y - box.y - box.height / 2;\n\n      if (labelPosition === LEFT) {\n        if (textAlign === LEFT) {\n          translateX = axisPosition - indentFromAxis - maxWidth - box.x;\n        } else if (textAlign === CENTER) {\n          translateX = axisPosition - indentFromAxis - maxWidth / 2 - box.x - box.width / 2;\n        } else {\n          translateX = axisPosition - indentFromAxis - box.x - box.width;\n        }\n\n        translateX -= offset;\n      } else {\n        if (textAlign === RIGHT) {\n          translateX = axisPosition + indentFromAxis + maxWidth - box.x - box.width;\n        } else if (textAlign === CENTER) {\n          translateX = axisPosition + indentFromAxis + maxWidth / 2 - box.x - box.width / 2;\n        } else {\n          translateX = axisPosition + indentFromAxis - box.x;\n        }\n\n        translateX += offset;\n      }\n    }\n\n    return {\n      translateX: translateX,\n      translateY: translateY\n    };\n  },\n  _createAxisConstantLineGroups: function _createAxisConstantLineGroups() {\n    var renderer = this._renderer;\n    var classSelector = this._axisCssPrefix;\n    var constantLinesClass = classSelector + \"constant-lines\";\n    var insideGroup = renderer.g().attr({\n      class: constantLinesClass\n    });\n    var outsideGroup1 = renderer.g().attr({\n      class: constantLinesClass\n    });\n    var outsideGroup2 = renderer.g().attr({\n      class: constantLinesClass\n    });\n    return {\n      inside: insideGroup,\n      outside1: outsideGroup1,\n      left: outsideGroup1,\n      top: outsideGroup1,\n      outside2: outsideGroup2,\n      right: outsideGroup2,\n      bottom: outsideGroup2,\n      remove: function remove() {\n        this.inside.remove();\n        this.outside1.remove();\n        this.outside2.remove();\n      },\n      clear: function clear() {\n        this.inside.clear();\n        this.outside1.clear();\n        this.outside2.clear();\n      }\n    };\n  },\n  _createAxisGroups: function _createAxisGroups() {\n    var renderer = this._renderer;\n    var classSelector = this._axisCssPrefix;\n    this._axisGroup = renderer.g().attr({\n      class: classSelector + \"axis\"\n    }).enableLinks();\n    this._axisStripGroup = renderer.g().attr({\n      class: classSelector + \"strips\"\n    });\n    this._axisGridGroup = renderer.g().attr({\n      class: classSelector + \"grid\"\n    });\n    this._axisElementsGroup = renderer.g().attr({\n      class: classSelector + \"elements\"\n    });\n    this._axisLineGroup = renderer.g().attr({\n      class: classSelector + \"line\"\n    }).linkOn(this._axisGroup, \"axisLine\").linkAppend();\n    this._axisTitleGroup = renderer.g().attr({\n      class: classSelector + \"title\"\n    }).append(this._axisGroup);\n    this._axisConstantLineGroups = {\n      above: this._createAxisConstantLineGroups(),\n      under: this._createAxisConstantLineGroups()\n    };\n    this._axisStripLabelGroup = renderer.g().attr({\n      class: classSelector + \"axis-labels\"\n    });\n  },\n  _clearAxisGroups: function _clearAxisGroups() {\n    this._axisGroup.remove();\n\n    this._axisStripGroup.remove();\n\n    this._axisStripLabelGroup.remove();\n\n    this._axisConstantLineGroups.above.remove();\n\n    this._axisConstantLineGroups.under.remove();\n\n    this._axisGridGroup.remove();\n\n    this._axisTitleGroup.clear();\n\n    if (!this._options.label.template || !this.isRendered()) {\n      this._axisElementsGroup.remove();\n\n      this._axisElementsGroup.clear();\n    }\n\n    this._axisLineGroup && this._axisLineGroup.clear();\n    this._axisStripGroup && this._axisStripGroup.clear();\n    this._axisGridGroup && this._axisGridGroup.clear();\n\n    this._axisConstantLineGroups.above.clear();\n\n    this._axisConstantLineGroups.under.clear();\n\n    this._axisStripLabelGroup && this._axisStripLabelGroup.clear();\n  },\n  _getLabelFormatObject: function _getLabelFormatObject(value, labelOptions, range, point, tickInterval, ticks) {\n    range = range || this._getViewportRange();\n    var formatObject = {\n      value: value,\n      valueText: _format(value, {\n        labelOptions: labelOptions,\n        ticks: ticks || convertTicksToValues(this._majorTicks),\n        tickInterval: null !== tickInterval && void 0 !== tickInterval ? tickInterval : this._tickInterval,\n        dataType: this._options.dataType,\n        logarithmBase: this._options.logarithmBase,\n        type: this._options.type,\n        showTransition: !this._options.marker.visible,\n        point: point\n      }) || \"\",\n      min: range.minVisible,\n      max: range.maxVisible\n    };\n\n    if (point) {\n      formatObject.point = point;\n    }\n\n    return formatObject;\n  },\n  formatLabel: function formatLabel(value, labelOptions, range, point, tickInterval, ticks) {\n    var formatObject = this._getLabelFormatObject(value, labelOptions, range, point, tickInterval, ticks);\n\n    return isFunction(labelOptions.customizeText) ? labelOptions.customizeText.call(formatObject, formatObject) : formatObject.valueText;\n  },\n  formatHint: function formatHint(value, labelOptions, range) {\n    var formatObject = this._getLabelFormatObject(value, labelOptions, range);\n\n    return isFunction(labelOptions.customizeHint) ? labelOptions.customizeHint.call(formatObject, formatObject) : void 0;\n  },\n  formatRange: function formatRange(startValue, endValue, interval, argumentFormat) {\n    return _formatRange({\n      startValue: startValue,\n      endValue: endValue,\n      tickInterval: interval,\n      argumentFormat: argumentFormat,\n      axisOptions: this.getOptions()\n    });\n  },\n  _setTickOffset: function _setTickOffset() {\n    var options = this._options;\n    var discreteAxisDivisionMode = options.discreteAxisDivisionMode;\n    this._tickOffset = +(\"crossLabels\" !== discreteAxisDivisionMode || !discreteAxisDivisionMode);\n  },\n  resetApplyingAnimation: function resetApplyingAnimation(isFirstDrawing) {\n    this._resetApplyingAnimation = true;\n\n    if (isFirstDrawing) {\n      this._firstDrawing = true;\n    }\n  },\n  isFirstDrawing: function isFirstDrawing() {\n    return this._firstDrawing;\n  },\n  getMargins: function getMargins() {\n    var that = this;\n    var _that$_options = that._options,\n        position = _that$_options.position,\n        offset = _that$_options.offset,\n        customPosition = _that$_options.customPosition,\n        placeholderSize = _that$_options.placeholderSize,\n        grid = _that$_options.grid,\n        tick = _that$_options.tick,\n        crosshairMargin = _that$_options.crosshairMargin;\n    var isDefinedCustomPositionOption = isDefined(customPosition);\n    var boundaryPosition = that.getResolvedBoundaryPosition();\n    var canvas = that.getCanvas();\n    var cLeft = canvas.left;\n    var cTop = canvas.top;\n    var cRight = canvas.width - canvas.right;\n    var cBottom = canvas.height - canvas.bottom;\n\n    var edgeMarginCorrection = _max(grid.visible && grid.width || 0, tick.visible && tick.width || 0);\n\n    var constantLineAboveSeries = that._axisConstantLineGroups.above;\n    var constantLineUnderSeries = that._axisConstantLineGroups.under;\n    var boxes = [that._axisElementsGroup, constantLineAboveSeries.outside1, constantLineAboveSeries.outside2, constantLineUnderSeries.outside1, constantLineUnderSeries.outside2, that._axisLineGroup].map(function (group) {\n      return group && group.getBBox();\n    }).concat(function (group) {\n      var box = group && group.getBBox();\n\n      if (!box || box.isEmpty) {\n        return box;\n      }\n\n      if (that._isHorizontal) {\n        box.x = cLeft;\n        box.width = cRight - cLeft;\n      } else {\n        box.y = cTop;\n        box.height = cBottom - cTop;\n      }\n\n      return box;\n    }(that._axisTitleGroup));\n    var margins = calculateCanvasMargins(boxes, canvas);\n    margins[position] += crosshairMargin;\n\n    if (that.hasNonBoundaryPosition() && isDefinedCustomPositionOption) {\n      margins[boundaryPosition] = 0;\n    }\n\n    if (placeholderSize) {\n      margins[position] = placeholderSize;\n    }\n\n    if (edgeMarginCorrection) {\n      if (that._isHorizontal && canvas.right < edgeMarginCorrection && margins.right < edgeMarginCorrection) {\n        margins.right = edgeMarginCorrection;\n      }\n\n      if (!that._isHorizontal && canvas.bottom < edgeMarginCorrection && margins.bottom < edgeMarginCorrection) {\n        margins.bottom = edgeMarginCorrection;\n      }\n    }\n\n    if (!isDefinedCustomPositionOption && isDefined(offset)) {\n      var moveByOffset = that.customPositionIsBoundary() && (offset > 0 && (boundaryPosition === LEFT || boundaryPosition === TOP) || offset < 0 && (boundaryPosition === RIGHT || boundaryPosition === BOTTOM));\n      margins[boundaryPosition] -= moveByOffset ? offset : 0;\n    }\n\n    return margins;\n  },\n  validateUnit: function validateUnit(unit, idError, parameters) {\n    unit = this.parser(unit);\n\n    if (void 0 === unit && idError) {\n      this._incidentOccurred(idError, [parameters]);\n    }\n\n    return unit;\n  },\n  _setType: function _setType(axisType, drawingType) {\n    var axisTypeMethods;\n\n    switch (axisType) {\n      case \"xyAxes\":\n        axisTypeMethods = xyMethods;\n        break;\n\n      case \"polarAxes\":\n        axisTypeMethods = polarMethods;\n    }\n\n    extend(this, axisTypeMethods[drawingType]);\n  },\n  _getSharpParam: function _getSharpParam() {\n    return true;\n  },\n  _disposeBreaksGroup: _noop,\n  dispose: function dispose() {\n    [this._axisElementsGroup, this._axisStripGroup, this._axisGroup].forEach(function (g) {\n      g.dispose();\n    });\n    this._strips = this._title = null;\n    this._axisStripGroup = this._axisConstantLineGroups = this._axisStripLabelGroup = this._axisBreaksGroup = null;\n    this._axisLineGroup = this._axisElementsGroup = this._axisGridGroup = null;\n    this._axisGroup = this._axisTitleGroup = null;\n    this._axesContainerGroup = this._stripsGroup = this._constantLinesGroup = this._labelsAxesGroup = null;\n    this._renderer = this._options = this._textOptions = this._textFontStyles = null;\n    this._translator = null;\n    this._majorTicks = this._minorTicks = null;\n\n    this._disposeBreaksGroup();\n\n    this._templatesRendered && this._templatesRendered.reject();\n  },\n  getOptions: function getOptions() {\n    return this._options;\n  },\n  setPane: function setPane(pane) {\n    this.pane = pane;\n    this._options.pane = pane;\n  },\n  setTypes: function setTypes(type, axisType, typeSelector) {\n    this._options.type = type || this._options.type;\n    this._options[typeSelector] = axisType || this._options[typeSelector];\n\n    this._updateTranslator();\n  },\n  resetTypes: function resetTypes(typeSelector) {\n    this._options.type = this._initTypes.type;\n    this._options[typeSelector] = this._initTypes[typeSelector];\n  },\n  getTranslator: function getTranslator() {\n    return this._translator;\n  },\n  updateOptions: function updateOptions(options) {\n    var that = this;\n    var labelOpt = options.label;\n    validateAxisOptions(options);\n    that._options = options;\n    options.tick = options.tick || {};\n    options.minorTick = options.minorTick || {};\n    options.grid = options.grid || {};\n    options.minorGrid = options.minorGrid || {};\n    options.title = options.title || {};\n    options.marker = options.marker || {};\n    that._initTypes = {\n      type: options.type,\n      argumentType: options.argumentType,\n      valueType: options.valueType\n    };\n\n    that._setTickOffset();\n\n    that._isHorizontal = options.isHorizontal;\n    that.pane = options.pane;\n    that.name = options.name;\n    that.priority = options.priority;\n    that._hasLabelFormat = \"\" !== labelOpt.format && isDefined(labelOpt.format);\n    that._textOptions = {\n      opacity: labelOpt.opacity,\n      align: \"center\",\n      class: labelOpt.cssClass\n    };\n    that._textFontStyles = patchFontOptions(labelOpt.font);\n\n    if (options.type === constants.logarithmic) {\n      if (options.logarithmBaseError) {\n        that._incidentOccurred(\"E2104\");\n\n        delete options.logarithmBaseError;\n      }\n    }\n\n    that._updateTranslator();\n\n    that._createConstantLines();\n\n    that._strips = (options.strips || []).map(function (o) {\n      return createStrip(that, o);\n    });\n    that._majorTicks = that._minorTicks = null;\n    that._firstDrawing = true;\n  },\n  calculateInterval: function calculateInterval(value, prevValue) {\n    var options = this._options;\n\n    if (!options || options.type !== constants.logarithmic) {\n      return _abs(value - prevValue);\n    }\n\n    var _Range = new Range(this.getTranslator().getBusinessRange()),\n        allowNegatives = _Range.allowNegatives,\n        linearThreshold = _Range.linearThreshold;\n\n    return _abs(getLog(value, options.logarithmBase, allowNegatives, linearThreshold) - getLog(prevValue, options.logarithmBase, allowNegatives, linearThreshold));\n  },\n  getCanvasRange: function getCanvasRange() {\n    var translator = this._translator;\n    return {\n      startValue: translator.from(translator.translate(\"canvas_position_start\")),\n      endValue: translator.from(translator.translate(\"canvas_position_end\"))\n    };\n  },\n  _processCanvas: function _processCanvas(canvas) {\n    return canvas;\n  },\n  updateCanvas: function updateCanvas(canvas, canvasRedesign) {\n    if (!canvasRedesign) {\n      var positions = this._orthogonalPositions = {\n        start: !this._isHorizontal ? canvas.left : canvas.top,\n        end: !this._isHorizontal ? canvas.width - canvas.right : canvas.height - canvas.bottom\n      };\n      positions.center = positions.start + (positions.end - positions.start) / 2;\n    } else {\n      this._orthogonalPositions = null;\n    }\n\n    this._canvas = canvas;\n\n    this._translator.updateCanvas(this._processCanvas(canvas));\n\n    this._initAxisPositions();\n  },\n  getCanvas: function getCanvas() {\n    return this._canvas;\n  },\n  getAxisShift: function getAxisShift() {\n    return this._axisShift || 0;\n  },\n  hideTitle: function hideTitle() {\n    if (this._options.title.text) {\n      this._incidentOccurred(\"W2105\", [this._isHorizontal ? \"horizontal\" : \"vertical\"]);\n\n      this._axisTitleGroup.clear();\n    }\n  },\n  getTitle: function getTitle() {\n    return this._title;\n  },\n  hideOuterElements: function hideOuterElements() {\n    var options = this._options;\n\n    if ((options.label.visible || this._outsideConstantLines.length) && !this._translator.getBusinessRange().isEmpty()) {\n      this._incidentOccurred(\"W2106\", [this._isHorizontal ? \"horizontal\" : \"vertical\"]);\n\n      this._axisElementsGroup.clear();\n\n      callAction(this._outsideConstantLines, \"removeLabel\");\n    }\n  },\n  _resolveLogarithmicOptionsForRange: function _resolveLogarithmicOptionsForRange(range) {\n    var options = this._options;\n\n    if (options.type === constants.logarithmic) {\n      range.addRange({\n        allowNegatives: void 0 !== options.allowNegatives ? options.allowNegatives : range.min <= 0\n      });\n\n      if (!isNaN(options.linearThreshold)) {\n        range.linearThreshold = options.linearThreshold;\n      }\n    }\n  },\n  adjustViewport: function adjustViewport(businessRange) {\n    var options = this._options;\n    var isDiscrete = options.type === constants.discrete;\n    var categories = this._seriesData && this._seriesData.categories || [];\n    var wholeRange = this.adjustRange(getVizRangeObject(options.wholeRange));\n    var visualRange = this.getViewport() || {};\n    var result = new Range(businessRange);\n\n    this._addConstantLinesToRange(result, \"minVisible\", \"maxVisible\");\n\n    var minDefined = isDefined(visualRange.startValue);\n    var maxDefined = isDefined(visualRange.endValue);\n\n    if (!isDiscrete) {\n      minDefined = minDefined && (!isDefined(wholeRange.endValue) || visualRange.startValue < wholeRange.endValue);\n      maxDefined = maxDefined && (!isDefined(wholeRange.startValue) || visualRange.endValue > wholeRange.startValue);\n    }\n\n    var minVisible = minDefined ? visualRange.startValue : result.minVisible;\n    var maxVisible = maxDefined ? visualRange.endValue : result.maxVisible;\n\n    if (!isDiscrete) {\n      var _wholeRange$startValu, _wholeRange$endValue;\n\n      result.min = null !== (_wholeRange$startValu = wholeRange.startValue) && void 0 !== _wholeRange$startValu ? _wholeRange$startValu : result.min;\n      result.max = null !== (_wholeRange$endValue = wholeRange.endValue) && void 0 !== _wholeRange$endValue ? _wholeRange$endValue : result.max;\n    } else {\n      var categoriesInfo = getCategoriesInfo(categories, wholeRange.startValue, wholeRange.endValue);\n      categories = categoriesInfo.categories;\n      result.categories = categories;\n    }\n\n    var adjustedVisualRange = adjustVisualRange({\n      axisType: options.type,\n      dataType: options.dataType,\n      base: options.logarithmBase\n    }, {\n      startValue: minDefined ? visualRange.startValue : void 0,\n      endValue: maxDefined ? visualRange.endValue : void 0,\n      length: visualRange.length\n    }, {\n      categories: categories,\n      min: wholeRange.startValue,\n      max: wholeRange.endValue\n    }, {\n      categories: categories,\n      min: minVisible,\n      max: maxVisible\n    });\n    result.minVisible = adjustedVisualRange.startValue;\n    result.maxVisible = adjustedVisualRange.endValue;\n    !isDefined(result.min) && (result.min = result.minVisible);\n    !isDefined(result.max) && (result.max = result.maxVisible);\n    result.addRange({});\n\n    this._resolveLogarithmicOptionsForRange(result);\n\n    return result;\n  },\n  adjustRange: function adjustRange(range) {\n    range = range || {};\n    var isDiscrete = this._options.type === constants.discrete;\n    var isLogarithmic = this._options.type === constants.logarithmic;\n    var disabledNegatives = false === this._options.allowNegatives;\n\n    if (isLogarithmic) {\n      range.startValue = disabledNegatives && range.startValue <= 0 ? null : range.startValue;\n      range.endValue = disabledNegatives && range.endValue <= 0 ? null : range.endValue;\n    }\n\n    if (!isDiscrete && isDefined(range.startValue) && isDefined(range.endValue) && range.startValue > range.endValue) {\n      var tmp = range.endValue;\n      range.endValue = range.startValue;\n      range.startValue = tmp;\n    }\n\n    return range;\n  },\n  _getVisualRangeUpdateMode: function _getVisualRangeUpdateMode(viewport, newRange, oppositeValue) {\n    var value = this._options.visualRangeUpdateMode;\n    var translator = this._translator;\n    var range = this._seriesData;\n    var prevDataInfo = this._prevDataInfo;\n\n    if (prevDataInfo.isEmpty && !prevDataInfo.containsConstantLine) {\n      return KEEP;\n    }\n\n    if (!this.isArgumentAxis) {\n      var _viewport = this.getViewport();\n\n      if (!isDefined(_viewport.startValue) && !isDefined(_viewport.endValue) && !isDefined(_viewport.length)) {\n        return RESET;\n      }\n    }\n\n    if (this.isArgumentAxis) {\n      if (-1 === [SHIFT, KEEP, RESET].indexOf(value)) {\n        if (range.axisType === constants.discrete) {\n          var categories = range.categories;\n          var newCategories = newRange.categories;\n          var visualRange = this.visualRange();\n\n          if (categories && newCategories && categories.length && -1 !== newCategories.map(function (c) {\n            return c.valueOf();\n          }).join(\",\").indexOf(categories.map(function (c) {\n            return c.valueOf();\n          }).join(\",\")) && (visualRange.startValue.valueOf() !== categories[0].valueOf() || visualRange.endValue.valueOf() !== categories[categories.length - 1].valueOf())) {\n            value = KEEP;\n          } else {\n            value = RESET;\n          }\n        } else {\n          var minPoint = translator.translate(range.min);\n          var minVisiblePoint = translator.translate(viewport.startValue);\n          var maxPoint = translator.translate(range.max);\n          var maxVisiblePoint = translator.translate(viewport.endValue);\n\n          if (minPoint === minVisiblePoint && maxPoint === maxVisiblePoint) {\n            value = RESET;\n          } else if (minPoint !== minVisiblePoint && maxPoint === maxVisiblePoint) {\n            value = SHIFT;\n          } else {\n            value = KEEP;\n          }\n        }\n\n        if (value === KEEP && prevDataInfo.isEmpty && prevDataInfo.containsConstantLine) {\n          value = RESET;\n        }\n      }\n    } else if (-1 === [KEEP, RESET].indexOf(value)) {\n      if (oppositeValue === KEEP) {\n        value = KEEP;\n      } else {\n        value = RESET;\n      }\n    }\n\n    return value;\n  },\n  _handleBusinessRangeChanged: function _handleBusinessRangeChanged(oppositeVisualRangeUpdateMode, axisReinitialized, newRange) {\n    var visualRange = this.visualRange();\n\n    if (axisReinitialized || this._translator.getBusinessRange().isEmpty()) {\n      return;\n    }\n\n    var visualRangeUpdateMode = this._lastVisualRangeUpdateMode = this._getVisualRangeUpdateMode(visualRange, newRange, oppositeVisualRangeUpdateMode);\n\n    if (visualRangeUpdateMode === KEEP) {\n      this._setVisualRange([visualRange.startValue, visualRange.endValue]);\n    } else if (visualRangeUpdateMode === RESET) {\n      this._setVisualRange([null, null]);\n    } else if (visualRangeUpdateMode === SHIFT) {\n      this._setVisualRange({\n        length: this.getVisualRangeLength()\n      });\n    }\n  },\n  getVisualRangeLength: function getVisualRangeLength(range) {\n    var currentBusinessRange = range || this._translator.getBusinessRange();\n\n    var type = this._options.type;\n    var length;\n\n    if (type === constants.logarithmic) {\n      length = adjust(this.calculateInterval(currentBusinessRange.maxVisible, currentBusinessRange.minVisible));\n    } else if (type === constants.discrete) {\n      var categoriesInfo = getCategoriesInfo(currentBusinessRange.categories, currentBusinessRange.minVisible, currentBusinessRange.maxVisible);\n      length = categoriesInfo.categories.length;\n    } else {\n      length = currentBusinessRange.maxVisible - currentBusinessRange.minVisible;\n    }\n\n    return length;\n  },\n  getVisualRangeCenter: function getVisualRangeCenter(range, useMerge) {\n    var translator = this.getTranslator();\n    var businessRange = translator.getBusinessRange();\n    var currentBusinessRange = useMerge ? extend(true, {}, businessRange, range || {}) : range || businessRange;\n    var _this$_options = this._options,\n        type = _this$_options.type,\n        logarithmBase = _this$_options.logarithmBase;\n    var center;\n\n    if (!isDefined(currentBusinessRange.minVisible) || !isDefined(currentBusinessRange.maxVisible)) {\n      return;\n    }\n\n    if (type === constants.logarithmic) {\n      var allowNegatives = currentBusinessRange.allowNegatives,\n          linearThreshold = currentBusinessRange.linearThreshold,\n          minVisible = currentBusinessRange.minVisible,\n          maxVisible = currentBusinessRange.maxVisible;\n      center = raiseTo(adjust(getLog(maxVisible, logarithmBase, allowNegatives, linearThreshold) + getLog(minVisible, logarithmBase, allowNegatives, linearThreshold)) / 2, logarithmBase, allowNegatives, linearThreshold);\n    } else if (type === constants.discrete) {\n      var categoriesInfo = getCategoriesInfo(currentBusinessRange.categories, currentBusinessRange.minVisible, currentBusinessRange.maxVisible);\n      var index = Math.ceil(categoriesInfo.categories.length / 2) - 1;\n      center = businessRange.categories.indexOf(categoriesInfo.categories[index]);\n    } else {\n      center = translator.toValue((currentBusinessRange.maxVisible.valueOf() + currentBusinessRange.minVisible.valueOf()) / 2);\n    }\n\n    return center;\n  },\n  setBusinessRange: function setBusinessRange(range, axisReinitialized, oppositeVisualRangeUpdateMode, argCategories) {\n    var _that$_seriesData$min, _that$_seriesData$max;\n\n    var options = this._options;\n    var isDiscrete = options.type === constants.discrete;\n\n    this._handleBusinessRangeChanged(oppositeVisualRangeUpdateMode, axisReinitialized, range);\n\n    this._seriesData = new Range(range);\n\n    var dataIsEmpty = this._seriesData.isEmpty();\n\n    var rangeWithConstantLines = new Range(this._seriesData);\n\n    this._addConstantLinesToRange(rangeWithConstantLines, \"minVisible\", \"maxVisible\");\n\n    this._prevDataInfo = {\n      isEmpty: dataIsEmpty,\n      containsConstantLine: rangeWithConstantLines.containsConstantLine\n    };\n\n    this._seriesData.addRange({\n      categories: options.categories,\n      dataType: options.dataType,\n      axisType: options.type,\n      base: options.logarithmBase,\n      invert: options.inverted\n    });\n\n    this._resolveLogarithmicOptionsForRange(this._seriesData);\n\n    if (!isDiscrete) {\n      if (!isDefined(this._seriesData.min) && !isDefined(this._seriesData.max)) {\n        var visualRange = this.getViewport();\n        visualRange && this._seriesData.addRange({\n          min: visualRange.startValue,\n          max: visualRange.endValue\n        });\n      }\n\n      var synchronizedValue = options.synchronizedValue;\n\n      if (isDefined(synchronizedValue)) {\n        this._seriesData.addRange({\n          min: synchronizedValue,\n          max: synchronizedValue\n        });\n      }\n    }\n\n    this._seriesData.minVisible = null !== (_that$_seriesData$min = this._seriesData.minVisible) && void 0 !== _that$_seriesData$min ? _that$_seriesData$min : this._seriesData.min;\n    this._seriesData.maxVisible = null !== (_that$_seriesData$max = this._seriesData.maxVisible) && void 0 !== _that$_seriesData$max ? _that$_seriesData$max : this._seriesData.max;\n\n    if (!this.isArgumentAxis && options.showZero) {\n      this._seriesData.correctValueZeroLevel();\n    }\n\n    this._seriesData.sortCategories(this.getCategoriesSorter(argCategories));\n\n    this._seriesData.userBreaks = this._seriesData.isEmpty() ? [] : this._getScaleBreaks(options, this._seriesData, this._series, this.isArgumentAxis);\n\n    this._translator.updateBusinessRange(this._getViewportRange());\n  },\n  _addConstantLinesToRange: function _addConstantLinesToRange(dataRange, minValueField, maxValueField) {\n    this._outsideConstantLines.concat(this._insideConstantLines || []).forEach(function (cl) {\n      if (cl.options.extendAxis) {\n        var _dataRange$addRange;\n\n        var value = cl.getParsedValue();\n        dataRange.addRange((_dataRange$addRange = {\n          containsConstantLine: true\n        }, _defineProperty(_dataRange$addRange, minValueField, value), _defineProperty(_dataRange$addRange, maxValueField, value), _dataRange$addRange));\n      }\n    });\n  },\n  setGroupSeries: function setGroupSeries(series) {\n    this._series = series;\n  },\n  getLabelsPosition: function getLabelsPosition() {\n    var options = this._options;\n    var position = options.position;\n    var labelShift = options.label.indentFromAxis + (this._axisShift || 0) + this._constantLabelOffset;\n    var axisPosition = this._axisPosition;\n    return position === TOP || position === LEFT ? axisPosition - labelShift : axisPosition + labelShift;\n  },\n  getFormattedValue: function getFormattedValue(value, options, point) {\n    var labelOptions = this._options.label;\n    return isDefined(value) ? this.formatLabel(value, extend(true, {}, labelOptions, options), void 0, point) : null;\n  },\n  _getBoundaryTicks: function _getBoundaryTicks(majors, viewPort) {\n    var length = majors.length;\n    var options = this._options;\n    var customBounds = options.customBoundTicks;\n    var min = viewPort.minVisible;\n    var max = viewPort.maxVisible;\n    var addMinMax = options.showCustomBoundaryTicks ? this._boundaryTicksVisibility : {};\n    var boundaryTicks = [];\n\n    if (options.type === constants.discrete) {\n      if (this._tickOffset && 0 !== majors.length) {\n        boundaryTicks = [majors[0], majors[majors.length - 1]];\n      }\n    } else if (customBounds) {\n      if (addMinMax.min && isDefined(customBounds[0])) {\n        boundaryTicks.push(customBounds[0]);\n      }\n\n      if (addMinMax.max && isDefined(customBounds[1])) {\n        boundaryTicks.push(customBounds[1]);\n      }\n    } else {\n      if (addMinMax.min && (0 === length || majors[0] > min)) {\n        boundaryTicks.push(min);\n      }\n\n      if (addMinMax.max && (0 === length || majors[length - 1] < max)) {\n        boundaryTicks.push(max);\n      }\n    }\n\n    return boundaryTicks;\n  },\n  setPercentLabelFormat: function setPercentLabelFormat() {\n    if (!this._hasLabelFormat) {\n      this._options.label.format = \"percent\";\n    }\n  },\n  resetAutoLabelFormat: function resetAutoLabelFormat() {\n    if (!this._hasLabelFormat) {\n      delete this._options.label.format;\n    }\n  },\n  getMultipleAxesSpacing: function getMultipleAxesSpacing() {\n    return this._options.multipleAxesSpacing || 0;\n  },\n  getTicksValues: function getTicksValues() {\n    return {\n      majorTicksValues: convertTicksToValues(this._majorTicks),\n      minorTicksValues: convertTicksToValues(this._minorTicks)\n    };\n  },\n  estimateTickInterval: function estimateTickInterval(canvas) {\n    this.updateCanvas(canvas);\n    return this._tickInterval !== this._getTicks(this._getViewportRange(), _noop, true).tickInterval;\n  },\n  setTicks: function setTicks(ticks) {\n    var majors = ticks.majorTicks || [];\n    this._majorTicks = majors.map(createMajorTick(this, this._renderer, this._getSkippedCategory(majors)));\n    this._minorTicks = (ticks.minorTicks || []).map(createMinorTick(this, this._renderer));\n    this._isSynchronized = true;\n  },\n  _adjustDivisionFactor: function _adjustDivisionFactor(val) {\n    return val;\n  },\n  _getTicks: function _getTicks(viewPort, incidentOccurred, skipTickGeneration) {\n    var options = this._options;\n    var customTicks = options.customTicks;\n    var customMinorTicks = options.customMinorTicks;\n    return getTickGenerator(options, incidentOccurred || this._incidentOccurred, skipTickGeneration, this._translator.getBusinessRange().isEmpty(), this._adjustDivisionFactor.bind(this), viewPort)({\n      min: viewPort.minVisible,\n      max: viewPort.maxVisible,\n      categories: viewPort.categories,\n      isSpacedMargin: viewPort.isSpacedMargin\n    }, this._getScreenDelta(), options.tickInterval, \"ignore\" === options.label.overlappingBehavior || options.forceUserTickInterval, {\n      majors: customTicks,\n      minors: customMinorTicks\n    }, options.minorTickInterval, options.minorTickCount, this._initialBreaks);\n  },\n  _createTicksAndLabelFormat: function _createTicksAndLabelFormat(range, incidentOccurred) {\n    var options = this._options;\n\n    var ticks = this._getTicks(range, incidentOccurred, false);\n\n    if (!range.isEmpty() && options.type === constants.discrete && \"datetime\" === options.dataType && !this._hasLabelFormat && ticks.ticks.length) {\n      options.label.format = formatHelper.getDateFormatByTicks(ticks.ticks);\n    }\n\n    return ticks;\n  },\n  getAggregationInfo: function getAggregationInfo(useAllAggregatedPoints, range) {\n    var _visualRange$startVal, _visualRange$endValue, _that$_seriesData;\n\n    var options = this._options;\n    var marginOptions = this._marginOptions;\n    var businessRange = new Range(this.getTranslator().getBusinessRange()).addRange(range);\n    var visualRange = this.getViewport();\n    var minVisible = null !== (_visualRange$startVal = null === visualRange || void 0 === visualRange ? void 0 : visualRange.startValue) && void 0 !== _visualRange$startVal ? _visualRange$startVal : businessRange.minVisible;\n    var maxVisible = null !== (_visualRange$endValue = null === visualRange || void 0 === visualRange ? void 0 : visualRange.endValue) && void 0 !== _visualRange$endValue ? _visualRange$endValue : businessRange.maxVisible;\n    var ticks = [];\n\n    if (options.type === constants.discrete && options.aggregateByCategory) {\n      return {\n        aggregateByCategory: true\n      };\n    }\n\n    var aggregationInterval = options.aggregationInterval;\n    var aggregationGroupWidth = options.aggregationGroupWidth;\n\n    if (!aggregationGroupWidth && marginOptions) {\n      if (marginOptions.checkInterval) {\n        aggregationGroupWidth = options.axisDivisionFactor;\n      }\n\n      if (marginOptions.sizePointNormalState) {\n        aggregationGroupWidth = Math.min(marginOptions.sizePointNormalState, options.axisDivisionFactor);\n      }\n    }\n\n    var minInterval = !options.aggregationGroupWidth && !aggregationInterval && range.interval;\n    var generateTicks = configureGenerator(options, aggregationGroupWidth, businessRange, this._getScreenDelta(), minInterval);\n    var tickInterval = generateTicks(aggregationInterval, true, minVisible, maxVisible, null === (_that$_seriesData = this._seriesData) || void 0 === _that$_seriesData ? void 0 : _that$_seriesData.breaks).tickInterval;\n\n    if (options.type !== constants.discrete) {\n      var min = useAllAggregatedPoints ? businessRange.min : minVisible;\n      var max = useAllAggregatedPoints ? businessRange.max : maxVisible;\n\n      if (isDefined(min) && isDefined(max)) {\n        var add = getAddFunction({\n          base: options.logarithmBase,\n          axisType: options.type,\n          dataType: options.dataType\n        }, false);\n        var start = min;\n        var end = max;\n\n        if (!useAllAggregatedPoints) {\n          var maxMinDistance = Math.max(this.calculateInterval(max, min), \"datetime\" === options.dataType ? dateUtils.dateToMilliseconds(tickInterval) : tickInterval);\n          start = add(min, maxMinDistance, -1);\n          end = add(max, maxMinDistance);\n        }\n\n        start = start < businessRange.min ? businessRange.min : start;\n        end = end > businessRange.max ? businessRange.max : end;\n\n        var breaks = this._getScaleBreaks(options, {\n          minVisible: start,\n          maxVisible: end\n        }, this._series, this.isArgumentAxis);\n\n        var filteredBreaks = this._filterBreaks(breaks, {\n          minVisible: start,\n          maxVisible: end\n        }, options.breakStyle);\n\n        ticks = generateTicks(tickInterval, false, start, end, filteredBreaks).ticks;\n      }\n    }\n\n    this._aggregationInterval = tickInterval;\n    return {\n      interval: tickInterval,\n      ticks: ticks\n    };\n  },\n  getTickInterval: function getTickInterval() {\n    return this._tickInterval;\n  },\n  getAggregationInterval: function getAggregationInterval() {\n    return this._aggregationInterval;\n  },\n  createTicks: function createTicks(canvas) {\n    var that = this;\n    var renderer = that._renderer;\n    var options = that._options;\n\n    if (!canvas) {\n      return;\n    }\n\n    that._isSynchronized = false;\n    that.updateCanvas(canvas);\n\n    var range = that._getViewportRange();\n\n    that._initialBreaks = range.breaks = this._seriesData.breaks = that._filterBreaks(this._seriesData.userBreaks, range, options.breakStyle);\n    that._estimatedTickInterval = that._getTicks(that.adjustViewport(this._seriesData), _noop, true).tickInterval;\n\n    var margins = this._calculateValueMargins();\n\n    range.addRange({\n      minVisible: margins.minValue,\n      maxVisible: margins.maxValue,\n      isSpacedMargin: margins.isSpacedMargin\n    });\n\n    var ticks = that._createTicksAndLabelFormat(range);\n\n    var boundaryTicks = that._getBoundaryTicks(ticks.ticks, that._getViewportRange());\n\n    if (options.showCustomBoundaryTicks && boundaryTicks.length) {\n      that._boundaryTicks = [boundaryTicks[0]].map(createBoundaryTick(that, renderer, true));\n\n      if (boundaryTicks.length > 1) {\n        that._boundaryTicks = that._boundaryTicks.concat([boundaryTicks[1]].map(createBoundaryTick(that, renderer, false)));\n      }\n    } else {\n      that._boundaryTicks = [];\n    }\n\n    var minors = (ticks.minorTicks || []).filter(function (minor) {\n      return !boundaryTicks.some(function (boundary) {\n        return valueOf(boundary) === valueOf(minor);\n      });\n    });\n    that._tickInterval = ticks.tickInterval;\n    that._minorTickInterval = ticks.minorTickInterval;\n    var oldMajorTicks = that._majorTicks || [];\n    var majorTicksByValues = oldMajorTicks.reduce(function (r, t) {\n      r[t.value.valueOf()] = t;\n      return r;\n    }, {});\n    var sameType = type(ticks.ticks[0]) === type(oldMajorTicks[0] && oldMajorTicks[0].value);\n\n    var skippedCategory = that._getSkippedCategory(ticks.ticks);\n\n    var majorTicks = ticks.ticks.map(function (v) {\n      var tick = majorTicksByValues[v.valueOf()];\n\n      if (tick && sameType) {\n        delete majorTicksByValues[v.valueOf()];\n        tick.setSkippedCategory(skippedCategory);\n        return tick;\n      } else {\n        return createMajorTick(that, renderer, skippedCategory)(v);\n      }\n    });\n    that._majorTicks = majorTicks;\n    var oldMinorTicks = that._minorTicks || [];\n    that._minorTicks = minors.map(function (v, i) {\n      var minorTick = oldMinorTicks[i];\n\n      if (minorTick) {\n        minorTick.updateValue(v);\n        return minorTick;\n      }\n\n      return createMinorTick(that, renderer)(v);\n    });\n    that._ticksToRemove = Object.keys(majorTicksByValues).map(function (k) {\n      return majorTicksByValues[k];\n    }).concat(oldMinorTicks.slice(that._minorTicks.length, oldMinorTicks.length));\n\n    that._ticksToRemove.forEach(function (t) {\n      var _t$label;\n\n      return null === (_t$label = t.label) || void 0 === _t$label ? void 0 : _t$label.removeTitle();\n    });\n\n    if (ticks.breaks) {\n      that._seriesData.breaks = ticks.breaks;\n    }\n\n    that._reinitTranslator(that._getViewportRange());\n  },\n  _reinitTranslator: function _reinitTranslator(range) {\n    var translator = this._translator;\n\n    if (this._isSynchronized) {\n      return;\n    }\n\n    translator.updateBusinessRange(range);\n  },\n  _getViewportRange: function _getViewportRange() {\n    return this.adjustViewport(this._seriesData);\n  },\n  setMarginOptions: function setMarginOptions(options) {\n    this._marginOptions = options;\n  },\n  getMarginOptions: function getMarginOptions() {\n    var _this$_marginOptions;\n\n    return null !== (_this$_marginOptions = this._marginOptions) && void 0 !== _this$_marginOptions ? _this$_marginOptions : {};\n  },\n  _calculateRangeInterval: function _calculateRangeInterval(interval) {\n    var isDateTime = \"datetime\" === this._options.dataType;\n    var minArgs = [];\n\n    var addToArgs = function addToArgs(value) {\n      isDefined(value) && minArgs.push(isDateTime ? dateUtils.dateToMilliseconds(value) : value);\n    };\n\n    addToArgs(this._tickInterval);\n    addToArgs(this._estimatedTickInterval);\n    isDefined(interval) && minArgs.push(interval);\n    addToArgs(this._aggregationInterval);\n    return this._calculateWorkWeekInterval(_min.apply(this, minArgs));\n  },\n  _calculateWorkWeekInterval: function _calculateWorkWeekInterval(businessInterval) {\n    var options = this._options;\n\n    if (\"datetime\" === options.dataType && options.workdaysOnly && businessInterval) {\n      var workWeek = options.workWeek.length * dateIntervals.day;\n      var weekend = dateIntervals.week - workWeek;\n\n      if (workWeek !== businessInterval && weekend < businessInterval) {\n        var weekendsCount = Math.ceil(businessInterval / dateIntervals.week);\n        businessInterval -= weekend * weekendsCount;\n      } else if (weekend >= businessInterval && businessInterval > dateIntervals.day) {\n        businessInterval = dateIntervals.day;\n      }\n    }\n\n    return businessInterval;\n  },\n  _getConvertIntervalCoefficient: function _getConvertIntervalCoefficient(intervalInPx, screenDelta) {\n    var ratioOfCanvasRange = this._translator.ratioOfCanvasRange();\n\n    return ratioOfCanvasRange / (ratioOfCanvasRange * screenDelta / (intervalInPx + screenDelta));\n  },\n  _calculateValueMargins: function _calculateValueMargins(ticks) {\n    this._resetMargins();\n\n    var margins = this.getMarginOptions();\n    var marginSize = (margins.size || 0) / 2;\n    var options = this._options;\n\n    var dataRange = this._getViewportRange();\n\n    var viewPort = this.getViewport();\n\n    var screenDelta = this._getScreenDelta();\n\n    var isDiscrete = -1 !== (options.type || \"\").indexOf(constants.discrete);\n    var valueMarginsEnabled = options.valueMarginsEnabled && !isDiscrete && !this.customPositionIsBoundaryOrthogonalAxis();\n    var translator = this._translator;\n    var minValueMargin = options.minValueMargin;\n    var maxValueMargin = options.maxValueMargin;\n    var minPadding = 0;\n    var maxPadding = 0;\n    var interval = 0;\n    var rangeInterval;\n\n    if (dataRange.stubData || !screenDelta) {\n      return {\n        startPadding: 0,\n        endPadding: 0\n      };\n    }\n\n    if (this.isArgumentAxis && margins.checkInterval) {\n      rangeInterval = this._calculateRangeInterval(dataRange.interval);\n      var pxInterval = translator.getInterval(rangeInterval);\n\n      if (isFinite(pxInterval)) {\n        interval = Math.ceil(pxInterval / (2 * this._getConvertIntervalCoefficient(pxInterval, screenDelta)));\n      } else {\n        rangeInterval = 0;\n      }\n    }\n\n    var minPercentPadding;\n    var maxPercentPadding;\n    var maxPaddingValue = screenDelta * MAX_MARGIN_VALUE / 2;\n\n    if (valueMarginsEnabled) {\n      if (isDefined(minValueMargin)) {\n        minPercentPadding = isFinite(minValueMargin) ? minValueMargin : 0;\n      } else if (!this.isArgumentAxis && margins.checkInterval && valueOf(dataRange.minVisible) > 0 && valueOf(dataRange.minVisible) === valueOf(dataRange.min)) {\n        minPadding = MIN_BAR_MARGIN;\n      } else {\n        minPadding = Math.max(marginSize, interval);\n        minPadding = Math.min(maxPaddingValue, minPadding);\n      }\n\n      if (isDefined(maxValueMargin)) {\n        maxPercentPadding = isFinite(maxValueMargin) ? maxValueMargin : 0;\n      } else if (!this.isArgumentAxis && margins.checkInterval && valueOf(dataRange.maxVisible) < 0 && valueOf(dataRange.maxVisible) === valueOf(dataRange.max)) {\n        maxPadding = MIN_BAR_MARGIN;\n      } else {\n        maxPadding = Math.max(marginSize, interval);\n        maxPadding = Math.min(maxPaddingValue, maxPadding);\n      }\n    }\n\n    var percentStick = margins.percentStick && !this.isArgumentAxis;\n\n    if (percentStick) {\n      if (1 === _abs(dataRange.max)) {\n        maxPadding = 0;\n      }\n\n      if (1 === _abs(dataRange.min)) {\n        minPadding = 0;\n      }\n    }\n\n    var canvasStartEnd = this._getCanvasStartEnd();\n\n    var commonMargin = 1 + (minPercentPadding || 0) + (maxPercentPadding || 0);\n    var screenDeltaWithMargins = (screenDelta - minPadding - maxPadding) / commonMargin || screenDelta;\n\n    if (void 0 !== minPercentPadding || void 0 !== maxPercentPadding) {\n      if (void 0 !== minPercentPadding) {\n        minPadding = screenDeltaWithMargins * minPercentPadding;\n      }\n\n      if (void 0 !== maxPercentPadding) {\n        maxPadding = screenDeltaWithMargins * maxPercentPadding;\n      }\n    }\n\n    var minValue;\n    var maxValue;\n\n    if (options.type !== constants.discrete && ticks && ticks.length > 1 && !options.skipViewportExtending && !viewPort.action && false !== options.endOnTick) {\n      var length = ticks.length;\n      var firstTickPosition = translator.translate(ticks[0].value);\n      var lastTickPosition = translator.translate(ticks[length - 1].value);\n      var invertMultiplier = firstTickPosition > lastTickPosition ? -1 : 1;\n\n      var minTickPadding = _max(invertMultiplier * (canvasStartEnd.start - firstTickPosition), 0);\n\n      var maxTickPadding = _max(invertMultiplier * (lastTickPosition - canvasStartEnd.end), 0);\n\n      if (minTickPadding > minPadding || maxTickPadding > maxPadding) {\n        var commonPadding = maxTickPadding + minTickPadding;\n\n        var coeff = this._getConvertIntervalCoefficient(commonPadding, screenDelta);\n\n        if (minTickPadding >= minPadding) {\n          minValue = ticks[0].value;\n        }\n\n        if (maxTickPadding >= maxPadding) {\n          maxValue = ticks[length - 1].value;\n        }\n\n        minPadding = _max(minTickPadding, minPadding) / coeff;\n        maxPadding = _max(maxTickPadding, maxPadding) / coeff;\n      }\n    }\n\n    minPercentPadding = void 0 === minPercentPadding ? minPadding / screenDeltaWithMargins : minPercentPadding;\n    maxPercentPadding = void 0 === maxPercentPadding ? maxPadding / screenDeltaWithMargins : maxPercentPadding;\n\n    if (!isDiscrete) {\n      if (this._translator.isInverted()) {\n        var _minValue, _maxValue;\n\n        minValue = null !== (_minValue = minValue) && void 0 !== _minValue ? _minValue : translator.from(canvasStartEnd.start + screenDelta * minPercentPadding, -1);\n        maxValue = null !== (_maxValue = maxValue) && void 0 !== _maxValue ? _maxValue : translator.from(canvasStartEnd.end - screenDelta * maxPercentPadding, 1);\n      } else {\n        var _minValue2, _maxValue2;\n\n        minValue = null !== (_minValue2 = minValue) && void 0 !== _minValue2 ? _minValue2 : translator.from(canvasStartEnd.start - screenDelta * minPercentPadding, -1);\n        maxValue = null !== (_maxValue2 = maxValue) && void 0 !== _maxValue2 ? _maxValue2 : translator.from(canvasStartEnd.end + screenDelta * maxPercentPadding, 1);\n      }\n    }\n\n    var _this$getCorrectedVal = this.getCorrectedValuesToZero(minValue, maxValue),\n        correctedMin = _this$getCorrectedVal.correctedMin,\n        correctedMax = _this$getCorrectedVal.correctedMax,\n        start = _this$getCorrectedVal.start,\n        end = _this$getCorrectedVal.end;\n\n    minPadding = null !== start && void 0 !== start ? start : minPadding;\n    maxPadding = null !== end && void 0 !== end ? end : maxPadding;\n    return {\n      startPadding: translator.isInverted() ? maxPadding : minPadding,\n      endPadding: translator.isInverted() ? minPadding : maxPadding,\n      minValue: null !== correctedMin && void 0 !== correctedMin ? correctedMin : minValue,\n      maxValue: null !== correctedMax && void 0 !== correctedMax ? correctedMax : maxValue,\n      interval: rangeInterval,\n      isSpacedMargin: minPadding === maxPadding && 0 !== minPadding\n    };\n  },\n  getCorrectedValuesToZero: function getCorrectedValuesToZero(minValue, maxValue) {\n    var that = this;\n    var translator = that._translator;\n\n    var canvasStartEnd = that._getCanvasStartEnd();\n\n    var dataRange = that._getViewportRange();\n\n    var screenDelta = that._getScreenDelta();\n\n    var options = that._options;\n    var start;\n    var end;\n    var correctedMin;\n    var correctedMax;\n\n    var correctZeroLevel = function correctZeroLevel(minPoint, maxPoint) {\n      var minExpectedPadding = _abs(canvasStartEnd.start - minPoint);\n\n      var maxExpectedPadding = _abs(canvasStartEnd.end - maxPoint);\n\n      var coeff = that._getConvertIntervalCoefficient(minExpectedPadding + maxExpectedPadding, screenDelta);\n\n      start = minExpectedPadding / coeff;\n      end = maxExpectedPadding / coeff;\n    };\n\n    if (!that.isArgumentAxis && \"datetime\" !== options.dataType) {\n      if (minValue * dataRange.min <= 0 && minValue * dataRange.minVisible <= 0) {\n        correctZeroLevel(translator.translate(0), translator.translate(maxValue));\n        correctedMin = 0;\n      }\n\n      if (maxValue * dataRange.max <= 0 && maxValue * dataRange.maxVisible <= 0) {\n        correctZeroLevel(translator.translate(minValue), translator.translate(0));\n        correctedMax = 0;\n      }\n    }\n\n    return {\n      start: isFinite(start) ? start : null,\n      end: isFinite(end) ? end : null,\n      correctedMin: correctedMin,\n      correctedMax: correctedMax\n    };\n  },\n  applyMargins: function applyMargins() {\n    if (this._isSynchronized) {\n      return;\n    }\n\n    var margins = this._calculateValueMargins(this._majorTicks);\n\n    var canvas = extend({}, this._canvas, {\n      startPadding: margins.startPadding,\n      endPadding: margins.endPadding\n    });\n\n    this._translator.updateCanvas(this._processCanvas(canvas));\n\n    if (isFinite(margins.interval)) {\n      var br = this._translator.getBusinessRange();\n\n      br.addRange({\n        interval: margins.interval\n      });\n\n      this._translator.updateBusinessRange(br);\n    }\n  },\n  _resetMargins: function _resetMargins() {\n    this._reinitTranslator(this._getViewportRange());\n\n    if (this._canvas) {\n      this._translator.updateCanvas(this._processCanvas(this._canvas));\n    }\n  },\n  _createConstantLines: function _createConstantLines() {\n    var _this2 = this;\n\n    var constantLines = (this._options.constantLines || []).map(function (o) {\n      return createConstantLine(_this2, o);\n    });\n    this._outsideConstantLines = constantLines.filter(function (l) {\n      return \"outside\" === l.labelPosition;\n    });\n    this._insideConstantLines = constantLines.filter(function (l) {\n      return \"inside\" === l.labelPosition;\n    });\n  },\n  draw: function draw(canvas, borderOptions) {\n    var that = this;\n    var options = this._options;\n    that.borderOptions = borderOptions || {\n      visible: false\n    };\n\n    that._resetMargins();\n\n    that.createTicks(canvas);\n    that.applyMargins();\n\n    that._clearAxisGroups();\n\n    initTickCoords(that._majorTicks);\n    initTickCoords(that._minorTicks);\n    initTickCoords(that._boundaryTicks);\n\n    that._axisGroup.append(that._axesContainerGroup);\n\n    that._drawAxis();\n\n    that._drawTitle();\n\n    drawTickMarks(that._majorTicks, options.tick);\n    drawTickMarks(that._minorTicks, options.minorTick);\n    drawTickMarks(that._boundaryTicks, options.tick);\n\n    var drawGridLine = that._getGridLineDrawer();\n\n    drawGrids(that._majorTicks, drawGridLine);\n    drawGrids(that._minorTicks, drawGridLine);\n    callAction(that._majorTicks, \"drawLabel\", that._getViewportRange(), that._getTemplate(options.label.template));\n    that._templatesRendered && that._templatesRendered.reject();\n    that._templatesRendered = new Deferred();\n\n    that._majorTicks.forEach(function (tick) {\n      tick.labelRotationAngle = 0;\n      tick.labelAlignment = void 0;\n      tick.labelOffset = 0;\n    });\n\n    callAction(that._outsideConstantLines.concat(that._insideConstantLines), \"draw\");\n    callAction(that._strips, \"draw\");\n    that._dateMarkers = that._drawDateMarkers() || [];\n    that._stripLabelAxesGroup && that._axisStripLabelGroup.append(that._stripLabelAxesGroup);\n    that._gridContainerGroup && that._axisGridGroup.append(that._gridContainerGroup);\n    that._stripsGroup && that._axisStripGroup.append(that._stripsGroup);\n    that._labelsAxesGroup && that._axisElementsGroup.append(that._labelsAxesGroup);\n\n    if (that._constantLinesGroup) {\n      that._axisConstantLineGroups.above.inside.append(that._constantLinesGroup.above);\n\n      that._axisConstantLineGroups.above.outside1.append(that._constantLinesGroup.above);\n\n      that._axisConstantLineGroups.above.outside2.append(that._constantLinesGroup.above);\n\n      that._axisConstantLineGroups.under.inside.append(that._constantLinesGroup.under);\n\n      that._axisConstantLineGroups.under.outside1.append(that._constantLinesGroup.under);\n\n      that._axisConstantLineGroups.under.outside2.append(that._constantLinesGroup.under);\n    }\n\n    that._measureTitle();\n\n    measureLabels(that._majorTicks);\n    !options.label.template && that._applyWordWrap();\n    measureLabels(that._outsideConstantLines);\n    measureLabels(that._insideConstantLines);\n    measureLabels(that._strips);\n    measureLabels(that._dateMarkers);\n\n    that._adjustConstantLineLabels(that._insideConstantLines);\n\n    that._adjustStripLabels();\n\n    var offset = that._constantLabelOffset = that._adjustConstantLineLabels(that._outsideConstantLines);\n\n    if (!that._translator.getBusinessRange().isEmpty()) {\n      that._setLabelsPlacement();\n\n      offset = that._adjustLabels(offset);\n    }\n\n    when.apply(this, that._majorTicks.map(function (tick) {\n      return tick.getTemplateDeferred();\n    })).done(function () {\n      that._templatesRendered.resolve();\n    });\n    offset = that._adjustDateMarkers(offset);\n\n    that._adjustTitle(offset);\n  },\n  getTemplatesDef: function getTemplatesDef() {\n    return this._templatesRendered;\n  },\n  setRenderedState: function setRenderedState(state) {\n    this._drawn = state;\n  },\n  isRendered: function isRendered() {\n    return this._drawn;\n  },\n  _applyWordWrap: function _applyWordWrap() {\n    var convertedTickInterval;\n    var textWidth;\n    var textHeight;\n    var options = this._options;\n    var tickInterval = this._tickInterval;\n\n    if (isDefined(tickInterval)) {\n      convertedTickInterval = this.getTranslator().getInterval(\"datetime\" === options.dataType ? dateUtils.dateToMilliseconds(tickInterval) : tickInterval);\n    }\n\n    var displayMode = this._validateDisplayMode(options.label.displayMode);\n\n    var overlappingMode = this._validateOverlappingMode(options.label.overlappingBehavior, displayMode);\n\n    var wordWrapMode = options.label.wordWrap || \"none\";\n    var overflowMode = options.label.textOverflow || \"none\";\n\n    if ((\"none\" !== wordWrapMode || \"none\" !== overflowMode) && displayMode !== ROTATE && overlappingMode !== ROTATE && \"auto\" !== overlappingMode) {\n      var usefulSpace = isDefined(options.placeholderSize) ? options.placeholderSize - options.label.indentFromAxis : void 0;\n\n      if (this._isHorizontal) {\n        textWidth = convertedTickInterval;\n        textHeight = usefulSpace;\n      } else {\n        textWidth = usefulSpace;\n        textHeight = convertedTickInterval;\n      }\n\n      var correctByWidth = false;\n      var correctByHeight = false;\n\n      if (textWidth) {\n        if (this._majorTicks.some(function (tick) {\n          return tick.labelBBox.width > textWidth;\n        })) {\n          correctByWidth = true;\n        }\n      }\n\n      if (textHeight) {\n        if (this._majorTicks.some(function (tick) {\n          return tick.labelBBox.height > textHeight;\n        })) {\n          correctByHeight = true;\n        }\n      }\n\n      if (correctByWidth || correctByHeight) {\n        this._majorTicks.forEach(function (tick) {\n          tick.label && tick.label.setMaxSize(textWidth, textHeight, options.label);\n        });\n\n        measureLabels(this._majorTicks);\n      }\n    }\n  },\n  _measureTitle: _noop,\n  animate: function animate() {\n    callAction(this._majorTicks, \"animateLabels\");\n  },\n  updateSize: function updateSize(canvas, animate) {\n    var updateTitle = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : true;\n    this.updateCanvas(canvas);\n\n    if (updateTitle) {\n      this._checkTitleOverflow();\n\n      this._measureTitle();\n\n      this._updateTitleCoords();\n    }\n\n    this._reinitTranslator(this._getViewportRange());\n\n    this.applyMargins();\n    var animationEnabled = !this._firstDrawing && animate;\n    var options = this._options;\n    initTickCoords(this._majorTicks);\n    initTickCoords(this._minorTicks);\n    initTickCoords(this._boundaryTicks);\n\n    if (this._resetApplyingAnimation && !this._firstDrawing) {\n      this._resetStartCoordinates();\n    }\n\n    cleanUpInvalidTicks(this._majorTicks);\n    cleanUpInvalidTicks(this._minorTicks);\n    cleanUpInvalidTicks(this._boundaryTicks);\n\n    if (this._axisElement) {\n      this._updateAxisElementPosition();\n    }\n\n    updateTicksPosition(this._majorTicks, options.tick, animationEnabled);\n    updateTicksPosition(this._minorTicks, options.minorTick, animationEnabled);\n    updateTicksPosition(this._boundaryTicks, options.tick);\n    callAction(this._majorTicks, \"updateLabelPosition\", animationEnabled);\n\n    this._outsideConstantLines.concat(this._insideConstantLines || []).forEach(function (l) {\n      return l.updatePosition(animationEnabled);\n    });\n\n    callAction(this._strips, \"updatePosition\", animationEnabled);\n    updateGridsPosition(this._majorTicks, animationEnabled);\n    updateGridsPosition(this._minorTicks, animationEnabled);\n\n    if (animationEnabled) {\n      callAction(this._ticksToRemove || [], \"fadeOutElements\");\n    }\n\n    this.prepareAnimation();\n    this._ticksToRemove = null;\n\n    if (!this._translator.getBusinessRange().isEmpty()) {\n      this._firstDrawing = false;\n    }\n\n    this._resetApplyingAnimation = false;\n\n    this._updateLabelsPosition();\n  },\n  _updateLabelsPosition: _noop,\n  prepareAnimation: function prepareAnimation() {\n    var action = \"saveCoords\";\n    callAction(this._majorTicks, action);\n    callAction(this._minorTicks, action);\n    callAction(this._insideConstantLines, action);\n    callAction(this._outsideConstantLines, action);\n    callAction(this._strips, action);\n  },\n  _resetStartCoordinates: function _resetStartCoordinates() {\n    var action = \"resetCoordinates\";\n    callAction(this._majorTicks, action);\n    callAction(this._minorTicks, action);\n    callAction(this._insideConstantLines, action);\n    callAction(this._outsideConstantLines, action);\n    callAction(this._strips, action);\n  },\n  applyClipRects: function applyClipRects(elementsClipID, canvasClipID) {\n    this._axisGroup.attr({\n      \"clip-path\": canvasClipID\n    });\n\n    this._axisStripGroup.attr({\n      \"clip-path\": elementsClipID\n    });\n\n    this._axisElementsGroup.attr({\n      \"clip-path\": canvasClipID\n    });\n  },\n  _validateVisualRange: function _validateVisualRange(optionValue) {\n    var range = getVizRangeObject(optionValue);\n\n    if (void 0 !== range.startValue) {\n      range.startValue = this.validateUnit(range.startValue);\n    }\n\n    if (void 0 !== range.endValue) {\n      range.endValue = this.validateUnit(range.endValue);\n    }\n\n    return convertVisualRangeObject(range, !_isArray(optionValue));\n  },\n  _validateOptions: function _validateOptions(options) {\n    options.wholeRange = this._validateVisualRange(options.wholeRange);\n    options.visualRange = options._customVisualRange = this._validateVisualRange(options._customVisualRange);\n\n    this._setVisualRange(options._customVisualRange);\n  },\n  validate: function validate() {\n    var options = this._options;\n    var dataType = this.isArgumentAxis ? options.argumentType : options.valueType;\n    var parser = dataType ? getParser(dataType) : function (unit) {\n      return unit;\n    };\n    this.parser = parser;\n    options.dataType = dataType;\n\n    this._validateOptions(options);\n  },\n  resetVisualRange: function resetVisualRange(isSilent) {\n    this._seriesData.minVisible = this._seriesData.min;\n    this._seriesData.maxVisible = this._seriesData.max;\n    this.handleZooming([null, null], {\n      start: !!isSilent,\n      end: !!isSilent\n    });\n  },\n  _setVisualRange: function _setVisualRange(visualRange, allowPartialUpdate) {\n    var range = this.adjustRange(getVizRangeObject(visualRange));\n\n    if (allowPartialUpdate) {\n      isDefined(range.startValue) && (this._viewport.startValue = range.startValue);\n      isDefined(range.endValue) && (this._viewport.endValue = range.endValue);\n    } else {\n      this._viewport = range;\n    }\n  },\n  _applyZooming: function _applyZooming(visualRange, allowPartialUpdate) {\n    this._resetVisualRangeOption();\n\n    this._setVisualRange(visualRange, allowPartialUpdate);\n\n    var viewPort = this.getViewport();\n    this._seriesData.userBreaks = this._getScaleBreaks(this._options, {\n      minVisible: viewPort.startValue,\n      maxVisible: viewPort.endValue\n    }, this._series, this.isArgumentAxis);\n\n    this._translator.updateBusinessRange(this._getViewportRange());\n  },\n  getZoomStartEventArg: function getZoomStartEventArg(event, actionType) {\n    return {\n      axis: this,\n      range: this.visualRange(),\n      cancel: false,\n      event: event,\n      actionType: actionType\n    };\n  },\n  _getZoomEndEventArg: function _getZoomEndEventArg(previousRange, event, actionType, zoomFactor, shift) {\n    var newRange = this.visualRange();\n    return {\n      axis: this,\n      previousRange: previousRange,\n      range: newRange,\n      cancel: false,\n      event: event,\n      actionType: actionType,\n      zoomFactor: zoomFactor,\n      shift: shift,\n      rangeStart: newRange.startValue,\n      rangeEnd: newRange.endValue\n    };\n  },\n  getZoomBounds: function getZoomBounds() {\n    var wholeRange = getVizRangeObject(this._options.wholeRange);\n    var range = this.getTranslator().getBusinessRange();\n    var secondPriorityRange = {\n      startValue: getZoomBoundValue(this._initRange.startValue, range.min),\n      endValue: getZoomBoundValue(this._initRange.endValue, range.max)\n    };\n    return {\n      startValue: getZoomBoundValue(wholeRange.startValue, secondPriorityRange.startValue),\n      endValue: getZoomBoundValue(wholeRange.endValue, secondPriorityRange.endValue)\n    };\n  },\n  setInitRange: function setInitRange() {\n    this._initRange = {};\n\n    if (0 === Object.keys(this._options.wholeRange || {}).length) {\n      this._initRange = this.getZoomBounds();\n    }\n  },\n  _resetVisualRangeOption: function _resetVisualRangeOption() {\n    this._options._customVisualRange = {};\n  },\n  getTemplatesGroups: function getTemplatesGroups() {\n    var ticks = this._majorTicks;\n\n    if (ticks) {\n      return this._majorTicks.map(function (tick) {\n        return tick.templateContainer;\n      }).filter(function (item) {\n        return isDefined(item);\n      });\n    } else {\n      return [];\n    }\n  },\n  setCustomVisualRange: function setCustomVisualRange(range) {\n    this._options._customVisualRange = range;\n  },\n  visualRange: function visualRange() {\n    var args = arguments;\n    var visualRange;\n\n    if (0 === args.length) {\n      var adjustedRange = this._getAdjustedBusinessRange();\n\n      var startValue = adjustedRange.minVisible;\n      var endValue = adjustedRange.maxVisible;\n\n      if (this._options.type === constants.discrete) {\n        var _startValue, _endValue;\n\n        startValue = null !== (_startValue = startValue) && void 0 !== _startValue ? _startValue : adjustedRange.categories[0];\n        endValue = null !== (_endValue = endValue) && void 0 !== _endValue ? _endValue : adjustedRange.categories[adjustedRange.categories.length - 1];\n        return {\n          startValue: startValue,\n          endValue: endValue,\n          categories: getCategoriesInfo(adjustedRange.categories, startValue, endValue).categories\n        };\n      }\n\n      return {\n        startValue: startValue,\n        endValue: endValue\n      };\n    } else if (_isArray(args[0])) {\n      visualRange = args[0];\n    } else if (isPlainObject(args[0])) {\n      visualRange = extend({}, args[0]);\n    } else {\n      visualRange = [args[0], args[1]];\n    }\n\n    var zoomResults = this.handleZooming(visualRange, args[1]);\n\n    if (!zoomResults.isPrevented) {\n      this._visualRange(this, zoomResults);\n    }\n  },\n  handleZooming: function handleZooming(visualRange, preventEvents, domEvent, action) {\n    preventEvents = preventEvents || {};\n\n    if (isDefined(visualRange)) {\n      visualRange = this._validateVisualRange(visualRange);\n      visualRange.action = action;\n    }\n\n    var zoomStartEvent = this.getZoomStartEventArg(domEvent, action);\n    var previousRange = zoomStartEvent.range;\n    !preventEvents.start && this._eventTrigger(\"zoomStart\", zoomStartEvent);\n    var zoomResults = {\n      isPrevented: zoomStartEvent.cancel,\n      skipEventRising: preventEvents.skipEventRising,\n      range: visualRange || zoomStartEvent.range\n    };\n\n    if (!zoomStartEvent.cancel) {\n      isDefined(visualRange) && this._applyZooming(visualRange, preventEvents.allowPartialUpdate);\n\n      if (!isDefined(this._storedZoomEndParams)) {\n        this._storedZoomEndParams = {\n          startRange: previousRange,\n          type: this.getOptions().type\n        };\n      }\n\n      this._storedZoomEndParams.event = domEvent;\n      this._storedZoomEndParams.action = action;\n      this._storedZoomEndParams.prevent = !!preventEvents.end;\n    }\n\n    return zoomResults;\n  },\n  handleZoomEnd: function handleZoomEnd() {\n    if (isDefined(this._storedZoomEndParams) && !this._storedZoomEndParams.prevent) {\n      var previousRange = this._storedZoomEndParams.startRange;\n      var domEvent = this._storedZoomEndParams.event;\n      var action = this._storedZoomEndParams.action;\n      var previousBusinessRange = {\n        minVisible: previousRange.startValue,\n        maxVisible: previousRange.endValue,\n        categories: previousRange.categories\n      };\n\n      var typeIsNotChanged = this.getOptions().type === this._storedZoomEndParams.type;\n\n      var shift = typeIsNotChanged ? adjust(this.getVisualRangeCenter() - this.getVisualRangeCenter(previousBusinessRange, false)) : NaN;\n      var zoomFactor = typeIsNotChanged ? +(Math.round(this.getVisualRangeLength(previousBusinessRange) / (this.getVisualRangeLength() || 1) + \"e+2\") + \"e-2\") : NaN;\n\n      var zoomEndEvent = this._getZoomEndEventArg(previousRange, domEvent, action, zoomFactor, shift);\n\n      zoomEndEvent.cancel = this.checkZoomingLowerLimitOvercome(1 === zoomFactor ? \"pan\" : \"zoom\", zoomFactor).stopInteraction;\n\n      this._eventTrigger(\"zoomEnd\", zoomEndEvent);\n\n      if (zoomEndEvent.cancel) {\n        this._restorePreviousVisualRange(previousRange);\n      }\n\n      this._storedZoomEndParams = null;\n    }\n  },\n  _restorePreviousVisualRange: function _restorePreviousVisualRange(previousRange) {\n    this._storedZoomEndParams = null;\n\n    this._applyZooming(previousRange);\n\n    this._visualRange(this, previousRange);\n  },\n  checkZoomingLowerLimitOvercome: function checkZoomingLowerLimitOvercome(actionType, zoomFactor, range) {\n    var options = this._options;\n    var translator = this._translator;\n    var minZoom = options.minVisualRangeLength;\n    var correctedRange = range;\n    var visualRange;\n    var isOvercoming = \"zoom\" === actionType && zoomFactor >= 1;\n    var businessRange = translator.getBusinessRange();\n\n    if (range) {\n      visualRange = this.adjustRange(getVizRangeObject(range));\n      visualRange = {\n        minVisible: visualRange.startValue,\n        maxVisible: visualRange.endValue,\n        categories: businessRange.categories\n      };\n    }\n\n    var beforeVisualRangeLength = this.getVisualRangeLength(businessRange);\n    var afterVisualRangeLength = this.getVisualRangeLength(visualRange);\n\n    if (isDefined(minZoom) || \"discrete\" === options.type) {\n      minZoom = translator.convert(minZoom);\n\n      if (visualRange && minZoom < beforeVisualRangeLength && minZoom >= afterVisualRangeLength) {\n        correctedRange = getVizRangeObject(translator.getRangeByMinZoomValue(minZoom, visualRange));\n        isOvercoming = false;\n      } else {\n        isOvercoming &= minZoom > afterVisualRangeLength;\n      }\n    } else {\n      var canvasLength = this._translator.canvasLength;\n      var fullRange = {\n        minVisible: businessRange.min,\n        maxVisible: businessRange.max,\n        categories: businessRange.categories\n      };\n      isOvercoming &= this.getVisualRangeLength(fullRange) / canvasLength >= afterVisualRangeLength;\n    }\n\n    return {\n      stopInteraction: !!isOvercoming,\n      correctedRange: correctedRange\n    };\n  },\n  isExtremePosition: function isExtremePosition(isMax) {\n    var extremeDataValue;\n    var seriesData;\n\n    if (\"discrete\" === this._options.type) {\n      seriesData = this._translator.getBusinessRange();\n      extremeDataValue = isMax ? seriesData.categories[seriesData.categories.length - 1] : seriesData.categories[0];\n    } else {\n      seriesData = this.getZoomBounds();\n      extremeDataValue = isMax ? seriesData.endValue : seriesData.startValue;\n    }\n\n    var translator = this.getTranslator();\n    var extremePoint = translator.translate(extremeDataValue);\n    var visualRange = this.visualRange();\n    var visualRangePoint = isMax ? translator.translate(visualRange.endValue) : translator.translate(visualRange.startValue);\n    return _abs(visualRangePoint - extremePoint) < SCROLL_THRESHOLD;\n  },\n  getViewport: function getViewport() {\n    return this._viewport;\n  },\n  getFullTicks: function getFullTicks() {\n    var majors = this._majorTicks || [];\n\n    if (this._options.type === constants.discrete) {\n      return convertTicksToValues(majors);\n    } else {\n      return convertTicksToValues(majors.concat(this._minorTicks, this._boundaryTicks)).sort(function (a, b) {\n        return valueOf(a) - valueOf(b);\n      });\n    }\n  },\n  measureLabels: function measureLabels(canvas, withIndents) {\n    var that = this;\n    var options = that._options;\n    var widthAxis = options.visible ? options.width : 0;\n    var ticks;\n    var indent = withIndents ? options.label.indentFromAxis + .5 * options.tick.length : 0;\n    var tickInterval;\n\n    var viewportRange = that._getViewportRange();\n\n    if (viewportRange.isEmpty() || !options.label.visible || !that._axisElementsGroup) {\n      return {\n        height: widthAxis,\n        width: widthAxis,\n        x: 0,\n        y: 0\n      };\n    }\n\n    if (that._majorTicks) {\n      ticks = convertTicksToValues(that._majorTicks);\n    } else {\n      that.updateCanvas(canvas);\n      ticks = that._createTicksAndLabelFormat(viewportRange, _noop);\n      tickInterval = ticks.tickInterval;\n      ticks = ticks.ticks;\n    }\n\n    var maxText = ticks.reduce(function (prevLabel, tick, index) {\n      var label = that.formatLabel(tick, options.label, viewportRange, void 0, tickInterval, ticks);\n\n      if (prevLabel.length < label.length) {\n        return label;\n      } else {\n        return prevLabel;\n      }\n    }, that.formatLabel(ticks[0], options.label, viewportRange, void 0, tickInterval, ticks));\n\n    var text = that._renderer.text(maxText, 0, 0).css(that._textFontStyles).attr(that._textOptions).append(that._renderer.root);\n\n    var box = text.getBBox();\n    text.remove();\n    return {\n      x: box.x,\n      y: box.y,\n      width: box.width + indent,\n      height: box.height + indent\n    };\n  },\n  _setLabelsPlacement: function _setLabelsPlacement() {\n    if (!this._options.label.visible) {\n      return;\n    }\n\n    var labelOpt = this._options.label;\n\n    var displayMode = this._validateDisplayMode(labelOpt.displayMode);\n\n    var overlappingMode = this._validateOverlappingMode(labelOpt.overlappingBehavior, displayMode);\n\n    var ignoreOverlapping = \"none\" === overlappingMode || \"ignore\" === overlappingMode;\n    var behavior = {\n      rotationAngle: labelOpt.rotationAngle,\n      staggeringSpacing: labelOpt.staggeringSpacing\n    };\n    var notRecastStep;\n\n    var boxes = this._majorTicks.map(function (tick) {\n      return tick.labelBBox;\n    });\n\n    var step = this._getStep(boxes);\n\n    switch (displayMode) {\n      case ROTATE:\n        if (ignoreOverlapping) {\n          notRecastStep = true;\n          step = 1;\n        }\n\n        this._applyLabelMode(displayMode, step, boxes, labelOpt, notRecastStep);\n\n        break;\n\n      case \"stagger\":\n        if (ignoreOverlapping) {\n          step = 2;\n        }\n\n        this._applyLabelMode(displayMode, _max(step, 2), boxes, labelOpt);\n\n        break;\n\n      default:\n        this._applyLabelOverlapping(boxes, overlappingMode, step, behavior);\n\n    }\n  },\n  _applyLabelOverlapping: function _applyLabelOverlapping(boxes, mode, step, behavior) {\n    var labelOpt = this._options.label;\n    var majorTicks = this._majorTicks;\n\n    if (\"none\" === mode || \"ignore\" === mode) {\n      return;\n    }\n\n    if (step > 1 && boxes.some(function (box, index, array) {\n      if (0 === index) {\n        return false;\n      }\n\n      return constants.areLabelsOverlap(box, array[index - 1], labelOpt.minSpacing, labelOpt.alignment);\n    })) {\n      this._applyLabelMode(mode, step, boxes, behavior);\n    }\n\n    this._checkBoundedLabelsOverlapping(majorTicks, boxes, mode);\n\n    this._checkShiftedLabels(majorTicks, boxes, labelOpt.minSpacing, labelOpt.alignment);\n  },\n  _applyLabelMode: function _applyLabelMode(mode, step, boxes, behavior, notRecastStep) {\n    var majorTicks = this._majorTicks;\n    var labelOpt = this._options.label;\n    var angle = behavior.rotationAngle;\n    var labelHeight;\n    var alignment;\n    var func;\n\n    switch (mode) {\n      case ROTATE:\n        if (!labelOpt.userAlignment) {\n          alignment = angle < 0 ? RIGHT : LEFT;\n\n          if (angle % 90 === 0) {\n            alignment = CENTER;\n          }\n        }\n\n        step = notRecastStep ? step : this._getStep(boxes, angle);\n\n        func = function func(tick) {\n          var contentContainer = tick.getContentContainer();\n\n          if (!contentContainer) {\n            return;\n          }\n\n          contentContainer.rotate(angle);\n          tick.labelRotationAngle = angle;\n          alignment && (tick.labelAlignment = alignment);\n        };\n\n        updateLabels(majorTicks, step, func);\n        break;\n\n      case \"stagger\":\n        labelHeight = this._getMaxLabelHeight(boxes, behavior.staggeringSpacing);\n\n        func = function func(tick, index) {\n          if (index / (step - 1) % 2 !== 0) {\n            tick.labelOffset = labelHeight;\n          }\n        };\n\n        updateLabels(majorTicks, step - 1, func);\n        break;\n\n      case \"auto\":\n      case \"_auto\":\n        if (2 === step) {\n          this._applyLabelMode(\"stagger\", step, boxes, behavior);\n        } else {\n          this._applyLabelMode(ROTATE, step, boxes, {\n            rotationAngle: getOptimalAngle(boxes, labelOpt)\n          });\n        }\n\n        break;\n\n      default:\n        updateLabels(majorTicks, step);\n    }\n  },\n  getMarkerTrackers: _noop,\n  _drawDateMarkers: _noop,\n  _adjustDateMarkers: _noop,\n  coordsIn: _noop,\n  areCoordsOutsideAxis: _noop,\n  _getSkippedCategory: _noop,\n  _initAxisPositions: _noop,\n  _drawTitle: _noop,\n  _updateTitleCoords: _noop,\n  _adjustConstantLineLabels: _noop,\n  _createTranslator: function _createTranslator() {\n    return new Translator2D({}, {}, {});\n  },\n  _updateTranslator: function _updateTranslator() {\n    var translator = this._translator;\n    translator.update(translator.getBusinessRange(), this._canvas || {}, this._getTranslatorOptions());\n  },\n  _getTranslatorOptions: function _getTranslatorOptions() {\n    var _options$workWeek2, _options$breakStyle$w, _options$breakStyle;\n\n    var options = this._options;\n    return {\n      isHorizontal: this._isHorizontal,\n      shiftZeroValue: !this.isArgumentAxis,\n      interval: options.semiDiscreteInterval,\n      firstDayOfWeek: null === (_options$workWeek2 = options.workWeek) || void 0 === _options$workWeek2 ? void 0 : _options$workWeek2[0],\n      stick: this._getStick(),\n      breaksSize: null !== (_options$breakStyle$w = null === (_options$breakStyle = options.breakStyle) || void 0 === _options$breakStyle ? void 0 : _options$breakStyle.width) && void 0 !== _options$breakStyle$w ? _options$breakStyle$w : 0\n    };\n  },\n  getVisibleArea: function getVisibleArea() {\n    var canvas = this._getCanvasStartEnd();\n\n    return [canvas.start, canvas.end].sort(function (a, b) {\n      return a - b;\n    });\n  },\n  _getCanvasStartEnd: function _getCanvasStartEnd() {\n    var isHorizontal = this._isHorizontal;\n    var canvas = this._canvas || {};\n\n    var invert = this._translator.getBusinessRange().invert;\n\n    var coords = isHorizontal ? [canvas.left, canvas.width - canvas.right] : [canvas.height - canvas.bottom, canvas.top];\n    invert && coords.reverse();\n    return {\n      start: coords[0],\n      end: coords[1]\n    };\n  },\n  _getScreenDelta: function _getScreenDelta() {\n    var canvas = this._getCanvasStartEnd();\n\n    var breaks = this._seriesData ? this._seriesData.breaks || [] : [];\n    var breaksLength = breaks.length;\n\n    var screenDelta = _abs(canvas.start - canvas.end);\n\n    return screenDelta - (breaksLength ? breaks[breaksLength - 1].cumulativeWidth : 0);\n  },\n  _getScaleBreaks: function _getScaleBreaks() {\n    return [];\n  },\n  _filterBreaks: function _filterBreaks() {\n    return [];\n  },\n  _adjustTitle: _noop,\n  _checkTitleOverflow: _noop,\n  getSpiderTicks: _noop,\n  setSpiderTicks: _noop,\n  _checkBoundedLabelsOverlapping: _noop,\n  _checkShiftedLabels: _noop,\n  drawScaleBreaks: _noop,\n  _visualRange: _noop,\n  _rotateConstantLine: _noop,\n  applyVisualRangeSetter: function applyVisualRangeSetter(visualRangeSetter) {\n    this._visualRange = visualRangeSetter;\n  },\n  getCategoriesSorter: function getCategoriesSorter(argCategories) {\n    var sort;\n\n    if (this.isArgumentAxis) {\n      sort = argCategories;\n    } else {\n      var categoriesSortingMethod = this._options.categoriesSortingMethod;\n      sort = null !== categoriesSortingMethod && void 0 !== categoriesSortingMethod ? categoriesSortingMethod : this._options.categories;\n    }\n\n    return sort;\n  },\n  _getAdjustedBusinessRange: function _getAdjustedBusinessRange() {\n    return this.adjustViewport(this._translator.getBusinessRange());\n  }\n};","map":null,"metadata":{},"sourceType":"module"}