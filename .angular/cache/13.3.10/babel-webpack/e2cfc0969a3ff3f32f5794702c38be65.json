{"ast":null,"code":"import _classCallCheck from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\n\n/**\r\n * DevExtreme (esm/ui/drawer/ui.drawer.rendering.strategy.overlap.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { getWidth } from \"../../core/utils/size\";\nimport { animation } from \"./ui.drawer.animation\";\nimport DrawerStrategy from \"./ui.drawer.rendering.strategy\";\nimport $ from \"../../core/renderer\";\nimport { move } from \"../../animation/translator\";\nimport Overlay from \"../overlay/ui.overlay\";\nimport { ensureDefined } from \"../../core/utils/common\";\nimport { camelize } from \"../../core/utils/inflector\";\n\nvar OverlapStrategy = /*#__PURE__*/function (_DrawerStrategy) {\n  _inherits(OverlapStrategy, _DrawerStrategy);\n\n  var _super = _createSuper(OverlapStrategy);\n\n  function OverlapStrategy() {\n    _classCallCheck(this, OverlapStrategy);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(OverlapStrategy, [{\n    key: \"renderPanelContent\",\n    value: function renderPanelContent(whenPanelContentRendered) {\n      var _this = this;\n\n      delete this._initialPosition;\n      var drawer = this.getDrawerInstance();\n\n      var _drawer$option = drawer.option(),\n          opened = _drawer$option.opened,\n          minSize = _drawer$option.minSize;\n\n      drawer._overlay = drawer._createComponent(drawer.content(), Overlay, {\n        shading: false,\n        container: drawer.getOverlayTarget(),\n        position: this._getOverlayPosition(),\n        width: opened ? \"auto\" : minSize || 0,\n        height: \"100%\",\n        templatesRenderAsynchronously: drawer.option(\"templatesRenderAsynchronously\"),\n        animation: {\n          show: {\n            duration: 0\n          }\n        },\n        onPositioned: function (e) {\n          this._fixOverlayPosition(e.component.$content());\n        }.bind(this),\n        contentTemplate: drawer.option(\"template\"),\n        onContentReady: function onContentReady(args) {\n          whenPanelContentRendered.resolve();\n\n          _this._processOverlayZIndex(args.component.content());\n        },\n        visible: true,\n        propagateOutsideClick: true,\n        useResizeObserver: false\n      });\n    }\n  }, {\n    key: \"_fixOverlayPosition\",\n    value: function _fixOverlayPosition($overlayContent) {\n      var position = ensureDefined(this._initialPosition, {\n        left: 0,\n        top: 0\n      });\n      move($overlayContent, position);\n\n      if (\"right\" === this.getDrawerInstance().calcTargetPosition()) {\n        $overlayContent.css(\"left\", \"auto\");\n      }\n\n      if (\"bottom\" === this.getDrawerInstance().calcTargetPosition()) {\n        $overlayContent.css(\"top\", \"auto\");\n        $overlayContent.css(\"bottom\", \"0px\");\n      }\n    }\n  }, {\n    key: \"_getOverlayPosition\",\n    value: function _getOverlayPosition() {\n      var drawer = this.getDrawerInstance();\n      var panelPosition = drawer.calcTargetPosition();\n      var result = {};\n\n      switch (panelPosition) {\n        case \"left\":\n          result = {\n            my: \"top left\",\n            at: \"top left\"\n          };\n          break;\n\n        case \"right\":\n          result = {\n            my: drawer.option(\"rtlEnabled\") ? \"top left\" : \"top right\",\n            at: \"top right\"\n          };\n          break;\n\n        case \"top\":\n        case \"bottom\":\n          result = {\n            my: panelPosition,\n            at: panelPosition\n          };\n      }\n\n      result.of = drawer.getOverlayTarget();\n      return result;\n    }\n  }, {\n    key: \"refreshPanelElementSize\",\n    value: function refreshPanelElementSize(calcFromRealPanelSize) {\n      var drawer = this.getDrawerInstance();\n      var overlay = drawer.getOverlay();\n\n      if (drawer.isHorizontalDirection()) {\n        overlay.option(\"height\", \"100%\");\n        overlay.option(\"width\", calcFromRealPanelSize ? drawer.getRealPanelWidth() : this._getPanelSize(drawer.option(\"opened\")));\n      } else {\n        overlay.option(\"width\", getWidth(overlay.option(\"container\")));\n        overlay.option(\"height\", calcFromRealPanelSize ? drawer.getRealPanelHeight() : this._getPanelSize(drawer.option(\"opened\")));\n      }\n    }\n  }, {\n    key: \"onPanelContentRendered\",\n    value: function onPanelContentRendered() {\n      this._updateViewContentStyles();\n    }\n  }, {\n    key: \"_updateViewContentStyles\",\n    value: function _updateViewContentStyles() {\n      var drawer = this.getDrawerInstance();\n      $(drawer.viewContent()).css(\"padding\" + camelize(drawer.calcTargetPosition(), true), drawer.option(\"minSize\"));\n      $(drawer.viewContent()).css(\"transform\", \"inherit\");\n    }\n  }, {\n    key: \"_internalRenderPosition\",\n    value: function _internalRenderPosition(changePositionUsingFxAnimation, whenAnimationCompleted) {\n      var drawer = this.getDrawerInstance();\n      var $panel = $(drawer.content());\n      var $panelOverlayContent = drawer.getOverlay().$content();\n      var revealMode = drawer.option(\"revealMode\");\n      var targetPanelPosition = drawer.calcTargetPosition();\n\n      var panelSize = this._getPanelSize(drawer.option(\"opened\"));\n\n      var panelOffset = this._getPanelOffset(drawer.option(\"opened\")) * drawer._getPositionCorrection();\n\n      var marginTop = drawer.getRealPanelHeight() - panelSize;\n\n      this._updateViewContentStyles();\n\n      if (changePositionUsingFxAnimation) {\n        if (\"slide\" === revealMode) {\n          this._initialPosition = drawer.isHorizontalDirection() ? {\n            left: panelOffset\n          } : {\n            top: panelOffset\n          };\n          animation.moveTo({\n            complete: function complete() {\n              whenAnimationCompleted.resolve();\n            },\n            duration: drawer.option(\"animationDuration\"),\n            direction: targetPanelPosition,\n            $element: $panel,\n            position: panelOffset\n          });\n        } else if (\"expand\" === revealMode) {\n          this._initialPosition = {\n            left: 0\n          };\n          move($panelOverlayContent, this._initialPosition);\n          animation.size({\n            complete: function complete() {\n              whenAnimationCompleted.resolve();\n            },\n            duration: drawer.option(\"animationDuration\"),\n            direction: targetPanelPosition,\n            $element: $panelOverlayContent,\n            size: panelSize,\n            marginTop: marginTop\n          });\n        }\n      } else if (\"slide\" === revealMode) {\n        this._initialPosition = drawer.isHorizontalDirection() ? {\n          left: panelOffset\n        } : {\n          top: panelOffset\n        };\n        move($panel, this._initialPosition);\n      } else if (\"expand\" === revealMode) {\n        this._initialPosition = {\n          left: 0\n        };\n        move($panelOverlayContent, this._initialPosition);\n\n        if (drawer.isHorizontalDirection()) {\n          $($panelOverlayContent).css(\"width\", panelSize);\n        } else {\n          $($panelOverlayContent).css(\"height\", panelSize);\n\n          if (\"bottom\" === targetPanelPosition) {\n            $($panelOverlayContent).css(\"marginTop\", marginTop);\n          }\n        }\n      }\n    }\n  }, {\n    key: \"getPanelContent\",\n    value: function getPanelContent() {\n      return $(this.getDrawerInstance().getOverlay().content());\n    }\n  }, {\n    key: \"_processOverlayZIndex\",\n    value: function _processOverlayZIndex($element) {\n      var styles = $($element).get(0).style;\n      var zIndex = styles.zIndex || 1;\n      this.getDrawerInstance().setZIndex(zIndex);\n    }\n  }, {\n    key: \"isViewContentFirst\",\n    value: function isViewContentFirst(position) {\n      return \"right\" === position || \"bottom\" === position;\n    }\n  }]);\n\n  return OverlapStrategy;\n}(DrawerStrategy);\n\nexport default OverlapStrategy;","map":null,"metadata":{},"sourceType":"module"}