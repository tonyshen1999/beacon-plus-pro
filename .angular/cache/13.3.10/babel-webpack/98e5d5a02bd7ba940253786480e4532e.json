{"ast":null,"code":"/**\r\n * DevExtreme (esm/viz/chart_components/layout_manager.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { isNumeric as _isNumber } from \"../../core/utils/type\";\nimport consts from \"../components/consts\";\nimport { WrapperLayoutElement } from \"../core/layout_element\";\nvar floor = Math.floor,\n    sqrt = Math.sqrt;\nvar _min = Math.min;\nvar _max = Math.max;\nvar DEFAULT_INNER_RADIUS = .5;\nvar RADIAL_LABEL_INDENT = consts.radialLabelIndent;\n\nfunction getNearestCoord(firstCoord, secondCoord, pointCenterCoord) {\n  var nearestCoord;\n\n  if (pointCenterCoord < firstCoord) {\n    nearestCoord = firstCoord;\n  } else if (secondCoord < pointCenterCoord) {\n    nearestCoord = secondCoord;\n  } else {\n    nearestCoord = pointCenterCoord;\n  }\n\n  return nearestCoord;\n}\n\nfunction getLabelLayout(point) {\n  if (point._label.isVisible() && \"inside\" !== point._label.getLayoutOptions().position) {\n    return point._label.getBoundingRect();\n  }\n}\n\nfunction getPieRadius(series, paneCenterX, paneCenterY, accessibleRadius, minR) {\n  series.some(function (singleSeries) {\n    return singleSeries.getVisiblePoints().reduce(function (radiusIsFound, point) {\n      var labelBBox = getLabelLayout(point);\n\n      if (labelBBox) {\n        var xCoords = getNearestCoord(labelBBox.x, labelBBox.x + labelBBox.width, paneCenterX);\n        var yCoords = getNearestCoord(labelBBox.y, labelBBox.y + labelBBox.height, paneCenterY);\n        accessibleRadius = _min(_max(getLengthFromCenter(xCoords, yCoords, paneCenterX, paneCenterY) - RADIAL_LABEL_INDENT, minR), accessibleRadius);\n        radiusIsFound = true;\n      }\n\n      return radiusIsFound;\n    }, false);\n  });\n  return accessibleRadius;\n}\n\nfunction getSizeLabels(series) {\n  return series.reduce(function (res, singleSeries) {\n    var maxWidth = singleSeries.getVisiblePoints().reduce(function (width, point) {\n      var labelBBox = getLabelLayout(point);\n\n      if (labelBBox && labelBBox.width > width) {\n        width = labelBBox.width;\n      }\n\n      return width;\n    }, 0);\n    var rWidth = maxWidth;\n\n    if (maxWidth) {\n      res.outerLabelsCount++;\n\n      if (res.outerLabelsCount > 1) {\n        maxWidth += consts.pieLabelSpacing;\n      }\n\n      rWidth += consts.pieLabelSpacing;\n    }\n\n    res.sizes.push(maxWidth);\n    res.rSizes.push(rWidth);\n    res.common += maxWidth;\n    return res;\n  }, {\n    sizes: [],\n    rSizes: [],\n    common: 0,\n    outerLabelsCount: 0\n  });\n}\n\nfunction correctLabelRadius(labelSizes, radius, series, canvas, averageWidthLabels, centerX) {\n  var curRadius;\n  var i;\n  var runningWidth = 0;\n  var sizes = labelSizes.sizes;\n  var rSizes = labelSizes.rSizes;\n\n  for (i = 0; i < series.length; i++) {\n    if (0 === sizes[i]) {\n      curRadius && (curRadius += rSizes[i - 1]);\n      continue;\n    }\n\n    curRadius = floor(curRadius ? curRadius + rSizes[i - 1] : radius);\n    series[i].correctLabelRadius(curRadius);\n    runningWidth += averageWidthLabels || sizes[i];\n    rSizes[i] = averageWidthLabels || rSizes[i];\n    series[i].setVisibleArea({\n      left: floor(centerX - radius - runningWidth),\n      right: floor(canvas.width - (centerX + radius + runningWidth)),\n      top: canvas.top,\n      bottom: canvas.bottom,\n      width: canvas.width,\n      height: canvas.height\n    });\n  }\n}\n\nfunction getLengthFromCenter(x, y, paneCenterX, paneCenterY) {\n  return sqrt((x - paneCenterX) * (x - paneCenterX) + (y - paneCenterY) * (y - paneCenterY));\n}\n\nfunction getInnerRadius(_ref) {\n  var type = _ref.type,\n      innerRadius = _ref.innerRadius;\n  return \"pie\" === type ? 0 : _isNumber(innerRadius) ? Number(innerRadius) : DEFAULT_INNER_RADIUS;\n}\n\nfunction LayoutManager() {}\n\nfunction getAverageLabelWidth(centerX, radius, canvas, sizeLabels) {\n  return (centerX - radius - RADIAL_LABEL_INDENT - canvas.left) / sizeLabels.outerLabelsCount;\n}\n\nfunction getFullRadiusWithLabels(centerX, canvas, sizeLabels) {\n  return centerX - canvas.left - (sizeLabels.outerLabelsCount > 0 ? sizeLabels.common + RADIAL_LABEL_INDENT : 0);\n}\n\nfunction correctAvailableRadius(availableRadius, canvas, series, minR, paneCenterX, paneCenterY) {\n  var sizeLabels = getSizeLabels(series);\n  var averageWidthLabels;\n  var fullRadiusWithLabels = getFullRadiusWithLabels(paneCenterX, canvas, sizeLabels);\n\n  if (fullRadiusWithLabels < minR) {\n    availableRadius = minR;\n    averageWidthLabels = getAverageLabelWidth(paneCenterX, availableRadius, canvas, sizeLabels);\n  } else {\n    availableRadius = _min(getPieRadius(series, paneCenterX, paneCenterY, availableRadius, minR), fullRadiusWithLabels);\n  }\n\n  correctLabelRadius(sizeLabels, availableRadius + RADIAL_LABEL_INDENT, series, canvas, averageWidthLabels, paneCenterX);\n  return availableRadius;\n}\n\nfunction toLayoutElementCoords(canvas) {\n  return new WrapperLayoutElement(null, {\n    x: canvas.left,\n    y: canvas.top,\n    width: canvas.width - canvas.left - canvas.right,\n    height: canvas.height - canvas.top - canvas.bottom\n  });\n}\n\nLayoutManager.prototype = {\n  constructor: LayoutManager,\n  setOptions: function setOptions(options) {\n    this._options = options;\n  },\n  applyPieChartSeriesLayout: function applyPieChartSeriesLayout(canvas, series, hideLayoutLabels) {\n    var paneSpaceHeight = canvas.height - canvas.top - canvas.bottom;\n    var paneSpaceWidth = canvas.width - canvas.left - canvas.right;\n    var paneCenterX = paneSpaceWidth / 2 + canvas.left;\n    var paneCenterY = paneSpaceHeight / 2 + canvas.top;\n    var piePercentage = this._options.piePercentage;\n    var availableRadius;\n    var minR;\n\n    if (_isNumber(piePercentage)) {\n      availableRadius = minR = piePercentage * _min(canvas.height, canvas.width) / 2;\n    } else {\n      availableRadius = _min(paneSpaceWidth, paneSpaceHeight) / 2;\n      minR = this._options.minPiePercentage * availableRadius;\n    }\n\n    if (!hideLayoutLabels) {\n      availableRadius = correctAvailableRadius(availableRadius, canvas, series, minR, paneCenterX, paneCenterY);\n    }\n\n    return {\n      centerX: floor(paneCenterX),\n      centerY: floor(paneCenterY),\n      radiusInner: floor(availableRadius * getInnerRadius(series[0])),\n      radiusOuter: floor(availableRadius)\n    };\n  },\n  applyEqualPieChartLayout: function applyEqualPieChartLayout(series, layout) {\n    var radius = layout.radius;\n    return {\n      centerX: floor(layout.x),\n      centerY: floor(layout.y),\n      radiusInner: floor(radius * getInnerRadius(series[0])),\n      radiusOuter: floor(radius)\n    };\n  },\n  correctPieLabelRadius: function correctPieLabelRadius(series, layout, canvas) {\n    var sizeLabels = getSizeLabels(series);\n    var averageWidthLabels;\n    var radius = layout.radiusOuter + RADIAL_LABEL_INDENT;\n    var availableLabelWidth = layout.centerX - canvas.left - radius;\n\n    if (sizeLabels.common + RADIAL_LABEL_INDENT > availableLabelWidth) {\n      averageWidthLabels = getAverageLabelWidth(layout.centerX, layout.radiusOuter, canvas, sizeLabels);\n    }\n\n    correctLabelRadius(sizeLabels, radius, series, canvas, averageWidthLabels, layout.centerX);\n  },\n  needMoreSpaceForPanesCanvas: function needMoreSpaceForPanesCanvas(panes, rotated, fixedSizeCallback) {\n    var options = this._options;\n    var width = options.width;\n    var height = options.height;\n    var piePercentage = options.piePercentage;\n\n    var percentageIsValid = _isNumber(piePercentage);\n\n    var needHorizontalSpace = 0;\n    var needVerticalSpace = 0;\n    panes.forEach(function (pane) {\n      var paneCanvas = pane.canvas;\n      var minSize = percentageIsValid ? _min(paneCanvas.width, paneCanvas.height) * piePercentage : void 0;\n      var paneSized = fixedSizeCallback ? fixedSizeCallback(pane) : {\n        width: false,\n        height: false\n      };\n      var needPaneHorizontalSpace = !paneSized.width ? (percentageIsValid ? minSize : width) - (paneCanvas.width - paneCanvas.left - paneCanvas.right) : 0;\n      var needPaneVerticalSpace = !paneSized.height ? (percentageIsValid ? minSize : height) - (paneCanvas.height - paneCanvas.top - paneCanvas.bottom) : 0;\n\n      if (rotated) {\n        needHorizontalSpace += needPaneHorizontalSpace > 0 ? needPaneHorizontalSpace : 0;\n        needVerticalSpace = _max(needPaneVerticalSpace > 0 ? needPaneVerticalSpace : 0, needVerticalSpace);\n      } else {\n        needHorizontalSpace = _max(needPaneHorizontalSpace > 0 ? needPaneHorizontalSpace : 0, needHorizontalSpace);\n        needVerticalSpace += needPaneVerticalSpace > 0 ? needPaneVerticalSpace : 0;\n      }\n    });\n    return needHorizontalSpace > 0 || needVerticalSpace > 0 ? {\n      width: needHorizontalSpace,\n      height: needVerticalSpace\n    } : false;\n  },\n  layoutInsideLegend: function layoutInsideLegend(legend, canvas) {\n    var layoutOptions = legend.getLayoutOptions();\n\n    if (!layoutOptions) {\n      return;\n    }\n\n    var position = layoutOptions.position;\n    var cutSide = layoutOptions.cutSide;\n    var my = {\n      horizontal: position.horizontal,\n      vertical: position.vertical\n    };\n    canvas[layoutOptions.cutLayoutSide] += \"horizontal\" === layoutOptions.cutSide ? layoutOptions.width : layoutOptions.height;\n    my[cutSide] = {\n      left: \"right\",\n      right: \"left\",\n      top: \"bottom\",\n      bottom: \"top\",\n      center: \"center\"\n    }[my[cutSide]];\n    legend.position({\n      of: toLayoutElementCoords(canvas),\n      my: my,\n      at: position\n    });\n  }\n};\nexport { LayoutManager };","map":null,"metadata":{},"sourceType":"module"}