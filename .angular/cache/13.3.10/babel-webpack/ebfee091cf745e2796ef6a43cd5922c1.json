{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/defer_rendering.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { TransitionExecutor } from \"../animation/transition_executor/transition_executor\";\nimport registerComponent from \"../core/component_registrator\";\nimport domAdapter from \"../core/dom_adapter\";\nimport $ from \"../core/renderer\";\nimport { noop, executeAsync } from \"../core/utils/common\";\nimport { Deferred, fromPromise } from \"../core/utils/deferred\";\nimport { extend } from \"../core/utils/extend\";\nimport { each } from \"../core/utils/iterator\";\nimport { isPromise } from \"../core/utils/type\";\nimport { getWindow, hasWindow } from \"../core/utils/window\";\nimport eventsEngine from \"../events/core/events_engine\";\nimport { triggerShownEvent } from \"../events/visibility_change\";\nimport LoadIndicator from \"./load_indicator\";\nimport Widget from \"./widget/ui.widget\";\nimport { getBoundingRect } from \"../core/utils/position\";\nvar window = getWindow();\nvar WIDGET_CLASS = \"dx-widget\";\nvar DEFER_RENDERING_CLASS = \"dx-deferrendering\";\nvar PENDING_RENDERING_CLASS = \"dx-pending-rendering\";\nvar PENDING_RENDERING_MANUAL_CLASS = \"dx-pending-rendering-manual\";\nvar PENDING_RENDERING_ACTIVE_CLASS = \"dx-pending-rendering-active\";\nvar VISIBLE_WHILE_PENDING_RENDERING_CLASS = \"dx-visible-while-pending-rendering\";\nvar INVISIBLE_WHILE_PENDING_RENDERING_CLASS = \"dx-invisible-while-pending-rendering\";\nvar LOADINDICATOR_CONTAINER_CLASS = \"dx-loadindicator-container\";\nvar DEFER_RENDERING_LOADINDICATOR_CONTAINER_CLASS = \"dx-deferrendering-loadindicator-container\";\nvar DEFER_DEFER_RENDERING_LOAD_INDICATOR = \"dx-deferrendering-load-indicator\";\nvar ANONYMOUS_TEMPLATE_NAME = \"content\";\nvar ACTIONS = [\"onRendered\", \"onShown\"];\nvar DeferRendering = Widget.inherit({\n  _getDefaultOptions: function _getDefaultOptions() {\n    return extend(this.callBase(), {\n      showLoadIndicator: false,\n      renderWhen: void 0,\n      animation: void 0,\n      staggerItemSelector: void 0,\n      onRendered: null,\n      onShown: null\n    });\n  },\n  _getAnonymousTemplateName: function _getAnonymousTemplateName() {\n    return ANONYMOUS_TEMPLATE_NAME;\n  },\n  _init: function _init() {\n    this.transitionExecutor = new TransitionExecutor();\n\n    this._initElement();\n\n    this._initRender();\n\n    this._$initialContent = this.$element().clone().contents();\n\n    this._initActions();\n\n    this.callBase();\n  },\n  _initElement: function _initElement() {\n    this.$element().addClass(DEFER_RENDERING_CLASS);\n  },\n  _initRender: function _initRender() {\n    var that = this;\n    var $element = this.$element();\n    var renderWhen = this.option(\"renderWhen\");\n\n    var doRender = function doRender() {\n      return that._renderDeferredContent();\n    };\n\n    if (isPromise(renderWhen)) {\n      fromPromise(renderWhen).done(doRender);\n    } else {\n      $element.data(\"dx-render-delegate\", doRender);\n\n      if (void 0 === renderWhen) {\n        $element.addClass(PENDING_RENDERING_MANUAL_CLASS);\n      }\n    }\n  },\n  _initActions: function _initActions() {\n    var _this = this;\n\n    this._actions = {};\n    each(ACTIONS, function (_, action) {\n      _this._actions[action] = _this._createActionByOption(action) || noop;\n    });\n  },\n  _initMarkup: function _initMarkup() {\n    this.callBase();\n\n    if (!this._initContent) {\n      this._initContent = this._renderContent;\n\n      this._renderContent = function () {};\n    }\n\n    this._initContent();\n  },\n  _renderContentImpl: function _renderContentImpl() {\n    this.$element().removeClass(WIDGET_CLASS);\n    this.$element().append(this._$initialContent);\n\n    this._setLoadingState();\n  },\n  _renderDeferredContent: function _renderDeferredContent() {\n    var that = this;\n    var $element = this.$element();\n    var result = new Deferred();\n    $element.removeClass(PENDING_RENDERING_MANUAL_CLASS);\n    $element.addClass(PENDING_RENDERING_ACTIVE_CLASS);\n\n    this._abortRenderTask();\n\n    this._renderTask = executeAsync(function () {\n      that._renderImpl().done(function () {\n        var shownArgs = {\n          element: $element\n        };\n\n        that._actions.onShown([shownArgs]);\n\n        result.resolve(shownArgs);\n      }).fail(function () {\n        result.rejectWith(result, arguments);\n      });\n    });\n    return result.promise();\n  },\n  _isElementInViewport: function _isElementInViewport(element) {\n    var rect = getBoundingRect(element);\n    return rect.bottom >= 0 && rect.right >= 0 && rect.top <= (window.innerHeight || domAdapter.getDocumentElement().clientHeight) && rect.left <= (window.innerWidth || domAdapter.getDocumentElement().clientWidth);\n  },\n  _animate: function _animate() {\n    var that = this;\n    var $element = this.$element();\n    var animation = hasWindow() && this.option(\"animation\");\n    var staggerItemSelector = this.option(\"staggerItemSelector\");\n    var animatePromise;\n    that.transitionExecutor.stop();\n\n    if (animation) {\n      if (staggerItemSelector) {\n        $element.find(staggerItemSelector).each(function () {\n          if (that._isElementInViewport(this)) {\n            that.transitionExecutor.enter($(this), animation);\n          }\n        });\n      } else {\n        that.transitionExecutor.enter($element, animation);\n      }\n\n      animatePromise = that.transitionExecutor.start();\n    } else {\n      animatePromise = new Deferred().resolve().promise();\n    }\n\n    return animatePromise;\n  },\n  _renderImpl: function _renderImpl() {\n    var $element = this.$element();\n    var renderedArgs = {\n      element: $element\n    };\n\n    var contentTemplate = this._getTemplate(this._templateManager.anonymousTemplateName);\n\n    if (contentTemplate) {\n      contentTemplate.render({\n        container: $element.empty(),\n        noModel: true\n      });\n    }\n\n    this._setRenderedState($element);\n\n    eventsEngine.trigger($element, \"dxcontentrendered\");\n\n    this._actions.onRendered([renderedArgs]);\n\n    this._isRendered = true;\n    return this._animate();\n  },\n  _setLoadingState: function _setLoadingState() {\n    var $element = this.$element();\n    var hasCustomLoadIndicator = !!$element.find(\".\" + VISIBLE_WHILE_PENDING_RENDERING_CLASS).length;\n    $element.addClass(PENDING_RENDERING_CLASS);\n\n    if (!hasCustomLoadIndicator) {\n      $element.children().addClass(INVISIBLE_WHILE_PENDING_RENDERING_CLASS);\n    }\n\n    if (this.option(\"showLoadIndicator\")) {\n      this._showLoadIndicator($element);\n    }\n  },\n  _showLoadIndicator: function _showLoadIndicator($container) {\n    this._$loadIndicator = new LoadIndicator($(\"<div>\"), {\n      visible: true\n    }).$element().addClass(DEFER_DEFER_RENDERING_LOAD_INDICATOR);\n    $(\"<div>\").addClass(LOADINDICATOR_CONTAINER_CLASS).addClass(DEFER_RENDERING_LOADINDICATOR_CONTAINER_CLASS).append(this._$loadIndicator).appendTo($container);\n  },\n  _setRenderedState: function _setRenderedState() {\n    var $element = this.$element();\n\n    if (this._$loadIndicator) {\n      this._$loadIndicator.remove();\n    }\n\n    $element.removeClass(PENDING_RENDERING_CLASS);\n    $element.removeClass(PENDING_RENDERING_ACTIVE_CLASS);\n    triggerShownEvent($element.children());\n  },\n  _optionChanged: function _optionChanged(args) {\n    var value = args.value;\n    var previousValue = args.previousValue;\n\n    switch (args.name) {\n      case \"renderWhen\":\n        if (false === previousValue && true === value) {\n          this._renderOrAnimate();\n        } else if (true === previousValue && false === value) {\n          this.transitionExecutor.stop();\n\n          this._setLoadingState();\n        }\n\n        break;\n\n      case \"showLoadIndicator\":\n      case \"onRendered\":\n      case \"onShown\":\n        break;\n\n      default:\n        this.callBase(args);\n    }\n  },\n  _renderOrAnimate: function _renderOrAnimate() {\n    var result;\n\n    if (this._isRendered) {\n      this._setRenderedState();\n\n      result = this._animate();\n    } else {\n      result = this._renderDeferredContent();\n    }\n\n    return result;\n  },\n  renderContent: function renderContent() {\n    return this._renderOrAnimate();\n  },\n  _abortRenderTask: function _abortRenderTask() {\n    if (this._renderTask) {\n      this._renderTask.abort();\n\n      this._renderTask = void 0;\n    }\n  },\n  _dispose: function _dispose() {\n    this.transitionExecutor.stop(true);\n\n    this._abortRenderTask();\n\n    this._actions = void 0;\n    this._$initialContent = void 0;\n    this.callBase();\n  }\n});\nregisterComponent(\"dxDeferRendering\", DeferRendering);\nexport default DeferRendering;","map":null,"metadata":{},"sourceType":"module"}