{"ast":null,"code":"/**\r\n * DevExtreme (esm/viz/series/bar_series.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { extend } from \"../../core/utils/extend\";\nimport { each } from \"../../core/utils/iterator\";\nimport * as scatterSeries from \"./scatter_series\";\nimport { chart as areaChart } from \"./area_series\";\nvar areaSeries = areaChart.area;\nimport { convertPolarToXY } from \"../core/utils\";\nvar chartSeries = scatterSeries.chart;\nvar polarSeries = scatterSeries.polar;\nimport { isDefined as _isDefined } from \"../../core/utils/type\";\nvar _extend = extend;\nvar _each = each;\nvar chart = {};\nvar polar = {};\nvar baseBarSeriesMethods = {\n  _createLegendState: function _createLegendState(styleOptions, defaultColor) {\n    return {\n      fill: styleOptions.color || defaultColor,\n      hatching: styleOptions.hatching\n    };\n  },\n  _parsePointStyle: function _parsePointStyle(style, defaultColor, defaultBorderColor) {\n    var color = style.color || defaultColor;\n\n    var base = chartSeries._parsePointStyle.call(this, style, color, defaultBorderColor);\n\n    base.fill = color;\n    base.hatching = style.hatching;\n    base.dashStyle = style.border && style.border.dashStyle || \"solid\";\n    delete base.r;\n    return base;\n  },\n  _applyMarkerClipRect: function _applyMarkerClipRect(settings) {\n    settings[\"clip-path\"] = null;\n  },\n  _setGroupsSettings: function _setGroupsSettings(animationEnabled, firstDrawing) {\n    var that = this;\n    var settings = {};\n\n    chartSeries._setGroupsSettings.apply(that, arguments);\n\n    if (animationEnabled && firstDrawing) {\n      settings = this._getAffineCoordOptions();\n    } else if (!animationEnabled) {\n      settings = {\n        scaleX: 1,\n        scaleY: 1,\n        translateX: 0,\n        translateY: 0\n      };\n    }\n\n    that._markersGroup.attr(settings);\n  },\n  _drawPoint: function _drawPoint(options) {\n    options.hasAnimation = options.hasAnimation && !options.firstDrawing;\n    options.firstDrawing = false;\n\n    chartSeries._drawPoint.call(this, options);\n  },\n  _getMainColor: function _getMainColor() {\n    return this._options.mainSeriesColor;\n  },\n  _createPointStyles: function _createPointStyles(pointOptions) {\n    var mainColor = pointOptions.color || this._getMainColor();\n\n    return {\n      normal: this._parsePointStyle(pointOptions, mainColor, mainColor),\n      hover: this._parsePointStyle(pointOptions.hoverStyle || {}, mainColor, mainColor),\n      selection: this._parsePointStyle(pointOptions.selectionStyle || {}, mainColor, mainColor)\n    };\n  },\n  _updatePointsVisibility: function _updatePointsVisibility() {\n    var visibility = this._options.visible;\n    each(this._points, function (_, point) {\n      point._options.visible = visibility;\n    });\n  },\n  _getOptionsForPoint: function _getOptionsForPoint() {\n    return this._options;\n  },\n  _animate: function _animate(firstDrawing) {\n    var that = this;\n\n    that._animatePoints(firstDrawing, function () {\n      that._animateComplete();\n    }, function (drawnPoints, complete) {\n      var lastPointIndex = drawnPoints.length - 1;\n\n      _each(drawnPoints || [], function (i, point) {\n        point.animate(i === lastPointIndex ? complete : void 0, point.getMarkerCoords());\n      });\n    });\n  },\n  getValueRangeInitialValue: areaSeries.getValueRangeInitialValue,\n  _patchMarginOptions: function _patchMarginOptions(options) {\n    options.checkInterval = !this.useAggregation();\n    return options;\n  },\n  _defaultAggregator: \"sum\",\n  _defineDrawingState: function _defineDrawingState() {},\n  usePointsToDefineAutoHiding: function usePointsToDefineAutoHiding() {\n    return false;\n  }\n};\nchart.bar = _extend({}, chartSeries, baseBarSeriesMethods, {\n  _getAffineCoordOptions: function _getAffineCoordOptions() {\n    var rotated = this._options.rotated;\n    var direction = rotated ? \"X\" : \"Y\";\n    var settings = {\n      scaleX: rotated ? .001 : 1,\n      scaleY: rotated ? 1 : .001\n    };\n    settings[\"translate\" + direction] = this.getValueAxis().getTranslator().translate(\"canvas_position_default\");\n    return settings;\n  },\n  _animatePoints: function _animatePoints(firstDrawing, complete, animateFunc) {\n    this._markersGroup.animate({\n      scaleX: 1,\n      scaleY: 1,\n      translateY: 0,\n      translateX: 0\n    }, void 0, complete);\n\n    if (!firstDrawing) {\n      animateFunc(this._drawnPoints, complete);\n    }\n  },\n  checkSeriesViewportCoord: function checkSeriesViewportCoord(axis, coord) {\n    if (!chartSeries.checkSeriesViewportCoord.call(this)) {\n      return false;\n    }\n\n    if (axis.isArgumentAxis) {\n      return true;\n    }\n\n    var translator = axis.getTranslator();\n    var range = this.getViewport();\n    var min = translator.translate(range.categories ? range.categories[0] : range.min);\n    var max = translator.translate(range.categories ? range.categories[range.categories.length - 1] : range.max);\n    var rotated = this.getOptions().rotated;\n    var inverted = axis.getOptions().inverted;\n    return rotated && !inverted || !rotated && inverted ? coord >= min && coord <= max : coord >= max && coord <= min;\n  },\n  getSeriesPairCoord: function getSeriesPairCoord(coord, isArgument) {\n    var oppositeCoord = null;\n    var rotated = this._options.rotated;\n    var isOpposite = !isArgument && !rotated || isArgument && rotated;\n    var coordName = isOpposite ? \"vy\" : \"vx\";\n    var oppositeCoordName = isOpposite ? \"vx\" : \"vy\";\n    var points = this.getPoints();\n\n    for (var i = 0; i < points.length; i++) {\n      var p = points[i];\n      var tmpCoord = void 0;\n\n      if (isArgument) {\n        tmpCoord = p.getCenterCoord()[coordName[1]] === coord ? p[oppositeCoordName] : void 0;\n      } else {\n        tmpCoord = p[coordName] === coord ? p[oppositeCoordName] : void 0;\n      }\n\n      if (this._checkAxisVisibleAreaCoord(!isArgument, tmpCoord)) {\n        oppositeCoord = tmpCoord;\n        break;\n      }\n    }\n\n    return oppositeCoord;\n  }\n});\npolar.bar = _extend({}, polarSeries, baseBarSeriesMethods, {\n  _animatePoints: function _animatePoints(firstDrawing, complete, animateFunc) {\n    animateFunc(this._drawnPoints, complete);\n  },\n  _setGroupsSettings: chartSeries._setGroupsSettings,\n  _drawPoint: function _drawPoint(point, groups, animationEnabled) {\n    chartSeries._drawPoint.call(this, point, groups, animationEnabled);\n  },\n  _parsePointStyle: function _parsePointStyle(style) {\n    var base = baseBarSeriesMethods._parsePointStyle.apply(this, arguments);\n\n    base.opacity = style.opacity;\n    return base;\n  },\n  _createGroups: chartSeries._createGroups,\n  _setMarkerGroupSettings: function _setMarkerGroupSettings() {\n    var markersSettings = this._createPointStyles(this._getMarkerGroupOptions()).normal;\n\n    markersSettings.class = \"dxc-markers\";\n\n    this._applyMarkerClipRect(markersSettings);\n\n    var groupSettings = _extend({}, markersSettings);\n\n    delete groupSettings.opacity;\n\n    this._markersGroup.attr(groupSettings);\n  },\n  getSeriesPairCoord: function getSeriesPairCoord(params, isArgument) {\n    var coords = null;\n    var paramName = isArgument ? \"argument\" : \"radius\";\n    var points = this.getVisiblePoints();\n    var argAxis = this.getArgumentAxis();\n    var startAngle = argAxis.getAngles()[0];\n\n    for (var i = 0; i < points.length; i++) {\n      var p = points[i];\n      var tmpPoint = _isDefined(p[paramName]) && _isDefined(params[paramName]) && p[paramName].valueOf() === params[paramName].valueOf() ? convertPolarToXY(argAxis.getCenter(), startAngle, -argAxis.getTranslatedAngle(p.angle), p.radius) : void 0;\n\n      if (_isDefined(tmpPoint)) {\n        coords = tmpPoint;\n        break;\n      }\n    }\n\n    return coords;\n  },\n  _createLegendState: areaSeries._createLegendState\n});\nexport { chart, polar };","map":null,"metadata":{},"sourceType":"module"}