{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/scroll_view/ui.scrollable.simulated.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { getHeight, getWidth } from \"../../core/utils/size\";\nimport $ from \"../../core/renderer\";\nimport domAdapter from \"../../core/dom_adapter\";\nimport eventsEngine from \"../../events/core/events_engine\";\nimport { titleize } from \"../../core/utils/inflector\";\nimport { extend } from \"../../core/utils/extend\";\nimport { getWindow, hasWindow } from \"../../core/utils/window\";\nimport { each, map } from \"../../core/utils/iterator\";\nimport { isDefined } from \"../../core/utils/type\";\nimport { getBoundingRect } from \"../../core/utils/position\";\nimport { resetPosition, move, locate } from \"../../animation/translator\";\nimport Class from \"../../core/class\";\nimport Animator from \"./animator\";\nimport { isDxMouseWheelEvent, addNamespace as addEventNamespace, normalizeKeyName, isCommandKeyPressed } from \"../../events/utils/index\";\nimport { deferUpdate, deferUpdater, deferRender, deferRenderer, noop } from \"../../core/utils/common\";\nimport Scrollbar from \"./ui.scrollbar\";\nimport { when, Deferred } from \"../../core/utils/deferred\";\nvar SCROLLABLE_SIMULATED = \"dxSimulatedScrollable\";\nvar SCROLLABLE_STRATEGY = \"dxScrollableStrategy\";\nvar SCROLLABLE_SIMULATED_CURSOR = SCROLLABLE_SIMULATED + \"Cursor\";\nvar SCROLLABLE_SIMULATED_KEYBOARD = SCROLLABLE_SIMULATED + \"Keyboard\";\nvar SCROLLABLE_SIMULATED_CLASS = \"dx-scrollable-simulated\";\nvar SCROLLABLE_SCROLLBARS_ALWAYSVISIBLE = \"dx-scrollable-scrollbars-alwaysvisible\";\nvar SCROLLABLE_SCROLLBAR_CLASS = \"dx-scrollable-scrollbar\";\nvar VERTICAL = \"vertical\";\nvar HORIZONTAL = \"horizontal\";\nvar ACCELERATION = .92;\nvar OUT_BOUNDS_ACCELERATION = .5;\nvar MIN_VELOCITY_LIMIT = 1;\nvar FRAME_DURATION = Math.round(1e3 / 60);\nvar SCROLL_LINE_HEIGHT = 40;\nvar VALIDATE_WHEEL_TIMEOUT = 500;\nvar BOUNCE_MIN_VELOCITY_LIMIT = MIN_VELOCITY_LIMIT / 5;\nvar BOUNCE_DURATION = 400;\nvar BOUNCE_FRAMES = BOUNCE_DURATION / FRAME_DURATION;\nvar BOUNCE_ACCELERATION_SUM = (1 - Math.pow(ACCELERATION, BOUNCE_FRAMES)) / (1 - ACCELERATION);\nvar KEY_CODES = {\n  PAGE_UP: \"pageUp\",\n  PAGE_DOWN: \"pageDown\",\n  END: \"end\",\n  HOME: \"home\",\n  LEFT: \"leftArrow\",\n  UP: \"upArrow\",\n  RIGHT: \"rightArrow\",\n  DOWN: \"downArrow\",\n  TAB: \"tab\"\n};\nvar InertiaAnimator = Animator.inherit({\n  ctor: function ctor(scroller) {\n    this.callBase();\n    this.scroller = scroller;\n  },\n  VELOCITY_LIMIT: MIN_VELOCITY_LIMIT,\n  _isFinished: function _isFinished() {\n    return Math.abs(this.scroller._velocity) <= this.VELOCITY_LIMIT;\n  },\n  _step: function _step() {\n    this.scroller._scrollStep(this.scroller._velocity);\n\n    this.scroller._velocity *= this._acceleration();\n  },\n  _acceleration: function _acceleration() {\n    return this.scroller._inBounds() ? ACCELERATION : OUT_BOUNDS_ACCELERATION;\n  },\n  _complete: function _complete() {\n    this.scroller._scrollComplete();\n  }\n});\nvar BounceAnimator = InertiaAnimator.inherit({\n  VELOCITY_LIMIT: BOUNCE_MIN_VELOCITY_LIMIT,\n  _isFinished: function _isFinished() {\n    return this.scroller._crossBoundOnNextStep() || this.callBase();\n  },\n  _acceleration: function _acceleration() {\n    return ACCELERATION;\n  },\n  _complete: function _complete() {\n    this.scroller._move(this.scroller._bounceLocation);\n\n    this.callBase();\n  }\n});\nexport var Scroller = Class.inherit({\n  ctor: function ctor(options) {\n    this._initOptions(options);\n\n    this._initAnimators();\n\n    this._initScrollbar();\n  },\n  _initOptions: function _initOptions(options) {\n    var _this = this;\n\n    this._location = 0;\n    this._topReached = false;\n    this._bottomReached = false;\n    this._axis = options.direction === HORIZONTAL ? \"x\" : \"y\";\n    this._prop = options.direction === HORIZONTAL ? \"left\" : \"top\";\n    this._dimension = options.direction === HORIZONTAL ? \"width\" : \"height\";\n    this._scrollProp = options.direction === HORIZONTAL ? \"scrollLeft\" : \"scrollTop\";\n    each(options, function (optionName, optionValue) {\n      _this[\"_\" + optionName] = optionValue;\n    });\n  },\n  _initAnimators: function _initAnimators() {\n    this._inertiaAnimator = new InertiaAnimator(this);\n    this._bounceAnimator = new BounceAnimator(this);\n  },\n  _initScrollbar: function _initScrollbar() {\n    this._scrollbar = new Scrollbar($(\"<div>\").appendTo(this._$container), {\n      direction: this._direction,\n      visible: this._scrollByThumb,\n      visibilityMode: this._visibilityModeNormalize(this._scrollbarVisible),\n      expandable: this._scrollByThumb\n    });\n    this._$scrollbar = this._scrollbar.$element();\n  },\n  _visibilityModeNormalize: function _visibilityModeNormalize(mode) {\n    return true === mode ? \"onScroll\" : false === mode ? \"never\" : mode;\n  },\n  _scrollStep: function _scrollStep(delta) {\n    var prevLocation = this._location;\n    this._location += delta;\n\n    this._suppressBounce();\n\n    this._move();\n\n    if (Math.abs(prevLocation - this._location) < 1) {\n      return;\n    }\n\n    eventsEngine.triggerHandler(this._$container, {\n      type: \"scroll\"\n    });\n  },\n  _suppressBounce: function _suppressBounce() {\n    if (this._bounceEnabled || this._inBounds(this._location)) {\n      return;\n    }\n\n    this._velocity = 0;\n    this._location = this._boundLocation();\n  },\n  _boundLocation: function _boundLocation(location) {\n    location = void 0 !== location ? location : this._location;\n    return Math.max(Math.min(location, this._maxOffset), this._minOffset);\n  },\n  _move: function _move(location) {\n    this._location = void 0 !== location ? location * this._getScaleRatio() : this._location;\n\n    this._moveContent();\n\n    this._moveScrollbar();\n  },\n  _moveContent: function _moveContent() {\n    var location = this._location;\n\n    this._$container[this._scrollProp](-location / this._getScaleRatio());\n\n    this._moveContentByTranslator(location);\n  },\n  _getScaleRatio: function _getScaleRatio() {\n    if (hasWindow() && !this._scaleRatio) {\n      var element = this._$element.get(0);\n\n      var realDimension = this._getRealDimension(element, this._dimension);\n\n      var baseDimension = this._getBaseDimension(element, this._dimension);\n\n      this._scaleRatio = Math.round(realDimension / baseDimension * 100) / 100;\n    }\n\n    return this._scaleRatio || 1;\n  },\n  _getRealDimension: function _getRealDimension(element, dimension) {\n    return Math.round(getBoundingRect(element)[dimension]);\n  },\n  _getBaseDimension: function _getBaseDimension(element, dimension) {\n    var dimensionName = \"offset\" + titleize(dimension);\n    return element[dimensionName];\n  },\n  _moveContentByTranslator: function _moveContentByTranslator(location) {\n    var translateOffset;\n    var minOffset = -this._maxScrollPropValue;\n\n    if (location > 0) {\n      translateOffset = location;\n    } else if (location <= minOffset) {\n      translateOffset = location - minOffset;\n    } else {\n      translateOffset = location % 1;\n    }\n\n    if (this._translateOffset === translateOffset) {\n      return;\n    }\n\n    var targetLocation = {};\n    targetLocation[this._prop] = translateOffset;\n    this._translateOffset = translateOffset;\n\n    if (0 === translateOffset) {\n      resetPosition(this._$content);\n      return;\n    }\n\n    move(this._$content, targetLocation);\n  },\n  _moveScrollbar: function _moveScrollbar() {\n    this._scrollbar.moveTo(this._location);\n  },\n  _scrollComplete: function _scrollComplete() {\n    if (this._inBounds()) {\n      this._hideScrollbar();\n\n      if (this._completeDeferred) {\n        this._completeDeferred.resolve();\n      }\n    }\n\n    this._scrollToBounds();\n  },\n  _scrollToBounds: function _scrollToBounds() {\n    if (this._inBounds()) {\n      return;\n    }\n\n    this._bounceAction();\n\n    this._setupBounce();\n\n    this._bounceAnimator.start();\n  },\n  _setupBounce: function _setupBounce() {\n    var boundLocation = this._bounceLocation = this._boundLocation();\n\n    var bounceDistance = boundLocation - this._location;\n    this._velocity = bounceDistance / BOUNCE_ACCELERATION_SUM;\n  },\n  _inBounds: function _inBounds(location) {\n    location = void 0 !== location ? location : this._location;\n    return this._boundLocation(location) === location;\n  },\n  _crossBoundOnNextStep: function _crossBoundOnNextStep() {\n    var location = this._location;\n    var nextLocation = location + this._velocity;\n    return location < this._minOffset && nextLocation >= this._minOffset || location > this._maxOffset && nextLocation <= this._maxOffset;\n  },\n  _initHandler: function _initHandler(e) {\n    this._stopScrolling();\n\n    this._prepareThumbScrolling(e);\n  },\n  _stopScrolling: deferRenderer(function () {\n    this._hideScrollbar();\n\n    this._inertiaAnimator.stop();\n\n    this._bounceAnimator.stop();\n  }),\n  _prepareThumbScrolling: function _prepareThumbScrolling(e) {\n    if (isDxMouseWheelEvent(e.originalEvent)) {\n      return;\n    }\n\n    var $target = $(e.originalEvent.target);\n\n    var scrollbarClicked = this._isScrollbar($target);\n\n    if (scrollbarClicked) {\n      this._moveToMouseLocation(e);\n    }\n\n    this._thumbScrolling = scrollbarClicked || this._isThumb($target);\n    this._crossThumbScrolling = !this._thumbScrolling && this._isAnyThumbScrolling($target);\n\n    if (this._thumbScrolling) {\n      this._scrollbar.feedbackOn();\n    }\n  },\n  _isThumbScrollingHandler: function _isThumbScrollingHandler($target) {\n    return this._isThumb($target);\n  },\n  _moveToMouseLocation: function _moveToMouseLocation(e) {\n    var mouseLocation = e[\"page\" + this._axis.toUpperCase()] - this._$element.offset()[this._prop];\n\n    var location = this._location + mouseLocation / this._containerToContentRatio() - getHeight(this._$container) / 2;\n\n    this._scrollStep(-Math.round(location));\n  },\n  _startHandler: function _startHandler() {\n    this._showScrollbar();\n  },\n  _moveHandler: function _moveHandler(delta) {\n    if (this._crossThumbScrolling) {\n      return;\n    }\n\n    if (this._thumbScrolling) {\n      delta[this._axis] = -Math.round(delta[this._axis] / this._containerToContentRatio());\n    }\n\n    this._scrollBy(delta);\n  },\n  _scrollBy: function _scrollBy(delta) {\n    delta = delta[this._axis];\n\n    if (!this._inBounds()) {\n      delta *= OUT_BOUNDS_ACCELERATION;\n    }\n\n    this._scrollStep(delta);\n  },\n  _scrollByHandler: function _scrollByHandler(delta) {\n    this._scrollBy(delta);\n\n    this._scrollComplete();\n  },\n  _containerToContentRatio: function _containerToContentRatio() {\n    return this._scrollbar.containerToContentRatio();\n  },\n  _endHandler: function _endHandler(velocity) {\n    this._completeDeferred = new Deferred();\n    this._velocity = velocity[this._axis];\n\n    this._inertiaHandler();\n\n    this._resetThumbScrolling();\n\n    return this._completeDeferred.promise();\n  },\n  _inertiaHandler: function _inertiaHandler() {\n    this._suppressInertia();\n\n    this._inertiaAnimator.start();\n  },\n  _suppressInertia: function _suppressInertia() {\n    if (!this._inertiaEnabled || this._thumbScrolling) {\n      this._velocity = 0;\n    }\n  },\n  _resetThumbScrolling: function _resetThumbScrolling() {\n    this._thumbScrolling = false;\n    this._crossThumbScrolling = false;\n  },\n  _stopHandler: function _stopHandler() {\n    if (this._thumbScrolling) {\n      this._scrollComplete();\n    }\n\n    this._resetThumbScrolling();\n\n    this._scrollToBounds();\n  },\n  _disposeHandler: function _disposeHandler() {\n    this._stopScrolling();\n\n    this._$scrollbar.remove();\n  },\n  _updateHandler: function _updateHandler() {\n    this._update();\n\n    this._moveToBounds();\n  },\n  _update: function _update() {\n    var _this2 = this;\n\n    this._stopScrolling();\n\n    return deferUpdate(function () {\n      _this2._resetScaleRatio();\n\n      _this2._updateLocation();\n\n      _this2._updateBounds();\n\n      _this2._updateScrollbar();\n\n      deferRender(function () {\n        _this2._moveScrollbar();\n\n        _this2._scrollbar.update();\n      });\n    });\n  },\n  _resetScaleRatio: function _resetScaleRatio() {\n    this._scaleRatio = null;\n  },\n  _updateLocation: function _updateLocation() {\n    this._location = (locate(this._$content)[this._prop] - this._$container[this._scrollProp]()) * this._getScaleRatio();\n  },\n  _updateBounds: function _updateBounds() {\n    this._maxOffset = this._getMaxOffset();\n    this._minOffset = this._getMinOffset();\n  },\n  _getMaxOffset: function _getMaxOffset() {\n    return 0;\n  },\n  _getMinOffset: function _getMinOffset() {\n    this._maxScrollPropValue = Math.max(this._contentSize() - this._containerSize(), 0);\n    return -this._maxScrollPropValue;\n  },\n  _updateScrollbar: deferUpdater(function () {\n    var _this3 = this;\n\n    var containerSize = this._containerSize();\n\n    var contentSize = this._contentSize();\n\n    var baseContainerSize = this._getBaseDimension(this._$container.get(0), this._dimension);\n\n    var baseContentSize = this._getBaseDimension(this._$content.get(0), this._dimension);\n\n    deferRender(function () {\n      _this3._scrollbar.option({\n        containerSize: containerSize,\n        contentSize: contentSize,\n        baseContainerSize: baseContainerSize,\n        baseContentSize: baseContentSize,\n        scaleRatio: _this3._getScaleRatio()\n      });\n    });\n  }),\n  _moveToBounds: deferRenderer(deferUpdater(deferRenderer(function () {\n    var location = this._boundLocation();\n\n    var locationChanged = location !== this._location;\n    this._location = location;\n\n    this._move();\n\n    if (locationChanged) {\n      this._scrollAction();\n    }\n  }))),\n  _createActionsHandler: function _createActionsHandler(actions) {\n    this._scrollAction = actions.scroll;\n    this._bounceAction = actions.bounce;\n  },\n  _showScrollbar: function _showScrollbar() {\n    this._scrollbar.option(\"visible\", true);\n  },\n  _hideScrollbar: function _hideScrollbar() {\n    this._scrollbar.option(\"visible\", false);\n  },\n  _containerSize: function _containerSize() {\n    return this._getRealDimension(this._$container.get(0), this._dimension);\n  },\n  _contentSize: function _contentSize() {\n    var isOverflowHidden = \"hidden\" === this._$content.css(\"overflow\" + this._axis.toUpperCase());\n\n    var contentSize = this._getRealDimension(this._$content.get(0), this._dimension);\n\n    if (!isOverflowHidden) {\n      var containerScrollSize = this._$content[0][\"scroll\" + titleize(this._dimension)] * this._getScaleRatio();\n\n      contentSize = Math.max(containerScrollSize, contentSize);\n    }\n\n    return contentSize;\n  },\n  _validateEvent: function _validateEvent(e) {\n    var $target = $(e.originalEvent.target);\n    return this._isThumb($target) || this._isScrollbar($target);\n  },\n  _isThumb: function _isThumb($element) {\n    return this._scrollByThumb && this._scrollbar.isThumb($element);\n  },\n  _isScrollbar: function _isScrollbar($element) {\n    return this._scrollByThumb && $element && $element.is(this._$scrollbar);\n  },\n  _reachedMin: function _reachedMin() {\n    return Math.round(this._location - this._minOffset) <= 0;\n  },\n  _reachedMax: function _reachedMax() {\n    return Math.round(this._location - this._maxOffset) >= 0;\n  },\n  _cursorEnterHandler: function _cursorEnterHandler() {\n    this._resetScaleRatio();\n\n    this._updateScrollbar();\n\n    this._scrollbar.cursorEnter();\n  },\n  _cursorLeaveHandler: function _cursorLeaveHandler() {\n    this._scrollbar.cursorLeave();\n  },\n  dispose: noop\n});\nvar hoveredScrollable;\nvar activeScrollable;\nexport var SimulatedStrategy = Class.inherit({\n  ctor: function ctor(scrollable) {\n    this._init(scrollable);\n  },\n  _init: function _init(scrollable) {\n    this._component = scrollable;\n    this._$element = scrollable.$element();\n    this._$container = $(scrollable.container());\n    this._$wrapper = scrollable._$wrapper;\n    this._$content = scrollable.$content();\n    this.option = scrollable.option.bind(scrollable);\n    this._createActionByOption = scrollable._createActionByOption.bind(scrollable);\n    this._isLocked = scrollable._isLocked.bind(scrollable);\n    this._isDirection = scrollable._isDirection.bind(scrollable);\n    this._allowedDirection = scrollable._allowedDirection.bind(scrollable);\n    this._getMaxOffset = scrollable._getMaxOffset.bind(scrollable);\n  },\n  render: function render() {\n    this._$element.addClass(SCROLLABLE_SIMULATED_CLASS);\n\n    this._createScrollers();\n\n    if (this.option(\"useKeyboard\")) {\n      this._$container.prop(\"tabIndex\", 0);\n    }\n\n    this._attachKeyboardHandler();\n\n    this._attachCursorHandlers();\n  },\n  _createScrollers: function _createScrollers() {\n    this._scrollers = {};\n\n    if (this._isDirection(HORIZONTAL)) {\n      this._createScroller(HORIZONTAL);\n    }\n\n    if (this._isDirection(VERTICAL)) {\n      this._createScroller(VERTICAL);\n    }\n\n    this._$element.toggleClass(SCROLLABLE_SCROLLBARS_ALWAYSVISIBLE, \"always\" === this.option(\"showScrollbar\"));\n  },\n  _createScroller: function _createScroller(direction) {\n    this._scrollers[direction] = new Scroller(this._scrollerOptions(direction));\n  },\n  _scrollerOptions: function _scrollerOptions(direction) {\n    return {\n      direction: direction,\n      $content: this._$content,\n      $container: this._$container,\n      $wrapper: this._$wrapper,\n      $element: this._$element,\n      scrollByThumb: this.option(\"scrollByThumb\"),\n      scrollbarVisible: this.option(\"showScrollbar\"),\n      bounceEnabled: this.option(\"bounceEnabled\"),\n      inertiaEnabled: this.option(\"inertiaEnabled\"),\n      isAnyThumbScrolling: this._isAnyThumbScrolling.bind(this)\n    };\n  },\n  _applyScaleRatio: function _applyScaleRatio(targetLocation) {\n    for (var direction in this._scrollers) {\n      var prop = this._getPropByDirection(direction);\n\n      if (isDefined(targetLocation[prop])) {\n        var scroller = this._scrollers[direction];\n        targetLocation[prop] *= scroller._getScaleRatio();\n      }\n    }\n\n    return targetLocation;\n  },\n  _isAnyThumbScrolling: function _isAnyThumbScrolling($target) {\n    var result = false;\n\n    this._eventHandler(\"isThumbScrolling\", $target).done(function (isThumbScrollingVertical, isThumbScrollingHorizontal) {\n      result = isThumbScrollingVertical || isThumbScrollingHorizontal;\n    });\n\n    return result;\n  },\n  handleInit: function handleInit(e) {\n    this._suppressDirections(e);\n\n    this._eventForUserAction = e;\n\n    this._eventHandler(\"init\", e);\n  },\n  _suppressDirections: function _suppressDirections(e) {\n    if (isDxMouseWheelEvent(e.originalEvent)) {\n      this._prepareDirections(true);\n\n      return;\n    }\n\n    this._prepareDirections();\n\n    this._eachScroller(function (scroller, direction) {\n      var $target = $(e.originalEvent.target);\n\n      var isValid = scroller._validateEvent(e) || this.option(\"scrollByContent\") && this._isContent($target);\n\n      this._validDirections[direction] = isValid;\n    });\n  },\n  _isContent: function _isContent($element) {\n    return !!$element.closest(this._$element).length;\n  },\n  _prepareDirections: function _prepareDirections(value) {\n    value = value || false;\n    this._validDirections = {};\n    this._validDirections[HORIZONTAL] = value;\n    this._validDirections[VERTICAL] = value;\n  },\n  _eachScroller: function _eachScroller(callback) {\n    callback = callback.bind(this);\n    each(this._scrollers, function (direction, scroller) {\n      callback(scroller, direction);\n    });\n  },\n  handleStart: function handleStart(e) {\n    this._eventForUserAction = e;\n\n    this._eventHandler(\"start\").done(this._startAction);\n  },\n  _saveActive: function _saveActive() {\n    activeScrollable = this;\n  },\n  _resetActive: function _resetActive() {\n    if (activeScrollable === this) {\n      activeScrollable = null;\n    }\n  },\n  handleMove: function handleMove(e) {\n    if (this._isLocked()) {\n      e.cancel = true;\n\n      this._resetActive();\n\n      return;\n    }\n\n    this._saveActive();\n\n    e.preventDefault && e.preventDefault();\n\n    this._adjustDistance(e, e.delta);\n\n    this._eventForUserAction = e;\n\n    this._eventHandler(\"move\", e.delta);\n  },\n  _adjustDistance: function _adjustDistance(e, distance) {\n    distance.x *= this._validDirections[HORIZONTAL];\n    distance.y *= this._validDirections[VERTICAL];\n\n    var devicePixelRatio = this._tryGetDevicePixelRatio();\n\n    if (devicePixelRatio && isDxMouseWheelEvent(e.originalEvent)) {\n      distance.x = Math.round(distance.x / devicePixelRatio * 100) / 100;\n      distance.y = Math.round(distance.y / devicePixelRatio * 100) / 100;\n    }\n  },\n  _tryGetDevicePixelRatio: function _tryGetDevicePixelRatio() {\n    if (hasWindow()) {\n      return getWindow().devicePixelRatio;\n    }\n  },\n  handleEnd: function handleEnd(e) {\n    this._resetActive();\n\n    this._refreshCursorState(e.originalEvent && e.originalEvent.target);\n\n    this._adjustDistance(e, e.velocity);\n\n    this._eventForUserAction = e;\n    return this._eventHandler(\"end\", e.velocity).done(this._endAction);\n  },\n  handleCancel: function handleCancel(e) {\n    this._resetActive();\n\n    this._eventForUserAction = e;\n    return this._eventHandler(\"end\", {\n      x: 0,\n      y: 0\n    });\n  },\n  handleStop: function handleStop() {\n    this._resetActive();\n\n    this._eventHandler(\"stop\");\n  },\n  handleScroll: function handleScroll() {\n    this._updateRtlConfig();\n\n    this._scrollAction();\n  },\n  _attachKeyboardHandler: function _attachKeyboardHandler() {\n    eventsEngine.off(this._$element, \".\".concat(SCROLLABLE_SIMULATED_KEYBOARD));\n\n    if (!this.option(\"disabled\") && this.option(\"useKeyboard\")) {\n      eventsEngine.on(this._$element, addEventNamespace(\"keydown\", SCROLLABLE_SIMULATED_KEYBOARD), this._keyDownHandler.bind(this));\n    }\n  },\n  _keyDownHandler: function _keyDownHandler(e) {\n    var _this4 = this;\n\n    clearTimeout(this._updateHandlerTimeout);\n    this._updateHandlerTimeout = setTimeout(function () {\n      if (normalizeKeyName(e) === KEY_CODES.TAB) {\n        _this4._eachScroller(function (scroller) {\n          scroller._updateHandler();\n        });\n      }\n    });\n\n    if (!this._$container.is(domAdapter.getActiveElement())) {\n      return;\n    }\n\n    var handled = true;\n\n    switch (normalizeKeyName(e)) {\n      case KEY_CODES.DOWN:\n        this._scrollByLine({\n          y: 1\n        });\n\n        break;\n\n      case KEY_CODES.UP:\n        this._scrollByLine({\n          y: -1\n        });\n\n        break;\n\n      case KEY_CODES.RIGHT:\n        this._scrollByLine({\n          x: 1\n        });\n\n        break;\n\n      case KEY_CODES.LEFT:\n        this._scrollByLine({\n          x: -1\n        });\n\n        break;\n\n      case KEY_CODES.PAGE_DOWN:\n        this._scrollByPage(1);\n\n        break;\n\n      case KEY_CODES.PAGE_UP:\n        this._scrollByPage(-1);\n\n        break;\n\n      case KEY_CODES.HOME:\n        this._scrollToHome();\n\n        break;\n\n      case KEY_CODES.END:\n        this._scrollToEnd();\n\n        break;\n\n      default:\n        handled = false;\n    }\n\n    if (handled) {\n      e.stopPropagation();\n      e.preventDefault();\n    }\n  },\n  _scrollByLine: function _scrollByLine(lines) {\n    var devicePixelRatio = this._tryGetDevicePixelRatio();\n\n    var scrollOffset = SCROLL_LINE_HEIGHT;\n\n    if (devicePixelRatio) {\n      scrollOffset = Math.abs(scrollOffset / devicePixelRatio * 100) / 100;\n    }\n\n    this.scrollBy({\n      top: (lines.y || 0) * -scrollOffset,\n      left: (lines.x || 0) * -scrollOffset\n    });\n  },\n  _scrollByPage: function _scrollByPage(page) {\n    var prop = this._wheelProp();\n\n    var dimension = this._dimensionByProp(prop);\n\n    var distance = {};\n    var getter = \"width\" === dimension ? getWidth : getHeight;\n    distance[prop] = page * -getter(this._$container);\n    this.scrollBy(distance);\n  },\n  _dimensionByProp: function _dimensionByProp(prop) {\n    return \"left\" === prop ? \"width\" : \"height\";\n  },\n  _getPropByDirection: function _getPropByDirection(direction) {\n    return direction === HORIZONTAL ? \"left\" : \"top\";\n  },\n  _scrollToHome: function _scrollToHome() {\n    var prop = this._wheelProp();\n\n    var distance = {};\n    distance[prop] = 0;\n\n    this._component.scrollTo(distance);\n  },\n  _scrollToEnd: function _scrollToEnd() {\n    var prop = this._wheelProp();\n\n    var dimension = this._dimensionByProp(prop);\n\n    var distance = {};\n    var getter = \"width\" === dimension ? getWidth : getHeight;\n    distance[prop] = getter(this._$content) - getter(this._$container);\n\n    this._component.scrollTo(distance);\n  },\n  createActions: function createActions() {\n    this._startAction = this._createActionHandler(\"onStart\");\n    this._endAction = this._createActionHandler(\"onEnd\");\n    this._updateAction = this._createActionHandler(\"onUpdated\");\n\n    this._createScrollerActions();\n  },\n  _createScrollerActions: function _createScrollerActions() {\n    this._scrollAction = this._createActionHandler(\"onScroll\");\n    this._bounceAction = this._createActionHandler(\"onBounce\");\n\n    this._eventHandler(\"createActions\", {\n      scroll: this._scrollAction,\n      bounce: this._bounceAction\n    });\n  },\n  _createActionHandler: function _createActionHandler(optionName) {\n    var _arguments = arguments,\n        _this5 = this;\n\n    var actionHandler = this._createActionByOption(optionName);\n\n    return function () {\n      actionHandler(extend(_this5._createActionArgs(), _arguments));\n    };\n  },\n  _createActionArgs: function _createActionArgs() {\n    var _this$_scrollers = this._scrollers,\n        scrollerX = _this$_scrollers.horizontal,\n        scrollerY = _this$_scrollers.vertical;\n\n    var offset = this._getScrollOffset();\n\n    this._scrollOffset = {\n      top: scrollerY && offset.top,\n      left: scrollerX && offset.left\n    };\n    return {\n      event: this._eventForUserAction,\n      scrollOffset: this._scrollOffset,\n      reachedLeft: scrollerX && scrollerX._reachedMax(),\n      reachedRight: scrollerX && scrollerX._reachedMin(),\n      reachedTop: scrollerY && scrollerY._reachedMax(),\n      reachedBottom: scrollerY && scrollerY._reachedMin()\n    };\n  },\n  _getScrollOffset: function _getScrollOffset() {\n    return {\n      top: -this.location().top,\n      left: -this.location().left\n    };\n  },\n  _eventHandler: function _eventHandler(eventName) {\n    var args = [].slice.call(arguments).slice(1);\n    var deferreds = map(this._scrollers, function (scroller) {\n      return scroller[\"_\" + eventName + \"Handler\"].apply(scroller, args);\n    });\n    return when.apply($, deferreds).promise();\n  },\n  location: function location() {\n    var location = locate(this._$content);\n    location.top -= this._$container.scrollTop();\n    location.left -= this._$container.scrollLeft();\n    return location;\n  },\n  disabledChanged: function disabledChanged() {\n    this._attachCursorHandlers();\n  },\n  _attachCursorHandlers: function _attachCursorHandlers() {\n    eventsEngine.off(this._$element, \".\".concat(SCROLLABLE_SIMULATED_CURSOR));\n\n    if (!this.option(\"disabled\") && this._isHoverMode()) {\n      eventsEngine.on(this._$element, addEventNamespace(\"mouseenter\", SCROLLABLE_SIMULATED_CURSOR), this._cursorEnterHandler.bind(this));\n      eventsEngine.on(this._$element, addEventNamespace(\"mouseleave\", SCROLLABLE_SIMULATED_CURSOR), this._cursorLeaveHandler.bind(this));\n    }\n  },\n  _isHoverMode: function _isHoverMode() {\n    return \"onHover\" === this.option(\"showScrollbar\");\n  },\n  _cursorEnterHandler: function _cursorEnterHandler(e) {\n    e = e || {};\n    e.originalEvent = e.originalEvent || {};\n\n    if (activeScrollable || e.originalEvent._hoverHandled) {\n      return;\n    }\n\n    if (hoveredScrollable) {\n      hoveredScrollable._cursorLeaveHandler();\n    }\n\n    hoveredScrollable = this;\n\n    this._eventHandler(\"cursorEnter\");\n\n    e.originalEvent._hoverHandled = true;\n  },\n  _cursorLeaveHandler: function _cursorLeaveHandler(e) {\n    if (hoveredScrollable !== this || activeScrollable === hoveredScrollable) {\n      return;\n    }\n\n    this._eventHandler(\"cursorLeave\");\n\n    hoveredScrollable = null;\n\n    this._refreshCursorState(e && e.relatedTarget);\n  },\n  _refreshCursorState: function _refreshCursorState(target) {\n    if (!this._isHoverMode() && (!target || activeScrollable)) {\n      return;\n    }\n\n    var $target = $(target);\n    var $scrollable = $target.closest(\".\".concat(SCROLLABLE_SIMULATED_CLASS, \":not(.dx-state-disabled)\"));\n    var targetScrollable = $scrollable.length && $scrollable.data(SCROLLABLE_STRATEGY);\n\n    if (hoveredScrollable && hoveredScrollable !== targetScrollable) {\n      hoveredScrollable._cursorLeaveHandler();\n    }\n\n    if (targetScrollable) {\n      targetScrollable._cursorEnterHandler();\n    }\n  },\n  update: function update() {\n    var _this6 = this;\n\n    var result = this._eventHandler(\"update\").done(this._updateAction);\n\n    return when(result, deferUpdate(function () {\n      var allowedDirections = _this6._allowedDirections();\n\n      deferRender(function () {\n        var touchDirection = allowedDirections.vertical ? \"pan-x\" : \"\";\n        touchDirection = allowedDirections.horizontal ? \"pan-y\" : touchDirection;\n        touchDirection = allowedDirections.vertical && allowedDirections.horizontal ? \"none\" : touchDirection;\n\n        _this6._$container.css(\"touchAction\", touchDirection);\n      });\n      return when().promise();\n    }));\n  },\n  _allowedDirections: function _allowedDirections() {\n    var bounceEnabled = this.option(\"bounceEnabled\");\n    var verticalScroller = this._scrollers[VERTICAL];\n    var horizontalScroller = this._scrollers[HORIZONTAL];\n    return {\n      vertical: verticalScroller && (verticalScroller._minOffset < 0 || bounceEnabled),\n      horizontal: horizontalScroller && (horizontalScroller._minOffset < 0 || bounceEnabled)\n    };\n  },\n  _updateBounds: function _updateBounds() {\n    this._scrollers[HORIZONTAL] && this._scrollers[HORIZONTAL]._updateBounds();\n  },\n  _isHorizontalAndRtlEnabled: function _isHorizontalAndRtlEnabled() {\n    return this.option(\"rtlEnabled\") && this.option(\"direction\") !== VERTICAL;\n  },\n  updateRtlPosition: function updateRtlPosition(needInitializeRtlConfig) {\n    var _this7 = this;\n\n    if (needInitializeRtlConfig) {\n      this._rtlConfig = {\n        scrollRight: 0,\n        clientWidth: this._$container.get(0).clientWidth,\n        windowPixelRatio: this._getWindowDevicePixelRatio()\n      };\n    }\n\n    this._updateBounds();\n\n    if (this._isHorizontalAndRtlEnabled()) {\n      deferUpdate(function () {\n        var scrollLeft = _this7._getMaxOffset().left - _this7._rtlConfig.scrollRight;\n\n        if (scrollLeft <= 0) {\n          scrollLeft = 0;\n          _this7._rtlConfig.scrollRight = _this7._getMaxOffset().left;\n        }\n\n        deferRender(function () {\n          if (_this7._getScrollOffset().left !== scrollLeft) {\n            _this7._rtlConfig.skipUpdating = true;\n\n            _this7._component.scrollTo({\n              left: scrollLeft\n            });\n\n            _this7._rtlConfig.skipUpdating = false;\n          }\n        });\n      });\n    }\n  },\n  _updateRtlConfig: function _updateRtlConfig() {\n    if (this._isHorizontalAndRtlEnabled() && !this._rtlConfig.skipUpdating) {\n      var _this$_$container$get = this._$container.get(0),\n          clientWidth = _this$_$container$get.clientWidth,\n          scrollLeft = _this$_$container$get.scrollLeft;\n\n      var windowPixelRatio = this._getWindowDevicePixelRatio();\n\n      if (this._rtlConfig.windowPixelRatio === windowPixelRatio && this._rtlConfig.clientWidth === clientWidth) {\n        this._rtlConfig.scrollRight = this._getMaxOffset().left - scrollLeft;\n      }\n\n      this._rtlConfig.clientWidth = clientWidth;\n      this._rtlConfig.windowPixelRatio = windowPixelRatio;\n    }\n  },\n  _getWindowDevicePixelRatio: function _getWindowDevicePixelRatio() {\n    return hasWindow() ? getWindow().devicePixelRatio : 1;\n  },\n  scrollBy: function scrollBy(distance) {\n    var verticalScroller = this._scrollers[VERTICAL];\n    var horizontalScroller = this._scrollers[HORIZONTAL];\n\n    if (verticalScroller) {\n      distance.top = verticalScroller._boundLocation(distance.top + verticalScroller._location) - verticalScroller._location;\n    }\n\n    if (horizontalScroller) {\n      distance.left = horizontalScroller._boundLocation(distance.left + horizontalScroller._location) - horizontalScroller._location;\n    }\n\n    this._prepareDirections(true);\n\n    this._startAction();\n\n    this._eventHandler(\"scrollBy\", {\n      x: distance.left,\n      y: distance.top\n    });\n\n    this._endAction();\n\n    this._updateRtlConfig();\n  },\n  validate: function validate(e) {\n    if (isDxMouseWheelEvent(e) && isCommandKeyPressed(e)) {\n      return false;\n    }\n\n    if (this.option(\"disabled\")) {\n      return false;\n    }\n\n    if (this.option(\"bounceEnabled\")) {\n      return true;\n    }\n\n    return isDxMouseWheelEvent(e) ? this._validateWheel(e) : this._validateMove(e);\n  },\n  _validateWheel: function _validateWheel(e) {\n    var _this8 = this;\n\n    var scroller = this._scrollers[this._wheelDirection(e)];\n\n    var reachedMin = scroller._reachedMin();\n\n    var reachedMax = scroller._reachedMax();\n\n    var contentGreaterThanContainer = !reachedMin || !reachedMax;\n    var locatedNotAtBound = !reachedMin && !reachedMax;\n    var scrollFromMin = reachedMin && e.delta > 0;\n    var scrollFromMax = reachedMax && e.delta < 0;\n    var validated = contentGreaterThanContainer && (locatedNotAtBound || scrollFromMin || scrollFromMax);\n    validated = validated || void 0 !== this._validateWheelTimer;\n\n    if (validated) {\n      clearTimeout(this._validateWheelTimer);\n      this._validateWheelTimer = setTimeout(function () {\n        _this8._validateWheelTimer = void 0;\n      }, VALIDATE_WHEEL_TIMEOUT);\n    }\n\n    return validated;\n  },\n  _validateMove: function _validateMove(e) {\n    if (!this.option(\"scrollByContent\") && !$(e.target).closest(\".\".concat(SCROLLABLE_SCROLLBAR_CLASS)).length) {\n      return false;\n    }\n\n    return this._allowedDirection();\n  },\n  getDirection: function getDirection(e) {\n    return isDxMouseWheelEvent(e) ? this._wheelDirection(e) : this._allowedDirection();\n  },\n  _wheelProp: function _wheelProp() {\n    return this._wheelDirection() === HORIZONTAL ? \"left\" : \"top\";\n  },\n  _wheelDirection: function _wheelDirection(e) {\n    switch (this.option(\"direction\")) {\n      case HORIZONTAL:\n        return HORIZONTAL;\n\n      case VERTICAL:\n        return VERTICAL;\n\n      default:\n        return e && e.shiftKey ? HORIZONTAL : VERTICAL;\n    }\n  },\n  dispose: function dispose() {\n    this._resetActive();\n\n    if (hoveredScrollable === this) {\n      hoveredScrollable = null;\n    }\n\n    this._eventHandler(\"dispose\");\n\n    this._detachEventHandlers();\n\n    this._$element.removeClass(SCROLLABLE_SIMULATED_CLASS);\n\n    this._eventForUserAction = null;\n    clearTimeout(this._validateWheelTimer);\n    clearTimeout(this._updateHandlerTimeout);\n  },\n  _detachEventHandlers: function _detachEventHandlers() {\n    eventsEngine.off(this._$element, \".\".concat(SCROLLABLE_SIMULATED_CURSOR));\n    eventsEngine.off(this._$container, \".\".concat(SCROLLABLE_SIMULATED_KEYBOARD));\n  }\n});","map":null,"metadata":{},"sourceType":"module"}