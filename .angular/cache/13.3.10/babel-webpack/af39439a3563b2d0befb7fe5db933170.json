{"ast":null,"code":"import _classCallCheck from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\n\n/**\r\n * DevExtreme (esm/ui/scheduler/appointments/appointmentCollection.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { setOuterWidth, setOuterHeight } from \"../../../core/utils/size\";\nimport $ from \"../../../core/renderer\";\nimport domAdapter from \"../../../core/dom_adapter\";\nimport eventsEngine from \"../../../events/core/events_engine\";\nimport { data as elementData } from \"../../../core/element_data\";\nimport { locate, move } from \"../../../animation/translator\";\nimport dateUtils from \"../../../core/utils/date\";\nimport { normalizeKey, grep } from \"../../../core/utils/common\";\nimport { isDefined, isDeferred, isString, isPlainObject } from \"../../../core/utils/type\";\nimport { each } from \"../../../core/utils/iterator\";\nimport { deepExtendArraySafe } from \"../../../core/utils/object\";\nimport { merge, inArray, wrapToArray } from \"../../../core/utils/array\";\nimport { extend } from \"../../../core/utils/extend\";\nimport { getPublicElement } from \"../../../core/element\";\nimport { getRecurrenceProcessor } from \"../recurrence\";\nimport registerComponent from \"../../../core/component_registrator\";\nimport { Appointment, AgendaAppointment } from \"./appointment\";\nimport { addNamespace, isFakeClickEvent } from \"../../../events/utils/index\";\nimport { name as dblclickEvent } from \"../../../events/double_click\";\nimport CollectionWidget from \"../../collection/ui.collection_widget.edit\";\nimport timeZoneUtils from \"../utils.timeZone\";\nimport { APPOINTMENT_SETTINGS_KEY } from \"../constants\";\nimport { APPOINTMENT_ITEM_CLASS, APPOINTMENT_DRAG_SOURCE_CLASS } from \"../classes\";\nimport { createAgendaAppointmentLayout, createAppointmentLayout } from \"./appointmentLayout\";\nimport { ExpressionUtils } from \"../expressionUtils\";\nimport { createAppointmentAdapter } from \"../appointmentAdapter\";\nimport { getAppointmentTakesSeveralDays, sortAppointmentsByStartDate } from \"./dataProvider/utils\";\nimport { getBoundingRect } from \"../../../core/utils/position\";\nimport { getAppointmentDateRange } from \"./resizing/core\";\nvar COMPONENT_CLASS = \"dx-scheduler-scrollable-appointments\";\nvar DBLCLICK_EVENT_NAME = addNamespace(dblclickEvent, \"dxSchedulerAppointment\");\nvar toMs = dateUtils.dateToMilliseconds;\n\nvar SchedulerAppointments = /*#__PURE__*/function (_CollectionWidget) {\n  _inherits(SchedulerAppointments, _CollectionWidget);\n\n  var _super = _createSuper(SchedulerAppointments);\n\n  function SchedulerAppointments(element, options) {\n    var _this;\n\n    _classCallCheck(this, SchedulerAppointments);\n\n    _this = _super.call(this, element, options);\n    _this._virtualAppointments = {};\n    return _this;\n  }\n\n  _createClass(SchedulerAppointments, [{\n    key: \"isAgendaView\",\n    get: function get() {\n      return this.invoke(\"isCurrentViewAgenda\");\n    }\n  }, {\n    key: \"isVirtualScrolling\",\n    get: function get() {\n      return this.invoke(\"isVirtualScrolling\");\n    }\n  }, {\n    key: \"appointmentDataProvider\",\n    get: function get() {\n      return this.option(\"getAppointmentDataProvider\")();\n    }\n  }, {\n    key: \"notifyObserver\",\n    value: function notifyObserver(subject, args) {\n      var observer = this.option(\"observer\");\n\n      if (observer) {\n        observer.fire(subject, args);\n      }\n    }\n  }, {\n    key: \"invoke\",\n    value: function invoke() {\n      var observer = this.option(\"observer\");\n\n      if (observer) {\n        return observer.fire.apply(observer, arguments);\n      }\n    }\n  }, {\n    key: \"_dispose\",\n    value: function _dispose() {\n      clearTimeout(this._appointmentClickTimeout);\n\n      _get(_getPrototypeOf(SchedulerAppointments.prototype), \"_dispose\", this).call(this);\n    }\n  }, {\n    key: \"_supportedKeys\",\n    value: function _supportedKeys() {\n      var parent = _get(_getPrototypeOf(SchedulerAppointments.prototype), \"_supportedKeys\", this).call(this);\n\n      return extend(parent, {\n        escape: function () {\n          this.moveAppointmentBack();\n          this._escPressed = true;\n        }.bind(this),\n        del: function (e) {\n          if (this.option(\"allowDelete\")) {\n            e.preventDefault();\n\n            var data = this._getItemData(e.target);\n\n            this.notifyObserver(\"onDeleteButtonPress\", {\n              data: data,\n              target: e.target\n            });\n          }\n        }.bind(this),\n        tab: function tab(e) {\n          var appointments = this._getAccessAppointments();\n\n          var focusedAppointment = appointments.filter(\".dx-state-focused\");\n          var index = focusedAppointment.data(APPOINTMENT_SETTINGS_KEY).sortedIndex;\n          var lastIndex = appointments.length - 1;\n\n          if (index > 0 && e.shiftKey || index < lastIndex && !e.shiftKey) {\n            e.preventDefault();\n            e.shiftKey ? index-- : index++;\n\n            var $nextAppointment = this._getAppointmentByIndex(index);\n\n            this._resetTabIndex($nextAppointment);\n\n            eventsEngine.trigger($nextAppointment, \"focus\");\n          }\n        }\n      });\n    }\n  }, {\n    key: \"_getAppointmentByIndex\",\n    value: function _getAppointmentByIndex(sortedIndex) {\n      var appointments = this._getAccessAppointments();\n\n      return appointments.filter(function (_, $item) {\n        return elementData($item, APPOINTMENT_SETTINGS_KEY).sortedIndex === sortedIndex;\n      }).eq(0);\n    }\n  }, {\n    key: \"_getAccessAppointments\",\n    value: function _getAccessAppointments() {\n      return this._itemElements().filter(\":visible\").not(\".dx-state-disabled\");\n    }\n  }, {\n    key: \"_resetTabIndex\",\n    value: function _resetTabIndex($appointment) {\n      this._focusTarget().attr(\"tabIndex\", -1);\n\n      $appointment.attr(\"tabIndex\", this.option(\"tabIndex\"));\n    }\n  }, {\n    key: \"_moveFocus\",\n    value: function _moveFocus() {}\n  }, {\n    key: \"_focusTarget\",\n    value: function _focusTarget() {\n      return this._itemElements();\n    }\n  }, {\n    key: \"_renderFocusTarget\",\n    value: function _renderFocusTarget() {\n      var $appointment = this._getAppointmentByIndex(0);\n\n      this._resetTabIndex($appointment);\n    }\n  }, {\n    key: \"_focusInHandler\",\n    value: function _focusInHandler(e) {\n      _get(_getPrototypeOf(SchedulerAppointments.prototype), \"_focusInHandler\", this).call(this, e);\n\n      this._$currentAppointment = $(e.target);\n      this.option(\"focusedElement\", getPublicElement($(e.target)));\n    }\n  }, {\n    key: \"_focusOutHandler\",\n    value: function _focusOutHandler(e) {\n      var $appointment = this._getAppointmentByIndex(0);\n\n      this.option(\"focusedElement\", getPublicElement($appointment));\n\n      _get(_getPrototypeOf(SchedulerAppointments.prototype), \"_focusOutHandler\", this).call(this, e);\n    }\n  }, {\n    key: \"_eventBindingTarget\",\n    value: function _eventBindingTarget() {\n      return this._itemContainer();\n    }\n  }, {\n    key: \"_getDefaultOptions\",\n    value: function _getDefaultOptions() {\n      return extend(_get(_getPrototypeOf(SchedulerAppointments.prototype), \"_getDefaultOptions\", this).call(this), {\n        noDataText: null,\n        activeStateEnabled: true,\n        hoverStateEnabled: true,\n        tabIndex: 0,\n        fixedContainer: null,\n        allDayContainer: null,\n        allowDrag: true,\n        allowResize: true,\n        allowAllDayResize: true,\n        onAppointmentDblClick: null,\n        _collectorOffset: 0,\n        groups: [],\n        resources: []\n      });\n    }\n  }, {\n    key: \"_optionChanged\",\n    value: function _optionChanged(args) {\n      if (this.option(\"isRenovatedAppointments\")) {\n        return;\n      }\n\n      switch (args.name) {\n        case \"items\":\n          this._cleanFocusState();\n\n          this._clearDropDownItems();\n\n          this._clearDropDownItemsElements();\n\n          this._repaintAppointments(args.value);\n\n          this._renderDropDownAppointments();\n\n          this._attachAppointmentsEvents();\n\n          break;\n\n        case \"fixedContainer\":\n        case \"allDayContainer\":\n        case \"onAppointmentDblClick\":\n          break;\n\n        case \"allowDrag\":\n        case \"allowResize\":\n        case \"allowAllDayResize\":\n          this._invalidate();\n\n          break;\n\n        case \"focusedElement\":\n          this._resetTabIndex($(args.value));\n\n          _get(_getPrototypeOf(SchedulerAppointments.prototype), \"_optionChanged\", this).call(this, args);\n\n          break;\n\n        case \"allowDelete\":\n          break;\n\n        case \"focusStateEnabled\":\n          this._clearDropDownItemsElements();\n\n          this._renderDropDownAppointments();\n\n          _get(_getPrototypeOf(SchedulerAppointments.prototype), \"_optionChanged\", this).call(this, args);\n\n          break;\n\n        default:\n          _get(_getPrototypeOf(SchedulerAppointments.prototype), \"_optionChanged\", this).call(this, args);\n\n      }\n    }\n  }, {\n    key: \"_isAllDayAppointment\",\n    value: function _isAllDayAppointment(appointment) {\n      return appointment.settings.length && appointment.settings[0].allDay || false;\n    }\n  }, {\n    key: \"_isRepaintAppointment\",\n    value: function _isRepaintAppointment(appointment) {\n      return !isDefined(appointment.needRepaint) || true === appointment.needRepaint;\n    }\n  }, {\n    key: \"_isRepaintAll\",\n    value: function _isRepaintAll(appointments) {\n      if (this.isAgendaView) {\n        return true;\n      }\n\n      for (var i = 0; i < appointments.length; i++) {\n        if (!this._isRepaintAppointment(appointments[i])) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"_applyFragment\",\n    value: function _applyFragment(fragment, allDay) {\n      if (fragment.children().length > 0) {\n        this._getAppointmentContainer(allDay).append(fragment);\n      }\n    }\n  }, {\n    key: \"_onEachAppointment\",\n    value: function _onEachAppointment(appointment, index, container, isRepaintAll) {\n      var _this2 = this;\n\n      if (true === (null === appointment || void 0 === appointment ? void 0 : appointment.needRemove)) {\n        this._clearItem(appointment);\n      } else if (isRepaintAll || this._isRepaintAppointment(appointment)) {\n        (function () {\n          appointment.needRepaint = false;\n\n          _this2._clearItem(appointment);\n\n          _this2._renderItem(index, appointment, container);\n        })();\n      }\n    }\n  }, {\n    key: \"_repaintAppointments\",\n    value: function _repaintAppointments(appointments) {\n      var _this3 = this;\n\n      this._renderByFragments(function ($commonFragment, $allDayFragment) {\n        var isRepaintAll = _this3._isRepaintAll(appointments);\n\n        if (isRepaintAll) {\n          _this3._getAppointmentContainer(true).html(\"\");\n\n          _this3._getAppointmentContainer(false).html(\"\");\n        }\n\n        !appointments.length && _this3._cleanItemContainer();\n        appointments.forEach(function (appointment, index) {\n          var container = _this3._isAllDayAppointment(appointment) ? $allDayFragment : $commonFragment;\n\n          _this3._onEachAppointment(appointment, index, container, isRepaintAll);\n        });\n      });\n    }\n  }, {\n    key: \"_renderByFragments\",\n    value: function _renderByFragments(renderFunction) {\n      if (this.isVirtualScrolling) {\n        var $commonFragment = $(domAdapter.createDocumentFragment());\n        var $allDayFragment = $(domAdapter.createDocumentFragment());\n        renderFunction($commonFragment, $allDayFragment);\n\n        this._applyFragment($commonFragment, false);\n\n        this._applyFragment($allDayFragment, true);\n      } else {\n        renderFunction(this._getAppointmentContainer(false), this._getAppointmentContainer(true));\n      }\n    }\n  }, {\n    key: \"_attachAppointmentsEvents\",\n    value: function _attachAppointmentsEvents() {\n      this._attachClickEvent();\n\n      this._attachHoldEvent();\n\n      this._attachContextMenuEvent();\n\n      this._attachAppointmentDblClick();\n\n      this._renderFocusState();\n\n      this._attachFeedbackEvents();\n\n      this._attachHoverEvents();\n    }\n  }, {\n    key: \"_clearItem\",\n    value: function _clearItem(item) {\n      var $items = this._findItemElementByItem(item.itemData);\n\n      if (!$items.length) {\n        return;\n      }\n\n      each($items, function (_, $item) {\n        $item.detach();\n        $item.remove();\n      });\n    }\n  }, {\n    key: \"_clearDropDownItems\",\n    value: function _clearDropDownItems() {\n      this._virtualAppointments = {};\n    }\n  }, {\n    key: \"_clearDropDownItemsElements\",\n    value: function _clearDropDownItemsElements() {\n      this.invoke(\"clearCompactAppointments\");\n    }\n  }, {\n    key: \"_findItemElementByItem\",\n    value: function _findItemElementByItem(item) {\n      var result = [];\n      var that = this;\n      this.itemElements().each(function () {\n        var $item = $(this);\n\n        if ($item.data(that._itemDataKey()) === item) {\n          result.push($item);\n        }\n      });\n      return result;\n    }\n  }, {\n    key: \"_itemClass\",\n    value: function _itemClass() {\n      return APPOINTMENT_ITEM_CLASS;\n    }\n  }, {\n    key: \"_itemContainer\",\n    value: function _itemContainer() {\n      var $container = _get(_getPrototypeOf(SchedulerAppointments.prototype), \"_itemContainer\", this).call(this);\n\n      var $result = $container;\n      var $allDayContainer = this.option(\"allDayContainer\");\n\n      if ($allDayContainer) {\n        $result = $container.add($allDayContainer);\n      }\n\n      return $result;\n    }\n  }, {\n    key: \"_cleanItemContainer\",\n    value: function _cleanItemContainer() {\n      _get(_getPrototypeOf(SchedulerAppointments.prototype), \"_cleanItemContainer\", this).call(this);\n\n      var $allDayContainer = this.option(\"allDayContainer\");\n\n      if ($allDayContainer) {\n        $allDayContainer.empty();\n      }\n\n      this._virtualAppointments = {};\n    }\n  }, {\n    key: \"_clean\",\n    value: function _clean() {\n      _get(_getPrototypeOf(SchedulerAppointments.prototype), \"_clean\", this).call(this);\n\n      delete this._$currentAppointment;\n      delete this._initialSize;\n      delete this._initialCoordinates;\n    }\n  }, {\n    key: \"_init\",\n    value: function _init() {\n      _get(_getPrototypeOf(SchedulerAppointments.prototype), \"_init\", this).call(this);\n\n      this.$element().addClass(COMPONENT_CLASS);\n      this._preventSingleAppointmentClick = false;\n    }\n  }, {\n    key: \"_renderAppointmentTemplate\",\n    value: function _renderAppointmentTemplate($container, appointment, model) {\n      var config = {\n        isAllDay: appointment.allDay,\n        isRecurrence: appointment.recurrenceRule,\n        html: isPlainObject(appointment) && appointment.html ? appointment.html : void 0\n      };\n      var formatText = this.invoke(\"getTextAndFormatDate\", model.appointmentData, this._currentAppointmentSettings.agendaSettings || model.targetedAppointmentData, \"TIME\");\n      $container.append(this.isAgendaView ? createAgendaAppointmentLayout(formatText, config) : createAppointmentLayout(formatText, config));\n    }\n  }, {\n    key: \"_executeItemRenderAction\",\n    value: function _executeItemRenderAction(index, itemData, itemElement) {\n      var action = this._getItemRenderAction();\n\n      if (action) {\n        action(this.invoke(\"mapAppointmentFields\", {\n          itemData: itemData,\n          itemElement: itemElement\n        }));\n      }\n\n      delete this._currentAppointmentSettings;\n    }\n  }, {\n    key: \"_itemClickHandler\",\n    value: function _itemClickHandler(e) {\n      _get(_getPrototypeOf(SchedulerAppointments.prototype), \"_itemClickHandler\", this).call(this, e, {}, {\n        afterExecute: function (e) {\n          this._processItemClick(e.args[0].event);\n        }.bind(this)\n      });\n    }\n  }, {\n    key: \"_processItemClick\",\n    value: function _processItemClick(e) {\n      var $target = $(e.currentTarget);\n\n      var data = this._getItemData($target);\n\n      if (\"keydown\" === e.type || isFakeClickEvent(e)) {\n        this.notifyObserver(\"showEditAppointmentPopup\", {\n          data: data,\n          target: $target\n        });\n        return;\n      }\n\n      this._appointmentClickTimeout = setTimeout(function () {\n        if (!this._preventSingleAppointmentClick && domAdapter.getBody().contains($target[0])) {\n          this.notifyObserver(\"showAppointmentTooltip\", {\n            data: data,\n            target: $target\n          });\n        }\n\n        this._preventSingleAppointmentClick = false;\n      }.bind(this), 300);\n    }\n  }, {\n    key: \"_extendActionArgs\",\n    value: function _extendActionArgs($itemElement) {\n      var args = _get(_getPrototypeOf(SchedulerAppointments.prototype), \"_extendActionArgs\", this).call(this, $itemElement);\n\n      return this.invoke(\"mapAppointmentFields\", args);\n    }\n  }, {\n    key: \"_render\",\n    value: function _render() {\n      _get(_getPrototypeOf(SchedulerAppointments.prototype), \"_render\", this).call(this);\n\n      this._attachAppointmentDblClick();\n    }\n  }, {\n    key: \"_attachAppointmentDblClick\",\n    value: function _attachAppointmentDblClick() {\n      var that = this;\n\n      var itemSelector = that._itemSelector();\n\n      var itemContainer = this._itemContainer();\n\n      eventsEngine.off(itemContainer, DBLCLICK_EVENT_NAME, itemSelector);\n      eventsEngine.on(itemContainer, DBLCLICK_EVENT_NAME, itemSelector, function (e) {\n        that._itemDXEventHandler(e, \"onAppointmentDblClick\", {}, {\n          afterExecute: function afterExecute(e) {\n            that._dblClickHandler(e.args[0].event);\n          }\n        });\n      });\n    }\n  }, {\n    key: \"_dblClickHandler\",\n    value: function _dblClickHandler(e) {\n      var $targetAppointment = $(e.currentTarget);\n\n      var appointmentData = this._getItemData($targetAppointment);\n\n      clearTimeout(this._appointmentClickTimeout);\n      this._preventSingleAppointmentClick = true;\n      this.notifyObserver(\"showEditAppointmentPopup\", {\n        data: appointmentData,\n        target: $targetAppointment\n      });\n    }\n  }, {\n    key: \"_renderItem\",\n    value: function _renderItem(index, item, container) {\n      var itemData = item.itemData;\n      var $items = [];\n\n      for (var i = 0; i < item.settings.length; i++) {\n        var setting = item.settings[i];\n        this._currentAppointmentSettings = setting;\n\n        var $item = _get(_getPrototypeOf(SchedulerAppointments.prototype), \"_renderItem\", this).call(this, index, itemData, container);\n\n        $item.data(APPOINTMENT_SETTINGS_KEY, setting);\n        $items.push($item);\n      }\n\n      return $items;\n    }\n  }, {\n    key: \"_getItemContent\",\n    value: function _getItemContent($itemFrame) {\n      $itemFrame.data(APPOINTMENT_SETTINGS_KEY, this._currentAppointmentSettings);\n\n      var $itemContent = _get(_getPrototypeOf(SchedulerAppointments.prototype), \"_getItemContent\", this).call(this, $itemFrame);\n\n      return $itemContent;\n    }\n  }, {\n    key: \"_createItemByTemplate\",\n    value: function _createItemByTemplate(itemTemplate, renderArgs) {\n      var itemData = renderArgs.itemData,\n          container = renderArgs.container,\n          index = renderArgs.index;\n      return itemTemplate.render({\n        model: {\n          appointmentData: itemData,\n          targetedAppointmentData: this.invoke(\"getTargetedAppointmentData\", itemData, $(container).parent())\n        },\n        container: container,\n        index: index\n      });\n    }\n  }, {\n    key: \"_getAppointmentContainer\",\n    value: function _getAppointmentContainer(allDay) {\n      var $allDayContainer = this.option(\"allDayContainer\");\n      var $container = this.itemsContainer().not($allDayContainer);\n\n      if (allDay && $allDayContainer) {\n        $container = $allDayContainer;\n      }\n\n      return $container;\n    }\n  }, {\n    key: \"_postprocessRenderItem\",\n    value: function _postprocessRenderItem(args) {\n      this._renderAppointment(args.itemElement, this._currentAppointmentSettings);\n    }\n  }, {\n    key: \"_renderAppointment\",\n    value: function _renderAppointment(element, settings) {\n      element.data(APPOINTMENT_SETTINGS_KEY, settings);\n\n      this._applyResourceDataAttr(element);\n\n      var rawAppointment = this._getItemData(element);\n\n      var geometry = this.invoke(\"getAppointmentGeometry\", settings);\n      var allowResize = this.option(\"allowResize\") && (!isDefined(settings.skipResizing) || isString(settings.skipResizing));\n      var allowDrag = this.option(\"allowDrag\");\n      var allDay = settings.allDay;\n      this.invoke(\"setCellDataCacheAlias\", this._currentAppointmentSettings, geometry);\n\n      if (settings.virtual) {\n        var appointmentConfig = {\n          itemData: rawAppointment,\n          groupIndex: settings.groupIndex,\n          groups: this.option(\"groups\")\n        };\n        var deferredColor = this.option(\"getAppointmentColor\")(appointmentConfig);\n\n        this._processVirtualAppointment(settings, element, rawAppointment, deferredColor);\n      } else {\n        var _settings$info;\n\n        var config = {\n          data: rawAppointment,\n          groupIndex: settings.groupIndex,\n          observer: this.option(\"observer\"),\n          geometry: geometry,\n          direction: settings.direction || \"vertical\",\n          allowResize: allowResize,\n          allowDrag: allowDrag,\n          allDay: allDay,\n          reduced: settings.appointmentReduced,\n          isCompact: settings.isCompact,\n          startDate: new Date(null === (_settings$info = settings.info) || void 0 === _settings$info ? void 0 : _settings$info.appointment.startDate),\n          cellWidth: this.invoke(\"getCellWidth\"),\n          cellHeight: this.invoke(\"getCellHeight\"),\n          resizableConfig: this._resizableConfig(rawAppointment, settings),\n          groups: this.option(\"groups\"),\n          getAppointmentColor: this.option(\"getAppointmentColor\"),\n          getResourceDataAccessors: this.option(\"getResourceDataAccessors\")\n        };\n\n        if (this.isAgendaView) {\n          var agendaResourceProcessor = this.option(\"getAgendaResourceProcessor\")();\n\n          config.createPlainResourceListAsync = function (rawAppointment) {\n            return agendaResourceProcessor.createListAsync(rawAppointment);\n          };\n        }\n\n        this._createComponent(element, this.isAgendaView ? AgendaAppointment : Appointment, _extends({}, config, {\n          dataAccessors: this.option(\"dataAccessors\"),\n          getResizableStep: this.option(\"getResizableStep\")\n        }));\n      }\n    }\n  }, {\n    key: \"_applyResourceDataAttr\",\n    value: function _applyResourceDataAttr($appointment) {\n      var dataAccessors = this.option(\"getResourceDataAccessors\")();\n\n      var rawAppointment = this._getItemData($appointment);\n\n      each(dataAccessors.getter, function (key) {\n        var value = dataAccessors.getter[key](rawAppointment);\n\n        if (isDefined(value)) {\n          var prefix = \"data-\".concat(normalizeKey(key.toLowerCase()), \"-\");\n          wrapToArray(value).forEach(function (value) {\n            return $appointment.attr(prefix + normalizeKey(value), true);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"_resizableConfig\",\n    value: function _resizableConfig(appointmentData, itemSetting) {\n      return {\n        area: this._calculateResizableArea(itemSetting, appointmentData),\n        onResizeStart: function (e) {\n          this._$currentAppointment = $(e.element);\n\n          if (this.invoke(\"needRecalculateResizableArea\")) {\n            var updatedArea = this._calculateResizableArea(this._$currentAppointment.data(APPOINTMENT_SETTINGS_KEY), this._$currentAppointment.data(\"dxItemData\"));\n\n            e.component.option(\"area\", updatedArea);\n\n            e.component._renderDragOffsets(e.event);\n          }\n\n          this._initialSize = {\n            width: e.width,\n            height: e.height\n          };\n          this._initialCoordinates = locate(this._$currentAppointment);\n        }.bind(this),\n        onResizeEnd: function (e) {\n          if (this._escPressed) {\n            e.event.cancel = true;\n            return;\n          }\n\n          this._resizeEndHandler(e);\n        }.bind(this)\n      };\n    }\n  }, {\n    key: \"_calculateResizableArea\",\n    value: function _calculateResizableArea(itemSetting, appointmentData) {\n      var area = this.$element().closest(\".dx-scrollable-content\");\n      return this.invoke(\"getResizableAppointmentArea\", {\n        coordinates: {\n          left: itemSetting.left,\n          top: 0,\n          groupIndex: itemSetting.groupIndex\n        },\n        allDay: itemSetting.allDay\n      }) || area;\n    }\n  }, {\n    key: \"_resizeEndHandler\",\n    value: function _resizeEndHandler(e) {\n      var $element = $(e.element);\n\n      var _$element$data = $element.data(\"dxAppointmentSettings\"),\n          allDay = _$element$data.allDay,\n          info = _$element$data.info;\n\n      var sourceAppointment = this._getItemData($element);\n\n      var dateRange = {};\n\n      if (allDay) {\n        dateRange = this.resizeAllDay(e);\n      } else {\n        var startDate = this._getEndResizeAppointmentStartDate(e, sourceAppointment, info.appointment);\n\n        var endDate = info.appointment.endDate;\n        dateRange = this._getDateRange(e, startDate, endDate);\n      }\n\n      this.updateResizedAppointment($element, dateRange, this.option(\"dataAccessors\"), this.option(\"timeZoneCalculator\"));\n    }\n  }, {\n    key: \"resizeAllDay\",\n    value: function resizeAllDay(e) {\n      var $element = $(e.element);\n      var timeZoneCalculator = this.option(\"timeZoneCalculator\");\n      var dataAccessors = this.option(\"dataAccessors\");\n      return getAppointmentDateRange({\n        handles: e.handles,\n        appointmentSettings: $element.data(\"dxAppointmentSettings\"),\n        isVerticalViewDirection: this.option(\"isVerticalViewDirection\")(),\n        isVerticalGroupedWorkSpace: this.option(\"isVerticalGroupedWorkSpace\")(),\n        appointmentRect: getBoundingRect($element[0]),\n        parentAppointmentRect: getBoundingRect($element.parent()[0]),\n        viewDataProvider: this.option(\"getViewDataProvider\")(),\n        isDateAndTimeView: this.option(\"isDateAndTimeView\")(),\n        startDayHour: this.invoke(\"getStartDayHour\"),\n        endDayHour: this.invoke(\"getEndDayHour\"),\n        timeZoneCalculator: timeZoneCalculator,\n        dataAccessors: dataAccessors,\n        rtlEnabled: this.option(\"rtlEnabled\"),\n        DOMMetaData: this.option(\"getDOMElementsMetaData\")()\n      });\n    }\n  }, {\n    key: \"updateResizedAppointment\",\n    value: function updateResizedAppointment($element, dateRange, dataAccessors, timeZoneCalculator) {\n      var sourceAppointment = this._getItemData($element);\n\n      var modifiedAppointmentAdapter = createAppointmentAdapter(sourceAppointment, dataAccessors, timeZoneCalculator).clone();\n      modifiedAppointmentAdapter.startDate = new Date(dateRange.startDate);\n      modifiedAppointmentAdapter.endDate = new Date(dateRange.endDate);\n      this.notifyObserver(\"updateAppointmentAfterResize\", {\n        target: sourceAppointment,\n        data: modifiedAppointmentAdapter.clone({\n          pathTimeZone: \"fromGrid\"\n        }).source(),\n        $appointment: $element\n      });\n    }\n  }, {\n    key: \"_getEndResizeAppointmentStartDate\",\n    value: function _getEndResizeAppointmentStartDate(e, rawAppointment, appointmentInfo) {\n      var timeZoneCalculator = this.option(\"timeZoneCalculator\");\n      var appointmentAdapter = createAppointmentAdapter(rawAppointment, this.option(\"dataAccessors\"), timeZoneCalculator);\n      var startDate = appointmentInfo.startDate;\n      var recurrenceProcessor = getRecurrenceProcessor();\n      var recurrenceRule = appointmentAdapter.recurrenceRule,\n          startDateTimeZone = appointmentAdapter.startDateTimeZone;\n      var isAllDay = this.invoke(\"isAllDay\", rawAppointment);\n      var isRecurrent = recurrenceProcessor.isValidRecurrenceRule(recurrenceRule);\n\n      if (!e.handles.top && !isRecurrent && !isAllDay) {\n        startDate = timeZoneCalculator.createDate(appointmentAdapter.startDate, {\n          appointmentTimeZone: startDateTimeZone,\n          path: \"toGrid\"\n        });\n      }\n\n      return startDate;\n    }\n  }, {\n    key: \"_getDateRange\",\n    value: function _getDateRange(e, startDate, endDate) {\n      var itemData = this._getItemData(e.element);\n\n      var deltaTime = this.invoke(\"getDeltaTime\", e, this._initialSize, itemData);\n      var renderingStrategyDirection = this.invoke(\"getRenderingStrategyDirection\");\n      var isStartDateChanged = false;\n      var isAllDay = this.invoke(\"isAllDay\", itemData);\n      var needCorrectDates = this.invoke(\"needCorrectAppointmentDates\") && !isAllDay;\n      var startTime;\n      var endTime;\n\n      if (\"vertical\" !== renderingStrategyDirection || isAllDay) {\n        isStartDateChanged = this.option(\"rtlEnabled\") ? e.handles.right : e.handles.left;\n      } else {\n        isStartDateChanged = e.handles.top;\n      }\n\n      if (isStartDateChanged) {\n        startTime = needCorrectDates ? this._correctStartDateByDelta(startDate, deltaTime) : startDate.getTime() - deltaTime;\n        startTime += timeZoneUtils.getTimezoneOffsetChangeInMs(startDate, endDate, startTime, endDate);\n        endTime = endDate.getTime();\n      } else {\n        startTime = startDate.getTime();\n        endTime = needCorrectDates ? this._correctEndDateByDelta(endDate, deltaTime) : endDate.getTime() + deltaTime;\n        endTime -= timeZoneUtils.getTimezoneOffsetChangeInMs(startDate, endDate, startDate, endTime);\n      }\n\n      return {\n        startDate: new Date(startTime),\n        endDate: new Date(endTime)\n      };\n    }\n  }, {\n    key: \"_correctEndDateByDelta\",\n    value: function _correctEndDateByDelta(endDate, deltaTime) {\n      var endDayHour = this.invoke(\"getEndDayHour\");\n      var startDayHour = this.invoke(\"getStartDayHour\");\n      var result = endDate.getTime() + deltaTime;\n      var visibleDayDuration = (endDayHour - startDayHour) * toMs(\"hour\");\n      var daysCount = deltaTime > 0 ? Math.ceil(deltaTime / visibleDayDuration) : Math.floor(deltaTime / visibleDayDuration);\n      var maxDate = new Date(endDate);\n      var minDate = new Date(endDate);\n      minDate.setHours(startDayHour, 0, 0, 0);\n      maxDate.setHours(endDayHour, 0, 0, 0);\n\n      if (result > maxDate.getTime() || result <= minDate.getTime()) {\n        var tailOfCurrentDay = maxDate.getTime() - endDate.getTime();\n        var tailOfPrevDays = deltaTime - tailOfCurrentDay;\n        var lastDay = new Date(endDate.setDate(endDate.getDate() + daysCount));\n        lastDay.setHours(startDayHour, 0, 0, 0);\n        result = lastDay.getTime() + tailOfPrevDays - visibleDayDuration * (daysCount - 1);\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_correctStartDateByDelta\",\n    value: function _correctStartDateByDelta(startDate, deltaTime) {\n      var endDayHour = this.invoke(\"getEndDayHour\");\n      var startDayHour = this.invoke(\"getStartDayHour\");\n      var result = startDate.getTime() - deltaTime;\n      var visibleDayDuration = (endDayHour - startDayHour) * toMs(\"hour\");\n      var daysCount = deltaTime > 0 ? Math.ceil(deltaTime / visibleDayDuration) : Math.floor(deltaTime / visibleDayDuration);\n      var maxDate = new Date(startDate);\n      var minDate = new Date(startDate);\n      minDate.setHours(startDayHour, 0, 0, 0);\n      maxDate.setHours(endDayHour, 0, 0, 0);\n\n      if (result < minDate.getTime() || result >= maxDate.getTime()) {\n        var tailOfCurrentDay = startDate.getTime() - minDate.getTime();\n        var tailOfPrevDays = deltaTime - tailOfCurrentDay;\n        var firstDay = new Date(startDate.setDate(startDate.getDate() - daysCount));\n        firstDay.setHours(endDayHour, 0, 0, 0);\n        result = firstDay.getTime() - tailOfPrevDays + visibleDayDuration * (daysCount - 1);\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_processVirtualAppointment\",\n    value: function _processVirtualAppointment(appointmentSetting, $appointment, appointmentData, color) {\n      var virtualAppointment = appointmentSetting.virtual;\n      var virtualGroupIndex = virtualAppointment.index;\n\n      if (!isDefined(this._virtualAppointments[virtualGroupIndex])) {\n        this._virtualAppointments[virtualGroupIndex] = {\n          coordinates: {\n            top: virtualAppointment.top,\n            left: virtualAppointment.left\n          },\n          items: {\n            data: [],\n            colors: [],\n            settings: []\n          },\n          isAllDay: virtualAppointment.isAllDay ? true : false,\n          buttonColor: color\n        };\n      }\n\n      appointmentSetting.targetedAppointmentData = this.invoke(\"getTargetedAppointmentData\", appointmentData, $appointment);\n\n      this._virtualAppointments[virtualGroupIndex].items.settings.push(appointmentSetting);\n\n      this._virtualAppointments[virtualGroupIndex].items.data.push(appointmentData);\n\n      this._virtualAppointments[virtualGroupIndex].items.colors.push(color);\n\n      $appointment.remove();\n    }\n  }, {\n    key: \"_renderContentImpl\",\n    value: function _renderContentImpl() {\n      _get(_getPrototypeOf(SchedulerAppointments.prototype), \"_renderContentImpl\", this).call(this);\n\n      this._renderDropDownAppointments();\n    }\n  }, {\n    key: \"_renderDropDownAppointments\",\n    value: function _renderDropDownAppointments() {\n      var _this4 = this;\n\n      this._renderByFragments(function ($commonFragment, $allDayFragment) {\n        each(_this4._virtualAppointments, function (groupIndex) {\n          var virtualGroup = this._virtualAppointments[groupIndex];\n          var virtualItems = virtualGroup.items;\n          var virtualCoordinates = virtualGroup.coordinates;\n          var $fragment = virtualGroup.isAllDay ? $allDayFragment : $commonFragment;\n          var left = virtualCoordinates.left;\n          var buttonWidth = this.invoke(\"getDropDownAppointmentWidth\", virtualGroup.isAllDay);\n          var buttonHeight = this.invoke(\"getDropDownAppointmentHeight\");\n          var rtlOffset = this.option(\"rtlEnabled\") ? buttonWidth : 0;\n          this.notifyObserver(\"renderCompactAppointments\", {\n            $container: $fragment,\n            coordinates: {\n              top: virtualCoordinates.top,\n              left: left + rtlOffset\n            },\n            items: virtualItems,\n            buttonColor: virtualGroup.buttonColor,\n            width: buttonWidth - this.option(\"_collectorOffset\"),\n            height: buttonHeight,\n            onAppointmentClick: this.option(\"onItemClick\"),\n            allowDrag: this.option(\"allowDrag\"),\n            cellWidth: this.invoke(\"getCellWidth\"),\n            isCompact: this.invoke(\"isAdaptive\") || this._isGroupCompact(virtualGroup)\n          });\n        }.bind(_this4));\n      });\n    }\n  }, {\n    key: \"_isGroupCompact\",\n    value: function _isGroupCompact(virtualGroup) {\n      return !virtualGroup.isAllDay && this.invoke(\"supportCompactDropDownAppointments\");\n    }\n  }, {\n    key: \"_sortAppointmentsByStartDate\",\n    value: function _sortAppointmentsByStartDate(appointments) {\n      return sortAppointmentsByStartDate(appointments, this.option(\"dataAccessors\"));\n    }\n  }, {\n    key: \"_processRecurrenceAppointment\",\n    value: function _processRecurrenceAppointment(appointment, index, skipLongAppointments) {\n      var recurrenceRule = ExpressionUtils.getField(this.option(\"dataAccessors\"), \"recurrenceRule\", appointment);\n      var result = {\n        parts: [],\n        indexes: []\n      };\n\n      if (recurrenceRule) {\n        var dates = appointment.settings || appointment;\n        var startDate = new Date(ExpressionUtils.getField(this.option(\"dataAccessors\"), \"startDate\", dates));\n        var endDate = new Date(ExpressionUtils.getField(this.option(\"dataAccessors\"), \"endDate\", dates));\n        var appointmentDuration = endDate.getTime() - startDate.getTime();\n        var recurrenceException = ExpressionUtils.getField(this.option(\"dataAccessors\"), \"recurrenceException\", appointment);\n        var startViewDate = this.invoke(\"getStartViewDate\");\n        var endViewDate = this.invoke(\"getEndViewDate\");\n        var recurrentDates = getRecurrenceProcessor().generateDates({\n          rule: recurrenceRule,\n          exception: recurrenceException,\n          start: startDate,\n          end: endDate,\n          min: startViewDate,\n          max: endViewDate\n        });\n        var recurrentDateCount = appointment.settings ? 1 : recurrentDates.length;\n\n        for (var i = 0; i < recurrentDateCount; i++) {\n          var appointmentPart = extend({}, appointment, true);\n\n          if (recurrentDates[i]) {\n            var appointmentSettings = this._applyStartDateToObj(recurrentDates[i], {});\n\n            this._applyEndDateToObj(new Date(recurrentDates[i].getTime() + appointmentDuration), appointmentSettings);\n\n            appointmentPart.settings = appointmentSettings;\n          } else {\n            appointmentPart.settings = dates;\n          }\n\n          result.parts.push(appointmentPart);\n\n          if (!skipLongAppointments) {\n            this._processLongAppointment(appointmentPart, result);\n          }\n        }\n\n        result.indexes.push(index);\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_processLongAppointment\",\n    value: function _processLongAppointment(appointment, result) {\n      var parts = this.splitAppointmentByDay(appointment);\n      var partCount = parts.length;\n      var endViewDate = this.invoke(\"getEndViewDate\").getTime();\n      var startViewDate = this.invoke(\"getStartViewDate\").getTime();\n      var timeZoneCalculator = this.option(\"timeZoneCalculator\");\n      result = result || {\n        parts: []\n      };\n\n      if (partCount > 1) {\n        extend(appointment, parts[0]);\n\n        for (var i = 1; i < partCount; i++) {\n          var startDate = ExpressionUtils.getField(this.option(\"dataAccessors\"), \"startDate\", parts[i].settings).getTime();\n          startDate = timeZoneCalculator.createDate(startDate, {\n            path: \"toGrid\"\n          });\n\n          if (startDate < endViewDate && startDate > startViewDate) {\n            result.parts.push(parts[i]);\n          }\n        }\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_reduceRecurrenceAppointments\",\n    value: function _reduceRecurrenceAppointments(recurrenceIndexes, appointments) {\n      each(recurrenceIndexes, function (i, index) {\n        appointments.splice(index - i, 1);\n      });\n    }\n  }, {\n    key: \"_combineAppointments\",\n    value: function _combineAppointments(appointments, additionalAppointments) {\n      if (additionalAppointments.length) {\n        merge(appointments, additionalAppointments);\n      }\n\n      this._sortAppointmentsByStartDate(appointments);\n    }\n  }, {\n    key: \"_applyStartDateToObj\",\n    value: function _applyStartDateToObj(startDate, obj) {\n      ExpressionUtils.setField(this.option(\"dataAccessors\"), \"startDate\", obj, startDate);\n      return obj;\n    }\n  }, {\n    key: \"_applyEndDateToObj\",\n    value: function _applyEndDateToObj(endDate, obj) {\n      ExpressionUtils.setField(this.option(\"dataAccessors\"), \"endDate\", obj, endDate);\n      return obj;\n    }\n  }, {\n    key: \"moveAppointmentBack\",\n    value: function moveAppointmentBack(dragEvent) {\n      var $appointment = this._$currentAppointment;\n      var size = this._initialSize;\n      var coords = this._initialCoordinates;\n\n      if (dragEvent) {\n        this._removeDragSourceClassFromDraggedAppointment();\n\n        if (isDeferred(dragEvent.cancel)) {\n          dragEvent.cancel.resolve(true);\n        } else {\n          dragEvent.cancel = true;\n        }\n      }\n\n      if ($appointment && !dragEvent) {\n        if (coords) {\n          move($appointment, coords);\n          delete this._initialSize;\n        }\n\n        if (size) {\n          setOuterWidth($appointment, size.width);\n          setOuterHeight($appointment, size.height);\n          delete this._initialCoordinates;\n        }\n      }\n    }\n  }, {\n    key: \"focus\",\n    value: function focus() {\n      if (this._$currentAppointment) {\n        var focusedElement = getPublicElement(this._$currentAppointment);\n        this.option(\"focusedElement\", focusedElement);\n        eventsEngine.trigger(focusedElement, \"focus\");\n      }\n    }\n  }, {\n    key: \"splitAppointmentByDay\",\n    value: function splitAppointmentByDay(appointment) {\n      var dates = appointment.settings || appointment;\n      var dataAccessors = this.option(\"dataAccessors\");\n      var originalStartDate = new Date(ExpressionUtils.getField(dataAccessors, \"startDate\", dates));\n      var startDate = dateUtils.makeDate(originalStartDate);\n      var endDate = dateUtils.makeDate(ExpressionUtils.getField(dataAccessors, \"endDate\", dates));\n      var maxAllowedDate = this.invoke(\"getEndViewDate\");\n      var startDayHour = this.invoke(\"getStartDayHour\");\n      var endDayHour = this.invoke(\"getEndDayHour\");\n      var timeZoneCalculator = this.option(\"timeZoneCalculator\");\n      var adapter = createAppointmentAdapter(appointment, dataAccessors, timeZoneCalculator);\n      var appointmentIsLong = getAppointmentTakesSeveralDays(adapter);\n      var result = [];\n      startDate = timeZoneCalculator.createDate(startDate, {\n        path: \"toGrid\"\n      });\n      endDate = timeZoneCalculator.createDate(endDate, {\n        path: \"toGrid\"\n      });\n\n      if (startDate.getHours() <= endDayHour && startDate.getHours() >= startDayHour && !appointmentIsLong) {\n        result.push(this._applyStartDateToObj(new Date(startDate), {\n          appointmentData: appointment\n        }));\n        startDate.setDate(startDate.getDate() + 1);\n      }\n\n      while (appointmentIsLong && startDate.getTime() < endDate.getTime() && startDate < maxAllowedDate) {\n        var currentStartDate = new Date(startDate);\n        var currentEndDate = new Date(startDate);\n\n        this._checkStartDate(currentStartDate, originalStartDate, startDayHour);\n\n        this._checkEndDate(currentEndDate, endDate, endDayHour);\n\n        var appointmentData = deepExtendArraySafe({}, appointment, true);\n        var appointmentSettings = {};\n\n        this._applyStartDateToObj(currentStartDate, appointmentSettings);\n\n        this._applyEndDateToObj(currentEndDate, appointmentSettings);\n\n        appointmentData.settings = appointmentSettings;\n        result.push(appointmentData);\n        startDate = dateUtils.trimTime(startDate);\n        startDate.setDate(startDate.getDate() + 1);\n        startDate.setHours(startDayHour);\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_checkStartDate\",\n    value: function _checkStartDate(currentDate, originalDate, startDayHour) {\n      if (!dateUtils.sameDate(currentDate, originalDate) || currentDate.getHours() <= startDayHour) {\n        currentDate.setHours(startDayHour, 0, 0, 0);\n      } else {\n        currentDate.setHours(originalDate.getHours(), originalDate.getMinutes(), originalDate.getSeconds(), originalDate.getMilliseconds());\n      }\n    }\n  }, {\n    key: \"_checkEndDate\",\n    value: function _checkEndDate(currentDate, originalDate, endDayHour) {\n      if (!dateUtils.sameDate(currentDate, originalDate) || currentDate.getHours() > endDayHour) {\n        currentDate.setHours(endDayHour, 0, 0, 0);\n      } else {\n        currentDate.setHours(originalDate.getHours(), originalDate.getMinutes(), originalDate.getSeconds(), originalDate.getMilliseconds());\n      }\n    }\n  }, {\n    key: \"_removeDragSourceClassFromDraggedAppointment\",\n    value: function _removeDragSourceClassFromDraggedAppointment() {\n      var $appointments = this._itemElements().filter(\".\".concat(APPOINTMENT_DRAG_SOURCE_CLASS));\n\n      $appointments.each(function (_, element) {\n        var appointmentInstance = $(element).dxSchedulerAppointment(\"instance\");\n        appointmentInstance.option(\"isDragSource\", false);\n      });\n    }\n  }, {\n    key: \"_setDragSourceAppointment\",\n    value: function _setDragSourceAppointment(appointment, settings) {\n      var $appointments = this._findItemElementByItem(appointment);\n\n      var _settings$info$source = settings.info.sourceAppointment,\n          startDate = _settings$info$source.startDate,\n          endDate = _settings$info$source.endDate;\n      var groupIndex = settings.groupIndex;\n      $appointments.forEach(function ($item) {\n        var _$item$data = $item.data(APPOINTMENT_SETTINGS_KEY),\n            itemInfo = _$item$data.info,\n            itemGroupIndex = _$item$data.groupIndex;\n\n        var _itemInfo$sourceAppoi = itemInfo.sourceAppointment,\n            itemStartDate = _itemInfo$sourceAppoi.startDate,\n            itemEndDate = _itemInfo$sourceAppoi.endDate;\n        var appointmentInstance = $item.dxSchedulerAppointment(\"instance\");\n        var isDragSource = startDate.getTime() === itemStartDate.getTime() && endDate.getTime() === itemEndDate.getTime() && groupIndex === itemGroupIndex;\n        appointmentInstance.option(\"isDragSource\", isDragSource);\n      });\n    }\n  }, {\n    key: \"updateResizableArea\",\n    value: function updateResizableArea() {\n      var _this5 = this;\n\n      var $allResizableElements = this.$element().find(\".dx-scheduler-appointment.dx-resizable\");\n      var horizontalResizables = grep($allResizableElements, function (el) {\n        var $el = $(el);\n        var resizableInst = $el.dxResizable(\"instance\");\n        var area = resizableInst.option(\"area\");\n        return inArray(resizableInst.option(\"handles\"), [\"right left\", \"left right\"]) > -1 && isPlainObject(area);\n      });\n      each(horizontalResizables, function (_, el) {\n        var $el = $(el);\n        var position = locate($el);\n\n        var appointmentData = _this5._getItemData($el);\n\n        var area = _this5._calculateResizableArea({\n          left: position.left\n        }, appointmentData);\n\n        $el.dxResizable(\"instance\").option(\"area\", area);\n      });\n    }\n  }]);\n\n  return SchedulerAppointments;\n}(CollectionWidget);\n\nregisterComponent(\"dxSchedulerAppointments\", SchedulerAppointments);\nexport default SchedulerAppointments;","map":null,"metadata":{},"sourceType":"module"}