{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/resizable.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { getOuterWidth, getOuterHeight, getInnerWidth, getInnerHeight, getWidth, getHeight } from \"../core/utils/size\";\nimport { locate, move } from \"../animation/translator\";\nimport registerComponent from \"../core/component_registrator\";\nimport DOMComponent from \"../core/dom_component\";\nimport $ from \"../core/renderer\";\nimport { inArray } from \"../core/utils/array\";\nimport { pairToObject } from \"../core/utils/common\";\nimport { extend } from \"../core/utils/extend\";\nimport { each } from \"../core/utils/iterator\";\nimport { fitIntoRange, inRange } from \"../core/utils/math\";\nimport { isPlainObject, isFunction, isWindow } from \"../core/utils/type\";\nimport { hasWindow } from \"../core/utils/window\";\nimport eventsEngine from \"../events/core/events_engine\";\nimport { start as dragEventStart, move as dragEventMove, end as dragEventEnd } from \"../events/drag\";\nimport { addNamespace } from \"../events/utils\";\nimport { triggerResizeEvent } from \"../events/visibility_change\";\nvar RESIZABLE = \"dxResizable\";\nvar RESIZABLE_CLASS = \"dx-resizable\";\nvar RESIZABLE_RESIZING_CLASS = \"dx-resizable-resizing\";\nvar RESIZABLE_HANDLE_CLASS = \"dx-resizable-handle\";\nvar RESIZABLE_HANDLE_TOP_CLASS = \"dx-resizable-handle-top\";\nvar RESIZABLE_HANDLE_BOTTOM_CLASS = \"dx-resizable-handle-bottom\";\nvar RESIZABLE_HANDLE_LEFT_CLASS = \"dx-resizable-handle-left\";\nvar RESIZABLE_HANDLE_RIGHT_CLASS = \"dx-resizable-handle-right\";\nvar RESIZABLE_HANDLE_CORNER_CLASS = \"dx-resizable-handle-corner\";\nvar DRAGSTART_START_EVENT_NAME = addNamespace(dragEventStart, RESIZABLE);\nvar DRAGSTART_EVENT_NAME = addNamespace(dragEventMove, RESIZABLE);\nvar DRAGSTART_END_EVENT_NAME = addNamespace(dragEventEnd, RESIZABLE);\nvar SIDE_BORDER_WIDTH_STYLES = {\n  left: \"borderLeftWidth\",\n  top: \"borderTopWidth\",\n  right: \"borderRightWidth\",\n  bottom: \"borderBottomWidth\"\n};\nvar Resizable = DOMComponent.inherit({\n  _getDefaultOptions: function _getDefaultOptions() {\n    return extend(this.callBase(), {\n      handles: \"all\",\n      step: \"1\",\n      stepPrecision: \"simple\",\n      area: void 0,\n      minWidth: 30,\n      maxWidth: 1 / 0,\n      minHeight: 30,\n      maxHeight: 1 / 0,\n      onResizeStart: null,\n      onResize: null,\n      onResizeEnd: null,\n      roundStepValue: true,\n      _keepAspectRatio: false\n    });\n  },\n  _init: function _init() {\n    this.callBase();\n    this.$element().addClass(RESIZABLE_CLASS);\n  },\n  _initMarkup: function _initMarkup() {\n    this.callBase();\n\n    this._renderHandles();\n  },\n  _render: function _render() {\n    this.callBase();\n\n    this._renderActions();\n  },\n  _renderActions: function _renderActions() {\n    this._resizeStartAction = this._createActionByOption(\"onResizeStart\");\n    this._resizeEndAction = this._createActionByOption(\"onResizeEnd\");\n    this._resizeAction = this._createActionByOption(\"onResize\");\n  },\n  _renderHandles: function _renderHandles() {\n    var _this = this;\n\n    this._handles = [];\n    var handles = this.option(\"handles\");\n\n    if (\"none\" === handles) {\n      return;\n    }\n\n    var directions = \"all\" === handles ? [\"top\", \"bottom\", \"left\", \"right\"] : handles.split(\" \");\n    each(directions, function (index, handleName) {\n      _this._renderHandle(handleName);\n    });\n    inArray(\"bottom\", directions) + 1 && inArray(\"right\", directions) + 1 && this._renderHandle(\"corner-bottom-right\");\n    inArray(\"bottom\", directions) + 1 && inArray(\"left\", directions) + 1 && this._renderHandle(\"corner-bottom-left\");\n    inArray(\"top\", directions) + 1 && inArray(\"right\", directions) + 1 && this._renderHandle(\"corner-top-right\");\n    inArray(\"top\", directions) + 1 && inArray(\"left\", directions) + 1 && this._renderHandle(\"corner-top-left\");\n\n    this._attachEventHandlers();\n  },\n  _renderHandle: function _renderHandle(handleName) {\n    var $handle = $(\"<div>\").addClass(RESIZABLE_HANDLE_CLASS).addClass(RESIZABLE_HANDLE_CLASS + \"-\" + handleName).appendTo(this.$element());\n\n    this._handles.push($handle);\n  },\n  _attachEventHandlers: function _attachEventHandlers() {\n    if (this.option(\"disabled\")) {\n      return;\n    }\n\n    var handlers = {};\n    handlers[DRAGSTART_START_EVENT_NAME] = this._dragStartHandler.bind(this);\n    handlers[DRAGSTART_EVENT_NAME] = this._dragHandler.bind(this);\n    handlers[DRAGSTART_END_EVENT_NAME] = this._dragEndHandler.bind(this);\n\n    this._handles.forEach(function (handleElement) {\n      eventsEngine.on(handleElement, handlers, {\n        direction: \"both\",\n        immediate: true\n      });\n    });\n  },\n  _detachEventHandlers: function _detachEventHandlers() {\n    this._handles.forEach(function (handleElement) {\n      eventsEngine.off(handleElement);\n    });\n  },\n  _toggleEventHandlers: function _toggleEventHandlers(shouldAttachEvents) {\n    shouldAttachEvents ? this._attachEventHandlers() : this._detachEventHandlers();\n  },\n  _getElementSize: function _getElementSize() {\n    var $element = this.$element();\n    return \"border-box\" === $element.css(\"boxSizing\") ? {\n      width: getOuterWidth($element),\n      height: getOuterHeight($element)\n    } : {\n      width: getWidth($element),\n      height: getHeight($element)\n    };\n  },\n  _dragStartHandler: function _dragStartHandler(e) {\n    var $element = this.$element();\n\n    if ($element.is(\".dx-state-disabled, .dx-state-disabled *\")) {\n      e.cancel = true;\n      return;\n    }\n\n    this._toggleResizingClass(true);\n\n    this._movingSides = this._getMovingSides(e);\n    this._elementLocation = locate($element);\n    this._elementSize = this._getElementSize();\n\n    this._renderDragOffsets(e);\n\n    this._resizeStartAction({\n      event: e,\n      width: this._elementSize.width,\n      height: this._elementSize.height,\n      handles: this._movingSides\n    });\n\n    e.targetElements = null;\n  },\n  _toggleResizingClass: function _toggleResizingClass(value) {\n    this.$element().toggleClass(RESIZABLE_RESIZING_CLASS, value);\n  },\n  _renderDragOffsets: function _renderDragOffsets(e) {\n    var area = this._getArea();\n\n    if (!area) {\n      return;\n    }\n\n    var $handle = $(e.target).closest(\".\" + RESIZABLE_HANDLE_CLASS);\n    var handleWidth = getOuterWidth($handle);\n    var handleHeight = getOuterHeight($handle);\n    var handleOffset = $handle.offset();\n    var areaOffset = area.offset;\n\n    var scrollOffset = this._getAreaScrollOffset();\n\n    e.maxLeftOffset = this._leftMaxOffset = handleOffset.left - areaOffset.left - scrollOffset.scrollX;\n    e.maxRightOffset = this._rightMaxOffset = areaOffset.left + area.width - handleOffset.left - handleWidth + scrollOffset.scrollX;\n    e.maxTopOffset = this._topMaxOffset = handleOffset.top - areaOffset.top - scrollOffset.scrollY;\n    e.maxBottomOffset = this._bottomMaxOffset = areaOffset.top + area.height - handleOffset.top - handleHeight + scrollOffset.scrollY;\n  },\n  _getBorderWidth: function _getBorderWidth($element, direction) {\n    if (isWindow($element.get(0))) {\n      return 0;\n    }\n\n    var borderWidth = $element.css(SIDE_BORDER_WIDTH_STYLES[direction]);\n    return parseInt(borderWidth) || 0;\n  },\n  _proportionate: function _proportionate(direction, value) {\n    var size = this._elementSize;\n    var factor = \"x\" === direction ? size.width / size.height : size.height / size.width;\n    return value * factor;\n  },\n  _getProportionalDelta: function _getProportionalDelta(_ref) {\n    var x = _ref.x,\n        y = _ref.y;\n\n    var proportionalY = this._proportionate(\"y\", x);\n\n    if (proportionalY >= y) {\n      return {\n        x: x,\n        y: proportionalY\n      };\n    }\n\n    var proportionalX = this._proportionate(\"x\", y);\n\n    if (proportionalX >= x) {\n      return {\n        x: proportionalX,\n        y: y\n      };\n    }\n\n    return {\n      x: 0,\n      y: 0\n    };\n  },\n  _getDirectionName: function _getDirectionName(axis) {\n    var sides = this._movingSides;\n\n    if (\"x\" === axis) {\n      return sides.left ? \"left\" : \"right\";\n    } else {\n      return sides.top ? \"top\" : \"bottom\";\n    }\n  },\n  _fitIntoArea: function _fitIntoArea(axis, value) {\n    var _this$;\n\n    var directionName = this._getDirectionName(axis);\n\n    return Math.min(value, null !== (_this$ = this[\"_\".concat(directionName, \"MaxOffset\")]) && void 0 !== _this$ ? _this$ : 1 / 0);\n  },\n  _fitDeltaProportionally: function _fitDeltaProportionally(delta) {\n    var _this2 = this;\n\n    var fittedDelta = _extends({}, delta);\n\n    var size = this._elementSize;\n\n    var _this$option = this.option(),\n        minWidth = _this$option.minWidth,\n        minHeight = _this$option.minHeight,\n        maxWidth = _this$option.maxWidth,\n        maxHeight = _this$option.maxHeight;\n\n    var getWidth = function getWidth() {\n      return size.width + fittedDelta.x;\n    };\n\n    var getHeight = function getHeight() {\n      return size.height + fittedDelta.y;\n    };\n\n    var isInArea = function isInArea(axis) {\n      return fittedDelta[axis] === _this2._fitIntoArea(axis, fittedDelta[axis]);\n    };\n\n    var isFittedX = function isFittedX() {\n      return inRange(getWidth(), minWidth, maxWidth) && isInArea(\"x\");\n    };\n\n    var isFittedY = function isFittedY() {\n      return inRange(getHeight(), minHeight, maxHeight) && isInArea(\"y\");\n    };\n\n    if (!isFittedX()) {\n      var x = this._fitIntoArea(\"x\", fitIntoRange(getWidth(), minWidth, maxWidth) - size.width);\n\n      fittedDelta = {\n        x: x,\n        y: this._proportionate(\"y\", x)\n      };\n    }\n\n    if (!isFittedY()) {\n      var y = this._fitIntoArea(\"y\", fitIntoRange(getHeight(), minHeight, maxHeight) - size.height);\n\n      fittedDelta = {\n        x: this._proportionate(\"x\", y),\n        y: y\n      };\n    }\n\n    return isFittedX() && isFittedY() ? fittedDelta : {\n      x: 0,\n      y: 0\n    };\n  },\n  _fitDelta: function _fitDelta(_ref2) {\n    var x = _ref2.x,\n        y = _ref2.y;\n    var size = this._elementSize;\n\n    var _this$option2 = this.option(),\n        minWidth = _this$option2.minWidth,\n        minHeight = _this$option2.minHeight,\n        maxWidth = _this$option2.maxWidth,\n        maxHeight = _this$option2.maxHeight;\n\n    return {\n      x: fitIntoRange(size.width + x, minWidth, maxWidth) - size.width,\n      y: fitIntoRange(size.height + y, minHeight, maxHeight) - size.height\n    };\n  },\n  _getDeltaByOffset: function _getDeltaByOffset(offset) {\n    var sides = this._movingSides;\n    var shouldKeepAspectRatio = this._isCornerHandler(sides) && this.option(\"_keepAspectRatio\");\n    var delta = {\n      x: offset.x * (sides.left ? -1 : 1),\n      y: offset.y * (sides.top ? -1 : 1)\n    };\n\n    if (shouldKeepAspectRatio) {\n      var proportionalDelta = this._getProportionalDelta(delta);\n\n      var fittedProportionalDelta = this._fitDeltaProportionally(proportionalDelta);\n\n      delta = fittedProportionalDelta;\n    } else {\n      var fittedDelta = this._fitDelta(delta);\n\n      var roundedFittedDelta = this._roundByStep(fittedDelta);\n\n      delta = roundedFittedDelta;\n    }\n\n    return delta;\n  },\n  _updatePosition: function _updatePosition(delta, _ref3) {\n    var width = _ref3.width,\n        height = _ref3.height;\n    var location = this._elementLocation;\n    var sides = this._movingSides;\n    var $element = this.$element();\n\n    var elementRect = this._getElementSize();\n\n    var offsetTop = delta.y * (sides.top ? -1 : 1) - ((elementRect.height || height) - height);\n    var offsetLeft = delta.x * (sides.left ? -1 : 1) - ((elementRect.width || width) - width);\n    move($element, {\n      top: location.top + (sides.top ? offsetTop : 0),\n      left: location.left + (sides.left ? offsetLeft : 0)\n    });\n  },\n  _dragHandler: function _dragHandler(e) {\n    var offset = this._getOffset(e);\n\n    var delta = this._getDeltaByOffset(offset);\n\n    var dimensions = this._updateDimensions(delta);\n\n    this._updatePosition(delta, dimensions);\n\n    this._triggerResizeAction(e, dimensions);\n  },\n  _updateDimensions: function _updateDimensions(delta) {\n    var isAbsoluteSize = function isAbsoluteSize(size) {\n      return \"px\" === size.substring(size.length - 2);\n    };\n\n    var isStepPrecisionStrict = \"strict\" === this.option(\"stepPrecision\");\n    var size = this._elementSize;\n    var width = size.width + delta.x;\n    var height = size.height + delta.y;\n    var elementStyle = this.$element().get(0).style;\n    var shouldRenderWidth = delta.x || isStepPrecisionStrict || isAbsoluteSize(elementStyle.width);\n    var shouldRenderHeight = delta.y || isStepPrecisionStrict || isAbsoluteSize(elementStyle.height);\n\n    if (shouldRenderWidth) {\n      this.option({\n        width: width\n      });\n    }\n\n    if (shouldRenderHeight) {\n      this.option({\n        height: height\n      });\n    }\n\n    return {\n      width: shouldRenderWidth ? width : size.width,\n      height: shouldRenderHeight ? height : size.height\n    };\n  },\n  _triggerResizeAction: function _triggerResizeAction(e, _ref4) {\n    var width = _ref4.width,\n        height = _ref4.height;\n\n    this._resizeAction({\n      event: e,\n      width: this.option(\"width\") || width,\n      height: this.option(\"height\") || height,\n      handles: this._movingSides\n    });\n\n    triggerResizeEvent(this.$element());\n  },\n  _isCornerHandler: function _isCornerHandler(sides) {\n    return 0 === Object.values(sides).reduce(function (xor, value) {\n      return xor ^ value;\n    }, 0);\n  },\n  _getOffset: function _getOffset(e) {\n    var offset = e.offset;\n    var sides = this._movingSides;\n\n    if (!sides.left && !sides.right) {\n      offset.x = 0;\n    }\n\n    if (!sides.top && !sides.bottom) {\n      offset.y = 0;\n    }\n\n    return offset;\n  },\n  _roundByStep: function _roundByStep(delta) {\n    return \"strict\" === this.option(\"stepPrecision\") ? this._roundStrict(delta) : this._roundNotStrict(delta);\n  },\n  _getSteps: function _getSteps() {\n    return pairToObject(this.option(\"step\"), !this.option(\"roundStepValue\"));\n  },\n  _roundNotStrict: function _roundNotStrict(delta) {\n    var steps = this._getSteps();\n\n    return {\n      x: delta.x - delta.x % steps.h,\n      y: delta.y - delta.y % steps.v\n    };\n  },\n  _roundStrict: function _roundStrict(delta) {\n    var sides = this._movingSides;\n    var offset = {\n      x: delta.x * (sides.left ? -1 : 1),\n      y: delta.y * (sides.top ? -1 : 1)\n    };\n\n    var steps = this._getSteps();\n\n    var location = this._elementLocation;\n    var size = this._elementSize;\n    var xPos = sides.left ? location.left : location.left + size.width;\n    var yPos = sides.top ? location.top : location.top + size.height;\n    var newXShift = (xPos + offset.x) % steps.h;\n    var newYShift = (yPos + offset.y) % steps.v;\n\n    var sign = Math.sign || function (x) {\n      x = +x;\n\n      if (0 === x || isNaN(x)) {\n        return x;\n      }\n\n      return x > 0 ? 1 : -1;\n    };\n\n    var separatorOffset = function separatorOffset(steps, offset) {\n      return (1 + .2 * sign(offset)) % 1 * steps;\n    };\n\n    var isSmallOffset = function isSmallOffset(offset, steps) {\n      return Math.abs(offset) < .2 * steps;\n    };\n\n    var newOffsetX = offset.x - newXShift;\n    var newOffsetY = offset.y - newYShift;\n\n    if (newXShift > separatorOffset(steps.h, offset.x)) {\n      newOffsetX += steps.h;\n    }\n\n    if (newYShift > separatorOffset(steps.v, offset.y)) {\n      newOffsetY += steps.v;\n    }\n\n    var roundedOffset_x = (sides.left || sides.right) && !isSmallOffset(offset.x, steps.h) ? newOffsetX : 0,\n        roundedOffset_y = (sides.top || sides.bottom) && !isSmallOffset(offset.y, steps.v) ? newOffsetY : 0;\n    return {\n      x: roundedOffset_x * (sides.left ? -1 : 1),\n      y: roundedOffset_y * (sides.top ? -1 : 1)\n    };\n  },\n  _getMovingSides: function _getMovingSides(e) {\n    var $target = $(e.target);\n    var hasCornerTopLeftClass = $target.hasClass(RESIZABLE_HANDLE_CORNER_CLASS + \"-top-left\");\n    var hasCornerTopRightClass = $target.hasClass(RESIZABLE_HANDLE_CORNER_CLASS + \"-top-right\");\n    var hasCornerBottomLeftClass = $target.hasClass(RESIZABLE_HANDLE_CORNER_CLASS + \"-bottom-left\");\n    var hasCornerBottomRightClass = $target.hasClass(RESIZABLE_HANDLE_CORNER_CLASS + \"-bottom-right\");\n    return {\n      top: $target.hasClass(RESIZABLE_HANDLE_TOP_CLASS) || hasCornerTopLeftClass || hasCornerTopRightClass,\n      left: $target.hasClass(RESIZABLE_HANDLE_LEFT_CLASS) || hasCornerTopLeftClass || hasCornerBottomLeftClass,\n      bottom: $target.hasClass(RESIZABLE_HANDLE_BOTTOM_CLASS) || hasCornerBottomLeftClass || hasCornerBottomRightClass,\n      right: $target.hasClass(RESIZABLE_HANDLE_RIGHT_CLASS) || hasCornerTopRightClass || hasCornerBottomRightClass\n    };\n  },\n  _getArea: function _getArea() {\n    var area = this.option(\"area\");\n\n    if (isFunction(area)) {\n      area = area.call(this);\n    }\n\n    if (isPlainObject(area)) {\n      return this._getAreaFromObject(area);\n    }\n\n    return this._getAreaFromElement(area);\n  },\n  _getAreaScrollOffset: function _getAreaScrollOffset() {\n    var area = this.option(\"area\");\n    var isElement = !isFunction(area) && !isPlainObject(area);\n    var scrollOffset = {\n      scrollY: 0,\n      scrollX: 0\n    };\n\n    if (isElement) {\n      var areaElement = $(area)[0];\n\n      if (isWindow(areaElement)) {\n        scrollOffset.scrollX = areaElement.pageXOffset;\n        scrollOffset.scrollY = areaElement.pageYOffset;\n      }\n    }\n\n    return scrollOffset;\n  },\n  _getAreaFromObject: function _getAreaFromObject(area) {\n    var result = {\n      width: area.right - area.left,\n      height: area.bottom - area.top,\n      offset: {\n        left: area.left,\n        top: area.top\n      }\n    };\n\n    this._correctAreaGeometry(result);\n\n    return result;\n  },\n  _getAreaFromElement: function _getAreaFromElement(area) {\n    var $area = $(area);\n    var result;\n\n    if ($area.length) {\n      result = {\n        width: getInnerWidth($area),\n        height: getInnerHeight($area),\n        offset: extend({\n          top: 0,\n          left: 0\n        }, isWindow($area[0]) ? {} : $area.offset())\n      };\n\n      this._correctAreaGeometry(result, $area);\n    }\n\n    return result;\n  },\n  _correctAreaGeometry: function _correctAreaGeometry(result, $area) {\n    var areaBorderLeft = $area ? this._getBorderWidth($area, \"left\") : 0;\n    var areaBorderTop = $area ? this._getBorderWidth($area, \"top\") : 0;\n    result.offset.left += areaBorderLeft + this._getBorderWidth(this.$element(), \"left\");\n    result.offset.top += areaBorderTop + this._getBorderWidth(this.$element(), \"top\");\n    result.width -= getOuterWidth(this.$element()) - getInnerWidth(this.$element());\n    result.height -= getOuterHeight(this.$element()) - getInnerHeight(this.$element());\n  },\n  _dragEndHandler: function _dragEndHandler(e) {\n    var $element = this.$element();\n\n    this._resizeEndAction({\n      event: e,\n      width: getOuterWidth($element),\n      height: getOuterHeight($element),\n      handles: this._movingSides\n    });\n\n    this._toggleResizingClass(false);\n  },\n  _renderWidth: function _renderWidth(width) {\n    this.option(\"width\", fitIntoRange(width, this.option(\"minWidth\"), this.option(\"maxWidth\")));\n  },\n  _renderHeight: function _renderHeight(height) {\n    this.option(\"height\", fitIntoRange(height, this.option(\"minHeight\"), this.option(\"maxHeight\")));\n  },\n  _optionChanged: function _optionChanged(args) {\n    switch (args.name) {\n      case \"disabled\":\n        this._toggleEventHandlers(!args.value);\n\n        this.callBase(args);\n        break;\n\n      case \"handles\":\n        this._invalidate();\n\n        break;\n\n      case \"minWidth\":\n      case \"maxWidth\":\n        hasWindow() && this._renderWidth(getOuterWidth(this.$element()));\n        break;\n\n      case \"minHeight\":\n      case \"maxHeight\":\n        hasWindow() && this._renderHeight(getOuterHeight(this.$element()));\n        break;\n\n      case \"onResize\":\n      case \"onResizeStart\":\n      case \"onResizeEnd\":\n        this._renderActions();\n\n        break;\n\n      case \"area\":\n      case \"stepPrecision\":\n      case \"step\":\n      case \"roundStepValue\":\n      case \"_keepAspectRatio\":\n        break;\n\n      default:\n        this.callBase(args);\n    }\n  },\n  _clean: function _clean() {\n    this.$element().find(\".\" + RESIZABLE_HANDLE_CLASS).remove();\n  },\n  _useTemplates: function _useTemplates() {\n    return false;\n  }\n});\nregisterComponent(RESIZABLE, Resizable);\nexport default Resizable;","map":null,"metadata":{},"sourceType":"module"}