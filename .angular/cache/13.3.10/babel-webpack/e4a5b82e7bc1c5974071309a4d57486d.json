{"ast":null,"code":"/**\r\n * DevExtreme (esm/viz/series/points/range_symbol_point.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { each } from \"../../../core/utils/iterator\";\nimport { extend } from \"../../../core/utils/extend\";\nimport { noop } from \"../../../core/utils/common\";\nimport { Label } from \"./label\";\nimport symbolPoint from \"./symbol_point\";\nvar _extend = extend;\nimport { isDefined as _isDefined } from \"../../../core/utils/type\";\nvar _math = Math;\nvar _abs = _math.abs;\nvar _min = _math.min;\nvar _max = _math.max;\nvar _round = _math.round;\nvar DEFAULT_IMAGE_WIDTH = 20;\nvar DEFAULT_IMAGE_HEIGHT = 20;\nexport default _extend({}, symbolPoint, {\n  deleteLabel: function deleteLabel() {\n    this._topLabel.dispose();\n\n    this._topLabel = null;\n\n    this._bottomLabel.dispose();\n\n    this._bottomLabel = null;\n  },\n  hideMarker: function hideMarker(type) {\n    var graphic = this.graphic;\n    var marker = graphic && graphic[type + \"Marker\"];\n    var label = this[\"_\" + type + \"Label\"];\n\n    if (marker && \"hidden\" !== marker.attr(\"visibility\")) {\n      marker.attr({\n        visibility: \"hidden\"\n      });\n    }\n\n    label.draw(false);\n  },\n  setInvisibility: function setInvisibility() {\n    this.hideMarker(\"top\");\n    this.hideMarker(\"bottom\");\n  },\n  clearVisibility: function clearVisibility() {\n    var graphic = this.graphic;\n    var topMarker = graphic && graphic.topMarker;\n    var bottomMarker = graphic && graphic.bottomMarker;\n\n    if (topMarker && topMarker.attr(\"visibility\")) {\n      topMarker.attr({\n        visibility: null\n      });\n    }\n\n    if (bottomMarker && bottomMarker.attr(\"visibility\")) {\n      bottomMarker.attr({\n        visibility: null\n      });\n    }\n  },\n  clearMarker: function clearMarker() {\n    var graphic = this.graphic;\n    var topMarker = graphic && graphic.topMarker;\n    var bottomMarker = graphic && graphic.bottomMarker;\n    var emptySettings = this._emptySettings;\n    topMarker && topMarker.attr(emptySettings);\n    bottomMarker && bottomMarker.attr(emptySettings);\n  },\n  _getLabelPosition: function _getLabelPosition(markerType) {\n    var position;\n    var labelsInside = \"inside\" === this._options.label.position;\n\n    if (!this._options.rotated) {\n      position = \"top\" === markerType ^ labelsInside ? \"top\" : \"bottom\";\n    } else {\n      position = \"top\" === markerType ^ labelsInside ? \"right\" : \"left\";\n    }\n\n    return position;\n  },\n  _getLabelMinFormatObject: function _getLabelMinFormatObject() {\n    return {\n      index: 0,\n      argument: this.initialArgument,\n      value: this.initialMinValue,\n      seriesName: this.series.name,\n      originalValue: this.originalMinValue,\n      originalArgument: this.originalArgument,\n      point: this\n    };\n  },\n  _updateLabelData: function _updateLabelData() {\n    var maxFormatObject = this._getLabelFormatObject();\n\n    maxFormatObject.index = 1;\n\n    this._topLabel.setData(maxFormatObject);\n\n    this._bottomLabel.setData(this._getLabelMinFormatObject());\n  },\n  _updateLabelOptions: function _updateLabelOptions() {\n    var options = this._options.label;\n    (!this._topLabel || !this._bottomLabel) && this._createLabel();\n\n    this._topLabel.setOptions(options);\n\n    this._bottomLabel.setOptions(options);\n  },\n  _createLabel: function _createLabel() {\n    var options = {\n      renderer: this.series._renderer,\n      labelsGroup: this.series._labelsGroup,\n      point: this\n    };\n    this._topLabel = new Label(options);\n    this._bottomLabel = new Label(options);\n  },\n  _getGraphicBBox: function _getGraphicBBox(location) {\n    var options = this._options;\n\n    var images = this._getImage(options.image);\n\n    var image = \"top\" === location ? this._checkImage(images.top) : this._checkImage(images.bottom);\n    var bBox;\n\n    var coord = this._getPositionFromLocation(location);\n\n    if (options.visible) {\n      bBox = image ? this._getImageBBox(coord.x, coord.y) : this._getSymbolBBox(coord.x, coord.y, options.styles.normal.r);\n    } else {\n      bBox = {\n        x: coord.x,\n        y: coord.y,\n        width: 0,\n        height: 0\n      };\n    }\n\n    return bBox;\n  },\n  _getPositionFromLocation: function _getPositionFromLocation(location) {\n    var x;\n    var y;\n    var isTop = \"top\" === location;\n\n    if (!this._options.rotated) {\n      x = this.x;\n      y = isTop ? _min(this.y, this.minY) : _max(this.y, this.minY);\n    } else {\n      x = isTop ? _max(this.x, this.minX) : _min(this.x, this.minX);\n      y = this.y;\n    }\n\n    return {\n      x: x,\n      y: y\n    };\n  },\n  _checkOverlay: function _checkOverlay(bottomCoord, topCoord, topValue) {\n    return bottomCoord < topCoord + topValue;\n  },\n  _getOverlayCorrections: function _getOverlayCorrections(topCoords, bottomCoords) {\n    var rotated = this._options.rotated;\n    var coordSelector = !rotated ? \"y\" : \"x\";\n    var valueSelector = !rotated ? \"height\" : \"width\";\n    var visibleArea = this.series.getValueAxis().getVisibleArea();\n    var minBound = visibleArea[0];\n    var maxBound = visibleArea[1];\n\n    var delta = _round((topCoords[coordSelector] + topCoords[valueSelector] - bottomCoords[coordSelector]) / 2);\n\n    var coord1 = topCoords[coordSelector] - delta;\n    var coord2 = bottomCoords[coordSelector] + delta;\n\n    if (coord1 < minBound) {\n      delta = minBound - coord1;\n      coord1 += delta;\n      coord2 += delta;\n    } else if (coord2 + bottomCoords[valueSelector] > maxBound) {\n      delta = maxBound - coord2 - bottomCoords[valueSelector];\n      coord1 += delta;\n      coord2 += delta;\n    }\n\n    return {\n      coord1: coord1,\n      coord2: coord2\n    };\n  },\n  _checkLabelsOverlay: function _checkLabelsOverlay(topLocation) {\n    var topCoords = this._topLabel.getBoundingRect();\n\n    var bottomCoords = this._bottomLabel.getBoundingRect();\n\n    var corrections = {};\n\n    if (!this._options.rotated) {\n      if (\"top\" === topLocation) {\n        if (this._checkOverlay(bottomCoords.y, topCoords.y, topCoords.height)) {\n          corrections = this._getOverlayCorrections(topCoords, bottomCoords);\n\n          this._topLabel.shift(topCoords.x, corrections.coord1);\n\n          this._bottomLabel.shift(bottomCoords.x, corrections.coord2);\n        }\n      } else if (this._checkOverlay(topCoords.y, bottomCoords.y, bottomCoords.height)) {\n        corrections = this._getOverlayCorrections(bottomCoords, topCoords);\n\n        this._topLabel.shift(topCoords.x, corrections.coord2);\n\n        this._bottomLabel.shift(bottomCoords.x, corrections.coord1);\n      }\n    } else if (\"top\" === topLocation) {\n      if (this._checkOverlay(topCoords.x, bottomCoords.x, bottomCoords.width)) {\n        corrections = this._getOverlayCorrections(bottomCoords, topCoords);\n\n        this._topLabel.shift(corrections.coord2, topCoords.y);\n\n        this._bottomLabel.shift(corrections.coord1, bottomCoords.y);\n      }\n    } else if (this._checkOverlay(bottomCoords.x, topCoords.x, topCoords.width)) {\n      corrections = this._getOverlayCorrections(topCoords, bottomCoords);\n\n      this._topLabel.shift(corrections.coord1, topCoords.y);\n\n      this._bottomLabel.shift(corrections.coord2, bottomCoords.y);\n    }\n  },\n  _drawLabel: function _drawLabel() {\n    var labels = [];\n    var notInverted = this._options.rotated ? this.x >= this.minX : this.y < this.minY;\n\n    var customVisibility = this._getCustomLabelVisibility();\n\n    var topLabel = this._topLabel;\n    var bottomLabel = this._bottomLabel;\n    topLabel.pointPosition = notInverted ? \"top\" : \"bottom\";\n    bottomLabel.pointPosition = notInverted ? \"bottom\" : \"top\";\n\n    if ((this.series.getLabelVisibility() || customVisibility) && this.hasValue() && false !== customVisibility) {\n      false !== this.visibleTopMarker && labels.push(topLabel);\n      false !== this.visibleBottomMarker && labels.push(bottomLabel);\n      each(labels, function (_, label) {\n        label.draw(true);\n      });\n\n      this._checkLabelsOverlay(this._topLabel.pointPosition);\n    } else {\n      topLabel.draw(false);\n      bottomLabel.draw(false);\n    }\n  },\n  _getImage: function _getImage(imageOption) {\n    var image = {};\n\n    if (_isDefined(imageOption)) {\n      if (\"string\" === typeof imageOption) {\n        image.top = image.bottom = imageOption;\n      } else {\n        image.top = {\n          url: \"string\" === typeof imageOption.url ? imageOption.url : imageOption.url && imageOption.url.rangeMaxPoint,\n          width: \"number\" === typeof imageOption.width ? imageOption.width : imageOption.width && imageOption.width.rangeMaxPoint,\n          height: \"number\" === typeof imageOption.height ? imageOption.height : imageOption.height && imageOption.height.rangeMaxPoint\n        };\n        image.bottom = {\n          url: \"string\" === typeof imageOption.url ? imageOption.url : imageOption.url && imageOption.url.rangeMinPoint,\n          width: \"number\" === typeof imageOption.width ? imageOption.width : imageOption.width && imageOption.width.rangeMinPoint,\n          height: \"number\" === typeof imageOption.height ? imageOption.height : imageOption.height && imageOption.height.rangeMinPoint\n        };\n      }\n    }\n\n    return image;\n  },\n  _checkSymbol: function _checkSymbol(oldOptions, newOptions) {\n    var oldSymbol = oldOptions.symbol;\n    var newSymbol = newOptions.symbol;\n    var symbolChanged = \"circle\" === oldSymbol && \"circle\" !== newSymbol || \"circle\" !== oldSymbol && \"circle\" === newSymbol;\n\n    var oldImages = this._getImage(oldOptions.image);\n\n    var newImages = this._getImage(newOptions.image);\n\n    var topImageChanged = this._checkImage(oldImages.top) !== this._checkImage(newImages.top);\n\n    var bottomImageChanged = this._checkImage(oldImages.bottom) !== this._checkImage(newImages.bottom);\n\n    return symbolChanged || topImageChanged || bottomImageChanged;\n  },\n  _getSettingsForTwoMarkers: function _getSettingsForTwoMarkers(style) {\n    var options = this._options;\n    var settings = {};\n    var x = options.rotated ? _min(this.x, this.minX) : this.x;\n    var y = options.rotated ? this.y : _min(this.y, this.minY);\n    var radius = style.r;\n\n    var points = this._populatePointShape(options.symbol, radius);\n\n    settings.top = _extend({\n      translateX: x + this.width,\n      translateY: y,\n      r: radius\n    }, style);\n    settings.bottom = _extend({\n      translateX: x,\n      translateY: y + this.height,\n      r: radius\n    }, style);\n\n    if (points) {\n      settings.top.points = settings.bottom.points = points;\n    }\n\n    return settings;\n  },\n  _hasGraphic: function _hasGraphic() {\n    return this.graphic && this.graphic.topMarker && this.graphic.bottomMarker;\n  },\n  _drawOneMarker: function _drawOneMarker(renderer, markerType, imageSettings, settings) {\n    var graphic = this.graphic;\n\n    if (graphic[markerType]) {\n      this._updateOneMarker(markerType, settings);\n    } else {\n      graphic[markerType] = this._createMarker(renderer, graphic, imageSettings, settings);\n    }\n  },\n  _drawMarker: function _drawMarker(renderer, group, animationEnabled, firstDrawing, style) {\n    var settings = this._getSettingsForTwoMarkers(style || this._getStyle());\n\n    var image = this._getImage(this._options.image);\n\n    if (this._checkImage(image.top)) {\n      settings.top = this._getImageSettings(settings.top, image.top);\n    }\n\n    if (this._checkImage(image.bottom)) {\n      settings.bottom = this._getImageSettings(settings.bottom, image.bottom);\n    }\n\n    this.graphic = this.graphic || renderer.g().append(group);\n    this.visibleTopMarker && this._drawOneMarker(renderer, \"topMarker\", image.top, settings.top);\n    this.visibleBottomMarker && this._drawOneMarker(renderer, \"bottomMarker\", image.bottom, settings.bottom);\n  },\n  _getSettingsForTracker: function _getSettingsForTracker(radius) {\n    var rotated = this._options.rotated;\n    return {\n      translateX: rotated ? _min(this.x, this.minX) - radius : this.x - radius,\n      translateY: rotated ? this.y - radius : _min(this.y, this.minY) - radius,\n      width: this.width + 2 * radius,\n      height: this.height + 2 * radius\n    };\n  },\n  isInVisibleArea: function isInVisibleArea() {\n    var rotated = this._options.rotated;\n    var argument = !rotated ? this.x : this.y;\n    var maxValue = !rotated ? _max(this.minY, this.y) : _max(this.minX, this.x);\n    var minValue = !rotated ? _min(this.minY, this.y) : _min(this.minX, this.x);\n    var tmp;\n    var visibleTopMarker;\n    var visibleBottomMarker;\n    var visibleRangeArea = true;\n    var visibleArgArea = this.series.getArgumentAxis().getVisibleArea();\n    var visibleValArea = this.series.getValueAxis().getVisibleArea();\n    var notVisibleByArg = visibleArgArea[1] < argument || visibleArgArea[0] > argument;\n    var notVisibleByVal = visibleValArea[0] > minValue && visibleValArea[0] > maxValue || visibleValArea[1] < minValue && visibleValArea[1] < maxValue;\n\n    if (notVisibleByArg || notVisibleByVal) {\n      visibleTopMarker = visibleBottomMarker = visibleRangeArea = false;\n    } else {\n      visibleTopMarker = visibleValArea[0] <= minValue && visibleValArea[1] > minValue;\n      visibleBottomMarker = visibleValArea[0] < maxValue && visibleValArea[1] >= maxValue;\n\n      if (rotated) {\n        tmp = visibleTopMarker;\n        visibleTopMarker = visibleBottomMarker;\n        visibleBottomMarker = tmp;\n      }\n    }\n\n    this.visibleTopMarker = visibleTopMarker;\n    this.visibleBottomMarker = visibleBottomMarker;\n    return visibleRangeArea;\n  },\n  getTooltipParams: function getTooltipParams() {\n    var x;\n    var y;\n    var rotated = this._options.rotated;\n    var minValue = !rotated ? _min(this.y, this.minY) : _min(this.x, this.minX);\n    var side = !rotated ? \"height\" : \"width\";\n\n    var visibleArea = this._getVisibleArea();\n\n    var minVisible = rotated ? visibleArea.minX : visibleArea.minY;\n    var maxVisible = rotated ? visibleArea.maxX : visibleArea.maxY;\n\n    var min = _max(minVisible, minValue);\n\n    var max = _min(maxVisible, minValue + this[side]);\n\n    if (!rotated) {\n      x = this.x;\n      y = min + (max - min) / 2;\n    } else {\n      y = this.y;\n      x = min + (max - min) / 2;\n    }\n\n    return {\n      x: x,\n      y: y,\n      offset: 0\n    };\n  },\n  _translate: function _translate() {\n    var rotated = this._options.rotated;\n\n    symbolPoint._translate.call(this);\n\n    this.height = rotated ? 0 : _abs(this.minY - this.y);\n    this.width = rotated ? _abs(this.x - this.minX) : 0;\n  },\n  hasCoords: function hasCoords() {\n    return symbolPoint.hasCoords.call(this) && !(null === this.minX || null === this.minY);\n  },\n  _updateData: function _updateData(data) {\n    symbolPoint._updateData.call(this, data);\n\n    this.minValue = this.initialMinValue = this.originalMinValue = data.minValue;\n  },\n  _getImageSettings: function _getImageSettings(settings, image) {\n    return {\n      href: image.url || image.toString(),\n      width: image.width || DEFAULT_IMAGE_WIDTH,\n      height: image.height || DEFAULT_IMAGE_HEIGHT,\n      translateX: settings.translateX,\n      translateY: settings.translateY\n    };\n  },\n  getCrosshairData: function getCrosshairData(x, y) {\n    var rotated = this._options.rotated;\n    var minX = this.minX;\n    var minY = this.minY;\n    var vx = this.vx;\n    var vy = this.vy;\n    var value = this.value;\n    var minValue = this.minValue;\n    var argument = this.argument;\n    var coords = {\n      axis: this.series.axis,\n      x: vx,\n      y: vy,\n      yValue: value,\n      xValue: argument\n    };\n\n    if (rotated) {\n      coords.yValue = argument;\n\n      if (_abs(vx - x) < _abs(minX - x)) {\n        coords.xValue = value;\n      } else {\n        coords.x = minX;\n        coords.xValue = minValue;\n      }\n    } else if (_abs(vy - y) >= _abs(minY - y)) {\n      coords.y = minY;\n      coords.yValue = minValue;\n    }\n\n    return coords;\n  },\n  _updateOneMarker: function _updateOneMarker(markerType, settings) {\n    this.graphic && this.graphic[markerType] && this.graphic[markerType].attr(settings);\n  },\n  _updateMarker: function _updateMarker(animationEnabled, style) {\n    this._drawMarker(void 0, void 0, false, false, style);\n  },\n  _getFormatObject: function _getFormatObject(tooltip) {\n    var initialMinValue = this.initialMinValue;\n    var initialValue = this.initialValue;\n    var initialArgument = this.initialArgument;\n    var minValue = tooltip.formatValue(initialMinValue);\n    var value = tooltip.formatValue(initialValue);\n    return {\n      argument: initialArgument,\n      argumentText: tooltip.formatValue(initialArgument, \"argument\"),\n      valueText: minValue + \" - \" + value,\n      rangeValue1Text: minValue,\n      rangeValue2Text: value,\n      rangeValue1: initialMinValue,\n      rangeValue2: initialValue,\n      seriesName: this.series.name,\n      point: this,\n      originalMinValue: this.originalMinValue,\n      originalValue: this.originalValue,\n      originalArgument: this.originalArgument\n    };\n  },\n  getLabel: function getLabel() {\n    return [this._topLabel, this._bottomLabel];\n  },\n  getLabels: function getLabels() {\n    return [this._topLabel, this._bottomLabel];\n  },\n  getBoundingRect: noop,\n  coordsIn: function coordsIn(x, y) {\n    var trackerRadius = this._storeTrackerR();\n\n    var xCond = x >= this.x - trackerRadius && x <= this.x + trackerRadius;\n    var yCond = y >= this.y - trackerRadius && y <= this.y + trackerRadius;\n\n    if (this._options.rotated) {\n      return yCond && (xCond || x >= this.minX - trackerRadius && x <= this.minX + trackerRadius);\n    } else {\n      return xCond && (yCond || y >= this.minY - trackerRadius && y <= this.minY + trackerRadius);\n    }\n  },\n  getMaxValue: function getMaxValue() {\n    if (\"discrete\" !== this.series.valueAxisType) {\n      return this.minValue > this.value ? this.minValue : this.value;\n    }\n\n    return this.value;\n  },\n  getMinValue: function getMinValue() {\n    if (\"discrete\" !== this.series.valueAxisType) {\n      return this.minValue < this.value ? this.minValue : this.value;\n    }\n\n    return this.minValue;\n  }\n});","map":null,"metadata":{},"sourceType":"module"}