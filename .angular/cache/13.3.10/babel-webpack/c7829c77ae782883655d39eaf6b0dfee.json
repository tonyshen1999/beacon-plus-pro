{"ast":null,"code":"/**\r\n * DevExtreme (esm/viz/chart_components/tracker.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport domAdapter from \"../../core/dom_adapter\";\nimport eventsEngine from \"../../events/core/events_engine\";\nimport { name as clickEventName } from \"../../events/click\";\nimport { extend } from \"../../core/utils/extend\";\nimport { each as _each } from \"../../core/utils/iterator\";\nimport consts from \"../components/consts\";\nimport { getDistance, pointInCanvas as inCanvas, normalizeEnum as _normalizeEnum } from \"../core/utils\";\nimport pointerEvents from \"../../events/pointer\";\nimport { addNamespace } from \"../../events/utils/index\";\nimport { isDefined } from \"../../core/utils/type\";\nimport { noop as _noop } from \"../../core/utils/common\";\nvar _floor = Math.floor;\nvar eventsConsts = consts.events;\nvar statesConsts = consts.states;\nvar HOVER_STATE = statesConsts.hoverMark;\nvar NORMAL_STATE = statesConsts.normalMark;\nvar EVENT_NS = \"dxChartTracker\";\nvar DOT_EVENT_NS = \".\" + EVENT_NS;\nvar POINTER_ACTION = addNamespace([pointerEvents.down, pointerEvents.move], EVENT_NS);\nvar LEGEND_CLICK = \"legendClick\";\nvar SERIES_CLICK = \"seriesClick\";\nvar POINT_CLICK = \"pointClick\";\nvar POINT_DATA = \"chart-data-point\";\nvar SERIES_DATA = \"chart-data-series\";\nvar ARG_DATA = \"chart-data-argument\";\nvar DELAY = 100;\nvar HOLD_TIMEOUT = 300;\nvar NONE_MODE = \"none\";\nvar ALL_ARGUMENT_POINTS_MODE = \"allargumentpoints\";\nvar INCLUDE_POINTS_MODE = \"includepoints\";\nvar EXLUDE_POINTS_MODE = \"excludepoints\";\nvar LEGEND_HOVER_MODES = [INCLUDE_POINTS_MODE, EXLUDE_POINTS_MODE, NONE_MODE];\n\nfunction getData(event, dataKey, tryCheckParent) {\n  var target = event.target;\n\n  if (\"tspan\" === target.tagName) {\n    return target.parentNode[dataKey];\n  }\n\n  var data = target[dataKey];\n\n  if (tryCheckParent && !isDefined(data)) {\n    return function getParentData(node) {\n      if (node.parentNode) {\n        if (isDefined(node.parentNode[dataKey])) {\n          return node.parentNode[dataKey];\n        } else {\n          return getParentData(node.parentNode);\n        }\n      }\n\n      return;\n    }(target);\n  }\n\n  return data;\n}\n\nfunction eventCanceled(event, target) {\n  return event.cancel || !target.getOptions();\n}\n\nfunction correctLegendHoverMode(mode) {\n  if (LEGEND_HOVER_MODES.indexOf(mode) > -1) {\n    return mode;\n  } else {\n    return INCLUDE_POINTS_MODE;\n  }\n}\n\nfunction correctHoverMode(target) {\n  var mode = target.getOptions().hoverMode;\n  return mode === NONE_MODE ? mode : ALL_ARGUMENT_POINTS_MODE;\n}\n\nvar baseTrackerPrototype = {\n  ctor: function ctor(options) {\n    var that = this;\n    var data = {\n      tracker: that\n    };\n    that._renderer = options.renderer;\n    that._legend = options.legend;\n    that._tooltip = options.tooltip;\n    that._eventTrigger = options.eventTrigger;\n    that._seriesGroup = options.seriesGroup;\n    options.seriesGroup.off(DOT_EVENT_NS).on(addNamespace(eventsConsts.showPointTooltip, EVENT_NS), data, that._showPointTooltip).on(addNamespace(eventsConsts.hidePointTooltip, EVENT_NS), data, that._hidePointTooltip);\n\n    that._renderer.root.off(DOT_EVENT_NS).on(POINTER_ACTION, data, that._pointerHandler).on(addNamespace(pointerEvents.up, EVENT_NS), function () {\n      return clearTimeout(that._holdTimer);\n    }).on(addNamespace(clickEventName, EVENT_NS), data, that._clickHandler);\n  },\n  update: function update(options) {\n    this._chart = options.chart;\n  },\n  updateSeries: function updateSeries(series, resetDecorations) {\n    var that = this;\n    var noHoveredSeries = !(null !== series && void 0 !== series && series.some(function (s) {\n      return s === that.hoveredSeries;\n    }) || that._hoveredPoint && that._hoveredPoint.series);\n\n    if (that._storedSeries !== series) {\n      that._storedSeries = series || [];\n    }\n\n    if (noHoveredSeries) {\n      that._clean();\n\n      that._renderer.initHatching();\n    }\n\n    if (resetDecorations) {\n      that.clearSelection();\n\n      if (!noHoveredSeries) {\n        that._hideTooltip(that.pointAtShownTooltip);\n\n        that.clearHover();\n      }\n    }\n  },\n  setCanvases: function setCanvases(mainCanvas, paneCanvases) {\n    this._mainCanvas = mainCanvas;\n    this._canvases = paneCanvases;\n  },\n  repairTooltip: function repairTooltip() {\n    var point = this.pointAtShownTooltip;\n\n    if (!point || !point.series || !point.isVisible()) {\n      this._hideTooltip(point, true);\n    } else {\n      this._showTooltip(point);\n    }\n  },\n  _setHoveredPoint: function _setHoveredPoint(point) {\n    if (point === this._hoveredPoint) {\n      return;\n    }\n\n    this._releaseHoveredPoint();\n\n    point.hover();\n    this._hoveredPoint = point;\n  },\n  _releaseHoveredPoint: function _releaseHoveredPoint(isPointerOut) {\n    if (this._hoveredPoint && this._hoveredPoint.getOptions()) {\n      this._hoveredPoint.clearHover();\n\n      this._hoveredPoint = null;\n\n      if (this._tooltip.isEnabled()) {\n        this._hideTooltip(this._hoveredPoint, false, isPointerOut);\n      }\n    }\n  },\n  _setHoveredSeries: function _setHoveredSeries(series, mode) {\n    this._releaseHoveredSeries();\n\n    this._releaseHoveredPoint();\n\n    series.hover(mode);\n    this.hoveredSeries = series;\n  },\n  _releaseHoveredSeries: function _releaseHoveredSeries() {\n    if (this.hoveredSeries) {\n      this.hoveredSeries.clearHover();\n      this.hoveredSeries = null;\n    }\n  },\n  clearSelection: function clearSelection() {\n    this._storedSeries.forEach(function (series) {\n      if (series) {\n        series.clearSelection();\n        series.getPoints().forEach(function (point) {\n          return point.clearSelection();\n        });\n      }\n    });\n  },\n  _clean: function _clean() {\n    this.hoveredPoint = this.hoveredSeries = this._hoveredArgumentPoints = null;\n\n    this._hideTooltip(this.pointAtShownTooltip);\n  },\n  clearHover: function clearHover(isPointerOut) {\n    this._resetHoveredArgument();\n\n    this._releaseHoveredSeries();\n\n    this._releaseHoveredPoint(isPointerOut);\n  },\n  _hideTooltip: function _hideTooltip(point, silent, isPointerOut) {\n    if (!this._tooltip || point && this.pointAtShownTooltip !== point) {\n      return;\n    }\n\n    if (!silent && this.pointAtShownTooltip) {\n      this.pointAtShownTooltip = null;\n    }\n\n    this._tooltip.hide(!!isPointerOut);\n  },\n  _showTooltip: function _showTooltip(point) {\n    var that = this;\n    var tooltipFormatObject;\n    var eventData = {\n      target: point\n    };\n\n    if (null !== point && void 0 !== point && point.getOptions()) {\n      tooltipFormatObject = point.getTooltipFormatObject(that._tooltip, that._tooltip.isShared() && that._chart.getStackedPoints(point));\n\n      if (!isDefined(tooltipFormatObject.valueText) && !tooltipFormatObject.points || !point.isVisible()) {\n        return;\n      }\n\n      var coords = point.getTooltipParams(that._tooltip.getLocation());\n\n      var rootOffset = that._renderer.getRootOffset();\n\n      coords.x += rootOffset.left;\n      coords.y += rootOffset.top;\n\n      var callback = function callback(result) {\n        result && (that.pointAtShownTooltip = point);\n      };\n\n      callback(that._tooltip.show(tooltipFormatObject, coords, eventData, void 0, callback));\n    }\n  },\n  _showPointTooltip: function _showPointTooltip(event, point) {\n    var that = event.data.tracker;\n    var pointWithTooltip = that.pointAtShownTooltip;\n\n    if (pointWithTooltip && pointWithTooltip !== point) {\n      that._hideTooltip(pointWithTooltip);\n    }\n\n    that._showTooltip(point);\n  },\n  _hidePointTooltip: function _hidePointTooltip(event, point) {\n    event.data.tracker._hideTooltip(point, false, true);\n  },\n  _enableOutHandler: function _enableOutHandler() {\n    if (this._outHandler) {\n      return;\n    }\n\n    var that = this;\n\n    var handler = function handler(e) {\n      var rootOffset = that._renderer.getRootOffset();\n\n      var x = _floor(e.pageX - rootOffset.left);\n\n      var y = _floor(e.pageY - rootOffset.top);\n\n      if (!inCanvas(that._mainCanvas, x, y) && !that._isCursorOnTooltip(e)) {\n        that._pointerOut();\n\n        that._disableOutHandler();\n      }\n    };\n\n    eventsEngine.on(domAdapter.getDocument(), POINTER_ACTION, handler);\n    this._outHandler = handler;\n  },\n  _isCursorOnTooltip: function _isCursorOnTooltip(e) {\n    return this._tooltip.isEnabled() && this._tooltip.isCursorOnTooltip(e.pageX, e.pageY);\n  },\n  _disableOutHandler: function _disableOutHandler() {\n    this._outHandler && eventsEngine.off(domAdapter.getDocument(), POINTER_ACTION, this._outHandler);\n    this._outHandler = null;\n  },\n  stopCurrentHandling: function stopCurrentHandling() {\n    this._pointerOut(true);\n  },\n  _pointerOut: function _pointerOut(force) {\n    this.clearHover(true);\n    (force || this._tooltip.isEnabled()) && this._hideTooltip(this.pointAtShownTooltip, false, true);\n  },\n  _triggerLegendClick: function _triggerLegendClick(eventArgs, elementClick) {\n    var eventTrigger = this._eventTrigger;\n    eventTrigger(LEGEND_CLICK, eventArgs, function () {\n      !eventCanceled(eventArgs.event, eventArgs.target) && eventTrigger(elementClick, eventArgs);\n    });\n  },\n  _hoverLegendItem: function _hoverLegendItem(x, y) {\n    var item = this._legend.getItemByCoord(x, y);\n\n    var series;\n    var legendHoverMode = correctLegendHoverMode(this._legend.getOptions().hoverMode);\n\n    if (item) {\n      series = this._storedSeries[item.id];\n\n      if (!series.isHovered() || series.lastHoverMode !== legendHoverMode) {\n        this._setHoveredSeries(series, legendHoverMode);\n      }\n\n      this._tooltip.isEnabled() && this._hideTooltip(this.pointAtShownTooltip);\n    } else {\n      this.clearHover();\n    }\n  },\n  _hoverArgument: function _hoverArgument(argument, argumentIndex) {\n    var hoverMode = this._getArgumentHoverMode();\n\n    if (isDefined(argument)) {\n      this._releaseHoveredPoint();\n\n      this._hoveredArgument = argument;\n      this._argumentIndex = argumentIndex;\n\n      this._notifySeries({\n        action: \"pointHover\",\n        notifyLegend: this._notifyLegendOnHoverArgument,\n        target: {\n          argument: argument,\n          fullState: HOVER_STATE,\n          argumentIndex: argumentIndex,\n          getOptions: function getOptions() {\n            return {\n              hoverMode: hoverMode\n            };\n          }\n        }\n      });\n    }\n  },\n  _resetHoveredArgument: function _resetHoveredArgument() {\n    var hoverMode;\n\n    if (isDefined(this._hoveredArgument)) {\n      hoverMode = this._getArgumentHoverMode();\n\n      this._notifySeries({\n        action: \"clearPointHover\",\n        notifyLegend: this._notifyLegendOnHoverArgument,\n        target: {\n          fullState: NORMAL_STATE,\n          argumentIndex: this._argumentIndex,\n          argument: this._hoveredArgument,\n          getOptions: function getOptions() {\n            return {\n              hoverMode: hoverMode\n            };\n          }\n        }\n      });\n\n      this._hoveredArgument = null;\n    }\n  },\n  _notifySeries: function _notifySeries(data) {\n    this._storedSeries.forEach(function (series) {\n      series.notify(data);\n    });\n  },\n  _pointerHandler: function _pointerHandler(e) {\n    var _series;\n\n    var that = e.data.tracker;\n\n    var rootOffset = that._renderer.getRootOffset();\n\n    var x = _floor(e.pageX - rootOffset.left);\n\n    var y = _floor(e.pageY - rootOffset.top);\n\n    var canvas = that._getCanvas(x, y);\n\n    var series = getData(e, SERIES_DATA);\n    var point = getData(e, POINT_DATA) || (null === (_series = series) || void 0 === _series ? void 0 : _series.getPointByCoord(x, y));\n    that._isHolding = false;\n    clearTimeout(that._holdTimer);\n\n    if (e.type === pointerEvents.down) {\n      that._holdTimer = setTimeout(function () {\n        return that._isHolding = true;\n      }, HOLD_TIMEOUT);\n    }\n\n    if (point && !point.getMarkerVisibility()) {\n      point = void 0;\n    }\n\n    that._enableOutHandler();\n\n    if (that._legend.coordsIn(x, y)) {\n      that._hoverLegendItem(x, y);\n\n      return;\n    }\n\n    if (that.hoveredSeries && that.hoveredSeries !== that._stuckSeries) {\n      that._releaseHoveredSeries();\n    }\n\n    if (that._hoverArgumentAxis(x, y, e)) {\n      return;\n    }\n\n    if (that._isPointerOut(canvas, point)) {\n      that._pointerOut();\n    }\n\n    if (!canvas && !point) {\n      return;\n    }\n\n    if (series && !point) {\n      point = series.getNeighborPoint(x, y);\n\n      if (!that._stickyHovering && point && !point.coordsIn(x, y)) {\n        point = null;\n      }\n\n      if (series !== that.hoveredSeries) {\n        that._setTimeout(function () {\n          that._setHoveredSeries(series);\n\n          that._setStuckSeries(e, series, x, y);\n\n          that._pointerComplete(point, x, y);\n        }, series);\n\n        return;\n      }\n    } else if (point) {\n      if (e.type !== pointerEvents.move && \"touch\" !== e.pointerType) {\n        return;\n      }\n\n      if (that.hoveredSeries) {\n        that._setTimeout(function () {\n          return that._pointerOnPoint(point, x, y, e);\n        }, point);\n      } else {\n        that._pointerOnPoint(point, x, y, e);\n      }\n\n      return;\n    } else if (that._setStuckSeries(e, void 0, x, y) && that._stickyHovering) {\n      var _point;\n\n      series = that._stuckSeries;\n      point = series.getNeighborPoint(x, y);\n\n      that._releaseHoveredSeries();\n\n      (null === (_point = point) || void 0 === _point ? void 0 : _point.getMarkerVisibility()) && that._setHoveredPoint(point);\n    } else if (!that._stickyHovering) {\n      that._pointerOut();\n    }\n\n    that._pointerComplete(point, x, y);\n  },\n  _pointerOnPoint: function _pointerOnPoint(point, x, y) {\n    this._resetHoveredArgument();\n\n    this._setHoveredPoint(point);\n\n    this._pointerComplete(point, x, y);\n  },\n  _pointerComplete: function _pointerComplete(point) {\n    this.pointAtShownTooltip !== point && this._tooltip.isEnabled() && this._showTooltip(point);\n  },\n  _clickHandler: function _clickHandler(e) {\n    var _point2;\n\n    var that = e.data.tracker;\n\n    if (that._isHolding) {\n      return;\n    }\n\n    var rootOffset = that._renderer.getRootOffset();\n\n    var x = _floor(e.pageX - rootOffset.left);\n\n    var y = _floor(e.pageY - rootOffset.top);\n\n    var point = getData(e, POINT_DATA);\n    var series = that._stuckSeries || getData(e, SERIES_DATA) || (null === (_point2 = point) || void 0 === _point2 ? void 0 : _point2.series);\n    var axis = that._argumentAxis;\n\n    if (that._legend.coordsIn(x, y)) {\n      var item = that._legend.getItemByCoord(x, y);\n\n      if (item) {\n        that._legendClick(item, e);\n      }\n    } else if (null !== axis && void 0 !== axis && axis.coordsIn(x, y)) {\n      var argument = getData(e, ARG_DATA, true);\n\n      if (isDefined(argument)) {\n        that._eventTrigger(\"argumentAxisClick\", {\n          argument: argument,\n          event: e\n        });\n      }\n    } else if (series) {\n      var _point3;\n\n      point = point || series.getPointByCoord(x, y);\n\n      if (null !== (_point3 = point) && void 0 !== _point3 && _point3.getMarkerVisibility()) {\n        that._pointClick(point, e);\n      } else {\n        getData(e, SERIES_DATA) && that._eventTrigger(SERIES_CLICK, {\n          target: series,\n          event: e\n        });\n      }\n    }\n  },\n  dispose: function dispose() {\n    this._disableOutHandler();\n\n    this._renderer.root.off(DOT_EVENT_NS);\n\n    this._seriesGroup.off(DOT_EVENT_NS);\n  }\n};\nexport var ChartTracker = function ChartTracker(options) {\n  this.ctor(options);\n};\nextend(ChartTracker.prototype, baseTrackerPrototype, {\n  _pointClick: function _pointClick(point, event) {\n    var eventTrigger = this._eventTrigger;\n    var series = point.series;\n    eventTrigger(POINT_CLICK, {\n      target: point,\n      event: event\n    }, function () {\n      !eventCanceled(event, series) && eventTrigger(SERIES_CLICK, {\n        target: series,\n        event: event\n      });\n    });\n  },\n  update: function update(options) {\n    baseTrackerPrototype.update.call(this, options);\n    this._argumentAxis = options.argumentAxis || {};\n    this._axisHoverEnabled = this._argumentAxis && _normalizeEnum(this._argumentAxis.getOptions().hoverMode) === ALL_ARGUMENT_POINTS_MODE;\n    this._rotated = options.rotated;\n    this._crosshair = options.crosshair;\n    this._stickyHovering = options.stickyHovering;\n  },\n  _getCanvas: function _getCanvas(x, y) {\n    var canvases = this._canvases || [];\n\n    for (var i = 0; i < canvases.length; i++) {\n      var c = canvases[i];\n\n      if (inCanvas(c, x, y)) {\n        return c;\n      }\n    }\n\n    return null;\n  },\n  _isPointerOut: function _isPointerOut(canvas) {\n    return !canvas && this._stuckSeries;\n  },\n  _hideCrosshair: function _hideCrosshair() {\n    var _this$_crosshair;\n\n    null === (_this$_crosshair = this._crosshair) || void 0 === _this$_crosshair ? void 0 : _this$_crosshair.hide();\n  },\n  _moveCrosshair: function _moveCrosshair(point, x, y) {\n    if (this._crosshair && null !== point && void 0 !== point && point.isVisible()) {\n      this._crosshair.show({\n        point: point,\n        x: x,\n        y: y\n      });\n    }\n  },\n  _clean: function _clean() {\n    baseTrackerPrototype._clean.call(this);\n\n    this._resetTimer();\n\n    this._stuckSeries = null;\n  },\n  _getSeriesForShared: function _getSeriesForShared(x, y) {\n    var _point4;\n\n    var points = [];\n    var point = null;\n    var distance = 1 / 0;\n\n    if (this._tooltip.isShared() && !this.hoveredSeries) {\n      _each(this._storedSeries, function (_, series) {\n        var point = series.getNeighborPoint(x, y);\n        point && points.push(point);\n      });\n\n      _each(points, function (_, p) {\n        var coords = p.getCrosshairData(x, y);\n        var d = getDistance(x, y, coords.x, coords.y);\n\n        if (d < distance) {\n          point = p;\n          distance = d;\n        }\n      });\n    }\n\n    return null === (_point4 = point) || void 0 === _point4 ? void 0 : _point4.series;\n  },\n  _setTimeout: function _setTimeout(callback, keeper) {\n    var that = this;\n\n    if (that._timeoutKeeper !== keeper) {\n      that._resetTimer();\n\n      that._hoverTimeout = setTimeout(function () {\n        callback();\n        that._timeoutKeeper = null;\n      }, DELAY);\n      that._timeoutKeeper = keeper;\n    }\n  },\n  _resetTimer: function _resetTimer() {\n    clearTimeout(this._hoverTimeout);\n    this._timeoutKeeper = this._hoverTimeout = null;\n  },\n  _stopEvent: function _stopEvent(e) {\n    if (!isDefined(e.cancelable) || e.cancelable) {\n      e.preventDefault();\n      e.stopPropagation();\n    }\n  },\n  _setStuckSeries: function _setStuckSeries(e, series, x, y) {\n    if (\"mouse\" !== e.pointerType) {\n      this._stuckSeries = null;\n    } else {\n      this._stuckSeries = series || this._stuckSeries || this._getSeriesForShared(x, y);\n    }\n\n    return !!this._stuckSeries;\n  },\n  _pointerOut: function _pointerOut() {\n    var that = this;\n    that._stuckSeries = null;\n\n    that._hideCrosshair();\n\n    that._resetTimer();\n\n    baseTrackerPrototype._pointerOut.apply(that, arguments);\n  },\n  _hoverArgumentAxis: function _hoverArgumentAxis(x, y, e) {\n    this._resetHoveredArgument();\n\n    if (this._axisHoverEnabled && this._argumentAxis.coordsIn(x, y)) {\n      this._hoverArgument(getData(e, ARG_DATA, true));\n\n      return true;\n    }\n  },\n  _pointerComplete: function _pointerComplete(point, x, y) {\n    this.hoveredSeries && this.hoveredSeries.updateHover(x, y);\n\n    this._resetTimer();\n\n    this._moveCrosshair(point, x, y);\n\n    baseTrackerPrototype._pointerComplete.call(this, point);\n  },\n  _legendClick: function _legendClick(item, e) {\n    var series = this._storedSeries[item.id];\n\n    this._triggerLegendClick({\n      target: series,\n      event: e\n    }, SERIES_CLICK);\n  },\n  _hoverLegendItem: function _hoverLegendItem(x, y) {\n    this._stuckSeries = null;\n\n    this._hideCrosshair();\n\n    baseTrackerPrototype._hoverLegendItem.call(this, x, y);\n  },\n  _pointerOnPoint: function _pointerOnPoint(point, x, y, e) {\n    this._setStuckSeries(e, point.series, x, y);\n\n    this._releaseHoveredSeries();\n\n    baseTrackerPrototype._pointerOnPoint.call(this, point, x, y, e);\n  },\n  _notifyLegendOnHoverArgument: false,\n  _getArgumentHoverMode: function _getArgumentHoverMode() {\n    return correctHoverMode(this._argumentAxis);\n  },\n  dispose: function dispose() {\n    this._resetTimer();\n\n    baseTrackerPrototype.dispose.call(this);\n  }\n});\nexport var PieTracker = function PieTracker(options) {\n  this.ctor(options);\n};\nextend(PieTracker.prototype, baseTrackerPrototype, {\n  _isPointerOut: function _isPointerOut(_, point) {\n    return !point;\n  },\n  _legendClick: function _legendClick(item, e) {\n    var points = [];\n\n    this._storedSeries.forEach(function (s) {\n      return points.push.apply(points, s.getPointsByKeys(item.argument, item.argumentIndex));\n    });\n\n    this._eventTrigger(LEGEND_CLICK, {\n      target: item.argument,\n      points: points,\n      event: e\n    });\n  },\n  _pointClick: function _pointClick(point, e) {\n    this._eventTrigger(POINT_CLICK, {\n      target: point,\n      event: e\n    });\n  },\n  _hoverLegendItem: function _hoverLegendItem(x, y) {\n    var item = this._legend.getItemByCoord(x, y);\n\n    if (item && this._hoveredArgument !== item.argument) {\n      this._resetHoveredArgument();\n\n      this._hoverArgument(item.argument, item.argumentIndex);\n    } else if (!item) {\n      this.clearHover();\n    }\n  },\n  _getArgumentHoverMode: function _getArgumentHoverMode() {\n    return correctHoverMode(this._legend);\n  },\n  _hoverArgumentAxis: _noop,\n  _setStuckSeries: _noop,\n  _getCanvas: _noop,\n  _notifyLegendOnHoverArgument: true\n});","map":null,"metadata":{},"sourceType":"module"}