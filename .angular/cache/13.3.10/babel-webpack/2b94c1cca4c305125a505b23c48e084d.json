{"ast":null,"code":"import _classCallCheck from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n\n/**\r\n * DevExtreme (esm/ui/scheduler/workspaces/ui.scheduler.work_space.grouped.strategy.horizontal.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { getBoundingRect } from \"../../../core/utils/position\";\nimport { FIRST_GROUP_CELL_CLASS, LAST_GROUP_CELL_CLASS } from \"../classes\";\n\nvar HorizontalGroupedStrategy = /*#__PURE__*/function () {\n  function HorizontalGroupedStrategy(workSpace) {\n    _classCallCheck(this, HorizontalGroupedStrategy);\n\n    this._workSpace = workSpace;\n  }\n\n  _createClass(HorizontalGroupedStrategy, [{\n    key: \"prepareCellIndexes\",\n    value: function prepareCellIndexes(cellCoordinates, groupIndex, inAllDay) {\n      var groupByDay = this._workSpace.isGroupedByDate();\n\n      if (!groupByDay) {\n        return {\n          rowIndex: cellCoordinates.rowIndex,\n          columnIndex: cellCoordinates.columnIndex + groupIndex * this._workSpace._getCellCount()\n        };\n      } else {\n        return {\n          rowIndex: cellCoordinates.rowIndex,\n          columnIndex: cellCoordinates.columnIndex * this._workSpace._getGroupCount() + groupIndex\n        };\n      }\n    }\n  }, {\n    key: \"getGroupIndex\",\n    value: function getGroupIndex(rowIndex, columnIndex) {\n      var groupByDay = this._workSpace.isGroupedByDate();\n\n      var groupCount = this._workSpace._getGroupCount();\n\n      if (groupByDay) {\n        return columnIndex % groupCount;\n      } else {\n        return Math.floor(columnIndex / this._workSpace._getCellCount());\n      }\n    }\n  }, {\n    key: \"calculateHeaderCellRepeatCount\",\n    value: function calculateHeaderCellRepeatCount() {\n      return this._workSpace._getGroupCount() || 1;\n    }\n  }, {\n    key: \"insertAllDayRowsIntoDateTable\",\n    value: function insertAllDayRowsIntoDateTable() {\n      return false;\n    }\n  }, {\n    key: \"getTotalCellCount\",\n    value: function getTotalCellCount(groupCount) {\n      groupCount = groupCount || 1;\n      return this._workSpace._getCellCount() * groupCount;\n    }\n  }, {\n    key: \"getTotalRowCount\",\n    value: function getTotalRowCount() {\n      return this._workSpace._getRowCount();\n    }\n  }, {\n    key: \"calculateTimeCellRepeatCount\",\n    value: function calculateTimeCellRepeatCount() {\n      return 1;\n    }\n  }, {\n    key: \"getWorkSpaceMinWidth\",\n    value: function getWorkSpaceMinWidth() {\n      return getBoundingRect(this._workSpace.$element().get(0)).width - this._workSpace.getTimePanelWidth();\n    }\n  }, {\n    key: \"getAllDayOffset\",\n    value: function getAllDayOffset() {\n      return this._workSpace.getAllDayHeight();\n    }\n  }, {\n    key: \"getGroupCountClass\",\n    value: function getGroupCountClass(groups) {\n      return;\n    }\n  }, {\n    key: \"getLeftOffset\",\n    value: function getLeftOffset() {\n      return this._workSpace.getTimePanelWidth();\n    }\n  }, {\n    key: \"_createGroupBoundOffset\",\n    value: function _createGroupBoundOffset(startCell, endCell, cellWidth) {\n      var extraOffset = cellWidth / 2;\n      var startOffset = startCell ? startCell.offset().left - extraOffset : 0;\n      var endOffset = endCell ? endCell.offset().left + cellWidth + extraOffset : 0;\n      return {\n        left: startOffset,\n        right: endOffset,\n        top: 0,\n        bottom: 0\n      };\n    }\n  }, {\n    key: \"_getGroupedByDateBoundOffset\",\n    value: function _getGroupedByDateBoundOffset($cells, cellWidth) {\n      var lastCellIndex = $cells.length - 1;\n      var startCell = $cells.eq(0);\n      var endCell = $cells.eq(lastCellIndex);\n      return this._createGroupBoundOffset(startCell, endCell, cellWidth);\n    }\n  }, {\n    key: \"getGroupBoundsOffset\",\n    value: function getGroupBoundsOffset(cellCount, $cells, cellWidth, coordinates, groupedDataMap) {\n      if (this._workSpace.isGroupedByDate()) {\n        return this._getGroupedByDateBoundOffset($cells, cellWidth);\n      }\n\n      var startCell;\n      var endCell;\n\n      var cellIndex = this._workSpace.getCellIndexByCoordinates(coordinates);\n\n      var groupIndex = coordinates.groupIndex || Math.floor(cellIndex / cellCount);\n      var currentCellGroup = groupedDataMap.dateTableGroupedMap[groupIndex];\n\n      if (currentCellGroup) {\n        var groupRowLength = currentCellGroup[0].length;\n        var groupStartPosition = currentCellGroup[0][0].position;\n        var groupEndPosition = currentCellGroup[0][groupRowLength - 1].position;\n        startCell = $cells.eq(groupStartPosition.columnIndex);\n        endCell = $cells.eq(groupEndPosition.columnIndex);\n      }\n\n      return this._createGroupBoundOffset(startCell, endCell, cellWidth);\n    }\n  }, {\n    key: \"shiftIndicator\",\n    value: function shiftIndicator($indicator, height, rtlOffset, groupIndex) {\n      var offset = this._getIndicatorOffset(groupIndex);\n\n      var horizontalOffset = rtlOffset ? rtlOffset - offset : offset;\n      $indicator.css(\"left\", horizontalOffset);\n      $indicator.css(\"top\", height);\n    }\n  }, {\n    key: \"_getIndicatorOffset\",\n    value: function _getIndicatorOffset(groupIndex) {\n      var groupByDay = this._workSpace.isGroupedByDate();\n\n      return groupByDay ? this._calculateGroupByDateOffset(groupIndex) : this._calculateOffset(groupIndex);\n    }\n  }, {\n    key: \"_calculateOffset\",\n    value: function _calculateOffset(groupIndex) {\n      return this._workSpace._getCellCount() * this._workSpace.getRoundedCellWidth(groupIndex - 1, 0) * groupIndex + this._workSpace.getIndicatorOffset(groupIndex) + groupIndex;\n    }\n  }, {\n    key: \"_calculateGroupByDateOffset\",\n    value: function _calculateGroupByDateOffset(groupIndex) {\n      return this._workSpace.getIndicatorOffset(0) * this._workSpace._getGroupCount() + this._workSpace.getRoundedCellWidth(groupIndex - 1, 0) * groupIndex;\n    }\n  }, {\n    key: \"getShaderOffset\",\n    value: function getShaderOffset(i, width) {\n      var offset = this._workSpace._getCellCount() * this._workSpace.getRoundedCellWidth(i - 1) * i;\n      return this._workSpace.option(\"rtlEnabled\") ? getBoundingRect(this._workSpace._dateTableScrollable.$content().get(0)).width - offset - this._workSpace.getTimePanelWidth() - width : offset;\n    }\n  }, {\n    key: \"getShaderTopOffset\",\n    value: function getShaderTopOffset(i) {\n      return -this.getShaderMaxHeight() * (i > 0 ? 1 : 0);\n    }\n  }, {\n    key: \"getShaderHeight\",\n    value: function getShaderHeight() {\n      var height = this._workSpace.getIndicationHeight();\n\n      return height;\n    }\n  }, {\n    key: \"getShaderMaxHeight\",\n    value: function getShaderMaxHeight() {\n      return getBoundingRect(this._workSpace._dateTableScrollable.$content().get(0)).height;\n    }\n  }, {\n    key: \"getShaderWidth\",\n    value: function getShaderWidth(i) {\n      return this._workSpace.getIndicationWidth(i);\n    }\n  }, {\n    key: \"getScrollableScrollTop\",\n    value: function getScrollableScrollTop(allDay) {\n      return !allDay ? this._workSpace.getScrollable().scrollTop() : 0;\n    }\n  }, {\n    key: \"addAdditionalGroupCellClasses\",\n    value: function addAdditionalGroupCellClasses(cellClass, index, i, j) {\n      var applyUnconditionally = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : false;\n      cellClass = this._addLastGroupCellClass(cellClass, index, applyUnconditionally);\n      return this._addFirstGroupCellClass(cellClass, index, applyUnconditionally);\n    }\n  }, {\n    key: \"_addLastGroupCellClass\",\n    value: function _addLastGroupCellClass(cellClass, index, applyUnconditionally) {\n      if (applyUnconditionally) {\n        return \"\".concat(cellClass, \" \").concat(LAST_GROUP_CELL_CLASS);\n      }\n\n      var groupByDate = this._workSpace.isGroupedByDate();\n\n      if (groupByDate) {\n        if (index % this._workSpace._getGroupCount() === 0) {\n          return \"\".concat(cellClass, \" \").concat(LAST_GROUP_CELL_CLASS);\n        }\n      } else if (index % this._workSpace._getCellCount() === 0) {\n        return \"\".concat(cellClass, \" \").concat(LAST_GROUP_CELL_CLASS);\n      }\n\n      return cellClass;\n    }\n  }, {\n    key: \"_addFirstGroupCellClass\",\n    value: function _addFirstGroupCellClass(cellClass, index, applyUnconditionally) {\n      if (applyUnconditionally) {\n        return \"\".concat(cellClass, \" \").concat(FIRST_GROUP_CELL_CLASS);\n      }\n\n      var groupByDate = this._workSpace.isGroupedByDate();\n\n      if (groupByDate) {\n        if ((index - 1) % this._workSpace._getGroupCount() === 0) {\n          return \"\".concat(cellClass, \" \").concat(FIRST_GROUP_CELL_CLASS);\n        }\n      } else if ((index - 1) % this._workSpace._getCellCount() === 0) {\n        return \"\".concat(cellClass, \" \").concat(FIRST_GROUP_CELL_CLASS);\n      }\n\n      return cellClass;\n    }\n  }]);\n\n  return HorizontalGroupedStrategy;\n}();\n\nexport default HorizontalGroupedStrategy;","map":null,"metadata":{},"sourceType":"module"}