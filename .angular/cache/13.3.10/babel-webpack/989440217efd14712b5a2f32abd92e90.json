{"ast":null,"code":"/**\r\n * DevExtreme (esm/events/gesture/emitter.gesture.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport $ from \"../../core/renderer\";\nimport eventsEngine from \"../../events/core/events_engine\";\nimport devices from \"../../core/devices\";\nimport { styleProp } from \"../../core/utils/style\";\nimport callOnce from \"../../core/utils/call_once\";\nimport { resetActiveElement, clearSelection } from \"../../core/utils/dom\";\nimport readyCallbacks from \"../../core/utils/ready_callbacks\";\nvar ready = readyCallbacks.add;\nimport { sign } from \"../../core/utils/math\";\nimport { noop } from \"../../core/utils/common\";\nimport { isDefined } from \"../../core/utils/type\";\nimport { needSkipEvent, createEvent, eventData, isDxMouseWheelEvent, eventDelta, isTouchEvent } from \"../utils/index\";\nimport Emitter from \"../core/emitter\";\nvar abs = Math.abs;\nvar SLEEP = 0;\nvar INITED = 1;\nvar STARTED = 2;\nvar TOUCH_BOUNDARY = 10;\nvar IMMEDIATE_TOUCH_BOUNDARY = 0;\nvar IMMEDIATE_TIMEOUT = 180;\n\nvar supportPointerEvents = function supportPointerEvents() {\n  return styleProp(\"pointer-events\");\n};\n\nvar setGestureCover = callOnce(function () {\n  var isDesktop = \"desktop\" === devices.real().deviceType;\n\n  if (!supportPointerEvents() || !isDesktop) {\n    return noop;\n  }\n\n  var $cover = $(\"<div>\").addClass(\"dx-gesture-cover\").css(\"pointerEvents\", \"none\");\n  eventsEngine.subscribeGlobal($cover, \"dxmousewheel\", function (e) {\n    e.preventDefault();\n  });\n  ready(function () {\n    $cover.appendTo(\"body\");\n  });\n  return function (toggle, cursor) {\n    $cover.css(\"pointerEvents\", toggle ? \"all\" : \"none\");\n    toggle && $cover.css(\"cursor\", cursor);\n  };\n});\n\nvar gestureCover = function gestureCover(toggle, cursor) {\n  var gestureCoverStrategy = setGestureCover();\n  gestureCoverStrategy(toggle, cursor);\n};\n\nvar GestureEmitter = Emitter.inherit({\n  gesture: true,\n  configure: function configure(data) {\n    this.getElement().css(\"msTouchAction\", data.immediate ? \"pinch-zoom\" : \"\");\n    this.callBase(data);\n  },\n  allowInterruptionByMouseWheel: function allowInterruptionByMouseWheel() {\n    return this._stage !== STARTED;\n  },\n  getDirection: function getDirection() {\n    return this.direction;\n  },\n  _cancel: function _cancel() {\n    this.callBase.apply(this, arguments);\n\n    this._toggleGestureCover(false);\n\n    this._stage = SLEEP;\n  },\n  start: function start(e) {\n    if (e._needSkipEvent || needSkipEvent(e)) {\n      this._cancel(e);\n\n      return;\n    }\n\n    this._startEvent = createEvent(e);\n    this._startEventData = eventData(e);\n    this._stage = INITED;\n\n    this._init(e);\n\n    this._setupImmediateTimer();\n  },\n  _setupImmediateTimer: function _setupImmediateTimer() {\n    clearTimeout(this._immediateTimer);\n    this._immediateAccepted = false;\n\n    if (!this.immediate) {\n      return;\n    }\n\n    this._immediateTimer = setTimeout(function () {\n      this._immediateAccepted = true;\n    }.bind(this), IMMEDIATE_TIMEOUT);\n  },\n  move: function move(e) {\n    if (this._stage === INITED && this._directionConfirmed(e)) {\n      this._stage = STARTED;\n\n      this._resetActiveElement();\n\n      this._toggleGestureCover(true);\n\n      this._clearSelection(e);\n\n      this._adjustStartEvent(e);\n\n      this._start(this._startEvent);\n\n      if (this._stage === SLEEP) {\n        return;\n      }\n\n      this._requestAccept(e);\n\n      this._move(e);\n\n      this._forgetAccept();\n    } else if (this._stage === STARTED) {\n      this._clearSelection(e);\n\n      this._move(e);\n    }\n  },\n  _directionConfirmed: function _directionConfirmed(e) {\n    var touchBoundary = this._getTouchBoundary(e);\n\n    var delta = eventDelta(this._startEventData, eventData(e));\n    var deltaX = abs(delta.x);\n    var deltaY = abs(delta.y);\n\n    var horizontalMove = this._validateMove(touchBoundary, deltaX, deltaY);\n\n    var verticalMove = this._validateMove(touchBoundary, deltaY, deltaX);\n\n    var direction = this.getDirection(e);\n    var bothAccepted = \"both\" === direction && (horizontalMove || verticalMove);\n    var horizontalAccepted = \"horizontal\" === direction && horizontalMove;\n    var verticalAccepted = \"vertical\" === direction && verticalMove;\n    return bothAccepted || horizontalAccepted || verticalAccepted || this._immediateAccepted;\n  },\n  _validateMove: function _validateMove(touchBoundary, mainAxis, crossAxis) {\n    return mainAxis && mainAxis >= touchBoundary && (this.immediate ? mainAxis >= crossAxis : true);\n  },\n  _getTouchBoundary: function _getTouchBoundary(e) {\n    return this.immediate || isDxMouseWheelEvent(e) ? IMMEDIATE_TOUCH_BOUNDARY : TOUCH_BOUNDARY;\n  },\n  _adjustStartEvent: function _adjustStartEvent(e) {\n    var touchBoundary = this._getTouchBoundary(e);\n\n    var delta = eventDelta(this._startEventData, eventData(e));\n    this._startEvent.pageX += sign(delta.x) * touchBoundary;\n    this._startEvent.pageY += sign(delta.y) * touchBoundary;\n  },\n  _resetActiveElement: function _resetActiveElement() {\n    if (\"ios\" === devices.real().platform && this.getElement().find(\":focus\").length) {\n      resetActiveElement();\n    }\n  },\n  _toggleGestureCover: function _toggleGestureCover(toggle) {\n    this._toggleGestureCoverImpl(toggle);\n  },\n  _toggleGestureCoverImpl: function _toggleGestureCoverImpl(toggle) {\n    var isStarted = this._stage === STARTED;\n\n    if (isStarted) {\n      gestureCover(toggle, this.getElement().css(\"cursor\"));\n    }\n  },\n  _clearSelection: function _clearSelection(e) {\n    if (isDxMouseWheelEvent(e) || isTouchEvent(e)) {\n      return;\n    }\n\n    clearSelection();\n  },\n  end: function end(e) {\n    this._toggleGestureCover(false);\n\n    if (this._stage === STARTED) {\n      this._end(e);\n    } else if (this._stage === INITED) {\n      this._stop(e);\n    }\n\n    this._stage = SLEEP;\n  },\n  dispose: function dispose() {\n    clearTimeout(this._immediateTimer);\n    this.callBase.apply(this, arguments);\n\n    this._toggleGestureCover(false);\n  },\n  _init: noop,\n  _start: noop,\n  _move: noop,\n  _stop: noop,\n  _end: noop\n});\nGestureEmitter.initialTouchBoundary = TOUCH_BOUNDARY;\n\nGestureEmitter.touchBoundary = function (newBoundary) {\n  if (isDefined(newBoundary)) {\n    TOUCH_BOUNDARY = newBoundary;\n    return;\n  }\n\n  return TOUCH_BOUNDARY;\n};\n\nexport default GestureEmitter;","map":null,"metadata":{},"sourceType":"module"}