{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/grid_core/ui.grid_core.utils.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { getHeight } from \"../../core/utils/size\";\nimport $ from \"../../core/renderer\";\nimport { isDefined, isFunction } from \"../../core/utils/type\";\nimport { when } from \"../../core/utils/deferred\";\nimport sharedFiltering from \"../shared/filtering\";\nimport { format } from \"../../core/utils/string\";\nimport { each } from \"../../core/utils/iterator\";\nimport { extend } from \"../../core/utils/extend\";\nimport { getBoundingRect } from \"../../core/utils/position\";\nimport { toComparable } from \"../../core/utils/data\";\nimport { equalByValue } from \"../../core/utils/common\";\nimport LoadPanel from \"../load_panel\";\nimport { normalizeSortingInfo as normalizeSortingInfoUtility } from \"../../data/utils\";\nimport formatHelper from \"../../format_helper\";\nimport { getWindow } from \"../../core/utils/window\";\nimport eventsEngine from \"../../events/core/events_engine\";\nvar DATAGRID_SELECTION_DISABLED_CLASS = \"dx-selection-disabled\";\nvar DATAGRID_GROUP_OPENED_CLASS = \"dx-datagrid-group-opened\";\nvar DATAGRID_GROUP_CLOSED_CLASS = \"dx-datagrid-group-closed\";\nvar DATAGRID_EXPAND_CLASS = \"dx-datagrid-expand\";\nvar NO_DATA_CLASS = \"nodata\";\nvar SCROLLING_MODE_INFINITE = \"infinite\";\nvar SCROLLING_MODE_VIRTUAL = \"virtual\";\nvar LEGACY_SCROLLING_MODE = \"scrolling.legacyMode\";\nvar SCROLLING_MODE_OPTION = \"scrolling.mode\";\nvar ROW_RENDERING_MODE_OPTION = \"scrolling.rowRenderingMode\";\nvar DATE_INTERVAL_SELECTORS = {\n  year: function year(value) {\n    return value && value.getFullYear();\n  },\n  month: function month(value) {\n    return value && value.getMonth() + 1;\n  },\n  day: function day(value) {\n    return value && value.getDate();\n  },\n  quarter: function quarter(value) {\n    return value && Math.floor(value.getMonth() / 3) + 1;\n  },\n  hour: function hour(value) {\n    return value && value.getHours();\n  },\n  minute: function minute(value) {\n    return value && value.getMinutes();\n  },\n  second: function second(value) {\n    return value && value.getSeconds();\n  }\n};\n\nvar getIntervalSelector = function getIntervalSelector() {\n  var data = arguments[1];\n  var value = this.calculateCellValue(data);\n\n  if (!isDefined(value)) {\n    return null;\n  } else if (isDateType(this.dataType)) {\n    var nameIntervalSelector = arguments[0];\n    return DATE_INTERVAL_SELECTORS[nameIntervalSelector](value);\n  } else if (\"number\" === this.dataType) {\n    var groupInterval = arguments[0];\n    return Math.floor(Number(value) / groupInterval) * groupInterval;\n  }\n};\n\nvar equalSelectors = function equalSelectors(selector1, selector2) {\n  if (isFunction(selector1) && isFunction(selector2)) {\n    if (selector1.originalCallback && selector2.originalCallback) {\n      return selector1.originalCallback === selector2.originalCallback && selector1.columnIndex === selector2.columnIndex;\n    }\n  }\n\n  return selector1 === selector2;\n};\n\nfunction isDateType(dataType) {\n  return \"date\" === dataType || \"datetime\" === dataType;\n}\n\nvar setEmptyText = function setEmptyText($container) {\n  $container.get(0).textContent = \"\\xa0\";\n};\n\nvar normalizeSortingInfo = function normalizeSortingInfo(sort) {\n  sort = sort || [];\n  var result = normalizeSortingInfoUtility(sort);\n\n  for (var i = 0; i < sort.length; i++) {\n    if (sort && sort[i] && void 0 !== sort[i].isExpanded) {\n      result[i].isExpanded = sort[i].isExpanded;\n    }\n\n    if (sort && sort[i] && void 0 !== sort[i].groupInterval) {\n      result[i].groupInterval = sort[i].groupInterval;\n    }\n  }\n\n  return result;\n};\n\nvar formatValue = function formatValue(value, options) {\n  var valueText = formatHelper.format(value, options.format) || value && value.toString() || \"\";\n  var formatObject = {\n    value: value,\n    valueText: options.getDisplayFormat ? options.getDisplayFormat(valueText) : valueText,\n    target: options.target || \"row\",\n    groupInterval: options.groupInterval\n  };\n  return options.customizeText ? options.customizeText.call(options, formatObject) : formatObject.valueText;\n};\n\nvar getSummaryText = function getSummaryText(summaryItem, summaryTexts) {\n  var displayFormat = summaryItem.displayFormat || summaryItem.columnCaption && summaryTexts[summaryItem.summaryType + \"OtherColumn\"] || summaryTexts[summaryItem.summaryType];\n  return formatValue(summaryItem.value, {\n    format: summaryItem.valueFormat,\n    getDisplayFormat: function getDisplayFormat(valueText) {\n      return displayFormat ? format(displayFormat, valueText, summaryItem.columnCaption) : valueText;\n    },\n    customizeText: summaryItem.customizeText\n  });\n};\n\nvar getWidgetInstance = function getWidgetInstance($element) {\n  var editorData = $element.data && $element.data();\n  var dxComponents = editorData && editorData.dxComponents;\n  var widgetName = dxComponents && dxComponents[0];\n  return widgetName && editorData[widgetName];\n};\n\nvar equalFilterParameters = function equalFilterParameters(filter1, filter2) {\n  if (Array.isArray(filter1) && Array.isArray(filter2)) {\n    if (filter1.length !== filter2.length) {\n      return false;\n    } else {\n      for (var i = 0; i < filter1.length; i++) {\n        if (!equalFilterParameters(filter1[i], filter2[i])) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  } else if (isFunction(filter1) && filter1.columnIndex >= 0 && isFunction(filter2) && filter2.columnIndex >= 0) {\n    return filter1.columnIndex === filter2.columnIndex && toComparable(filter1.filterValue) === toComparable(filter2.filterValue);\n  } else {\n    return toComparable(filter1) == toComparable(filter2);\n  }\n};\n\nexport default {\n  renderNoDataText: function renderNoDataText($element) {\n    $element = $element || this.element();\n\n    if (!$element) {\n      return;\n    }\n\n    var noDataClass = this.addWidgetPrefix(NO_DATA_CLASS);\n    var noDataElement = $element.find(\".\" + noDataClass).last();\n\n    var isVisible = this._dataController.isEmpty();\n\n    var isLoading = this._dataController.isLoading();\n\n    if (!noDataElement.length) {\n      noDataElement = $(\"<span>\").addClass(noDataClass).appendTo($element);\n    }\n\n    if (isVisible && !isLoading) {\n      noDataElement.removeClass(\"dx-hidden\").text(this._getNoDataText());\n    } else {\n      noDataElement.addClass(\"dx-hidden\");\n    }\n  },\n  renderLoadPanel: function renderLoadPanel($element, $container, isLocalStore) {\n    var loadPanelOptions;\n    this._loadPanel && this._loadPanel.$element().remove();\n    loadPanelOptions = this.option(\"loadPanel\");\n\n    if (loadPanelOptions && (\"auto\" === loadPanelOptions.enabled ? !isLocalStore : loadPanelOptions.enabled)) {\n      loadPanelOptions = extend({\n        shading: false,\n        message: loadPanelOptions.text,\n        container: $container\n      }, loadPanelOptions);\n      this._loadPanel = this._createComponent($(\"<div>\").appendTo($container), LoadPanel, loadPanelOptions);\n    } else {\n      this._loadPanel = null;\n    }\n  },\n  calculateLoadPanelPosition: function calculateLoadPanelPosition($element) {\n    var $window = $(getWindow());\n\n    if (getHeight($element) > getHeight($window)) {\n      return {\n        of: $window,\n        boundary: $element,\n        collision: \"fit\"\n      };\n    }\n\n    return {\n      of: $element\n    };\n  },\n  getIndexByKey: function getIndexByKey(key, items, keyName) {\n    var index = -1;\n\n    if (void 0 !== key && Array.isArray(items)) {\n      keyName = arguments.length <= 2 ? \"key\" : keyName;\n\n      for (var i = 0; i < items.length; i++) {\n        var item = isDefined(keyName) ? items[i][keyName] : items[i];\n\n        if (equalByValue(key, item)) {\n          index = i;\n          break;\n        }\n      }\n    }\n\n    return index;\n  },\n  combineFilters: function combineFilters(filters, operation) {\n    var resultFilter = [];\n    operation = operation || \"and\";\n\n    for (var i = 0; i < filters.length; i++) {\n      var _filters$i;\n\n      if (!filters[i]) {\n        continue;\n      }\n\n      if (1 === (null === (_filters$i = filters[i]) || void 0 === _filters$i ? void 0 : _filters$i.length) && \"!\" === filters[i][0]) {\n        if (\"and\" === operation) {\n          return [\"!\"];\n        } else if (\"or\" === operation) {\n          continue;\n        }\n      }\n\n      if (resultFilter.length) {\n        resultFilter.push(operation);\n      }\n\n      resultFilter.push(filters[i]);\n    }\n\n    if (1 === resultFilter.length) {\n      resultFilter = resultFilter[0];\n    }\n\n    if (resultFilter.length) {\n      return resultFilter;\n    }\n  },\n  checkChanges: function checkChanges(changes, changeNames) {\n    var changesWithChangeNamesCount = 0;\n\n    for (var i = 0; i < changeNames.length; i++) {\n      if (changes[changeNames[i]]) {\n        changesWithChangeNamesCount++;\n      }\n    }\n\n    return changes.length && changes.length === changesWithChangeNamesCount;\n  },\n  equalFilterParameters: equalFilterParameters,\n  proxyMethod: function proxyMethod(instance, methodName, defaultResult) {\n    if (!instance[methodName]) {\n      instance[methodName] = function () {\n        var dataSource = this._dataSource;\n        return dataSource ? dataSource[methodName].apply(dataSource, arguments) : defaultResult;\n      };\n    }\n  },\n  formatValue: formatValue,\n  getFormatOptionsByColumn: function getFormatOptionsByColumn(column, target) {\n    return {\n      format: column.format,\n      getDisplayFormat: column.getDisplayFormat,\n      customizeText: column.customizeText,\n      target: target,\n      trueText: column.trueText,\n      falseText: column.falseText\n    };\n  },\n  getDisplayValue: function getDisplayValue(column, value, data, rowType) {\n    if (column.displayValueMap && void 0 !== column.displayValueMap[value]) {\n      return column.displayValueMap[value];\n    } else if (column.calculateDisplayValue && data && \"group\" !== rowType) {\n      return column.calculateDisplayValue(data);\n    } else if (column.lookup && !(\"group\" === rowType && (column.calculateGroupValue || column.calculateDisplayValue))) {\n      return column.lookup.calculateCellValue(value);\n    }\n\n    return value;\n  },\n  getGroupRowSummaryText: function getGroupRowSummaryText(summaryItems, summaryTexts) {\n    var result = \"(\";\n\n    for (var i = 0; i < summaryItems.length; i++) {\n      var summaryItem = summaryItems[i];\n      result += (i > 0 ? \", \" : \"\") + getSummaryText(summaryItem, summaryTexts);\n    }\n\n    return result + \")\";\n  },\n  getSummaryText: getSummaryText,\n  normalizeSortingInfo: normalizeSortingInfo,\n  getFormatByDataType: function getFormatByDataType(dataType) {\n    switch (dataType) {\n      case \"date\":\n        return \"shortDate\";\n\n      case \"datetime\":\n        return \"shortDateShortTime\";\n    }\n  },\n  getHeaderFilterGroupParameters: function getHeaderFilterGroupParameters(column, remoteGrouping) {\n    var result = [];\n    var dataField = column.dataField || column.name;\n    var groupInterval = sharedFiltering.getGroupInterval(column);\n\n    if (groupInterval) {\n      each(groupInterval, function (index, interval) {\n        result.push(remoteGrouping ? {\n          selector: dataField,\n          groupInterval: interval,\n          isExpanded: index < groupInterval.length - 1\n        } : getIntervalSelector.bind(column, interval));\n      });\n      return result;\n    }\n\n    if (remoteGrouping) {\n      result = [{\n        selector: dataField,\n        isExpanded: false\n      }];\n    } else {\n      result = function result(data) {\n        var result = column.calculateCellValue(data);\n\n        if (void 0 === result || \"\" === result) {\n          result = null;\n        }\n\n        return result;\n      };\n\n      if (column.sortingMethod) {\n        result = [{\n          selector: result,\n          compare: column.sortingMethod.bind(column)\n        }];\n      }\n    }\n\n    return result;\n  },\n  equalSortParameters: function equalSortParameters(sortParameters1, sortParameters2, ignoreIsExpanded) {\n    sortParameters1 = normalizeSortingInfo(sortParameters1);\n    sortParameters2 = normalizeSortingInfo(sortParameters2);\n\n    if (Array.isArray(sortParameters1) && Array.isArray(sortParameters2)) {\n      if (sortParameters1.length !== sortParameters2.length) {\n        return false;\n      } else {\n        for (var i = 0; i < sortParameters1.length; i++) {\n          if (!equalSelectors(sortParameters1[i].selector, sortParameters2[i].selector) || sortParameters1[i].desc !== sortParameters2[i].desc || sortParameters1[i].groupInterval !== sortParameters2[i].groupInterval || !ignoreIsExpanded && Boolean(sortParameters1[i].isExpanded) !== Boolean(sortParameters2[i].isExpanded)) {\n            return false;\n          }\n        }\n      }\n\n      return true;\n    } else {\n      return (!sortParameters1 || !sortParameters1.length) === (!sortParameters2 || !sortParameters2.length);\n    }\n  },\n  getPointsByColumns: function getPointsByColumns(items, pointCreated, isVertical, startColumnIndex) {\n    var cellsLength = items.length;\n    var notCreatePoint = false;\n    var item;\n    var offset;\n    var columnIndex = startColumnIndex || 0;\n    var result = [];\n    var rtlEnabled;\n\n    for (var i = 0; i <= cellsLength; i++) {\n      if (i < cellsLength) {\n        item = items.eq(i);\n        offset = item.offset();\n        rtlEnabled = \"rtl\" === item.css(\"direction\");\n      }\n\n      var point = {\n        index: columnIndex,\n        x: offset ? offset.left + (!isVertical && rtlEnabled ^ i === cellsLength ? getBoundingRect(item[0]).width : 0) : 0,\n        y: offset ? offset.top + (isVertical && i === cellsLength ? getBoundingRect(item[0]).height : 0) : 0,\n        columnIndex: columnIndex\n      };\n\n      if (!isVertical && i > 0) {\n        var prevItemOffset = items.eq(i - 1).offset();\n\n        if (prevItemOffset.top < point.y) {\n          point.y = prevItemOffset.top;\n        }\n      }\n\n      if (pointCreated) {\n        notCreatePoint = pointCreated(point);\n      }\n\n      if (!notCreatePoint) {\n        result.push(point);\n      }\n\n      columnIndex++;\n    }\n\n    return result;\n  },\n  getExpandCellTemplate: function getExpandCellTemplate() {\n    return {\n      allowRenderToDetachedContainer: true,\n      render: function render(container, options) {\n        var $container = $(container);\n\n        if (isDefined(options.value) && !(options.data && options.data.isContinuation) && !options.row.isNewRow) {\n          var rowsView = options.component.getView(\"rowsView\");\n          $container.addClass(DATAGRID_EXPAND_CLASS).addClass(DATAGRID_SELECTION_DISABLED_CLASS);\n          $(\"<div>\").addClass(options.value ? DATAGRID_GROUP_OPENED_CLASS : DATAGRID_GROUP_CLOSED_CLASS).appendTo($container);\n          rowsView.setAria(\"label\", options.value ? rowsView.localize(\"dxDataGrid-ariaCollapse\") : rowsView.localize(\"dxDataGrid-ariaExpand\"), $container);\n        } else {\n          setEmptyText($container);\n        }\n      }\n    };\n  },\n  setEmptyText: setEmptyText,\n  isDateType: isDateType,\n  getSelectionRange: function getSelectionRange(focusedElement) {\n    try {\n      if (focusedElement) {\n        return {\n          selectionStart: focusedElement.selectionStart,\n          selectionEnd: focusedElement.selectionEnd\n        };\n      }\n    } catch (e) {}\n\n    return {};\n  },\n  setSelectionRange: function setSelectionRange(focusedElement, selectionRange) {\n    try {\n      if (focusedElement && focusedElement.setSelectionRange) {\n        focusedElement.setSelectionRange(selectionRange.selectionStart, selectionRange.selectionEnd);\n      }\n    } catch (e) {}\n  },\n  focusAndSelectElement: function focusAndSelectElement(component, $element) {\n    var isFocused = $element.is(\":focus\");\n    eventsEngine.trigger($element, \"focus\");\n    var isSelectTextOnEditingStart = component.option(\"editing.selectTextOnEditStart\");\n    var element = $element.get(0);\n\n    if (!isFocused && isSelectTextOnEditingStart && $element.is(\".dx-texteditor-input\") && !$element.is(\"[readonly]\")) {\n      var editor = getWidgetInstance($element.closest(\".dx-texteditor\"));\n      when(editor && editor._loadItemDeferred).done(function () {\n        element.select();\n      });\n    }\n  },\n  getWidgetInstance: getWidgetInstance,\n  getLastResizableColumnIndex: function getLastResizableColumnIndex(columns, resultWidths) {\n    var hasResizableColumns = columns.some(function (column) {\n      return column && !column.command && !column.fixed && false !== column.allowResizing;\n    });\n    var lastColumnIndex;\n\n    for (lastColumnIndex = columns.length - 1; columns[lastColumnIndex]; lastColumnIndex--) {\n      var column = columns[lastColumnIndex];\n      var width = resultWidths && resultWidths[lastColumnIndex];\n      var allowResizing = !hasResizableColumns || false !== column.allowResizing;\n\n      if (!column.command && !column.fixed && \"adaptiveHidden\" !== width && allowResizing) {\n        break;\n      }\n    }\n\n    return lastColumnIndex;\n  },\n  isElementInCurrentGrid: function isElementInCurrentGrid(controller, $element) {\n    if ($element && $element.length) {\n      var $grid = $element.closest(\".\" + controller.getWidgetContainerClass()).parent();\n      return $grid.is(controller.component.$element());\n    }\n\n    return false;\n  },\n  isVirtualRowRendering: function isVirtualRowRendering(that) {\n    var rowRenderingMode = that.option(ROW_RENDERING_MODE_OPTION);\n    var isVirtualMode = that.option(SCROLLING_MODE_OPTION) === SCROLLING_MODE_VIRTUAL;\n    var isAppendMode = that.option(SCROLLING_MODE_OPTION) === SCROLLING_MODE_INFINITE;\n\n    if (false === that.option(LEGACY_SCROLLING_MODE) && (isVirtualMode || isAppendMode)) {\n      return true;\n    }\n\n    return rowRenderingMode === SCROLLING_MODE_VIRTUAL;\n  },\n  getPixelRatio: function getPixelRatio(window) {\n    return window.devicePixelRatio || 1;\n  },\n  getContentHeightLimit: function getContentHeightLimit(browser) {\n    if (browser.mozilla) {\n      return 8e6;\n    }\n\n    return 15e6 / this.getPixelRatio(getWindow());\n  }\n};","map":null,"metadata":{},"sourceType":"module"}