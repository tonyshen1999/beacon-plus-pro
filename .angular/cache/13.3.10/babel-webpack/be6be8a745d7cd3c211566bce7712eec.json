{"ast":null,"code":"/**\r\n * DevExtreme (esm/viz/chart_components/base_chart.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { noop, grep } from \"../../core/utils/common\";\nimport eventsEngine from \"../../events/core/events_engine\";\nimport { isDefined as _isDefined, isFunction } from \"../../core/utils/type\";\nimport { each as _each, reverseEach as _reverseEach } from \"../../core/utils/iterator\";\nimport { extend } from \"../../core/utils/extend\";\nimport { inArray } from \"../../core/utils/array\";\nimport { isTouchEvent, isPointerEvent } from \"../../events/utils/index\";\nimport BaseWidget from \"../core/base_widget\";\nimport { Legend } from \"../components/legend\";\nimport { validateData } from \"../components/data_validator\";\nimport { Series } from \"../series/base_series\";\nimport { ThemeManager } from \"../components/chart_theme_manager\";\nimport { LayoutManager } from \"./layout_manager\";\nimport * as trackerModule from \"./tracker\";\nimport { map as _map, setCanvasValues as _setCanvasValues, processSeriesTemplate } from \"../core/utils\";\nvar _isArray = Array.isArray;\nvar REINIT_REFRESH_ACTION = \"_reinit\";\nvar REINIT_DATA_SOURCE_REFRESH_ACTION = \"_updateDataSource\";\nvar DATA_INIT_REFRESH_ACTION = \"_dataInit\";\nvar FORCE_RENDER_REFRESH_ACTION = \"_forceRender\";\nvar RESIZE_REFRESH_ACTION = \"_resize\";\nvar ACTIONS_BY_PRIORITY = [REINIT_REFRESH_ACTION, REINIT_DATA_SOURCE_REFRESH_ACTION, DATA_INIT_REFRESH_ACTION, FORCE_RENDER_REFRESH_ACTION, RESIZE_REFRESH_ACTION];\nvar DEFAULT_OPACITY = .3;\nvar REFRESH_SERIES_DATA_INIT_ACTION_OPTIONS = [\"series\", \"commonSeriesSettings\", \"dataPrepareSettings\", \"seriesSelectionMode\", \"pointSelectionMode\", \"synchronizeMultiAxes\", \"resolveLabelsOverlapping\"];\nvar REFRESH_SERIES_FAMILIES_ACTION_OPTIONS = [\"minBubbleSize\", \"maxBubbleSize\", \"barGroupPadding\", \"barGroupWidth\", \"negativesAsZeroes\", \"negativesAsZeros\"];\nvar FORCE_RENDER_REFRESH_ACTION_OPTIONS = [\"adaptiveLayout\", \"crosshair\", \"resolveLabelOverlapping\", \"adjustOnZoom\", \"stickyHovering\"];\nvar FONT = \"font\";\n\nfunction checkHeightRollingStock(rollingStocks, stubCanvas) {\n  var canvasSize = stubCanvas.end - stubCanvas.start;\n  var size = 0;\n  rollingStocks.forEach(function (rollingStock) {\n    size += rollingStock.getBoundingRect().width;\n  });\n\n  while (canvasSize < size) {\n    size -= findAndKillSmallValue(rollingStocks);\n  }\n}\n\nfunction findAndKillSmallValue(rollingStocks) {\n  var smallestObject = rollingStocks.reduce(function (prev, rollingStock, index) {\n    if (!rollingStock) {\n      return prev;\n    }\n\n    var value = rollingStock.value();\n    return value < prev.value ? {\n      value: value,\n      rollingStock: rollingStock,\n      index: index\n    } : prev;\n  }, {\n    rollingStock: void 0,\n    value: 1 / 0,\n    index: void 0\n  });\n  smallestObject.rollingStock.getLabels()[0].draw(false);\n  var width = smallestObject.rollingStock.getBoundingRect().width;\n  rollingStocks[smallestObject.index] = null;\n  return width;\n}\n\nfunction checkStackOverlap(rollingStocks) {\n  var i;\n  var j;\n  var iLength;\n  var jLength;\n  var overlap = false;\n\n  for (i = 0, iLength = rollingStocks.length - 1; i < iLength; i++) {\n    for (j = i + 1, jLength = rollingStocks.length; j < jLength; j++) {\n      if (i !== j && checkStacksOverlapping(rollingStocks[i], rollingStocks[j], true)) {\n        overlap = true;\n        break;\n      }\n    }\n\n    if (overlap) {\n      break;\n    }\n  }\n\n  return overlap;\n}\n\nfunction resolveLabelOverlappingInOneDirection(points, canvas, isRotated, isInverted, shiftFunction) {\n  var customSorting = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : function () {\n    return 0;\n  };\n  var rollingStocks = [];\n  var stubCanvas = {\n    start: isRotated ? canvas.left : canvas.top,\n    end: isRotated ? canvas.width - canvas.right : canvas.height - canvas.bottom\n  };\n  var hasStackedSeries = false;\n  points.forEach(function (p) {\n    if (!p) {\n      return;\n    }\n\n    hasStackedSeries = hasStackedSeries || p.series.isStackedSeries() || p.series.isFullStackedSeries();\n    p.getLabels().forEach(function (l) {\n      l.isVisible() && rollingStocks.push(new RollingStock(l, isRotated, shiftFunction));\n    });\n  });\n\n  if (hasStackedSeries) {\n    !isRotated ^ isInverted && rollingStocks.reverse();\n  } else {\n    var rollingStocksTmp = rollingStocks.slice();\n    rollingStocks.sort(function (a, b) {\n      return customSorting(a, b) || a.getInitialPosition() - b.getInitialPosition() || rollingStocksTmp.indexOf(a) - rollingStocksTmp.indexOf(b);\n    });\n  }\n\n  if (!checkStackOverlap(rollingStocks)) {\n    return false;\n  }\n\n  checkHeightRollingStock(rollingStocks, stubCanvas);\n  prepareOverlapStacks(rollingStocks);\n  rollingStocks.reverse();\n  moveRollingStock(rollingStocks, stubCanvas);\n  return true;\n}\n\nfunction checkStacksOverlapping(firstRolling, secondRolling, inTwoSides) {\n  if (!firstRolling || !secondRolling) {\n    return;\n  }\n\n  var firstRect = firstRolling.getBoundingRect();\n  var secondRect = secondRolling.getBoundingRect();\n  var oppositeOverlapping = inTwoSides ? firstRect.oppositeStart <= secondRect.oppositeStart && firstRect.oppositeEnd > secondRect.oppositeStart || secondRect.oppositeStart <= firstRect.oppositeStart && secondRect.oppositeEnd > firstRect.oppositeStart : true;\n  return firstRect.end > secondRect.start && oppositeOverlapping;\n}\n\nfunction prepareOverlapStacks(rollingStocks) {\n  var i;\n  var currentRollingStock;\n  var root;\n\n  for (i = 0; i < rollingStocks.length - 1; i++) {\n    currentRollingStock = root || rollingStocks[i];\n\n    if (checkStacksOverlapping(currentRollingStock, rollingStocks[i + 1])) {\n      currentRollingStock.toChain(rollingStocks[i + 1]);\n      rollingStocks[i + 1] = null;\n      root = currentRollingStock;\n    } else {\n      root = rollingStocks[i + 1] || currentRollingStock;\n    }\n  }\n}\n\nfunction moveRollingStock(rollingStocks, canvas) {\n  var i;\n  var j;\n  var currentRollingStock;\n  var nextRollingStock;\n  var currentBBox;\n  var nextBBox;\n\n  for (i = 0; i < rollingStocks.length; i++) {\n    currentRollingStock = rollingStocks[i];\n\n    if (rollingStocksIsOut(currentRollingStock, canvas)) {\n      currentBBox = currentRollingStock.getBoundingRect();\n\n      for (j = i + 1; j < rollingStocks.length; j++) {\n        nextRollingStock = rollingStocks[j];\n\n        if (!nextRollingStock) {\n          continue;\n        }\n\n        nextBBox = nextRollingStock.getBoundingRect();\n\n        if (nextBBox.end > currentBBox.start - (currentBBox.end - canvas.end)) {\n          nextRollingStock.toChain(currentRollingStock);\n          rollingStocks[i] = currentRollingStock = null;\n          break;\n        }\n      }\n    }\n\n    currentRollingStock && currentRollingStock.setRollingStockInCanvas(canvas);\n  }\n}\n\nfunction rollingStocksIsOut(rollingStock, canvas) {\n  return rollingStock && rollingStock.getBoundingRect().end > canvas.end;\n}\n\nfunction RollingStock(label, isRotated, shiftFunction) {\n  var bBox = label.getBoundingRect();\n  var x = bBox.x;\n  var y = bBox.y;\n  var endX = bBox.x + bBox.width;\n  var endY = bBox.y + bBox.height;\n  this.labels = [label];\n  this.shiftFunction = shiftFunction;\n  this._bBox = {\n    start: isRotated ? x : y,\n    width: isRotated ? bBox.width : bBox.height,\n    end: isRotated ? endX : endY,\n    oppositeStart: isRotated ? y : x,\n    oppositeEnd: isRotated ? endY : endX\n  };\n  this._initialPosition = isRotated ? bBox.x : bBox.y;\n  return this;\n}\n\nRollingStock.prototype = {\n  toChain: function toChain(nextRollingStock) {\n    var nextRollingStockBBox = nextRollingStock.getBoundingRect();\n    nextRollingStock.shift(nextRollingStockBBox.start - this._bBox.end);\n\n    this._changeBoxWidth(nextRollingStockBBox.width);\n\n    this.labels = this.labels.concat(nextRollingStock.labels);\n  },\n  getBoundingRect: function getBoundingRect() {\n    return this._bBox;\n  },\n  shift: function shift(shiftLength) {\n    var shiftFunction = this.shiftFunction;\n\n    _each(this.labels, function (index, label) {\n      var bBox = label.getBoundingRect();\n      var coords = shiftFunction(bBox, shiftLength);\n\n      if (!label.hideInsideLabel(coords)) {\n        label.shift(coords.x, coords.y);\n      }\n    });\n\n    this._bBox.end -= shiftLength;\n    this._bBox.start -= shiftLength;\n  },\n  setRollingStockInCanvas: function setRollingStockInCanvas(canvas) {\n    if (this._bBox.end > canvas.end) {\n      this.shift(this._bBox.end - canvas.end);\n    }\n  },\n  getLabels: function getLabels() {\n    return this.labels;\n  },\n  value: function value() {\n    return this.labels[0].getData().value;\n  },\n  getInitialPosition: function getInitialPosition() {\n    return this._initialPosition;\n  },\n  _changeBoxWidth: function _changeBoxWidth(width) {\n    this._bBox.end += width;\n    this._bBox.width += width;\n  }\n};\n\nfunction getLegendFields(name) {\n  return {\n    nameField: name + \"Name\",\n    colorField: name + \"Color\",\n    indexField: name + \"Index\"\n  };\n}\n\nfunction getLegendSettings(legendDataField) {\n  var formatObjectFields = getLegendFields(legendDataField);\n  return {\n    getFormatObject: function getFormatObject(data) {\n      var res = {};\n      res[formatObjectFields.indexField] = data.id;\n      res[formatObjectFields.colorField] = data.states.normal.fill;\n      res[formatObjectFields.nameField] = data.text;\n      return res;\n    },\n    textField: formatObjectFields.nameField\n  };\n}\n\nfunction checkOverlapping(firstRect, secondRect) {\n  return (firstRect.x <= secondRect.x && secondRect.x <= firstRect.x + firstRect.width || firstRect.x >= secondRect.x && firstRect.x <= secondRect.x + secondRect.width) && (firstRect.y <= secondRect.y && secondRect.y <= firstRect.y + firstRect.height || firstRect.y >= secondRect.y && firstRect.y <= secondRect.y + secondRect.height);\n}\n\nexport var overlapping = {\n  resolveLabelOverlappingInOneDirection: resolveLabelOverlappingInOneDirection\n};\nexport var BaseChart = BaseWidget.inherit({\n  _eventsMap: {\n    onSeriesClick: {\n      name: \"seriesClick\"\n    },\n    onPointClick: {\n      name: \"pointClick\"\n    },\n    onArgumentAxisClick: {\n      name: \"argumentAxisClick\"\n    },\n    onLegendClick: {\n      name: \"legendClick\"\n    },\n    onSeriesSelectionChanged: {\n      name: \"seriesSelectionChanged\"\n    },\n    onPointSelectionChanged: {\n      name: \"pointSelectionChanged\"\n    },\n    onSeriesHoverChanged: {\n      name: \"seriesHoverChanged\"\n    },\n    onPointHoverChanged: {\n      name: \"pointHoverChanged\"\n    },\n    onDone: {\n      name: \"done\"\n    },\n    onZoomStart: {\n      name: \"zoomStart\"\n    },\n    onZoomEnd: {\n      name: \"zoomEnd\"\n    }\n  },\n  _fontFields: [\"legend.\" + FONT, \"legend.title.\" + FONT, \"legend.title.subtitle.\" + FONT, \"commonSeriesSettings.label.\" + FONT],\n  _rootClassPrefix: \"dxc\",\n  _rootClass: \"dxc-chart\",\n  _initialChanges: [\"INIT\"],\n  _themeDependentChanges: [\"REFRESH_SERIES_REINIT\"],\n  _getThemeManagerOptions: function _getThemeManagerOptions() {\n    var themeOptions = this.callBase.apply(this, arguments);\n    themeOptions.options = this.option();\n    return themeOptions;\n  },\n  _createThemeManager: function _createThemeManager() {\n    var chartOption = this.option();\n    var themeManager = new ThemeManager(this._getThemeManagerOptions());\n    themeManager.setTheme(chartOption.theme, chartOption.rtlEnabled);\n    return themeManager;\n  },\n  _initCore: function _initCore() {\n    this._canvasClipRect = this._renderer.clipRect();\n\n    this._createHtmlStructure();\n\n    this._createLegend();\n\n    this._createTracker();\n\n    this._needHandleRenderComplete = true;\n    this.layoutManager = new LayoutManager();\n\n    this._createScrollBar();\n\n    eventsEngine.on(this._$element, \"contextmenu\", function (event) {\n      if (isTouchEvent(event) || isPointerEvent(event)) {\n        event.preventDefault();\n      }\n    });\n    eventsEngine.on(this._$element, \"MSHoldVisual\", function (event) {\n      event.preventDefault();\n    });\n  },\n  _getLayoutItems: noop,\n  _layoutManagerOptions: function _layoutManagerOptions() {\n    return this._themeManager.getOptions(\"adaptiveLayout\");\n  },\n  _reinit: function _reinit() {\n    _setCanvasValues(this._canvas);\n\n    this._reinitAxes();\n\n    this._requestChange([\"DATA_SOURCE\", \"DATA_INIT\", \"CORRECT_AXIS\", \"FULL_RENDER\"]);\n  },\n  _correctAxes: noop,\n  _createHtmlStructure: function _createHtmlStructure() {\n    var that = this;\n    var renderer = that._renderer;\n    var root = renderer.root;\n\n    var createConstantLinesGroup = function createConstantLinesGroup() {\n      return renderer.g().attr({\n        class: \"dxc-constant-lines-group\"\n      }).linkOn(root, \"constant-lines\");\n    };\n\n    that._constantLinesGroup = {\n      dispose: function dispose() {\n        this.under.dispose();\n        this.above.dispose();\n      },\n      linkOff: function linkOff() {\n        this.under.linkOff();\n        this.above.linkOff();\n      },\n      clear: function clear() {\n        this.under.linkRemove().clear();\n        this.above.linkRemove().clear();\n      },\n      linkAppend: function linkAppend() {\n        this.under.linkAppend();\n        this.above.linkAppend();\n      }\n    };\n    that._labelsAxesGroup = renderer.g().attr({\n      class: \"dxc-elements-axes-group\"\n    });\n\n    var appendLabelsAxesGroup = function appendLabelsAxesGroup() {\n      that._labelsAxesGroup.linkOn(root, \"elements\");\n    };\n\n    that._backgroundRect = renderer.rect().attr({\n      fill: \"gray\",\n      opacity: 1e-4\n    }).append(root);\n    that._panesBackgroundGroup = renderer.g().attr({\n      class: \"dxc-background\"\n    }).append(root);\n    that._stripsGroup = renderer.g().attr({\n      class: \"dxc-strips-group\"\n    }).linkOn(root, \"strips\");\n    that._gridGroup = renderer.g().attr({\n      class: \"dxc-grids-group\"\n    }).linkOn(root, \"grids\");\n    that._panesBorderGroup = renderer.g().attr({\n      class: \"dxc-border\"\n    }).linkOn(root, \"border\");\n    that._axesGroup = renderer.g().attr({\n      class: \"dxc-axes-group\"\n    }).linkOn(root, \"axes\");\n\n    that._executeAppendBeforeSeries(appendLabelsAxesGroup);\n\n    that._stripLabelAxesGroup = renderer.g().attr({\n      class: \"dxc-strips-labels-group\"\n    }).linkOn(root, \"strips-labels\");\n    that._constantLinesGroup.under = createConstantLinesGroup();\n    that._seriesGroup = renderer.g().attr({\n      class: \"dxc-series-group\"\n    }).linkOn(root, \"series\");\n\n    that._executeAppendAfterSeries(appendLabelsAxesGroup);\n\n    that._constantLinesGroup.above = createConstantLinesGroup();\n    that._scaleBreaksGroup = renderer.g().attr({\n      class: \"dxc-scale-breaks\"\n    }).linkOn(root, \"scale-breaks\");\n    that._labelsGroup = renderer.g().attr({\n      class: \"dxc-labels-group\"\n    }).linkOn(root, \"labels\");\n    that._crosshairCursorGroup = renderer.g().attr({\n      class: \"dxc-crosshair-cursor\"\n    }).linkOn(root, \"crosshair\");\n    that._legendGroup = renderer.g().attr({\n      class: \"dxc-legend\",\n      \"clip-path\": that._getCanvasClipRectID()\n    }).linkOn(root, \"legend\").linkAppend(root).enableLinks();\n    that._scrollBarGroup = renderer.g().attr({\n      class: \"dxc-scroll-bar\"\n    }).linkOn(root, \"scroll-bar\");\n  },\n  _executeAppendBeforeSeries: function _executeAppendBeforeSeries() {},\n  _executeAppendAfterSeries: function _executeAppendAfterSeries() {},\n  _disposeObjectsInArray: function _disposeObjectsInArray(propName, fieldNames) {\n    _each(this[propName] || [], function (_, item) {\n      if (fieldNames && item) {\n        _each(fieldNames, function (_, field) {\n          item[field] && item[field].dispose();\n        });\n      } else {\n        item && item.dispose();\n      }\n    });\n\n    this[propName] = null;\n  },\n  _disposeCore: function _disposeCore() {\n    var that = this;\n\n    var disposeObject = function disposeObject(propName) {\n      if (that[propName]) {\n        that[propName].dispose();\n        that[propName] = null;\n      }\n    };\n\n    var unlinkGroup = function unlinkGroup(name) {\n      that[name].linkOff();\n    };\n\n    var disposeObjectsInArray = this._disposeObjectsInArray;\n\n    that._renderer.stopAllAnimations();\n\n    disposeObjectsInArray.call(that, \"series\");\n    disposeObject(\"_tracker\");\n    disposeObject(\"_crosshair\");\n    that.layoutManager = that._userOptions = that._canvas = that._groupsData = null;\n    unlinkGroup(\"_stripsGroup\");\n    unlinkGroup(\"_gridGroup\");\n    unlinkGroup(\"_axesGroup\");\n    unlinkGroup(\"_constantLinesGroup\");\n    unlinkGroup(\"_stripLabelAxesGroup\");\n    unlinkGroup(\"_panesBorderGroup\");\n    unlinkGroup(\"_seriesGroup\");\n    unlinkGroup(\"_labelsGroup\");\n    unlinkGroup(\"_crosshairCursorGroup\");\n    unlinkGroup(\"_legendGroup\");\n    unlinkGroup(\"_scrollBarGroup\");\n    unlinkGroup(\"_scaleBreaksGroup\");\n    disposeObject(\"_canvasClipRect\");\n    disposeObject(\"_panesBackgroundGroup\");\n    disposeObject(\"_backgroundRect\");\n    disposeObject(\"_stripsGroup\");\n    disposeObject(\"_gridGroup\");\n    disposeObject(\"_axesGroup\");\n    disposeObject(\"_constantLinesGroup\");\n    disposeObject(\"_stripLabelAxesGroup\");\n    disposeObject(\"_panesBorderGroup\");\n    disposeObject(\"_seriesGroup\");\n    disposeObject(\"_labelsGroup\");\n    disposeObject(\"_crosshairCursorGroup\");\n    disposeObject(\"_legendGroup\");\n    disposeObject(\"_scrollBarGroup\");\n    disposeObject(\"_scaleBreaksGroup\");\n  },\n  _getAnimationOptions: function _getAnimationOptions() {\n    return this._themeManager.getOptions(\"animation\");\n  },\n  _getDefaultSize: function _getDefaultSize() {\n    return {\n      width: 400,\n      height: 400\n    };\n  },\n  _getOption: function _getOption(name) {\n    return this._themeManager.getOptions(name);\n  },\n  _applySize: function _applySize(rect) {\n    this._rect = rect.slice();\n\n    if (!this._changes.has(\"FULL_RENDER\")) {\n      this._processRefreshData(RESIZE_REFRESH_ACTION);\n    }\n  },\n  _resize: function _resize() {\n    this._doRender(this.__renderOptions || {\n      animate: false,\n      isResize: true\n    });\n  },\n  _trackerType: \"ChartTracker\",\n  _createTracker: function _createTracker() {\n    this._tracker = new trackerModule[this._trackerType]({\n      seriesGroup: this._seriesGroup,\n      renderer: this._renderer,\n      tooltip: this._tooltip,\n      legend: this._legend,\n      eventTrigger: this._eventTrigger\n    });\n  },\n  _getTrackerSettings: function _getTrackerSettings() {\n    return extend({\n      chart: this\n    }, this._getSelectionModes());\n  },\n  _getSelectionModes: function _getSelectionModes() {\n    var themeManager = this._themeManager;\n    return {\n      seriesSelectionMode: themeManager.getOptions(\"seriesSelectionMode\"),\n      pointSelectionMode: themeManager.getOptions(\"pointSelectionMode\")\n    };\n  },\n  _updateTracker: function _updateTracker(trackerCanvases) {\n    this._tracker.update(this._getTrackerSettings());\n\n    this._tracker.setCanvases({\n      left: 0,\n      right: this._canvas.width,\n      top: 0,\n      bottom: this._canvas.height\n    }, trackerCanvases);\n  },\n  _createCanvasFromRect: function _createCanvasFromRect(rect) {\n    var currentCanvas = this._canvas;\n    return _setCanvasValues({\n      left: rect[0],\n      top: rect[1],\n      right: currentCanvas.width - rect[2],\n      bottom: currentCanvas.height - rect[3],\n      width: currentCanvas.width,\n      height: currentCanvas.height\n    });\n  },\n  _doRender: function _doRender(_options) {\n    if (0 === this._canvas.width && 0 === this._canvas.height) {\n      return;\n    }\n\n    this._resetIsReady();\n\n    var drawOptions = this._prepareDrawOptions(_options);\n\n    var recreateCanvas = drawOptions.recreateCanvas;\n\n    this._preserveOriginalCanvas();\n\n    if (recreateCanvas) {\n      this.__currentCanvas = this._canvas;\n    } else {\n      this._canvas = this.__currentCanvas;\n    }\n\n    recreateCanvas && this._updateCanvasClipRect(this._canvas);\n    this._canvas = this._createCanvasFromRect(this._rect);\n\n    this._renderer.stopAllAnimations(true);\n\n    this._cleanGroups();\n\n    var startTime = new Date();\n\n    this._renderElements(drawOptions);\n\n    this._lastRenderingTime = new Date() - startTime;\n  },\n  _preserveOriginalCanvas: function _preserveOriginalCanvas() {\n    this.__originalCanvas = this._canvas;\n    this._canvas = extend({}, this._canvas);\n  },\n  _layoutAxes: noop,\n  _renderElements: function _renderElements(drawOptions) {\n    var that = this;\n\n    var preparedOptions = that._prepareToRender(drawOptions);\n\n    var isRotated = that._isRotated();\n\n    var isLegendInside = that._isLegendInside();\n\n    var trackerCanvases = [];\n    extend({}, that._canvas);\n    var argBusinessRange;\n    var zoomMinArg;\n    var zoomMaxArg;\n\n    that._renderer.lock();\n\n    if (drawOptions.drawLegend && that._legend) {\n      that._legendGroup.linkAppend();\n    }\n\n    that.layoutManager.setOptions(that._layoutManagerOptions());\n\n    var layoutTargets = that._getLayoutTargets();\n\n    this._layoutAxes(function (needSpace) {\n      var axisDrawOptions = needSpace ? extend({}, drawOptions, {\n        animate: false,\n        recreateCanvas: true\n      }) : drawOptions;\n\n      var canvas = that._renderAxes(axisDrawOptions, preparedOptions);\n\n      that._shrinkAxes(needSpace, canvas);\n    });\n\n    that._applyClipRects(preparedOptions);\n\n    that._appendSeriesGroups();\n\n    that._createCrosshairCursor();\n\n    layoutTargets.forEach(function (_ref) {\n      var canvas = _ref.canvas;\n      trackerCanvases.push({\n        left: canvas.left,\n        right: canvas.width - canvas.right,\n        top: canvas.top,\n        bottom: canvas.height - canvas.bottom\n      });\n    });\n\n    if (that._scrollBar) {\n      argBusinessRange = that._argumentAxes[0].getTranslator().getBusinessRange();\n\n      if (\"discrete\" === argBusinessRange.axisType && argBusinessRange.categories && argBusinessRange.categories.length <= 1 || \"discrete\" !== argBusinessRange.axisType && argBusinessRange.min === argBusinessRange.max) {\n        zoomMinArg = zoomMaxArg = void 0;\n      } else {\n        zoomMinArg = argBusinessRange.minVisible;\n        zoomMaxArg = argBusinessRange.maxVisible;\n      }\n\n      that._scrollBar.init(argBusinessRange, !that._argumentAxes[0].getOptions().valueMarginsEnabled).setPosition(zoomMinArg, zoomMaxArg);\n    }\n\n    that._updateTracker(trackerCanvases);\n\n    that._updateLegendPosition(drawOptions, isLegendInside);\n\n    that._applyPointMarkersAutoHiding();\n\n    that._renderSeries(drawOptions, isRotated, isLegendInside);\n\n    that._renderer.unlock();\n  },\n  _updateLegendPosition: noop,\n  _createCrosshairCursor: noop,\n  _appendSeriesGroups: function _appendSeriesGroups() {\n    this._seriesGroup.linkAppend();\n\n    this._labelsGroup.linkAppend();\n\n    this._appendAdditionalSeriesGroups();\n  },\n  _renderSeries: function _renderSeries(drawOptions, isRotated, isLegendInside) {\n    this._calculateSeriesLayout(drawOptions, isRotated);\n\n    this._renderSeriesElements(drawOptions, isLegendInside);\n  },\n  _calculateSeriesLayout: function _calculateSeriesLayout(drawOptions, isRotated) {\n    drawOptions.hideLayoutLabels = this.layoutManager.needMoreSpaceForPanesCanvas(this._getLayoutTargets(), isRotated) && !this._themeManager.getOptions(\"adaptiveLayout\").keepLabels;\n\n    this._updateSeriesDimensions(drawOptions);\n  },\n  _getArgFilter: function _getArgFilter() {\n    return function () {\n      return true;\n    };\n  },\n  _getValFilter: function _getValFilter(series) {\n    return function () {\n      return true;\n    };\n  },\n  _getPointsToAnimation: function _getPointsToAnimation(series) {\n    var _this = this;\n\n    var argViewPortFilter = this._getArgFilter();\n\n    return series.map(function (s) {\n      var valViewPortFilter = _this._getValFilter(s);\n\n      return s.getPoints().filter(function (p) {\n        return p.getOptions().visible && argViewPortFilter(p.argument) && (valViewPortFilter(p.getMinValue(true)) || valViewPortFilter(p.getMaxValue(true)));\n      }).length;\n    });\n  },\n  _renderSeriesElements: function _renderSeriesElements(drawOptions, isLegendInside) {\n    var i;\n    var series = this.series;\n    var singleSeries;\n    var seriesLength = series.length;\n\n    var resolveLabelOverlapping = this._themeManager.getOptions(\"resolveLabelOverlapping\");\n\n    var pointsToAnimation = this._getPointsToAnimation(series);\n\n    for (i = 0; i < seriesLength; i++) {\n      singleSeries = series[i];\n\n      this._applyExtraSettings(singleSeries, drawOptions);\n\n      singleSeries.draw(drawOptions.animate && pointsToAnimation[i] <= drawOptions.animationPointsLimit && this._renderer.animationEnabled(), drawOptions.hideLayoutLabels, this._getLegendCallBack(singleSeries));\n    }\n\n    if (\"none\" === resolveLabelOverlapping) {\n      this._adjustSeriesLabels(false);\n    } else {\n      this._locateLabels(resolveLabelOverlapping);\n    }\n\n    this._renderTrackers(isLegendInside);\n\n    this._tracker.repairTooltip();\n\n    this._renderExtraElements();\n\n    this._clearCanvas();\n\n    this._seriesElementsDrawn = true;\n  },\n  _changesApplied: function _changesApplied() {\n    if (this._seriesElementsDrawn) {\n      this._seriesElementsDrawn = false;\n\n      this._drawn();\n\n      this._renderCompleteHandler();\n    }\n  },\n  _locateLabels: function _locateLabels(resolveLabelOverlapping) {\n    this._resolveLabelOverlapping(resolveLabelOverlapping);\n  },\n  _renderExtraElements: function _renderExtraElements() {},\n  _clearCanvas: function _clearCanvas() {\n    this._canvas = this.__originalCanvas;\n  },\n  _resolveLabelOverlapping: function _resolveLabelOverlapping(resolveLabelOverlapping) {\n    var func;\n\n    switch (resolveLabelOverlapping) {\n      case \"stack\":\n        func = this._resolveLabelOverlappingStack;\n        break;\n\n      case \"hide\":\n        func = this._resolveLabelOverlappingHide;\n        break;\n\n      case \"shift\":\n        func = this._resolveLabelOverlappingShift;\n    }\n\n    return isFunction(func) && func.call(this);\n  },\n  _getVisibleSeries: function _getVisibleSeries() {\n    return grep(this.getAllSeries(), function (series) {\n      return series.isVisible();\n    });\n  },\n  _resolveLabelOverlappingHide: function _resolveLabelOverlappingHide() {\n    var labels = [];\n    var currentLabel;\n    var nextLabel;\n    var currentLabelRect;\n    var nextLabelRect;\n    var i;\n    var j;\n    var points;\n\n    var series = this._getVisibleSeries();\n\n    for (i = 0; i < series.length; i++) {\n      points = series[i].getVisiblePoints();\n\n      for (j = 0; j < points.length; j++) {\n        labels.push.apply(labels, points[j].getLabels());\n      }\n    }\n\n    for (i = 0; i < labels.length; i++) {\n      currentLabel = labels[i];\n\n      if (!currentLabel.isVisible()) {\n        continue;\n      }\n\n      currentLabelRect = currentLabel.getBoundingRect();\n\n      for (j = i + 1; j < labels.length; j++) {\n        nextLabel = labels[j];\n        nextLabelRect = nextLabel.getBoundingRect();\n\n        if (checkOverlapping(currentLabelRect, nextLabelRect)) {\n          nextLabel.draw(false);\n        }\n      }\n    }\n  },\n  _cleanGroups: function _cleanGroups() {\n    this._stripsGroup.linkRemove().clear();\n\n    this._gridGroup.linkRemove().clear();\n\n    this._axesGroup.linkRemove().clear();\n\n    this._constantLinesGroup.above.clear();\n\n    this._stripLabelAxesGroup.linkRemove().clear();\n\n    this._labelsGroup.linkRemove().clear();\n\n    this._crosshairCursorGroup.linkRemove().clear();\n\n    this._scaleBreaksGroup.linkRemove().clear();\n  },\n  _allowLegendInsidePosition: function _allowLegendInsidePosition() {\n    return false;\n  },\n  _createLegend: function _createLegend() {\n    var legendSettings = getLegendSettings(this._legendDataField);\n    this._legend = new Legend({\n      renderer: this._renderer,\n      widget: this,\n      group: this._legendGroup,\n      backgroundClass: \"dxc-border\",\n      itemGroupClass: \"dxc-item\",\n      titleGroupClass: \"dxc-title\",\n      textField: legendSettings.textField,\n      getFormatObject: legendSettings.getFormatObject,\n      allowInsidePosition: this._allowLegendInsidePosition()\n    });\n\n    this._updateLegend();\n\n    this._layout.add(this._legend);\n  },\n  _updateLegend: function _updateLegend() {\n    var themeManager = this._themeManager;\n    var legendOptions = themeManager.getOptions(\"legend\");\n\n    var legendData = this._getLegendData();\n\n    legendOptions.containerBackgroundColor = themeManager.getOptions(\"containerBackgroundColor\");\n    legendOptions._incidentOccurred = this._incidentOccurred;\n\n    this._legend.update(legendData, legendOptions, themeManager.theme(\"legend\").title);\n\n    this._change([\"LAYOUT\"]);\n  },\n  _prepareDrawOptions: function _prepareDrawOptions(drawOptions) {\n    var animationOptions = this._getAnimationOptions();\n\n    var options = extend({}, {\n      force: false,\n      adjustAxes: true,\n      drawLegend: true,\n      drawTitle: true,\n      animate: animationOptions.enabled,\n      animationPointsLimit: animationOptions.maxPointCountSupported\n    }, drawOptions, this.__renderOptions);\n\n    if (!_isDefined(options.recreateCanvas)) {\n      options.recreateCanvas = options.adjustAxes && options.drawLegend && options.drawTitle;\n    }\n\n    return options;\n  },\n  _processRefreshData: function _processRefreshData(newRefreshAction) {\n    var currentRefreshActionPosition = inArray(this._currentRefreshData, ACTIONS_BY_PRIORITY);\n    var newRefreshActionPosition = inArray(newRefreshAction, ACTIONS_BY_PRIORITY);\n\n    if (!this._currentRefreshData || currentRefreshActionPosition >= 0 && newRefreshActionPosition < currentRefreshActionPosition) {\n      this._currentRefreshData = newRefreshAction;\n    }\n\n    this._requestChange([\"REFRESH\"]);\n  },\n  _getLegendData: function _getLegendData() {\n    return _map(this._getLegendTargets(), function (item) {\n      var legendData = item.legendData;\n      var style = item.getLegendStyles;\n      var opacity = style.normal.opacity;\n\n      if (!item.visible) {\n        if (!_isDefined(opacity) || opacity > DEFAULT_OPACITY) {\n          opacity = DEFAULT_OPACITY;\n        }\n\n        legendData.textOpacity = DEFAULT_OPACITY;\n      }\n\n      var opacityStyle = {\n        opacity: opacity\n      };\n      legendData.states = {\n        hover: extend({}, style.hover, opacityStyle),\n        selection: extend({}, style.selection, opacityStyle),\n        normal: extend({}, style.normal, opacityStyle)\n      };\n      return legendData;\n    });\n  },\n  _getLegendOptions: function _getLegendOptions(item) {\n    return {\n      legendData: {\n        text: item[this._legendItemTextField],\n        id: item.index,\n        visible: true\n      },\n      getLegendStyles: item.getLegendStyles(),\n      visible: item.isVisible()\n    };\n  },\n  _disposeSeries: function _disposeSeries(seriesIndex) {\n    var _that$series;\n\n    if (this.series) {\n      if (_isDefined(seriesIndex)) {\n        this.series[seriesIndex].dispose();\n        this.series.splice(seriesIndex, 1);\n      } else {\n        _each(this.series, function (_, s) {\n          return s.dispose();\n        });\n\n        this.series.length = 0;\n      }\n    }\n\n    if (!(null !== (_that$series = this.series) && void 0 !== _that$series && _that$series.length)) {\n      this.series = [];\n    }\n  },\n  _disposeSeriesFamilies: function _disposeSeriesFamilies() {\n    _each(this.seriesFamilies || [], function (_, family) {\n      family.dispose();\n    });\n\n    this.seriesFamilies = null;\n    this._needHandleRenderComplete = true;\n  },\n  _optionChanged: function _optionChanged(arg) {\n    this._themeManager.resetOptions(arg.name);\n\n    this.callBase.apply(this, arguments);\n  },\n  _applyChanges: function _applyChanges() {\n    this._themeManager.update(this._options.silent());\n\n    this.callBase.apply(this, arguments);\n  },\n  _optionChangesMap: {\n    animation: \"ANIMATION\",\n    dataSource: \"DATA_SOURCE\",\n    palette: \"PALETTE\",\n    paletteExtensionMode: \"PALETTE\",\n    legend: \"FORCE_DATA_INIT\",\n    seriesTemplate: \"FORCE_DATA_INIT\",\n    export: \"FORCE_RENDER\",\n    valueAxis: \"AXES_AND_PANES\",\n    argumentAxis: \"AXES_AND_PANES\",\n    commonAxisSettings: \"AXES_AND_PANES\",\n    panes: \"AXES_AND_PANES\",\n    commonPaneSettings: \"AXES_AND_PANES\",\n    defaultPane: \"AXES_AND_PANES\",\n    containerBackgroundColor: \"AXES_AND_PANES\",\n    rotated: \"ROTATED\",\n    autoHidePointMarkers: \"REFRESH_SERIES_REINIT\",\n    customizePoint: \"REFRESH_SERIES_REINIT\",\n    customizeLabel: \"REFRESH_SERIES_REINIT\",\n    scrollBar: \"SCROLL_BAR\"\n  },\n  _optionChangesOrder: [\"ROTATED\", \"PALETTE\", \"REFRESH_SERIES_REINIT\", \"AXES_AND_PANES\", \"INIT\", \"REINIT\", \"DATA_SOURCE\", \"REFRESH_SERIES_DATA_INIT\", \"DATA_INIT\", \"FORCE_DATA_INIT\", \"REFRESH_AXES\", \"CORRECT_AXIS\"],\n  _customChangesOrder: [\"ANIMATION\", \"REFRESH_SERIES_FAMILIES\", \"FORCE_FIRST_DRAWING\", \"FORCE_DRAWING\", \"FORCE_RENDER\", \"VISUAL_RANGE\", \"SCROLL_BAR\", \"REINIT\", \"REFRESH\", \"FULL_RENDER\"],\n  _change_ANIMATION: function _change_ANIMATION() {\n    this._renderer.updateAnimationOptions(this._getAnimationOptions());\n  },\n  _change_DATA_SOURCE: function _change_DATA_SOURCE() {\n    this._needHandleRenderComplete = true;\n\n    this._updateDataSource();\n  },\n  _change_PALETTE: function _change_PALETTE() {\n    this._themeManager.updatePalette();\n\n    this._refreshSeries(\"DATA_INIT\");\n  },\n  _change_REFRESH_SERIES_DATA_INIT: function _change_REFRESH_SERIES_DATA_INIT() {\n    this._refreshSeries(\"DATA_INIT\");\n  },\n  _change_DATA_INIT: function _change_DATA_INIT() {\n    if ((!this.series || this.needToPopulateSeries) && !this._changes.has(\"FORCE_DATA_INIT\")) {\n      this._dataInit();\n    }\n  },\n  _change_FORCE_DATA_INIT: function _change_FORCE_DATA_INIT() {\n    this._dataInit();\n  },\n  _change_REFRESH_SERIES_FAMILIES: function _change_REFRESH_SERIES_FAMILIES() {\n    this._processSeriesFamilies();\n\n    this._populateBusinessRange();\n\n    this._processRefreshData(FORCE_RENDER_REFRESH_ACTION);\n  },\n  _change_FORCE_RENDER: function _change_FORCE_RENDER() {\n    this._processRefreshData(FORCE_RENDER_REFRESH_ACTION);\n  },\n  _change_AXES_AND_PANES: function _change_AXES_AND_PANES() {\n    this._refreshSeries(\"INIT\");\n  },\n  _change_ROTATED: function _change_ROTATED() {\n    this._createScrollBar();\n\n    this._refreshSeries(\"INIT\");\n  },\n  _change_REFRESH_SERIES_REINIT: function _change_REFRESH_SERIES_REINIT() {\n    this._refreshSeries(\"INIT\");\n  },\n  _change_REFRESH_AXES: function _change_REFRESH_AXES() {\n    _setCanvasValues(this._canvas);\n\n    this._reinitAxes();\n\n    this._requestChange([\"CORRECT_AXIS\", \"FULL_RENDER\"]);\n  },\n  _change_SCROLL_BAR: function _change_SCROLL_BAR() {\n    this._createScrollBar();\n\n    this._processRefreshData(FORCE_RENDER_REFRESH_ACTION);\n  },\n  _change_REINIT: function _change_REINIT() {\n    this._processRefreshData(REINIT_REFRESH_ACTION);\n  },\n  _change_FORCE_DRAWING: function _change_FORCE_DRAWING() {\n    this._resetComponentsAnimation();\n  },\n  _change_FORCE_FIRST_DRAWING: function _change_FORCE_FIRST_DRAWING() {\n    this._resetComponentsAnimation(true);\n  },\n  _resetComponentsAnimation: function _resetComponentsAnimation(isFirstDrawing) {\n    this.series.forEach(function (s) {\n      s.resetApplyingAnimation(isFirstDrawing);\n    });\n\n    this._resetAxesAnimation(isFirstDrawing);\n  },\n  _resetAxesAnimation: noop,\n  _refreshSeries: function _refreshSeries(actionName) {\n    this.needToPopulateSeries = true;\n\n    this._requestChange([actionName]);\n  },\n  _change_CORRECT_AXIS: function _change_CORRECT_AXIS() {\n    this._correctAxes();\n  },\n  _doRefresh: function _doRefresh() {\n    var methodName = this._currentRefreshData;\n\n    if (methodName) {\n      this._currentRefreshData = null;\n\n      this._renderer.stopAllAnimations(true);\n\n      this[methodName]();\n    }\n  },\n  _updateCanvasClipRect: function _updateCanvasClipRect(canvas) {\n    var width = Math.max(canvas.width - canvas.left - canvas.right, 0);\n    var height = Math.max(canvas.height - canvas.top - canvas.bottom, 0);\n\n    this._canvasClipRect.attr({\n      x: canvas.left,\n      y: canvas.top,\n      width: width,\n      height: height\n    });\n\n    this._backgroundRect.attr({\n      x: canvas.left,\n      y: canvas.top,\n      width: width,\n      height: height\n    });\n  },\n  _getCanvasClipRectID: function _getCanvasClipRectID() {\n    return this._canvasClipRect.id;\n  },\n  _dataSourceChangedHandler: function _dataSourceChangedHandler() {\n    if (this._changes.has(\"INIT\")) {\n      this._requestChange([\"DATA_INIT\"]);\n    } else {\n      this._requestChange([\"FORCE_DATA_INIT\"]);\n    }\n  },\n  _dataInit: function _dataInit() {\n    this._dataSpecificInit(true);\n  },\n  _processSingleSeries: function _processSingleSeries(singleSeries) {\n    singleSeries.createPoints(false);\n  },\n  _handleSeriesDataUpdated: function _handleSeriesDataUpdated() {\n    var _this2 = this;\n\n    if (this._getVisibleSeries().some(function (s) {\n      return s.useAggregation();\n    })) {\n      this._populateMarginOptions();\n    }\n\n    this.series.forEach(function (s) {\n      return _this2._processSingleSeries(s);\n    }, this);\n  },\n  _dataSpecificInit: function _dataSpecificInit(needRedraw) {\n    if (!this.series || this.needToPopulateSeries) {\n      this.series = this._populateSeries();\n    }\n\n    this._repopulateSeries();\n\n    this._seriesPopulatedHandlerCore();\n\n    this._populateBusinessRange();\n\n    this._tracker.updateSeries(this.series, this._changes.has(\"INIT\"));\n\n    this._updateLegend();\n\n    if (needRedraw) {\n      this._requestChange([\"FULL_RENDER\"]);\n    }\n  },\n  _forceRender: function _forceRender() {\n    this._doRender({\n      force: true\n    });\n  },\n  _repopulateSeries: function _repopulateSeries() {\n    var themeManager = this._themeManager;\n\n    var data = this._dataSourceItems();\n\n    var dataValidatorOptions = themeManager.getOptions(\"dataPrepareSettings\");\n    var seriesTemplate = themeManager.getOptions(\"seriesTemplate\");\n\n    if (seriesTemplate) {\n      this._populateSeries(data);\n    }\n\n    this._groupSeries();\n\n    var parsedData = validateData(data, this._groupsData, this._incidentOccurred, dataValidatorOptions);\n    themeManager.resetPalette();\n    this.series.forEach(function (singleSeries) {\n      singleSeries.updateData(parsedData[singleSeries.getArgumentField()]);\n    });\n\n    this._handleSeriesDataUpdated();\n  },\n  _renderCompleteHandler: function _renderCompleteHandler() {\n    var allSeriesInited = true;\n\n    if (this._needHandleRenderComplete) {\n      _each(this.series, function (_, s) {\n        allSeriesInited = allSeriesInited && s.canRenderCompleteHandle();\n      });\n\n      if (allSeriesInited) {\n        this._needHandleRenderComplete = false;\n\n        this._eventTrigger(\"done\", {\n          target: this\n        });\n      }\n    }\n  },\n  _dataIsReady: function _dataIsReady() {\n    return _isDefined(this.option(\"dataSource\")) && this._dataIsLoaded();\n  },\n  _populateSeriesOptions: function _populateSeriesOptions(data) {\n    var that = this;\n    var themeManager = that._themeManager;\n    var seriesTemplate = themeManager.getOptions(\"seriesTemplate\");\n    var seriesOptions = seriesTemplate ? processSeriesTemplate(seriesTemplate, data || []) : that.option(\"series\");\n    var allSeriesOptions = _isArray(seriesOptions) ? seriesOptions : seriesOptions ? [seriesOptions] : [];\n\n    var extraOptions = that._getExtraOptions();\n\n    var particularSeriesOptions;\n    var seriesTheme;\n    var seriesThemes = [];\n\n    var seriesVisibilityChanged = function seriesVisibilityChanged(target) {\n      that._specialProcessSeries();\n\n      that._populateBusinessRange(target && target.getValueAxis(), true);\n\n      that._renderer.stopAllAnimations(true);\n\n      that._updateLegend();\n\n      that._requestChange([\"FULL_RENDER\"]);\n    };\n\n    for (var i = 0; i < allSeriesOptions.length; i++) {\n      particularSeriesOptions = extend(true, {}, allSeriesOptions[i], extraOptions);\n\n      if (!_isDefined(particularSeriesOptions.name) || \"\" === particularSeriesOptions.name) {\n        particularSeriesOptions.name = \"Series \" + (i + 1).toString();\n      }\n\n      particularSeriesOptions.rotated = that._isRotated();\n      particularSeriesOptions.customizePoint = themeManager.getOptions(\"customizePoint\");\n      particularSeriesOptions.customizeLabel = themeManager.getOptions(\"customizeLabel\");\n      particularSeriesOptions.visibilityChanged = seriesVisibilityChanged;\n      particularSeriesOptions.incidentOccurred = that._incidentOccurred;\n      seriesTheme = themeManager.getOptions(\"series\", particularSeriesOptions, allSeriesOptions.length);\n\n      if (that._checkPaneName(seriesTheme)) {\n        seriesThemes.push(seriesTheme);\n      }\n    }\n\n    return seriesThemes;\n  },\n  _populateSeries: function _populateSeries(data) {\n    var _that$series2;\n\n    var that = this;\n    var seriesBasis = [];\n    var incidentOccurred = that._incidentOccurred;\n\n    var seriesThemes = that._populateSeriesOptions(data);\n\n    var particularSeries;\n    var disposeSeriesFamilies = false;\n    that.needToPopulateSeries = false;\n\n    _each(seriesThemes, function (_, theme) {\n      var curSeries = that.series && that.series.filter(function (s) {\n        return s.name === theme.name && -1 === seriesBasis.map(function (sb) {\n          return sb.series;\n        }).indexOf(s);\n      })[0];\n\n      if (curSeries && curSeries.type === theme.type) {\n        seriesBasis.push({\n          series: curSeries,\n          options: theme\n        });\n      } else {\n        seriesBasis.push({\n          options: theme\n        });\n        disposeSeriesFamilies = true;\n      }\n    });\n\n    0 !== (null === (_that$series2 = that.series) || void 0 === _that$series2 ? void 0 : _that$series2.length) && that._tracker.clearHover();\n\n    _reverseEach(that.series, function (index, series) {\n      if (!seriesBasis.some(function (s) {\n        return series === s.series;\n      })) {\n        that._disposeSeries(index);\n\n        disposeSeriesFamilies = true;\n      }\n    });\n\n    !disposeSeriesFamilies && (disposeSeriesFamilies = seriesBasis.some(function (sb) {\n      return sb.series.name !== seriesThemes[sb.series.index].name;\n    }));\n    that.series = [];\n    disposeSeriesFamilies && that._disposeSeriesFamilies();\n\n    that._themeManager.resetPalette();\n\n    var eventPipe = function eventPipe(data) {\n      that.series.forEach(function (currentSeries) {\n        currentSeries.notify(data);\n      });\n    };\n\n    _each(seriesBasis, function (_, basis) {\n      var _that$_argumentAxes$f, _that$_argumentAxes;\n\n      var seriesTheme = basis.options;\n      var argumentAxis = null !== (_that$_argumentAxes$f = null === (_that$_argumentAxes = that._argumentAxes) || void 0 === _that$_argumentAxes ? void 0 : _that$_argumentAxes.filter(function (a) {\n        return a.pane === seriesTheme.pane;\n      })[0]) && void 0 !== _that$_argumentAxes$f ? _that$_argumentAxes$f : that.getArgumentAxis();\n      var renderSettings = {\n        commonSeriesModes: that._getSelectionModes(),\n        argumentAxis: argumentAxis,\n        valueAxis: that._getValueAxis(seriesTheme.pane, seriesTheme.axis)\n      };\n\n      if (basis.series) {\n        particularSeries = basis.series;\n        particularSeries.updateOptions(seriesTheme, renderSettings);\n      } else {\n        particularSeries = new Series(extend({\n          renderer: that._renderer,\n          seriesGroup: that._seriesGroup,\n          labelsGroup: that._labelsGroup,\n          eventTrigger: that._eventTrigger,\n          eventPipe: eventPipe,\n          incidentOccurred: incidentOccurred\n        }, renderSettings), seriesTheme);\n      }\n\n      if (!particularSeries.isUpdated) {\n        incidentOccurred(\"E2101\", [seriesTheme.type]);\n      } else {\n        particularSeries.index = that.series.length;\n        that.series.push(particularSeries);\n      }\n    });\n\n    return that.series;\n  },\n  getStackedPoints: function getStackedPoints(point) {\n    var stackName = point.series.getStackName();\n    return this._getVisibleSeries().reduce(function (stackPoints, series) {\n      if (!_isDefined(series.getStackName()) || !_isDefined(stackName) || stackName === series.getStackName()) {\n        stackPoints = stackPoints.concat(series.getPointsByArg(point.argument));\n      }\n\n      return stackPoints;\n    }, []);\n  },\n  getAllSeries: function getAllSeries() {\n    return (this.series || []).slice();\n  },\n  getSeriesByName: function getSeriesByName(name) {\n    var found = null;\n\n    _each(this.series, function (i, singleSeries) {\n      if (singleSeries.name === name) {\n        found = singleSeries;\n        return false;\n      }\n    });\n\n    return found;\n  },\n  getSeriesByPos: function getSeriesByPos(pos) {\n    return (this.series || [])[pos];\n  },\n  clearSelection: function clearSelection() {\n    this._tracker.clearSelection();\n  },\n  hideTooltip: function hideTooltip() {\n    this._tracker._hideTooltip();\n  },\n  clearHover: function clearHover() {\n    this._tracker.clearHover();\n  },\n  render: function render(renderOptions) {\n    var that = this;\n    that.__renderOptions = renderOptions;\n    that.__forceRender = renderOptions && renderOptions.force;\n    that.callBase.apply(that, arguments);\n    that.__renderOptions = that.__forceRender = null;\n    return that;\n  },\n  refresh: function refresh() {\n    this._disposeSeries();\n\n    this._disposeSeriesFamilies();\n\n    this._requestChange([\"CONTAINER_SIZE\", \"REFRESH_SERIES_REINIT\"]);\n  },\n  _getMinSize: function _getMinSize() {\n    var adaptiveLayout = this._layoutManagerOptions();\n\n    return [adaptiveLayout.width, adaptiveLayout.height];\n  },\n  _change_REFRESH: function _change_REFRESH() {\n    if (!this._changes.has(\"INIT\")) {\n      this._doRefresh();\n    } else {\n      this._currentRefreshData = null;\n    }\n  },\n  _change_FULL_RENDER: function _change_FULL_RENDER() {\n    this._forceRender();\n  },\n  _change_INIT: function _change_INIT() {\n    this._reinit();\n  },\n  _stopCurrentHandling: function _stopCurrentHandling() {\n    this._tracker.stopCurrentHandling();\n  }\n});\nREFRESH_SERIES_DATA_INIT_ACTION_OPTIONS.forEach(function (name) {\n  BaseChart.prototype._optionChangesMap[name] = \"REFRESH_SERIES_DATA_INIT\";\n});\nFORCE_RENDER_REFRESH_ACTION_OPTIONS.forEach(function (name) {\n  BaseChart.prototype._optionChangesMap[name] = \"FORCE_RENDER\";\n});\nREFRESH_SERIES_FAMILIES_ACTION_OPTIONS.forEach(function (name) {\n  BaseChart.prototype._optionChangesMap[name] = \"REFRESH_SERIES_FAMILIES\";\n});\nimport { plugin as exportPlugin } from \"../core/export\";\nimport { plugin as titlePlugin } from \"../core/title\";\nimport { plugin as dataSourcePlugin } from \"../core/data_source\";\nimport { plugin as tooltipPlugin } from \"../core/tooltip\";\nimport { plugin as loadingIndicatorPlugin } from \"../core/loading_indicator\";\nBaseChart.addPlugin(exportPlugin);\nBaseChart.addPlugin(titlePlugin);\nBaseChart.addPlugin(dataSourcePlugin);\nBaseChart.addPlugin(tooltipPlugin);\nBaseChart.addPlugin(loadingIndicatorPlugin);\nvar _change_TITLE = BaseChart.prototype._change_TITLE;\n\nBaseChart.prototype._change_TITLE = function () {\n  _change_TITLE.apply(this, arguments);\n\n  this._change([\"FORCE_RENDER\"]);\n};","map":null,"metadata":{},"sourceType":"module"}