{"ast":null,"code":"import _classCallCheck from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\n\n/**\r\n * DevExtreme (esm/ui/scheduler/appointments/rendering_strategies/strategy_vertical.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport BaseAppointmentsStrategy from \"./strategy.base\";\nimport { extend } from \"../../../../core/utils/extend\";\nimport { isNumeric } from \"../../../../core/utils/type\";\nimport dateUtils from \"../../../../core/utils/date\";\nimport timeZoneUtils from \"../../utils.timeZone\";\nimport { ExpressionUtils } from \"../../expressionUtils\";\nimport { createAppointmentAdapter } from \"../../appointmentAdapter\";\nimport { getAppointmentTakesAllDay } from \"../dataProvider/utils\";\nimport getSkippedHoursInRange from \"../../../../renovation/ui/scheduler/view_model/appointments/utils/getSkippedHoursInRange\";\nvar ALLDAY_APPOINTMENT_MIN_VERTICAL_OFFSET = 5;\nvar ALLDAY_APPOINTMENT_MAX_VERTICAL_OFFSET = 20;\nvar toMs = dateUtils.dateToMilliseconds;\n\nvar VerticalRenderingStrategy = /*#__PURE__*/function (_BaseAppointmentsStra) {\n  _inherits(VerticalRenderingStrategy, _BaseAppointmentsStra);\n\n  var _super = _createSuper(VerticalRenderingStrategy);\n\n  function VerticalRenderingStrategy() {\n    _classCallCheck(this, VerticalRenderingStrategy);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(VerticalRenderingStrategy, [{\n    key: \"getDeltaTime\",\n    value: function getDeltaTime(args, initialSize, appointment) {\n      var deltaTime = 0;\n\n      if (this.isAllDay(appointment)) {\n        deltaTime = this._getDeltaWidth(args, initialSize) * toMs(\"day\");\n      } else {\n        var deltaHeight = args.height - initialSize.height;\n        deltaTime = toMs(\"minute\") * Math.round(deltaHeight / this.cellHeight * this.cellDurationInMinutes);\n      }\n\n      return deltaTime;\n    }\n  }, {\n    key: \"_correctCollectorCoordinatesInAdaptive\",\n    value: function _correctCollectorCoordinatesInAdaptive(coordinates, isAllDay) {\n      if (isAllDay) {\n        _get(_getPrototypeOf(VerticalRenderingStrategy.prototype), \"_correctCollectorCoordinatesInAdaptive\", this).call(this, coordinates, isAllDay);\n      } else if (0 === this._getMaxAppointmentCountPerCellByType()) {\n        var cellHeight = this.cellHeight;\n        var cellWidth = this.cellWidth;\n        coordinates.top += (cellHeight - this.getDropDownButtonAdaptiveSize()) / 2;\n        coordinates.left += (cellWidth - this.getDropDownButtonAdaptiveSize()) / 2;\n      }\n    }\n  }, {\n    key: \"getAppointmentGeometry\",\n    value: function getAppointmentGeometry(coordinates) {\n      var geometry = null;\n\n      if (coordinates.allDay) {\n        geometry = this._getAllDayAppointmentGeometry(coordinates);\n      } else {\n        geometry = this.isAdaptive && coordinates.isCompact ? this._getAdaptiveGeometry(coordinates) : this._getVerticalAppointmentGeometry(coordinates);\n      }\n\n      return _get(_getPrototypeOf(VerticalRenderingStrategy.prototype), \"getAppointmentGeometry\", this).call(this, geometry);\n    }\n  }, {\n    key: \"_getAdaptiveGeometry\",\n    value: function _getAdaptiveGeometry(coordinates) {\n      var config = this._calculateGeometryConfig(coordinates);\n\n      return this._customizeCoordinates(coordinates, config.height, config.appointmentCountPerCell, config.offset);\n    }\n  }, {\n    key: \"_getItemPosition\",\n    value: function _getItemPosition(appointment) {\n      var adapter = createAppointmentAdapter(appointment, this.dataAccessors, this.timeZoneCalculator);\n      var allDay = this.isAllDay(appointment);\n      var isRecurring = !!adapter.recurrenceRule;\n      var appointmentStartDate = adapter.calculateStartDate(\"toGrid\");\n      var appointmentEndDate = adapter.calculateEndDate(\"toGrid\");\n      var isAppointmentTakesSeveralDays = !timeZoneUtils.isSameAppointmentDates(appointmentStartDate, appointmentEndDate);\n\n      if (allDay) {\n        return _get(_getPrototypeOf(VerticalRenderingStrategy.prototype), \"_getItemPosition\", this).call(this, appointment);\n      }\n\n      var settings = this.generateAppointmentSettings(appointment);\n      var result = [];\n\n      for (var j = 0; j < settings.length; j++) {\n        var currentSetting = settings[j];\n        var height = this.calculateAppointmentHeight(appointment, currentSetting);\n        var width = this.calculateAppointmentWidth(appointment, currentSetting);\n        var resultHeight = height;\n        var appointmentReduced = null;\n        var multiDaysAppointmentParts = [];\n        var currentMaxAllowedPosition = currentSetting.vMax;\n\n        if (this._isMultiViewAppointment(currentSetting, height) || isAppointmentTakesSeveralDays && !isRecurring) {\n          var reduceHead = dateUtils.sameDate(appointmentStartDate, currentSetting.info.appointment.startDate) || isRecurring;\n\n          if (reduceHead) {\n            resultHeight = this._reduceMultiDayAppointment(height, {\n              top: currentSetting.top,\n              bottom: currentMaxAllowedPosition\n            });\n            multiDaysAppointmentParts = this._getAppointmentParts({\n              sourceAppointmentHeight: height,\n              reducedHeight: resultHeight,\n              width: width\n            }, currentSetting);\n          }\n\n          var isMultiDay = this._isMultiDayAppointment(currentSetting, height);\n\n          if (isMultiDay) {\n            appointmentReduced = reduceHead ? \"head\" : \"tail\";\n          }\n        }\n\n        extend(currentSetting, {\n          height: resultHeight,\n          width: width,\n          allDay: allDay,\n          appointmentReduced: appointmentReduced\n        });\n        result = this._getAppointmentPartsPosition(multiDaysAppointmentParts, currentSetting, result);\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_isMultiDayAppointment\",\n    value: function _isMultiDayAppointment(position, height) {\n      if (this.isVirtualScrolling) {\n        var maxTop = this._getGroupHeight() - this._getGroupTopOffset(position);\n\n        return height > maxTop;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"_isMultiViewAppointment\",\n    value: function _isMultiViewAppointment(position, height) {\n      return height > position.vMax - position.top;\n    }\n  }, {\n    key: \"_reduceMultiDayAppointment\",\n    value: function _reduceMultiDayAppointment(sourceAppointmentHeight, bound) {\n      sourceAppointmentHeight = bound.bottom - Math.floor(bound.top);\n      return sourceAppointmentHeight;\n    }\n  }, {\n    key: \"_getGroupHeight\",\n    value: function _getGroupHeight() {\n      return this.cellHeight * this.rowCount;\n    }\n  }, {\n    key: \"_getGroupTopOffset\",\n    value: function _getGroupTopOffset(appointmentSettings) {\n      var groupIndex = appointmentSettings.groupIndex;\n      var groupTop = Math.max(0, this.positionHelper.getGroupTop({\n        groupIndex: groupIndex,\n        showAllDayPanel: this.showAllDayPanel,\n        isGroupedAllDayPanel: this.isGroupedAllDayPanel\n      }));\n      var allDayPanelOffset = this.positionHelper.getOffsetByAllDayPanel({\n        groupIndex: groupIndex,\n        supportAllDayRow: this.allDaySupported(),\n        showAllDayPanel: this.showAllDayPanel\n      });\n      var appointmentGroupTopOffset = appointmentSettings.top - groupTop - allDayPanelOffset;\n      return appointmentGroupTopOffset;\n    }\n  }, {\n    key: \"_getTailHeight\",\n    value: function _getTailHeight(appointmentGeometry, appointmentSettings) {\n      if (!this.isVirtualScrolling) {\n        return appointmentGeometry.sourceAppointmentHeight - appointmentGeometry.reducedHeight;\n      }\n\n      var appointmentGroupTopOffset = this._getGroupTopOffset(appointmentSettings);\n\n      var sourceAppointmentHeight = appointmentGeometry.sourceAppointmentHeight;\n\n      var groupHeight = this._getGroupHeight();\n\n      var tailHeight = appointmentGroupTopOffset + sourceAppointmentHeight - groupHeight;\n      return tailHeight;\n    }\n  }, {\n    key: \"_getAppointmentParts\",\n    value: function _getAppointmentParts(appointmentGeometry, appointmentSettings) {\n      var tailHeight = this._getTailHeight(appointmentGeometry, appointmentSettings);\n\n      var width = appointmentGeometry.width;\n      var result = [];\n      var currentPartTop = Math.max(0, this.positionHelper.getGroupTop({\n        groupIndex: appointmentSettings.groupIndex,\n        showAllDayPanel: this.showAllDayPanel,\n        isGroupedAllDayPanel: this.isGroupedAllDayPanel\n      }));\n      var cellsDiff = this.isGroupedByDate ? this.groupCount : 1;\n      var offset = this.cellWidth * cellsDiff;\n      var left = appointmentSettings.left + offset;\n\n      if (tailHeight > 0) {\n        var minHeight = this.getAppointmentMinSize();\n\n        if (tailHeight < minHeight) {\n          tailHeight = minHeight;\n        }\n\n        var allDayPanelOffset = this.positionHelper.getOffsetByAllDayPanel({\n          groupIndex: appointmentSettings.groupIndex,\n          supportAllDayRow: this.allDaySupported(),\n          showAllDayPanel: this.showAllDayPanel\n        });\n        currentPartTop += allDayPanelOffset;\n        result.push(extend(true, {}, appointmentSettings, {\n          top: currentPartTop,\n          left: left,\n          height: tailHeight,\n          width: width,\n          appointmentReduced: \"tail\",\n          rowIndex: 0,\n          columnIndex: appointmentSettings.columnIndex + cellsDiff\n        }));\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_getMinuteHeight\",\n    value: function _getMinuteHeight() {\n      return this.cellHeight / this.cellDurationInMinutes;\n    }\n  }, {\n    key: \"_getCompactLeftCoordinate\",\n    value: function _getCompactLeftCoordinate(itemLeft, index) {\n      var cellWidth = this.cellWidth || this.getAppointmentMinSize();\n      return itemLeft + (1 + cellWidth) * index;\n    }\n  }, {\n    key: \"_getVerticalAppointmentGeometry\",\n    value: function _getVerticalAppointmentGeometry(coordinates) {\n      var config = this._calculateVerticalGeometryConfig(coordinates);\n\n      return this._customizeVerticalCoordinates(coordinates, config.width, config.appointmentCountPerCell, config.offset);\n    }\n  }, {\n    key: \"_customizeVerticalCoordinates\",\n    value: function _customizeVerticalCoordinates(coordinates, width, appointmentCountPerCell, topOffset, isAllDay) {\n      var appointmentWidth = Math.max(width / appointmentCountPerCell, width / coordinates.count);\n      var height = coordinates.height;\n      var appointmentLeft = coordinates.left + coordinates.index * appointmentWidth;\n      var top = coordinates.top;\n\n      if (coordinates.isCompact) {\n        this._markAppointmentAsVirtual(coordinates, isAllDay);\n      }\n\n      return {\n        height: height,\n        width: appointmentWidth,\n        top: top,\n        left: appointmentLeft,\n        empty: this._isAppointmentEmpty(height, width)\n      };\n    }\n  }, {\n    key: \"_calculateVerticalGeometryConfig\",\n    value: function _calculateVerticalGeometryConfig(coordinates) {\n      var overlappingMode = this.maxAppointmentsPerCell;\n\n      var offsets = this._getOffsets();\n\n      var appointmentDefaultOffset = this._getAppointmentDefaultOffset();\n\n      var appointmentCountPerCell = this._getAppointmentCount(overlappingMode, coordinates);\n\n      var ratio = this._getDefaultRatio(coordinates, appointmentCountPerCell);\n\n      var maxWidth = this._getMaxWidth();\n\n      if (!appointmentCountPerCell) {\n        appointmentCountPerCell = coordinates.count;\n        ratio = (maxWidth - offsets.unlimited) / maxWidth;\n      }\n\n      var topOffset = (1 - ratio) * maxWidth;\n\n      if (\"auto\" === overlappingMode || isNumeric(overlappingMode)) {\n        ratio = 1;\n        maxWidth -= appointmentDefaultOffset;\n        topOffset = 0;\n      }\n\n      return {\n        width: ratio * maxWidth,\n        appointmentCountPerCell: appointmentCountPerCell,\n        offset: topOffset\n      };\n    }\n  }, {\n    key: \"_getMaxWidth\",\n    value: function _getMaxWidth() {\n      return this.cellWidth || this.cellWidth;\n    }\n  }, {\n    key: \"isAllDay\",\n    value: function isAllDay(appointmentData) {\n      var allDay = ExpressionUtils.getField(this.dataAccessors, \"allDay\", appointmentData);\n\n      if (allDay) {\n        return true;\n      }\n\n      var adapter = createAppointmentAdapter(appointmentData, this.dataAccessors, this.timeZoneCalculator);\n      return getAppointmentTakesAllDay(adapter, this.startDayHour, this.endDayHour);\n    }\n  }, {\n    key: \"_getAppointmentMaxWidth\",\n    value: function _getAppointmentMaxWidth() {\n      return this.cellWidth - this._getAppointmentDefaultOffset();\n    }\n  }, {\n    key: \"calculateAppointmentWidth\",\n    value: function calculateAppointmentWidth(appointment, position) {\n      if (!this.isAllDay(appointment)) {\n        return 0;\n      }\n\n      var startDate = dateUtils.trimTime(position.info.appointment.startDate);\n      var normalizedEndDate = position.info.appointment.normalizedEndDate;\n      var cellWidth = this.cellWidth || this.getAppointmentMinSize();\n      var durationInHours = (normalizedEndDate.getTime() - startDate.getTime()) / toMs(\"hour\");\n      var skippedHours = getSkippedHoursInRange(position.info.appointment.startDate, position.info.appointment.endDate, this.viewDataProvider);\n      var width = Math.ceil((durationInHours - skippedHours) / 24) * cellWidth;\n      width = this.cropAppointmentWidth(width, cellWidth);\n      return width;\n    }\n  }, {\n    key: \"calculateAppointmentHeight\",\n    value: function calculateAppointmentHeight(appointment, position) {\n      if (this.isAllDay(appointment)) {\n        return 0;\n      }\n\n      var startDate = position.info.appointment.startDate;\n      var normalizedEndDate = position.info.appointment.normalizedEndDate;\n      var allDay = ExpressionUtils.getField(this.dataAccessors, \"allDay\", appointment);\n      var duration = this.getAppointmentDurationInMs(startDate, normalizedEndDate, allDay);\n      var durationInMinutes = this._adjustDurationByDaylightDiff(duration, startDate, normalizedEndDate) / toMs(\"minute\");\n\n      var height = durationInMinutes * this._getMinuteHeight();\n\n      return height;\n    }\n  }, {\n    key: \"getDirection\",\n    value: function getDirection() {\n      return \"vertical\";\n    }\n  }, {\n    key: \"_sortCondition\",\n    value: function _sortCondition(a, b) {\n      var allDayCondition = a.allDay - b.allDay;\n      var isAllDay = a.allDay && b.allDay;\n      var condition = \"vertical\" === this.groupOrientation && isAllDay ? this._columnCondition(a, b) : this._rowCondition(a, b);\n      return allDayCondition ? allDayCondition : condition;\n    }\n  }, {\n    key: \"allDaySupported\",\n    value: function allDaySupported() {\n      return true;\n    }\n  }, {\n    key: \"_getAllDayAppointmentGeometry\",\n    value: function _getAllDayAppointmentGeometry(coordinates) {\n      var config = this._calculateGeometryConfig(coordinates);\n\n      return this._customizeCoordinates(coordinates, config.height, config.appointmentCountPerCell, config.offset, true);\n    }\n  }, {\n    key: \"_calculateGeometryConfig\",\n    value: function _calculateGeometryConfig(coordinates) {\n      if (!this.allowResizing || !this.allowAllDayResizing) {\n        coordinates.skipResizing = true;\n      }\n\n      var config = _get(_getPrototypeOf(VerticalRenderingStrategy.prototype), \"_calculateGeometryConfig\", this).call(this, coordinates);\n\n      if (coordinates.count <= this._getDynamicAppointmentCountPerCell().allDay) {\n        config.offset = 0;\n      }\n\n      return config;\n    }\n  }, {\n    key: \"_getAppointmentCount\",\n    value: function _getAppointmentCount(overlappingMode, coordinates) {\n      return \"auto\" !== overlappingMode && 1 === coordinates.count && !isNumeric(overlappingMode) ? coordinates.count : this._getMaxAppointmentCountPerCellByType(coordinates.allDay);\n    }\n  }, {\n    key: \"_getDefaultRatio\",\n    value: function _getDefaultRatio(coordinates, appointmentCountPerCell) {\n      return coordinates.count > this.appointmentCountPerCell ? .65 : 1;\n    }\n  }, {\n    key: \"_getOffsets\",\n    value: function _getOffsets() {\n      return {\n        unlimited: ALLDAY_APPOINTMENT_MIN_VERTICAL_OFFSET,\n        auto: ALLDAY_APPOINTMENT_MAX_VERTICAL_OFFSET\n      };\n    }\n  }, {\n    key: \"_getMaxHeight\",\n    value: function _getMaxHeight() {\n      return this.allDayHeight || this.getAppointmentMinSize();\n    }\n  }, {\n    key: \"_needVerticalGroupBounds\",\n    value: function _needVerticalGroupBounds(allDay) {\n      return !allDay;\n    }\n  }, {\n    key: \"_needHorizontalGroupBounds\",\n    value: function _needHorizontalGroupBounds() {\n      return false;\n    }\n  }, {\n    key: \"getPositionShift\",\n    value: function getPositionShift(timeShift, isAllDay) {\n      if (!isAllDay && this.isAdaptive && 0 === this._getMaxAppointmentCountPerCellByType(isAllDay)) {\n        return {\n          top: 0,\n          left: 0,\n          cellPosition: 0\n        };\n      }\n\n      return _get(_getPrototypeOf(VerticalRenderingStrategy.prototype), \"getPositionShift\", this).call(this, timeShift, isAllDay);\n    }\n  }]);\n\n  return VerticalRenderingStrategy;\n}(BaseAppointmentsStrategy);\n\nexport default VerticalRenderingStrategy;","map":null,"metadata":{},"sourceType":"module"}