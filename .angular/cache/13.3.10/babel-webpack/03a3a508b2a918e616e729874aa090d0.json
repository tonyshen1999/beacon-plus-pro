{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/pivot_grid/ui.pivot_grid.summary_display_modes.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { isFunction, isDefined, isObject } from \"../../core/utils/type\";\nimport { extend } from \"../../core/utils/extend\";\nimport { inArray } from \"../../core/utils/array\";\nimport { findField, foreachTree, setFieldProperty } from \"./ui.pivot_grid.utils\";\nvar COLUMN = \"column\";\nvar ROW = \"row\";\nvar NULL = null;\n\nvar calculatePercentValue = function calculatePercentValue(value, totalValue) {\n  var result = value / totalValue;\n\n  if (!isDefined(value) || isNaN(result)) {\n    result = NULL;\n  }\n\n  return result;\n};\n\nvar _percentOfGrandTotal = function _percentOfGrandTotal(e, dimension) {\n  return calculatePercentValue(e.value(), e.grandTotal(dimension).value());\n};\n\nvar percentOfParent = function percentOfParent(e, dimension) {\n  var parent = e.parent(dimension);\n  var parentValue = parent ? parent.value() : e.value();\n  return calculatePercentValue(e.value(), parentValue);\n};\n\nvar createAbsoluteVariationExp = function createAbsoluteVariationExp(allowCrossGroup) {\n  return function (e) {\n    var prevCell = e.prev(COLUMN, allowCrossGroup);\n    var prevValue = prevCell && prevCell.value();\n\n    if (isDefined(prevValue) && isDefined(e.value())) {\n      return e.value() - prevValue;\n    }\n\n    return NULL;\n  };\n};\n\nvar createPercentVariationExp = function createPercentVariationExp(allowCrossGroup) {\n  var absoluteExp = createAbsoluteVariationExp(allowCrossGroup);\n  return function (e) {\n    var absVar = absoluteExp(e);\n    var prevCell = e.prev(COLUMN, allowCrossGroup);\n    var prevValue = prevCell && prevCell.value();\n    return absVar !== NULL && prevValue ? absVar / prevValue : NULL;\n  };\n};\n\nvar summaryDictionary = {\n  percentOfColumnTotal: function percentOfColumnTotal(e) {\n    return percentOfParent(e, ROW);\n  },\n  percentOfRowTotal: function percentOfRowTotal(e) {\n    return percentOfParent(e, COLUMN);\n  },\n  percentOfColumnGrandTotal: function percentOfColumnGrandTotal(e) {\n    return _percentOfGrandTotal(e, ROW);\n  },\n  percentOfRowGrandTotal: function percentOfRowGrandTotal(e) {\n    return _percentOfGrandTotal(e, COLUMN);\n  },\n  percentOfGrandTotal: function percentOfGrandTotal(e) {\n    return _percentOfGrandTotal(e);\n  }\n};\n\nvar getPrevCellCrossGroup = function getPrevCellCrossGroup(cell, direction) {\n  if (!cell || !cell.parent(direction)) {\n    return;\n  }\n\n  var prevCell = cell.prev(direction);\n\n  if (!prevCell) {\n    prevCell = getPrevCellCrossGroup(cell.parent(direction), direction);\n  }\n\n  return prevCell;\n};\n\nvar createRunningTotalExpr = function createRunningTotalExpr(field) {\n  if (!field.runningTotal) {\n    return;\n  }\n\n  var direction = field.runningTotal === COLUMN ? ROW : COLUMN;\n  return function (e) {\n    var prevCell = field.allowCrossGroupCalculation ? getPrevCellCrossGroup(e, direction) : e.prev(direction, false);\n    var value = e.value(true);\n    var prevValue = prevCell && prevCell.value(true);\n\n    if (isDefined(prevValue) && isDefined(value)) {\n      value = prevValue + value;\n    } else if (isDefined(prevValue)) {\n      value = prevValue;\n    }\n\n    return value;\n  };\n};\n\nfunction createCache() {\n  return {\n    fields: {},\n    positions: {}\n  };\n}\n\nfunction getFieldPos(descriptions, field, cache) {\n  var fieldParams = {\n    index: -1\n  };\n\n  if (!isObject(field)) {\n    if (cache.fields[field]) {\n      field = cache[field];\n    } else {\n      var allFields = descriptions.columns.concat(descriptions.rows).concat(descriptions.values);\n      var fieldIndex = findField(allFields, field);\n      field = cache[field] = allFields[fieldIndex];\n    }\n  }\n\n  if (field) {\n    var area = field.area || \"data\";\n    fieldParams = cache.positions[field.index] = cache.positions[field.index] || {\n      area: area,\n      index: inArray(field, descriptions[\"data\" === area ? \"values\" : area + \"s\"])\n    };\n  }\n\n  return fieldParams;\n}\n\nfunction getPathFieldName(dimension) {\n  return dimension === ROW ? \"_rowPath\" : \"_columnPath\";\n}\n\nvar SummaryCell = function SummaryCell(columnPath, rowPath, data, descriptions, fieldIndex, fieldsCache) {\n  this._columnPath = columnPath;\n  this._rowPath = rowPath;\n  this._fieldIndex = fieldIndex;\n  this._fieldsCache = fieldsCache || createCache();\n  this._data = data;\n  this._descriptions = descriptions;\n  var cell = data.values && data.values[rowPath[0].index] && data.values[rowPath[0].index][columnPath[0].index];\n\n  if (cell) {\n    cell.originalCell = cell.originalCell || cell.slice();\n    cell.postProcessedFlags = cell.postProcessedFlags || [];\n    this._cell = cell;\n  }\n};\n\nSummaryCell.prototype = extend(SummaryCell.prototype, {\n  _getPath: function _getPath(dimension) {\n    return this[getPathFieldName(dimension)];\n  },\n  _getDimension: function _getDimension(dimension) {\n    dimension = dimension === ROW ? \"rows\" : \"columns\";\n    return this._descriptions[dimension];\n  },\n  _createCell: function _createCell(config) {\n    return new SummaryCell(config._columnPath || this._columnPath, config._rowPath || this._rowPath, this._data, this._descriptions, this._fieldIndex);\n  },\n  parent: function parent(direction) {\n    var path = this._getPath(direction).slice();\n\n    var config = {};\n    path.shift();\n\n    if (path.length) {\n      config[getPathFieldName(direction)] = path;\n      return this._createCell(config);\n    }\n\n    return NULL;\n  },\n  children: function children(direction) {\n    var path = this._getPath(direction).slice();\n\n    var item = path[0];\n    var result = [];\n    var cellConfig = {};\n\n    if (item.children) {\n      for (var i = 0; i < item.children.length; i++) {\n        cellConfig[getPathFieldName(direction)] = [item.children[i]].concat(path.slice());\n        result.push(this._createCell(cellConfig));\n      }\n    }\n\n    return result;\n  },\n  grandTotal: function grandTotal(direction) {\n    var config = {};\n    var rowPath = this._rowPath;\n    var columnPath = this._columnPath;\n\n    var dimensionPath = this._getPath(direction);\n\n    var pathFieldName = getPathFieldName(direction);\n\n    if (!direction) {\n      config._rowPath = [rowPath[rowPath.length - 1]];\n      config._columnPath = [columnPath[columnPath.length - 1]];\n    } else {\n      config[pathFieldName] = [dimensionPath[dimensionPath.length - 1]];\n    }\n\n    return this._createCell(config);\n  },\n  next: function next(direction, allowCrossGroup) {\n    var currentPath = this._getPath(direction);\n\n    var item = currentPath[0];\n    var parent = this.parent(direction);\n    var siblings;\n\n    if (parent) {\n      var index = inArray(item, currentPath[1].children);\n      siblings = parent.children(direction);\n\n      if (siblings[index + 1]) {\n        return siblings[index + 1];\n      }\n    }\n\n    if (allowCrossGroup && parent) {\n      do {\n        parent = parent.next(direction, allowCrossGroup);\n        siblings = parent ? parent.children(direction) : [];\n      } while (parent && !siblings.length);\n\n      return siblings[0] || NULL;\n    }\n\n    return NULL;\n  },\n  prev: function prev(direction, allowCrossGroup) {\n    var currentPath = this._getPath(direction);\n\n    var item = currentPath[0];\n    var parent = this.parent(direction);\n    var siblings;\n\n    if (parent) {\n      var index = inArray(item, currentPath[1].children);\n      siblings = parent.children(direction);\n\n      if (siblings[index - 1]) {\n        return siblings[index - 1];\n      }\n    }\n\n    if (allowCrossGroup && parent) {\n      do {\n        parent = parent.prev(direction, allowCrossGroup);\n        siblings = parent ? parent.children(direction) : [];\n      } while (parent && !siblings.length);\n\n      return siblings[siblings.length - 1] || NULL;\n    }\n\n    return NULL;\n  },\n  cell: function cell() {\n    return this._cell;\n  },\n  field: function field(area) {\n    if (\"data\" === area) {\n      return this._descriptions.values[this._fieldIndex];\n    }\n\n    var path = this._getPath(area);\n\n    var descriptions = this._getDimension(area);\n\n    var field = descriptions[path.length - 2];\n    return field || NULL;\n  },\n  child: function child(direction, fieldValue) {\n    var children = this.children(direction);\n\n    for (var i = 0; i < children.length; i++) {\n      var childLevelField = childLevelField || children[i].field(direction);\n\n      if (children[i].value(childLevelField) === fieldValue) {\n        return children[i];\n      }\n    }\n\n    return NULL;\n  },\n  slice: function slice(field, value) {\n    var config = {};\n    var fieldPos = getFieldPos(this._descriptions, field, this._fieldsCache);\n    var area = fieldPos.area;\n    var fieldIndex = fieldPos.index;\n    var sliceCell = NULL;\n\n    if (area === ROW || area === COLUMN) {\n      var path = this._getPath(area).slice();\n\n      var level = -1 !== fieldIndex && path.length - 2 - fieldIndex;\n\n      if (path[level]) {\n        [][path.length - 1] = path[path.length - 1];\n\n        for (var i = level; i >= 0; i--) {\n          if (path[i + 1]) {\n            var childItems = path[i + 1].children || [];\n            var currentValue = i === level ? value : path[i].value;\n            path[i] = void 0;\n\n            for (var childIndex = 0; childIndex < childItems.length; childIndex++) {\n              if (childItems[childIndex].value === currentValue) {\n                path[i] = childItems[childIndex];\n                break;\n              }\n            }\n          }\n\n          if (void 0 === path[i]) {\n            return sliceCell;\n          }\n        }\n\n        config[getPathFieldName(area)] = path;\n        sliceCell = this._createCell(config);\n      }\n    }\n\n    return sliceCell;\n  },\n  value: function value(arg1, arg2) {\n    var cell = this._cell;\n    var fieldIndex = this._fieldIndex;\n    var fistArgIsBoolean = true === arg1 || false === arg1;\n    var field = !fistArgIsBoolean ? arg1 : NULL;\n    var needCalculatedValue = fistArgIsBoolean && arg1 || arg2;\n\n    if (isDefined(field)) {\n      var fieldPos = getFieldPos(this._descriptions, field, this._fieldsCache);\n      fieldIndex = fieldPos.index;\n\n      if (\"data\" !== fieldPos.area) {\n        var path = this._getPath(fieldPos.area);\n\n        var level = -1 !== fieldIndex && path.length - 2 - fieldIndex;\n        return path[level] && path[level].value;\n      }\n    }\n\n    if (cell && cell.originalCell) {\n      return needCalculatedValue ? cell[fieldIndex] : cell.originalCell[fieldIndex];\n    }\n\n    return NULL;\n  },\n  isPostProcessed: function isPostProcessed(field) {\n    var fieldIndex = this._fieldIndex;\n\n    if (isDefined(field)) {\n      var fieldPos = getFieldPos(this._descriptions, field, this._fieldsCache);\n      fieldIndex = fieldPos.index;\n\n      if (\"data\" !== fieldPos.area) {\n        return false;\n      }\n    }\n\n    return !!(this._cell && this._cell.postProcessedFlags[fieldIndex]);\n  }\n});\n\nfunction getExpression(field) {\n  var summaryDisplayMode = field.summaryDisplayMode;\n  var crossGroupCalculation = field.allowCrossGroupCalculation;\n  var expression = NULL;\n\n  if (isFunction(field.calculateSummaryValue)) {\n    expression = field.calculateSummaryValue;\n  } else if (summaryDisplayMode) {\n    if (\"absoluteVariation\" === summaryDisplayMode) {\n      expression = createAbsoluteVariationExp(crossGroupCalculation);\n    } else if (\"percentVariation\" === summaryDisplayMode) {\n      expression = createPercentVariationExp(crossGroupCalculation);\n    } else {\n      expression = summaryDictionary[summaryDisplayMode];\n    }\n\n    if (expression && !field.format && -1 !== summaryDisplayMode.indexOf(\"percent\")) {\n      setFieldProperty(field, \"format\", \"percent\");\n    }\n  }\n\n  return expression;\n}\n\nfunction processDataCell(data, rowIndex, columnIndex, isRunningTotalCalculation) {\n  var values = data.values[rowIndex][columnIndex] = data.values[rowIndex][columnIndex] || [];\n  var originalCell = values.originalCell;\n\n  if (!originalCell) {\n    return;\n  }\n\n  if (values.allowResetting || !isRunningTotalCalculation) {\n    data.values[rowIndex][columnIndex] = originalCell.slice();\n  }\n\n  data.values[rowIndex][columnIndex].allowResetting = isRunningTotalCalculation;\n}\n\nexport function applyDisplaySummaryMode(descriptions, data) {\n  var expressions = [];\n  var columnElements = [{\n    index: data.grandTotalColumnIndex,\n    children: data.columns\n  }];\n  var rowElements = [{\n    index: data.grandTotalRowIndex,\n    children: data.rows\n  }];\n  var valueFields = descriptions.values;\n  var fieldsCache = createCache();\n  data.values = data.values || [];\n  foreachTree(columnElements, function (columnPath) {\n    columnPath[0].isEmpty = [];\n  }, false);\n  foreachTree(rowElements, function (rowPath) {\n    var rowItem = rowPath[0];\n    rowItem.isEmpty = [];\n    data.values[rowItem.index] = data.values[rowItem.index] || [];\n    foreachTree(columnElements, function (columnPath) {\n      var columnItem = columnPath[0];\n      var isEmptyCell;\n      processDataCell(data, rowItem.index, columnItem.index, false);\n\n      for (var i = 0; i < valueFields.length; i++) {\n        var field = valueFields[i];\n        var expression = expressions[i] = void 0 === expressions[i] ? getExpression(field) : expressions[i];\n        isEmptyCell = false;\n\n        if (expression) {\n          var expressionArg = new SummaryCell(columnPath, rowPath, data, descriptions, i, fieldsCache);\n          var cell = expressionArg.cell();\n          var value = cell[i] = expression(expressionArg);\n          cell.postProcessedFlags[i] = true;\n          isEmptyCell = null === value || void 0 === value;\n        }\n\n        if (void 0 === columnItem.isEmpty[i]) {\n          columnItem.isEmpty[i] = true;\n        }\n\n        if (void 0 === rowItem.isEmpty[i]) {\n          rowItem.isEmpty[i] = true;\n        }\n\n        if (!isEmptyCell) {\n          rowItem.isEmpty[i] = columnItem.isEmpty[i] = false;\n        }\n      }\n    }, false);\n  }, false);\n  data.isEmptyGrandTotalRow = rowElements[0].isEmpty;\n  data.isEmptyGrandTotalColumn = columnElements[0].isEmpty;\n}\nexport function applyRunningTotal(descriptions, data) {\n  var expressions = [];\n  var columnElements = [{\n    index: data.grandTotalColumnIndex,\n    children: data.columns\n  }];\n  var rowElements = [{\n    index: data.grandTotalRowIndex,\n    children: data.rows\n  }];\n  var valueFields = descriptions.values;\n  var fieldsCache = createCache();\n  data.values = data.values || [];\n  foreachTree(rowElements, function (rowPath) {\n    var rowItem = rowPath[0];\n    data.values[rowItem.index] = data.values[rowItem.index] || [];\n    foreachTree(columnElements, function (columnPath) {\n      var columnItem = columnPath[0];\n      processDataCell(data, rowItem.index, columnItem.index, true);\n\n      for (var i = 0; i < valueFields.length; i++) {\n        var field = valueFields[i];\n        var expression = expressions[i] = void 0 === expressions[i] ? createRunningTotalExpr(field) : expressions[i];\n\n        if (expression) {\n          var expressionArg = new SummaryCell(columnPath, rowPath, data, descriptions, i, fieldsCache);\n          var cell = expressionArg.cell();\n          cell[i] = expression(expressionArg);\n          cell.postProcessedFlags[i] = true;\n        }\n      }\n    }, false);\n  }, false);\n}\nexport function createMockSummaryCell(descriptions, fields, indices) {\n  var summaryCell = new SummaryCell([], [], {}, descriptions, 0);\n\n  summaryCell.value = function (fieldId) {\n    if (isDefined(fieldId)) {\n      var index = findField(fields, fieldId);\n      var field = fields[index];\n\n      if (!indices[index] && field && !isDefined(field.area)) {\n        descriptions.values.push(field);\n        indices[index] = true;\n      }\n    }\n  };\n\n  summaryCell.grandTotal = function () {\n    return this;\n  };\n\n  summaryCell.children = function () {\n    return [];\n  };\n\n  return summaryCell;\n}","map":null,"metadata":{},"sourceType":"module"}