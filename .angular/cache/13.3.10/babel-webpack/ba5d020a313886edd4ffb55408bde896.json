{"ast":null,"code":"/**\r\n * DevExtreme (esm/events/core/events_engine.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport registerEventCallbacks from \"./event_registrator_callbacks\";\nimport { extend } from \"../../core/utils/extend\";\nimport domAdapter from \"../../core/dom_adapter\";\nimport { getWindow, hasWindow } from \"../../core/utils/window\";\nvar window = getWindow();\nimport injector from \"../../core/utils/dependency_injector\";\nimport { isWindow, isFunction, isString } from \"../../core/utils/type\";\nimport Callbacks from \"../../core/utils/callbacks\";\nimport errors from \"../../core/errors\";\nimport WeakMap from \"../../core/polyfills/weak_map\";\nimport hookTouchProps from \"../../events/core/hook_touch_props\";\nimport callOnce from \"../../core/utils/call_once\";\nvar EMPTY_EVENT_NAME = \"dxEmptyEventType\";\nvar NATIVE_EVENTS_TO_SUBSCRIBE = {\n  mouseenter: \"mouseover\",\n  mouseleave: \"mouseout\",\n  pointerenter: \"pointerover\",\n  pointerleave: \"pointerout\"\n};\nvar NATIVE_EVENTS_TO_TRIGGER = {\n  focusin: \"focus\",\n  focusout: \"blur\"\n};\nvar NO_BUBBLE_EVENTS = [\"blur\", \"focus\", \"load\"];\nvar forcePassiveFalseEventNames = [\"touchmove\", \"wheel\", \"mousewheel\", \"touchstart\"];\nvar EVENT_PROPERTIES = [\"target\", \"relatedTarget\", \"delegateTarget\", \"altKey\", \"bubbles\", \"cancelable\", \"changedTouches\", \"ctrlKey\", \"detail\", \"eventPhase\", \"metaKey\", \"shiftKey\", \"view\", \"char\", \"code\", \"charCode\", \"key\", \"keyCode\", \"button\", \"buttons\", \"offsetX\", \"offsetY\", \"pointerId\", \"pointerType\", \"targetTouches\", \"toElement\", \"touches\"];\n\nfunction matchesSafe(target, selector) {\n  return !isWindow(target) && \"#document\" !== target.nodeName && domAdapter.elementMatches(target, selector);\n}\n\nvar elementDataMap = new WeakMap();\nvar guid = 0;\nvar skipEvent;\n\nvar special = function () {\n  var specialData = {};\n  registerEventCallbacks.add(function (eventName, eventObject) {\n    specialData[eventName] = eventObject;\n  });\n  return {\n    getField: function getField(eventName, field) {\n      return specialData[eventName] && specialData[eventName][field];\n    },\n    callMethod: function callMethod(eventName, methodName, context, args) {\n      return specialData[eventName] && specialData[eventName][methodName] && specialData[eventName][methodName].apply(context, args);\n    }\n  };\n}();\n\nvar eventsEngine = injector({\n  on: getHandler(normalizeOnArguments(iterate(function (element, eventName, selector, data, handler) {\n    var handlersController = getHandlersController(element, eventName);\n    handlersController.addHandler(handler, selector, data);\n  }))),\n  one: getHandler(normalizeOnArguments(function (element, eventName, selector, data, handler) {\n    eventsEngine.on(element, eventName, selector, data, function oneTimeHandler() {\n      eventsEngine.off(element, eventName, selector, oneTimeHandler);\n      handler.apply(this, arguments);\n    });\n  })),\n  off: getHandler(normalizeOffArguments(iterate(function (element, eventName, selector, handler) {\n    var handlersController = getHandlersController(element, eventName);\n    handlersController.removeHandler(handler, selector);\n  }))),\n  trigger: getHandler(normalizeTriggerArguments(function (element, event, extraParameters) {\n    var eventName = event.type;\n    var handlersController = getHandlersController(element, event.type);\n    special.callMethod(eventName, \"trigger\", element, [event, extraParameters]);\n    handlersController.callHandlers(event, extraParameters);\n    var noBubble = special.getField(eventName, \"noBubble\") || event.isPropagationStopped() || -1 !== NO_BUBBLE_EVENTS.indexOf(eventName);\n\n    if (!noBubble) {\n      var parents = [];\n      !function getParents(element) {\n        var parent = element.parentNode;\n\n        if (parent) {\n          parents.push(parent);\n          getParents(parent);\n        }\n      }(element);\n      parents.push(window);\n      var i = 0;\n\n      while (parents[i] && !event.isPropagationStopped()) {\n        var parentDataByEvent = getHandlersController(parents[i], event.type);\n        parentDataByEvent.callHandlers(extend(event, {\n          currentTarget: parents[i]\n        }), extraParameters);\n        i++;\n      }\n    }\n\n    if (element.nodeType || isWindow(element)) {\n      special.callMethod(eventName, \"_default\", element, [event, extraParameters]);\n      callNativeMethod(eventName, element);\n    }\n  })),\n  triggerHandler: getHandler(normalizeTriggerArguments(function (element, event, extraParameters) {\n    var handlersController = getHandlersController(element, event.type);\n    handlersController.callHandlers(event, extraParameters);\n  }))\n});\n\nfunction applyForEach(args, method) {\n  var element = args[0];\n\n  if (!element) {\n    return;\n  }\n\n  if (domAdapter.isNode(element) || isWindow(element)) {\n    method.apply(eventsEngine, args);\n  } else if (!isString(element) && \"length\" in element) {\n    var itemArgs = Array.prototype.slice.call(args, 0);\n    Array.prototype.forEach.call(element, function (itemElement) {\n      itemArgs[0] = itemElement;\n      applyForEach(itemArgs, method);\n    });\n  } else {\n    throw errors.Error(\"E0025\");\n  }\n}\n\nfunction getHandler(method) {\n  return function () {\n    applyForEach(arguments, method);\n  };\n}\n\nfunction detectPassiveEventHandlersSupport() {\n  var isSupported = false;\n\n  try {\n    var options = Object.defineProperty({}, \"passive\", {\n      get: function get() {\n        isSupported = true;\n        return true;\n      }\n    });\n    window.addEventListener(\"test\", null, options);\n  } catch (e) {}\n\n  return isSupported;\n}\n\nvar passiveEventHandlersSupported = callOnce(detectPassiveEventHandlersSupport);\n\nvar contains = function contains(container, element) {\n  if (isWindow(container)) {\n    return contains(container.document, element);\n  }\n\n  return container.contains ? container.contains(element) : !!(element.compareDocumentPosition(container) & element.DOCUMENT_POSITION_CONTAINS);\n};\n\nfunction getHandlersController(element, eventName) {\n  var elementData = elementDataMap.get(element);\n  eventName = eventName || \"\";\n  var eventNameParts = eventName.split(\".\");\n  var namespaces = eventNameParts.slice(1);\n  var eventNameIsDefined = !!eventNameParts[0];\n  eventName = eventNameParts[0] || EMPTY_EVENT_NAME;\n\n  if (!elementData) {\n    elementData = {};\n    elementDataMap.set(element, elementData);\n  }\n\n  if (!elementData[eventName]) {\n    elementData[eventName] = {\n      handleObjects: [],\n      nativeHandler: null\n    };\n  }\n\n  var eventData = elementData[eventName];\n  return {\n    addHandler: function addHandler(handler, selector, data) {\n      var callHandler = function callHandler(e, extraParameters) {\n        var handlerArgs = [e];\n        var target = e.currentTarget;\n        var relatedTarget = e.relatedTarget;\n        var secondaryTargetIsInside;\n        var result;\n\n        if (eventName in NATIVE_EVENTS_TO_SUBSCRIBE) {\n          secondaryTargetIsInside = relatedTarget && target && (relatedTarget === target || contains(target, relatedTarget));\n        }\n\n        if (void 0 !== extraParameters) {\n          handlerArgs.push(extraParameters);\n        }\n\n        special.callMethod(eventName, \"handle\", element, [e, data]);\n\n        if (!secondaryTargetIsInside) {\n          result = handler.apply(target, handlerArgs);\n        }\n\n        if (false === result) {\n          e.preventDefault();\n          e.stopPropagation();\n        }\n      };\n\n      var handleObject = {\n        handler: handler,\n        wrappedHandler: function wrappedHandler(e, extraParameters) {\n          if (skipEvent && e.type === skipEvent) {\n            return;\n          }\n\n          e.data = data;\n          e.delegateTarget = element;\n\n          if (selector) {\n            var currentTarget = e.target;\n\n            while (currentTarget && currentTarget !== element) {\n              if (matchesSafe(currentTarget, selector)) {\n                e.currentTarget = currentTarget;\n                callHandler(e, extraParameters);\n              }\n\n              currentTarget = currentTarget.parentNode;\n            }\n          } else {\n            e.currentTarget = e.delegateTarget || e.target;\n            callHandler(e, extraParameters);\n          }\n        },\n        selector: selector,\n        type: eventName,\n        data: data,\n        namespace: namespaces.join(\".\"),\n        namespaces: namespaces,\n        guid: ++guid\n      };\n      eventData.handleObjects.push(handleObject);\n      var firstHandlerForTheType = 1 === eventData.handleObjects.length;\n      var shouldAddNativeListener = firstHandlerForTheType && eventNameIsDefined;\n      var nativeListenerOptions;\n\n      if (shouldAddNativeListener) {\n        shouldAddNativeListener = !special.callMethod(eventName, \"setup\", element, [data, namespaces, handler]);\n      }\n\n      if (shouldAddNativeListener) {\n        eventData.nativeHandler = getNativeHandler(eventName);\n\n        if (passiveEventHandlersSupported() && forcePassiveFalseEventNames.indexOf(eventName) > -1) {\n          nativeListenerOptions = {\n            passive: false\n          };\n        }\n\n        eventData.removeListener = domAdapter.listen(element, NATIVE_EVENTS_TO_SUBSCRIBE[eventName] || eventName, eventData.nativeHandler, nativeListenerOptions);\n      }\n\n      special.callMethod(eventName, \"add\", element, [handleObject]);\n    },\n    removeHandler: function removeHandler(handler, selector) {\n      var removeByEventName = function removeByEventName(eventName) {\n        var eventData = elementData[eventName];\n\n        if (!eventData.handleObjects.length) {\n          delete elementData[eventName];\n          return;\n        }\n\n        var removedHandler;\n        eventData.handleObjects = eventData.handleObjects.filter(function (handleObject) {\n          var skip = namespaces.length && !isSubset(handleObject.namespaces, namespaces) || handler && handleObject.handler !== handler || selector && handleObject.selector !== selector;\n\n          if (!skip) {\n            removedHandler = handleObject.handler;\n            special.callMethod(eventName, \"remove\", element, [handleObject]);\n          }\n\n          return skip;\n        });\n        var lastHandlerForTheType = !eventData.handleObjects.length;\n        var shouldRemoveNativeListener = lastHandlerForTheType && eventName !== EMPTY_EVENT_NAME;\n\n        if (shouldRemoveNativeListener) {\n          special.callMethod(eventName, \"teardown\", element, [namespaces, removedHandler]);\n\n          if (eventData.nativeHandler) {\n            eventData.removeListener();\n          }\n\n          delete elementData[eventName];\n        }\n      };\n\n      if (eventNameIsDefined) {\n        removeByEventName(eventName);\n      } else {\n        for (var name in elementData) {\n          removeByEventName(name);\n        }\n      }\n\n      var elementDataIsEmpty = 0 === Object.keys(elementData).length;\n\n      if (elementDataIsEmpty) {\n        elementDataMap.delete(element);\n      }\n    },\n    callHandlers: function callHandlers(event, extraParameters) {\n      var forceStop = false;\n\n      var handleCallback = function handleCallback(handleObject) {\n        if (forceStop) {\n          return;\n        }\n\n        if (!namespaces.length || isSubset(handleObject.namespaces, namespaces)) {\n          handleObject.wrappedHandler(event, extraParameters);\n          forceStop = event.isImmediatePropagationStopped();\n        }\n      };\n\n      eventData.handleObjects.forEach(handleCallback);\n\n      if (namespaces.length && elementData[EMPTY_EVENT_NAME]) {\n        elementData[EMPTY_EVENT_NAME].handleObjects.forEach(handleCallback);\n      }\n    }\n  };\n}\n\nfunction getNativeHandler(subscribeName) {\n  return function (event, extraParameters) {\n    var handlersController = getHandlersController(this, subscribeName);\n    event = eventsEngine.Event(event);\n    handlersController.callHandlers(event, extraParameters);\n  };\n}\n\nfunction isSubset(original, checked) {\n  for (var i = 0; i < checked.length; i++) {\n    if (original.indexOf(checked[i]) < 0) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction normalizeOnArguments(callback) {\n  return function (element, eventName, selector, data, handler) {\n    if (!handler) {\n      handler = data;\n      data = void 0;\n    }\n\n    if (\"string\" !== typeof selector) {\n      data = selector;\n      selector = void 0;\n    }\n\n    if (!handler && \"string\" === typeof eventName) {\n      handler = data || selector;\n      selector = void 0;\n      data = void 0;\n    }\n\n    callback(element, eventName, selector, data, handler);\n  };\n}\n\nfunction normalizeOffArguments(callback) {\n  return function (element, eventName, selector, handler) {\n    if (\"function\" === typeof selector) {\n      handler = selector;\n      selector = void 0;\n    }\n\n    callback(element, eventName, selector, handler);\n  };\n}\n\nfunction normalizeTriggerArguments(callback) {\n  return function (element, src, extraParameters) {\n    if (\"string\" === typeof src) {\n      src = {\n        type: src\n      };\n    }\n\n    if (!src.target) {\n      src.target = element;\n    }\n\n    src.currentTarget = element;\n\n    if (!src.delegateTarget) {\n      src.delegateTarget = element;\n    }\n\n    if (!src.type && src.originalEvent) {\n      src.type = src.originalEvent.type;\n    }\n\n    callback(element, src instanceof eventsEngine.Event ? src : eventsEngine.Event(src), extraParameters);\n  };\n}\n\nfunction normalizeEventArguments(callback) {\n  eventsEngine.Event = function (src, config) {\n    if (!(this instanceof eventsEngine.Event)) {\n      return new eventsEngine.Event(src, config);\n    }\n\n    if (!src) {\n      src = {};\n    }\n\n    if (\"string\" === typeof src) {\n      src = {\n        type: src\n      };\n    }\n\n    if (!config) {\n      config = {};\n    }\n\n    callback.call(this, src, config);\n  };\n\n  _extends(eventsEngine.Event.prototype, {\n    _propagationStopped: false,\n    _immediatePropagationStopped: false,\n    _defaultPrevented: false,\n    isPropagationStopped: function isPropagationStopped() {\n      return !!(this._propagationStopped || this.originalEvent && this.originalEvent.propagationStopped);\n    },\n    stopPropagation: function stopPropagation() {\n      this._propagationStopped = true;\n      this.originalEvent && this.originalEvent.stopPropagation();\n    },\n    isImmediatePropagationStopped: function isImmediatePropagationStopped() {\n      return this._immediatePropagationStopped;\n    },\n    stopImmediatePropagation: function stopImmediatePropagation() {\n      this.stopPropagation();\n      this._immediatePropagationStopped = true;\n      this.originalEvent && this.originalEvent.stopImmediatePropagation();\n    },\n    isDefaultPrevented: function isDefaultPrevented() {\n      return !!(this._defaultPrevented || this.originalEvent && this.originalEvent.defaultPrevented);\n    },\n    preventDefault: function preventDefault() {\n      this._defaultPrevented = true;\n      this.originalEvent && this.originalEvent.preventDefault();\n    }\n  });\n\n  return eventsEngine.Event;\n}\n\nfunction iterate(callback) {\n  var iterateEventNames = function iterateEventNames(element, eventName) {\n    if (eventName && eventName.indexOf(\" \") > -1) {\n      var args = Array.prototype.slice.call(arguments, 0);\n      eventName.split(\" \").forEach(function (eventName) {\n        args[1] = eventName;\n        callback.apply(this, args);\n      });\n    } else {\n      callback.apply(this, arguments);\n    }\n  };\n\n  return function (element, eventName) {\n    if (\"object\" === typeof eventName) {\n      var args = Array.prototype.slice.call(arguments, 0);\n\n      for (var name in eventName) {\n        args[1] = name;\n        args[args.length - 1] = eventName[name];\n        iterateEventNames.apply(this, args);\n      }\n    } else {\n      iterateEventNames.apply(this, arguments);\n    }\n  };\n}\n\nfunction callNativeMethod(eventName, element) {\n  var nativeMethodName = NATIVE_EVENTS_TO_TRIGGER[eventName] || eventName;\n\n  if (function (eventName, element) {\n    return \"click\" === eventName && \"a\" === element.localName;\n  }(eventName, element)) {\n    return;\n  }\n\n  if (isFunction(element[nativeMethodName])) {\n    skipEvent = eventName;\n    element[nativeMethodName]();\n    skipEvent = void 0;\n  }\n}\n\nfunction calculateWhich(event) {\n  if (function (event) {\n    return null == event.which && 0 === event.type.indexOf(\"key\");\n  }(event)) {\n    return null != event.charCode ? event.charCode : event.keyCode;\n  }\n\n  if (function (event) {\n    return !event.which && void 0 !== event.button && /^(?:mouse|pointer|contextmenu|drag|drop)|click/.test(event.type);\n  }(event)) {\n    return {\n      1: 1,\n      2: 3,\n      3: 1,\n      4: 2\n    }[event.button];\n  }\n\n  return event.which;\n}\n\nfunction initEvent(EventClass) {\n  if (EventClass) {\n    eventsEngine.Event = EventClass;\n    eventsEngine.Event.prototype = EventClass.prototype;\n  }\n}\n\ninitEvent(normalizeEventArguments(function (src, config) {\n  var _src$view;\n\n  var srcIsEvent = src instanceof eventsEngine.Event || hasWindow() && src instanceof window.Event || (null === (_src$view = src.view) || void 0 === _src$view ? void 0 : _src$view.Event) && src instanceof src.view.Event;\n\n  if (srcIsEvent) {\n    this.originalEvent = src;\n    this.type = src.type;\n    this.currentTarget = void 0;\n\n    if (Object.prototype.hasOwnProperty.call(src, \"isTrusted\")) {\n      this.isTrusted = src.isTrusted;\n    }\n\n    this.timeStamp = src.timeStamp || Date.now();\n  } else {\n    _extends(this, src);\n  }\n\n  addProperty(\"which\", calculateWhich, this);\n\n  if (0 === src.type.indexOf(\"touch\")) {\n    delete config.pageX;\n    delete config.pageY;\n  }\n\n  _extends(this, config);\n\n  this.guid = ++guid;\n}));\n\nfunction addProperty(propName, hook, eventInstance) {\n  Object.defineProperty(eventInstance || eventsEngine.Event.prototype, propName, {\n    enumerable: true,\n    configurable: true,\n    get: function get() {\n      return this.originalEvent && hook(this.originalEvent);\n    },\n    set: function set(value) {\n      Object.defineProperty(this, propName, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value: value\n      });\n    }\n  });\n}\n\nEVENT_PROPERTIES.forEach(function (prop) {\n  return addProperty(prop, function (event) {\n    return event[prop];\n  });\n});\nhookTouchProps(addProperty);\nvar beforeSetStrategy = Callbacks();\nvar afterSetStrategy = Callbacks();\n\neventsEngine.set = function (engine) {\n  beforeSetStrategy.fire();\n  eventsEngine.inject(engine);\n  initEvent(engine.Event);\n  afterSetStrategy.fire();\n};\n\neventsEngine.subscribeGlobal = function () {\n  applyForEach(arguments, normalizeOnArguments(function () {\n    var args = arguments;\n    eventsEngine.on.apply(this, args);\n    beforeSetStrategy.add(function () {\n      var offArgs = Array.prototype.slice.call(args, 0);\n      offArgs.splice(3, 1);\n      eventsEngine.off.apply(this, offArgs);\n    });\n    afterSetStrategy.add(function () {\n      eventsEngine.on.apply(this, args);\n    });\n  }));\n};\n\neventsEngine.forcePassiveFalseEventNames = forcePassiveFalseEventNames;\neventsEngine.passiveEventHandlersSupported = passiveEventHandlersSupported;\nexport default eventsEngine;","map":null,"metadata":{},"sourceType":"module"}