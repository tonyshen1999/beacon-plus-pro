{"ast":null,"code":"/**\r\n * DevExtreme (esm/viz/range_selector/range_selector.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport registerComponent from \"../../core/component_registrator\";\nimport { isDefined as _isDefined, isNumeric as _isNumber, isDate as _isDate, type as _type, isFunction, isPlainObject } from \"../../core/utils/type\";\nimport { extend } from \"../../core/utils/extend\";\nimport { each } from \"../../core/utils/iterator\";\nimport { patchFontOptions, normalizeEnum as _normalizeEnum, getVizRangeObject as parseValue, convertVisualRangeObject, getCategoriesInfo, getLog, rangesAreEqual } from \"../core/utils\";\nimport dateUtils from \"../../core/utils/date\";\nimport { adjust } from \"../../core/utils/math\";\nimport { Range } from \"../translators/range\";\nimport { Axis } from \"../axes/base_axis\";\nimport { correctValueType, getParser } from \"../components/parse_utils\";\nimport formatHelper from \"../../format_helper\";\nimport { consts, formatValue, HEIGHT_COMPACT_MODE } from \"./common\";\nimport { SlidersController } from \"./sliders_controller\";\nimport { Tracker } from \"./tracker\";\nimport { RangeView } from \"./range_view\";\nimport { SeriesDataSource } from \"./series_data_source\";\nimport { tickGenerator } from \"../axes/tick_generator\";\nimport constants from \"../axes/axes_constants\";\nimport baseWidgetModule from \"../core/base_widget\";\nvar _max = Math.max;\nvar _ceil = Math.ceil;\nvar _floor = Math.floor;\nvar START_VALUE = \"startValue\";\nvar END_VALUE = \"endValue\";\nvar DATETIME = \"datetime\";\nvar VALUE = \"value\";\nvar DISCRETE = \"discrete\";\nvar SEMIDISCRETE = \"semidiscrete\";\nvar STRING = \"string\";\nvar VALUE_CHANGED = VALUE + \"Changed\";\nvar CONTAINER_BACKGROUND_COLOR = \"containerBackgroundColor\";\nvar SLIDER_MARKER = \"sliderMarker\";\nvar OPTION_BACKGROUND = \"background\";\nvar LOGARITHMIC = \"logarithmic\";\nvar KEEP = \"keep\";\nvar SHIFT = \"shift\";\nvar RESET = \"reset\";\nvar INVISIBLE_POS = -1e3;\nvar SEMIDISCRETE_GRID_SPACING_FACTOR = 50;\nvar DEFAULT_AXIS_DIVISION_FACTOR = 30;\nvar DEFAULT_MINOR_AXIS_DIVISION_FACTOR = 15;\nvar logarithmBase = 10;\n\nfunction calculateMarkerHeight(renderer, value, sliderMarkerOptions) {\n  var formattedText = void 0 === value ? consts.emptySliderMarkerText : formatValue(value, sliderMarkerOptions);\n  var textBBox = getTextBBox(renderer, formattedText, sliderMarkerOptions.font);\n  return _ceil(textBBox.height) + 2 * sliderMarkerOptions.paddingTopBottom + consts.pointerSize;\n}\n\nfunction calculateScaleLabelHalfWidth(renderer, value, scaleOptions, tickIntervalsInfo) {\n  var formattedText = formatValue(value, scaleOptions.label, tickIntervalsInfo, scaleOptions.valueType, scaleOptions.type, scaleOptions.logarithmBase);\n  var textBBox = getTextBBox(renderer, formattedText, scaleOptions.label.font);\n  return _ceil(textBBox.width / 2);\n}\n\nfunction calculateIndents(renderer, scale, sliderMarkerOptions, indentOptions, tickIntervalsInfo) {\n  var leftMarkerHeight;\n  var leftScaleLabelWidth = 0;\n  var rightScaleLabelWidth = 0;\n  var rightMarkerHeight;\n  var placeholderWidthLeft;\n  var placeholderWidthRight;\n  var placeholderHeight;\n  var ticks = \"semidiscrete\" === scale.type ? scale.customTicks : tickIntervalsInfo.ticks;\n  var startTickValue;\n  var endTickValue;\n  indentOptions = indentOptions || {};\n  placeholderWidthLeft = indentOptions.left;\n  placeholderWidthRight = indentOptions.right;\n  placeholderHeight = sliderMarkerOptions.placeholderHeight;\n\n  if (sliderMarkerOptions.visible) {\n    leftMarkerHeight = calculateMarkerHeight(renderer, scale.startValue, sliderMarkerOptions);\n    rightMarkerHeight = calculateMarkerHeight(renderer, scale.endValue, sliderMarkerOptions);\n\n    if (void 0 === placeholderHeight) {\n      placeholderHeight = _max(leftMarkerHeight, rightMarkerHeight);\n    }\n  }\n\n  if (scale.label.visible) {\n    startTickValue = _isDefined(scale.startValue) ? ticks[0] : void 0;\n    endTickValue = _isDefined(scale.endValue) ? ticks[ticks.length - 1] : void 0;\n    leftScaleLabelWidth = calculateScaleLabelHalfWidth(renderer, startTickValue, scale, tickIntervalsInfo);\n    rightScaleLabelWidth = calculateScaleLabelHalfWidth(renderer, endTickValue, scale, tickIntervalsInfo);\n  }\n\n  placeholderWidthLeft = void 0 !== placeholderWidthLeft ? placeholderWidthLeft : leftScaleLabelWidth;\n  placeholderWidthRight = (void 0 !== placeholderWidthRight ? placeholderWidthRight : rightScaleLabelWidth) || 1;\n  return {\n    left: placeholderWidthLeft,\n    right: placeholderWidthRight,\n    top: placeholderHeight || 0,\n    bottom: 0\n  };\n}\n\nfunction calculateValueType(firstValue, secondValue) {\n  var typeFirstValue = _type(firstValue);\n\n  var typeSecondValue = _type(secondValue);\n\n  var validType = function validType(type) {\n    return typeFirstValue === type || typeSecondValue === type;\n  };\n\n  return validType(\"date\") ? DATETIME : validType(\"number\") ? \"numeric\" : validType(STRING) ? STRING : \"\";\n}\n\nfunction showScaleMarkers(scaleOptions) {\n  return scaleOptions.valueType === DATETIME && scaleOptions.marker.visible;\n}\n\nfunction updateTranslatorRangeInterval(translatorRange, scaleOptions) {\n  var intervalX = scaleOptions.minorTickInterval || scaleOptions.tickInterval;\n\n  if (\"datetime\" === scaleOptions.valueType) {\n    intervalX = dateUtils.dateToMilliseconds(intervalX);\n  }\n\n  translatorRange.addRange({\n    interval: intervalX\n  });\n}\n\nfunction checkLogarithmicOptions(options, defaultLogarithmBase, incidentOccurred) {\n  if (!options) {\n    return;\n  }\n\n  var logarithmBase = options.logarithmBase;\n\n  if (options.type === LOGARITHMIC && logarithmBase <= 0 || logarithmBase && !_isNumber(logarithmBase)) {\n    options.logarithmBase = defaultLogarithmBase;\n    incidentOccurred(\"E2104\");\n  } else if (options.type !== LOGARITHMIC) {\n    options.logarithmBase = void 0;\n  }\n}\n\nfunction calculateScaleAreaHeight(renderer, scaleOptions, visibleMarkers, tickIntervalsInfo) {\n  var labelScaleOptions = scaleOptions.label;\n  var markerScaleOptions = scaleOptions.marker;\n  var placeholderHeight = scaleOptions.placeholderHeight;\n  var ticks = \"semidiscrete\" === scaleOptions.type ? scaleOptions.customTicks : tickIntervalsInfo.ticks;\n  var text = formatValue(ticks[0], labelScaleOptions);\n\n  if (placeholderHeight) {\n    return placeholderHeight;\n  } else {\n    return (labelScaleOptions.visible ? labelScaleOptions.topIndent + getTextBBox(renderer, text, labelScaleOptions.font).height : 0) + (visibleMarkers ? markerScaleOptions.topIndent + markerScaleOptions.separatorHeight : 0);\n  }\n}\n\nfunction getMinorTickIntervalUnit(tickInterval, minorTickInterval, withCorrection) {\n  var interval = dateUtils.getDateUnitInterval(minorTickInterval);\n  var majorUnit = dateUtils.getDateUnitInterval(tickInterval);\n  var idx = dateUtils.dateUnitIntervals.indexOf(interval);\n\n  if (withCorrection && interval === majorUnit && idx > 0) {\n    interval = dateUtils.dateUnitIntervals[idx - 1];\n  }\n\n  return interval;\n}\n\nfunction getNextTickInterval(tickInterval, minorTickInterval, isDateType) {\n  if (!tickInterval) {\n    tickInterval = minorTickInterval;\n  } else if (isDateType) {\n    tickInterval = dateUtils.getNextDateUnit(tickInterval);\n  } else {\n    tickInterval += minorTickInterval;\n  }\n\n  return tickInterval;\n}\n\nfunction calculateTickIntervalsForSemidiscreteScale(scaleOptions, min, max, screenDelta) {\n  var minorTickInterval = scaleOptions.minorTickInterval;\n  var tickInterval = scaleOptions.tickInterval;\n  var interval;\n  var isDateType = \"datetime\" === scaleOptions.valueType;\n  var gridSpacingFactor = scaleOptions.axisDivisionFactor || {};\n  var tickCountByInterval;\n  var tickCountByScreen;\n\n  if (!tickInterval) {\n    do {\n      interval = getNextTickInterval(tickInterval, minorTickInterval, isDateType);\n\n      if (tickInterval !== interval) {\n        tickInterval = interval;\n      } else {\n        break;\n      }\n\n      if (isDateType) {\n        interval = dateUtils.dateToMilliseconds(tickInterval);\n      }\n\n      tickCountByInterval = _ceil((max - min) / interval);\n      tickCountByScreen = _floor(screenDelta / (gridSpacingFactor[tickInterval] || SEMIDISCRETE_GRID_SPACING_FACTOR)) || 1;\n    } while (interval && tickCountByInterval > tickCountByScreen);\n  }\n\n  return {\n    tickInterval: tickInterval,\n    minorTickInterval: minorTickInterval,\n    bounds: {\n      minVisible: min,\n      maxVisible: max\n    },\n    ticks: []\n  };\n}\n\nfunction updateTickIntervals(scaleOptions, screenDelta, incidentOccurred, range) {\n  var result;\n  var min = _isDefined(range.minVisible) ? range.minVisible : range.min;\n  var max = _isDefined(range.maxVisible) ? range.maxVisible : range.max;\n  var categoriesInfo = scaleOptions._categoriesInfo;\n  var ticksInfo;\n  var length;\n  var bounds = {};\n\n  if (scaleOptions.type === SEMIDISCRETE) {\n    result = calculateTickIntervalsForSemidiscreteScale(scaleOptions, min, max, screenDelta);\n  } else {\n    ticksInfo = tickGenerator({\n      axisType: scaleOptions.type,\n      dataType: scaleOptions.valueType,\n      logBase: scaleOptions.logarithmBase,\n      allowNegatives: true,\n      linearThreshold: Math.abs(scaleOptions.linearThreshold || 0),\n      axisDivisionFactor: scaleOptions.axisDivisionFactor,\n      minorAxisDivisionFactor: scaleOptions.minorAxisDivisionFactor,\n      calculateMinors: true,\n      allowDecimals: scaleOptions.allowDecimals,\n      endOnTick: scaleOptions.endOnTick,\n      incidentOccurred: incidentOccurred,\n      rangeIsEmpty: range.isEmpty()\n    })({\n      min: min,\n      max: max,\n      categories: _isDefined(categoriesInfo) ? categoriesInfo.categories : []\n    }, screenDelta, scaleOptions.tickInterval, scaleOptions.forceUserTickInterval, void 0, scaleOptions.minorTickInterval, scaleOptions.minorTickCount);\n    length = ticksInfo.ticks.length;\n    bounds.minVisible = ticksInfo.ticks[0] < min ? ticksInfo.ticks[0] : min;\n    bounds.maxVisible = ticksInfo.ticks[length - 1] > max ? ticksInfo.ticks[length - 1] : max;\n    result = {\n      tickInterval: ticksInfo.tickInterval,\n      minorTickInterval: 0 === scaleOptions.minorTickInterval ? 0 : ticksInfo.minorTickInterval,\n      bounds: bounds,\n      ticks: ticksInfo.ticks\n    };\n  }\n\n  return result;\n}\n\nfunction getFirstDayOfWeek(options) {\n  var _options$workWeek;\n\n  return null === (_options$workWeek = options.workWeek) || void 0 === _options$workWeek ? void 0 : _options$workWeek[0];\n}\n\nfunction calculateTranslatorRange(seriesDataSource, scaleOptions) {\n  var minValue;\n  var maxValue;\n  var inverted = false;\n  var startValue = scaleOptions.startValue;\n  var endValue = scaleOptions.endValue;\n  var categories;\n  var categoriesInfo;\n  var translatorRange = seriesDataSource ? seriesDataSource.getBoundRange().arg : new Range();\n  var rangeForCategories;\n  var isDate = \"datetime\" === scaleOptions.valueType;\n  var firstDayOfWeek = getFirstDayOfWeek(scaleOptions);\n  var minRange = scaleOptions.minRange;\n\n  if (scaleOptions.type === DISCRETE) {\n    rangeForCategories = new Range({\n      minVisible: startValue,\n      maxVisible: endValue\n    });\n    rangeForCategories.addRange(translatorRange);\n    translatorRange = rangeForCategories;\n    categories = seriesDataSource ? seriesDataSource.argCategories : scaleOptions.categories || startValue && endValue && [startValue, endValue];\n    categories = categories || [];\n    scaleOptions._categoriesInfo = categoriesInfo = getCategoriesInfo(categories, startValue, endValue);\n  }\n\n  if (scaleOptions.type === SEMIDISCRETE) {\n    startValue = scaleOptions.startValue = correctValueByInterval(scaleOptions.startValue, isDate, minRange, firstDayOfWeek);\n    endValue = scaleOptions.endValue = correctValueByInterval(scaleOptions.endValue, isDate, minRange, firstDayOfWeek);\n    translatorRange.minVisible = correctValueByInterval(translatorRange.minVisible, isDate, minRange, firstDayOfWeek);\n    translatorRange.maxVisible = correctValueByInterval(translatorRange.maxVisible, isDate, minRange, firstDayOfWeek);\n    translatorRange.min = correctValueByInterval(translatorRange.min, isDate, minRange, firstDayOfWeek);\n    translatorRange.max = correctValueByInterval(translatorRange.max, isDate, minRange, firstDayOfWeek);\n  }\n\n  if (_isDefined(startValue) && _isDefined(endValue)) {\n    inverted = categoriesInfo ? categoriesInfo.inverted : startValue > endValue;\n    minValue = categoriesInfo ? categoriesInfo.start : inverted ? endValue : startValue;\n    maxValue = categoriesInfo ? categoriesInfo.end : inverted ? startValue : endValue;\n  } else if (_isDefined(startValue) || _isDefined(endValue)) {\n    minValue = startValue;\n    maxValue = endValue;\n  } else if (categoriesInfo) {\n    minValue = categoriesInfo.start;\n    maxValue = categoriesInfo.end;\n  }\n\n  translatorRange.addRange({\n    invert: inverted,\n    min: minValue,\n    max: maxValue,\n    minVisible: minValue,\n    maxVisible: maxValue,\n    dataType: scaleOptions.valueType\n  });\n  translatorRange.addRange({\n    categories: !seriesDataSource ? categories : void 0,\n    base: scaleOptions.logarithmBase,\n    axisType: scaleOptions.type,\n    dataType: scaleOptions.valueType\n  });\n  seriesDataSource && translatorRange.sortCategories(categories);\n  return translatorRange;\n}\n\nfunction startEndNotDefined(start, end) {\n  return !_isDefined(start) || !_isDefined(end);\n}\n\nfunction getTextBBox(renderer, text, fontOptions) {\n  var textElement = renderer.text(text, INVISIBLE_POS, INVISIBLE_POS).css(patchFontOptions(fontOptions)).append(renderer.root);\n  var textBBox = textElement.getBBox();\n  textElement.remove();\n  return textBBox;\n}\n\nfunction getDateMarkerVisibilityChecker(screenDelta) {\n  return function (isDateScale, isMarkerVisible, min, max, tickInterval) {\n    if (isMarkerVisible && isDateScale) {\n      if (!_isDefined(tickInterval) || tickInterval.years || tickInterval.months >= 6 || screenDelta / SEMIDISCRETE_GRID_SPACING_FACTOR < _ceil((max - min) / dateUtils.dateToMilliseconds(\"year\")) + 1) {\n        isMarkerVisible = false;\n      }\n    }\n\n    return isMarkerVisible;\n  };\n}\n\nfunction updateScaleOptions(scaleOptions, seriesDataSource, translatorRange, tickIntervalsInfo, checkDateMarkerVisibility) {\n  var bounds;\n  var isEmptyInterval;\n  var categoriesInfo = scaleOptions._categoriesInfo;\n  var intervals;\n  var isDateTime = scaleOptions.valueType === DATETIME;\n\n  if (seriesDataSource && !seriesDataSource.isEmpty() && !translatorRange.isEmpty()) {\n    bounds = tickIntervalsInfo.bounds;\n    translatorRange.addRange(bounds);\n    scaleOptions.startValue = translatorRange.invert ? bounds.maxVisible : bounds.minVisible;\n    scaleOptions.endValue = translatorRange.invert ? bounds.minVisible : bounds.maxVisible;\n  }\n\n  scaleOptions.marker.visible = checkDateMarkerVisibility(isDateTime && -1 === scaleOptions.type.indexOf(DISCRETE), scaleOptions.marker.visible, scaleOptions.startValue, scaleOptions.endValue, tickIntervalsInfo.tickInterval);\n\n  if (categoriesInfo) {\n    scaleOptions.startValue = categoriesInfo.start;\n    scaleOptions.endValue = categoriesInfo.end;\n  }\n\n  if (-1 === scaleOptions.type.indexOf(DISCRETE)) {\n    isEmptyInterval = _isDate(scaleOptions.startValue) && _isDate(scaleOptions.endValue) && scaleOptions.startValue.getTime() === scaleOptions.endValue.getTime() || scaleOptions.startValue === scaleOptions.endValue;\n  }\n\n  scaleOptions.isEmpty = startEndNotDefined(scaleOptions.startValue, scaleOptions.endValue) || isEmptyInterval;\n\n  if (scaleOptions.isEmpty) {\n    scaleOptions.startValue = scaleOptions.endValue = void 0;\n  } else {\n    scaleOptions.minorTickInterval = tickIntervalsInfo.minorTickInterval;\n    scaleOptions.tickInterval = tickIntervalsInfo.tickInterval;\n\n    if (isDateTime && (!_isDefined(scaleOptions.label.format) || scaleOptions.type === SEMIDISCRETE && scaleOptions.minorTickInterval !== scaleOptions.tickInterval)) {\n      if (scaleOptions.type === DISCRETE) {\n        scaleOptions.label.format = formatHelper.getDateFormatByTicks(tickIntervalsInfo.ticks);\n      } else if (!scaleOptions.marker.visible) {\n        scaleOptions.label.format = formatHelper.getDateFormatByTickInterval(scaleOptions.startValue, scaleOptions.endValue, scaleOptions.tickInterval);\n      } else {\n        scaleOptions.label.format = dateUtils.getDateFormatByTickInterval(scaleOptions.tickInterval);\n      }\n    }\n  }\n\n  if (scaleOptions.type === SEMIDISCRETE) {\n    intervals = getIntervalCustomTicks(scaleOptions);\n    scaleOptions.customMinorTicks = intervals.altIntervals;\n    scaleOptions.customTicks = intervals.intervals;\n    scaleOptions.customBoundTicks = [scaleOptions.customTicks[0]];\n  }\n}\n\nfunction prepareScaleOptions(scaleOption, calculatedValueType, incidentOccurred, containerColor) {\n  var parsedValue = 0;\n  var valueType = correctValueType(_normalizeEnum(scaleOption.valueType));\n\n  var validateStartEndValues = function validateStartEndValues(field, parser) {\n    var messageToIncidentOccurred = field === START_VALUE ? \"start\" : \"end\";\n\n    if (_isDefined(scaleOption[field])) {\n      parsedValue = parser(scaleOption[field]);\n\n      if (_isDefined(parsedValue)) {\n        scaleOption[field] = parsedValue;\n      } else {\n        scaleOption[field] = void 0;\n        incidentOccurred(\"E2202\", [messageToIncidentOccurred]);\n      }\n    }\n  };\n\n  valueType = calculatedValueType || valueType;\n\n  if (!valueType) {\n    valueType = calculateValueType(scaleOption.startValue, scaleOption.endValue) || \"numeric\";\n  }\n\n  if (valueType === STRING || scaleOption.categories) {\n    scaleOption.type = DISCRETE;\n    valueType = STRING;\n  }\n\n  scaleOption.containerColor = containerColor;\n  scaleOption.valueType = valueType;\n  scaleOption.dataType = valueType;\n  var parser = getParser(valueType);\n  validateStartEndValues(START_VALUE, parser);\n  validateStartEndValues(END_VALUE, parser);\n  checkLogarithmicOptions(scaleOption, logarithmBase, incidentOccurred);\n\n  if (!scaleOption.type) {\n    scaleOption.type = \"continuous\";\n  }\n\n  scaleOption.parser = parser;\n\n  if (scaleOption.type === SEMIDISCRETE) {\n    scaleOption.minorTick.visible = false;\n    scaleOption.minorTickInterval = scaleOption.minRange;\n    scaleOption.marker.visible = false;\n    scaleOption.maxRange = void 0;\n  }\n\n  scaleOption.forceUserTickInterval |= _isDefined(scaleOption.tickInterval) && !_isDefined(scaleOption.axisDivisionFactor);\n  scaleOption.axisDivisionFactor = _isDefined(scaleOption.axisDivisionFactor) ? scaleOption.axisDivisionFactor : DEFAULT_AXIS_DIVISION_FACTOR;\n  scaleOption.minorAxisDivisionFactor = _isDefined(scaleOption.minorAxisDivisionFactor) ? scaleOption.minorAxisDivisionFactor : DEFAULT_MINOR_AXIS_DIVISION_FACTOR;\n  return scaleOption;\n}\n\nfunction correctValueByInterval(value, isDate, interval, firstDayOfWeek) {\n  if (_isDefined(value)) {\n    value = isDate ? dateUtils.correctDateWithUnitBeginning(new Date(value), interval, null, firstDayOfWeek) : adjust(_floor(adjust(value / interval)) * interval);\n  }\n\n  return value;\n}\n\nfunction getIntervalCustomTicks(options) {\n  var min = options.startValue;\n  var max = options.endValue;\n  var isDate = \"datetime\" === options.valueType;\n  var firstDayOfWeek = getFirstDayOfWeek(options);\n  var tickInterval = options.tickInterval;\n  var res = {\n    intervals: []\n  };\n\n  if (!_isDefined(min) || !_isDefined(max)) {\n    return res;\n  }\n\n  res.intervals = dateUtils.getSequenceByInterval(min, max, options.minorTickInterval);\n\n  if (tickInterval !== options.minorTickInterval) {\n    res.altIntervals = res.intervals;\n    min = correctValueByInterval(min, isDate, tickInterval, firstDayOfWeek);\n    max = correctValueByInterval(max, isDate, tickInterval, firstDayOfWeek);\n    res.intervals = dateUtils.getSequenceByInterval(min, max, tickInterval);\n    res.intervals[0] = res.altIntervals[0];\n  }\n\n  return res;\n}\n\nfunction getPrecisionForSlider(startValue, endValue, screenDelta) {\n  var d = Math.abs(endValue - startValue) / screenDelta;\n\n  var tail = d - _floor(d);\n\n  return tail > 0 ? _ceil(Math.abs(adjust(getLog(tail, 10)))) : 0;\n}\n\nvar dxRangeSelector = baseWidgetModule.inherit({\n  _toggleParentsScrollSubscription: function _toggleParentsScrollSubscription() {},\n  _eventsMap: {\n    onValueChanged: {\n      name: VALUE_CHANGED\n    }\n  },\n  _rootClassPrefix: \"dxrs\",\n  _rootClass: \"dxrs-range-selector\",\n  _dataIsReady: function _dataIsReady() {\n    return this._dataIsLoaded();\n  },\n  _initialChanges: [\"DATA_SOURCE\", \"VALUE\"],\n  _themeDependentChanges: [\"MOSTLY_TOTAL\"],\n  _themeSection: \"rangeSelector\",\n  _fontFields: [\"scale.label.font\", \"sliderMarker.font\"],\n  _initCore: function _initCore() {\n    var that = this;\n    var renderer = that._renderer;\n    var root = renderer.root;\n    root.css({\n      \"touch-action\": \"pan-y\"\n    });\n    that._clipRect = renderer.clipRect();\n    var rangeViewGroup = renderer.g().attr({\n      class: \"dxrs-view\"\n    }).append(root);\n    var slidersGroup = renderer.g().attr({\n      class: \"dxrs-slidersContainer\",\n      \"clip-path\": that._clipRect.id\n    }).append(root);\n    var scaleGroup = renderer.g().attr({\n      class: \"dxrs-scale\",\n      \"clip-path\": that._clipRect.id\n    }).append(root);\n    var labelsAxesGroup = renderer.g().attr({\n      class: \"dxrs-scale-elements\",\n      \"clip-path\": that._clipRect.id\n    }).append(root);\n    var scaleBreaksGroup = renderer.g().attr({\n      class: \"dxrs-scale-breaks\"\n    }).append(root);\n    var trackersGroup = renderer.g().attr({\n      class: \"dxrs-trackers\"\n    }).append(root);\n    that._axis = new AxisWrapper({\n      renderer: renderer,\n      root: scaleGroup,\n      scaleBreaksGroup: scaleBreaksGroup,\n      labelsAxesGroup: labelsAxesGroup,\n      updateSelectedRange: function updateSelectedRange(range, e) {\n        that.setValue(convertVisualRangeObject(range), e);\n      },\n      incidentOccurred: that._incidentOccurred\n    });\n    that._rangeView = new RangeView({\n      renderer: renderer,\n      root: rangeViewGroup,\n      translator: that._axis.getTranslator()\n    });\n    that._slidersController = new SlidersController({\n      renderer: renderer,\n      root: slidersGroup,\n      trackersGroup: trackersGroup,\n      updateSelectedRange: function updateSelectedRange(range, lastSelectedRange, e) {\n        if (!that._rangeOption) {\n          that.option(VALUE, convertVisualRangeObject(range, isPlainObject(that._options.silent(VALUE))));\n        }\n\n        that._eventTrigger(VALUE_CHANGED, {\n          value: convertVisualRangeObject(range),\n          previousValue: convertVisualRangeObject(lastSelectedRange),\n          event: e\n        });\n      },\n      axis: that._axis,\n      translator: that._axis.getTranslator()\n    });\n    that._tracker = new Tracker({\n      renderer: renderer,\n      controller: that._slidersController\n    });\n  },\n  _getDefaultSize: function _getDefaultSize() {\n    return {\n      width: 400,\n      height: 160\n    };\n  },\n  _disposeCore: function _disposeCore() {\n    this._axis.dispose();\n\n    this._slidersController.dispose();\n\n    this._tracker.dispose();\n  },\n  _applySize: function _applySize(rect) {\n    this._clientRect = rect.slice();\n\n    this._change([\"MOSTLY_TOTAL\"]);\n  },\n  _optionChangesMap: {\n    scale: \"SCALE\",\n    value: \"VALUE\",\n    dataSource: \"DATA_SOURCE\"\n  },\n  _optionChangesOrder: [\"SCALE\", \"DATA_SOURCE\"],\n  _change_SCALE: function _change_SCALE() {\n    this._change([\"MOSTLY_TOTAL\"]);\n  },\n  _setValueByDataSource: function _setValueByDataSource() {\n    var options = this._options.silent();\n\n    var axis = this._axis;\n\n    if (options.dataSource) {\n      var selectedRangeUpdateMode = this.option(\"selectedRangeUpdateMode\");\n      var value = this.getValue();\n\n      var valueIsReady = _isDefined(value[0]) && _isDefined(value[1]);\n\n      if (_isDefined(selectedRangeUpdateMode)) {\n        selectedRangeUpdateMode = _normalizeEnum(selectedRangeUpdateMode);\n        this.__skipAnimation = true;\n      } else if (valueIsReady && !this._dataSourceIsAsync) {\n        selectedRangeUpdateMode = RESET;\n      }\n\n      if (\"auto\" === selectedRangeUpdateMode && valueIsReady) {\n        var rangesInfo = axis.allScaleSelected(value);\n\n        if (rangesInfo.startValue && rangesInfo.endValue) {\n          selectedRangeUpdateMode = RESET;\n        } else if (rangesInfo.endValue) {\n          selectedRangeUpdateMode = SHIFT;\n        } else {\n          selectedRangeUpdateMode = KEEP;\n        }\n      }\n\n      if (selectedRangeUpdateMode === RESET) {\n        options[VALUE] = null;\n      } else if (selectedRangeUpdateMode === SHIFT && valueIsReady) {\n        var _value = this.getValue();\n\n        this.__skipAnimation = true;\n        options[VALUE] = {\n          length: axis.getVisualRangeLength({\n            minVisible: _value[0],\n            maxVisible: _value[1]\n          })\n        };\n      } else if (selectedRangeUpdateMode === KEEP) {\n        this.__skipAnimation = true;\n      }\n    }\n\n    this._dataSourceIsAsync = void 0;\n  },\n  _change_DATA_SOURCE: function _change_DATA_SOURCE() {\n    if (this._options.silent(\"dataSource\")) {\n      this._updateDataSource();\n    }\n  },\n  _customChangesOrder: [\"MOSTLY_TOTAL\", \"VALUE\", \"SLIDER_SELECTION\"],\n  _change_MOSTLY_TOTAL: function _change_MOSTLY_TOTAL() {\n    this._applyMostlyTotalChange();\n  },\n  _change_SLIDER_SELECTION: function _change_SLIDER_SELECTION() {\n    var value = this._options.silent(VALUE);\n\n    this._slidersController.setSelectedRange(value && parseValue(value));\n  },\n  _change_VALUE: function _change_VALUE() {\n    var option = this._rangeOption;\n    this._dataSourceIsAsync = !this._dataIsReady();\n\n    if (option) {\n      this._options.silent(VALUE, option);\n\n      this.setValue(option);\n    }\n  },\n  _validateRange: function _validateRange(start, end) {\n    var translator = this._axis.getTranslator();\n\n    if (_isDefined(start) && !translator.isValid(start) || _isDefined(end) && !translator.isValid(end)) {\n      this._incidentOccurred(\"E2203\");\n    }\n  },\n  _applyChanges: function _applyChanges() {\n    var that = this;\n\n    var value = that._options.silent(VALUE);\n\n    if (that._changes.has(\"VALUE\") && value) {\n      that._rangeOption = value;\n    }\n\n    that.callBase.apply(that, arguments);\n    that._rangeOption = null;\n    that.__isResizing = that.__skipAnimation = false;\n  },\n  _applyMostlyTotalChange: function _applyMostlyTotalChange() {\n    var renderer = this._renderer;\n    var rect = this._clientRect;\n    var currentAnimationEnabled;\n    var canvas = {\n      left: rect[0],\n      top: rect[1],\n      width: rect[2] - rect[0],\n      height: rect[3] - rect[1]\n    };\n\n    if (this.__isResizing || this.__skipAnimation) {\n      currentAnimationEnabled = renderer.animationEnabled();\n      renderer.updateAnimationOptions({\n        enabled: false\n      });\n    }\n\n    this._clipRect.attr({\n      x: rect[0],\n      y: rect[1],\n      width: rect[2] - rect[0],\n      height: rect[3] - rect[1]\n    });\n\n    this._axis.getTranslator().update(new Range(), canvas, {\n      isHorizontal: true\n    });\n\n    this._updateContent({\n      left: rect[0],\n      top: rect[1],\n      width: rect[2] - rect[0],\n      height: rect[3] - rect[1]\n    });\n\n    if (this.__isResizing || this.__skipAnimation) {\n      renderer.updateAnimationOptions({\n        enabled: currentAnimationEnabled\n      });\n    }\n\n    this._drawn();\n  },\n  _dataSourceChangedHandler: function _dataSourceChangedHandler() {\n    this._setValueByDataSource();\n\n    this._requestChange([\"MOSTLY_TOTAL\"]);\n  },\n  _completeSeriesDataSourceCreation: function _completeSeriesDataSourceCreation(scaleOptions, seriesDataSource) {\n    var rect = this._clientRect;\n    var canvas = {\n      left: rect[0],\n      top: rect[1],\n      width: rect[2] - rect[0],\n      height: rect[3] - rect[1]\n    };\n\n    this._axis.updateOptions(extend({}, scaleOptions, {\n      isHorizontal: true,\n      label: {}\n    }));\n\n    seriesDataSource.isShowChart() && this._axis.setMarginOptions(seriesDataSource.getMarginOptions(canvas));\n\n    this._axis.updateCanvas(canvas);\n\n    seriesDataSource.createPoints();\n  },\n  _updateContent: function _updateContent(canvas) {\n    var chartOptions = this.option(\"chart\");\n\n    var seriesDataSource = this._createSeriesDataSource(chartOptions);\n\n    var isCompactMode = !(seriesDataSource && seriesDataSource.isShowChart() || this.option(\"background.image.url\"));\n    var scaleOptions = prepareScaleOptions(this._getOption(\"scale\"), seriesDataSource && seriesDataSource.getCalculatedValueType(), this._incidentOccurred, this._getOption(\"containerBackgroundColor\", true));\n    seriesDataSource && this._completeSeriesDataSourceCreation(scaleOptions, seriesDataSource);\n    var argTranslatorRange = calculateTranslatorRange(seriesDataSource, scaleOptions);\n    var tickIntervalsInfo = updateTickIntervals(scaleOptions, canvas.width, this._incidentOccurred, argTranslatorRange);\n    var chartThemeManager = seriesDataSource && seriesDataSource.isShowChart() && seriesDataSource.getThemeManager();\n\n    if (chartThemeManager) {\n      checkLogarithmicOptions(chartOptions && chartOptions.valueAxis, chartThemeManager.getOptions(\"valueAxis\").logarithmBase, this._incidentOccurred);\n    }\n\n    updateScaleOptions(scaleOptions, seriesDataSource, argTranslatorRange, tickIntervalsInfo, getDateMarkerVisibilityChecker(canvas.width));\n    updateTranslatorRangeInterval(argTranslatorRange, scaleOptions);\n\n    var sliderMarkerOptions = this._prepareSliderMarkersOptions(scaleOptions, canvas.width, tickIntervalsInfo, argTranslatorRange);\n\n    var indents = calculateIndents(this._renderer, scaleOptions, sliderMarkerOptions, this.option(\"indent\"), tickIntervalsInfo);\n    var rangeContainerCanvas = {\n      left: canvas.left + indents.left,\n      top: canvas.top + indents.top,\n      width: canvas.left + indents.left + _max(canvas.width - indents.left - indents.right, 1),\n      height: _max(!isCompactMode ? canvas.height - indents.top - indents.bottom - calculateScaleAreaHeight(this._renderer, scaleOptions, showScaleMarkers(scaleOptions), tickIntervalsInfo) : HEIGHT_COMPACT_MODE, 0),\n      right: 0,\n      bottom: 0\n    };\n\n    this._axis.update(scaleOptions, isCompactMode, rangeContainerCanvas, argTranslatorRange, seriesDataSource);\n\n    scaleOptions.minorTickInterval = scaleOptions.isEmpty ? 0 : scaleOptions.minorTickInterval;\n\n    this._updateElements(scaleOptions, sliderMarkerOptions, isCompactMode, rangeContainerCanvas, seriesDataSource);\n\n    if (chartThemeManager) {\n      chartThemeManager.dispose();\n    }\n  },\n  _updateElements: function _updateElements(scaleOptions, sliderMarkerOptions, isCompactMode, canvas, seriesDataSource) {\n    var behavior = this._getOption(\"behavior\");\n\n    var shutterOptions = this._getOption(\"shutter\");\n\n    var isNotSemiDiscrete = scaleOptions.type !== SEMIDISCRETE;\n    shutterOptions.color = shutterOptions.color || this._getOption(CONTAINER_BACKGROUND_COLOR, true);\n\n    this._rangeView.update(this.option(\"background\"), this._themeManager.theme(\"background\"), canvas, isCompactMode, behavior.animationEnabled && this._renderer.animationEnabled(), seriesDataSource);\n\n    this._isUpdating = true;\n\n    this._slidersController.update([canvas.top, canvas.top + canvas.height], behavior, isCompactMode, this._getOption(\"sliderHandle\"), sliderMarkerOptions, shutterOptions, {\n      minRange: isNotSemiDiscrete ? this.option(\"scale.minRange\") : void 0,\n      maxRange: isNotSemiDiscrete ? this.option(\"scale.maxRange\") : void 0\n    }, this._axis.getFullTicks(), this._getOption(\"selectedRangeColor\", true));\n\n    this._requestChange([\"SLIDER_SELECTION\"]);\n\n    this._isUpdating = false;\n\n    this._tracker.update(!this._axis.getTranslator().getBusinessRange().isEmpty(), behavior);\n  },\n  _createSeriesDataSource: function _createSeriesDataSource(chartOptions) {\n    var seriesDataSource;\n\n    var dataSource = this._dataSourceItems();\n\n    var scaleOptions = this._getOption(\"scale\");\n\n    var valueType = scaleOptions.valueType || calculateValueType(scaleOptions.startValue, scaleOptions.endValue);\n    var valueAxis = new Axis({\n      renderer: this._renderer,\n      axisType: \"xyAxes\",\n      drawingType: \"linear\"\n    });\n    valueAxis.updateOptions({\n      isHorizontal: false,\n      label: {},\n      categoriesSortingMethod: this._getOption(\"chart\").valueAxis.categoriesSortingMethod\n    });\n\n    if (dataSource || chartOptions && chartOptions.series) {\n      chartOptions = extend({}, chartOptions, {\n        theme: this.option(\"theme\")\n      });\n      seriesDataSource = new SeriesDataSource({\n        renderer: this._renderer,\n        dataSource: dataSource,\n        valueType: _normalizeEnum(valueType),\n        axisType: scaleOptions.type,\n        chart: chartOptions,\n        dataSourceField: this.option(\"dataSourceField\"),\n        incidentOccurred: this._incidentOccurred,\n        categories: scaleOptions.categories,\n        argumentAxis: this._axis,\n        valueAxis: valueAxis\n      });\n    }\n\n    return seriesDataSource;\n  },\n  _prepareSliderMarkersOptions: function _prepareSliderMarkersOptions(scaleOptions, screenDelta, tickIntervalsInfo, argRange) {\n    var minorTickInterval = tickIntervalsInfo.minorTickInterval;\n    var tickInterval = tickIntervalsInfo.tickInterval;\n    var interval = tickInterval;\n    var endValue = scaleOptions.endValue;\n    var startValue = scaleOptions.startValue;\n\n    var sliderMarkerOptions = this._getOption(SLIDER_MARKER);\n\n    var doNotSnap = !this._getOption(\"behavior\").snapToTicks;\n    var isTypeDiscrete = scaleOptions.type === DISCRETE;\n    var isValueTypeDatetime = scaleOptions.valueType === DATETIME;\n    sliderMarkerOptions.borderColor = this._getOption(CONTAINER_BACKGROUND_COLOR, true);\n\n    if (!sliderMarkerOptions.format && !argRange.isEmpty()) {\n      if (doNotSnap && _isNumber(scaleOptions.startValue)) {\n        sliderMarkerOptions.format = {\n          type: \"fixedPoint\",\n          precision: getPrecisionForSlider(startValue, endValue, screenDelta)\n        };\n      }\n\n      if (isValueTypeDatetime && !isTypeDiscrete) {\n        if (_isDefined(minorTickInterval) && 0 !== minorTickInterval) {\n          interval = getMinorTickIntervalUnit(tickInterval, minorTickInterval, doNotSnap);\n        }\n\n        if (!scaleOptions.marker.visible) {\n          if (_isDefined(startValue) && _isDefined(endValue)) {\n            sliderMarkerOptions.format = formatHelper.getDateFormatByTickInterval(startValue, endValue, interval);\n          }\n        } else {\n          sliderMarkerOptions.format = dateUtils.getDateFormatByTickInterval(interval);\n        }\n      }\n\n      if (isValueTypeDatetime && isTypeDiscrete && tickIntervalsInfo.ticks.length) {\n        sliderMarkerOptions.format = formatHelper.getDateFormatByTicks(tickIntervalsInfo.ticks);\n      }\n    }\n\n    return sliderMarkerOptions;\n  },\n  getValue: function getValue() {\n    return convertVisualRangeObject(this._slidersController.getSelectedRange());\n  },\n  setValue: function setValue(value, e) {\n    var visualRange = parseValue(value);\n\n    if (!this._isUpdating && value) {\n      this._validateRange(visualRange.startValue, visualRange.endValue);\n\n      !rangesAreEqual(visualRange, this._slidersController.getSelectedRange()) && this._slidersController.setSelectedRange(visualRange, e);\n    }\n  },\n  _setContentSize: function _setContentSize() {\n    this.__isResizing = 2 === this._changes.count();\n    this.callBase.apply(this, arguments);\n  }\n});\neach([\"selectedRangeColor\", \"containerBackgroundColor\", \"sliderMarker\", \"sliderHandle\", \"shutter\", OPTION_BACKGROUND, \"behavior\", \"chart\", \"indent\"], function (_, name) {\n  dxRangeSelector.prototype._optionChangesMap[name] = \"MOSTLY_TOTAL\";\n});\n\nfunction prepareAxisOptions(scaleOptions, isCompactMode, height, axisPosition) {\n  scaleOptions.marker.label.font = scaleOptions.label.font;\n  scaleOptions.color = scaleOptions.marker.color = scaleOptions.tick.color;\n  scaleOptions.opacity = scaleOptions.marker.opacity = scaleOptions.tick.opacity;\n  scaleOptions.width = scaleOptions.marker.width = scaleOptions.tick.width;\n  scaleOptions.placeholderSize = (scaleOptions.placeholderHeight || 0) + axisPosition;\n  scaleOptions.argumentType = scaleOptions.valueType;\n  scaleOptions.visible = isCompactMode;\n  scaleOptions.isHorizontal = true;\n  scaleOptions.calculateMinors = true;\n  scaleOptions.semiDiscreteInterval = scaleOptions.minRange;\n\n  if (!isCompactMode) {\n    scaleOptions.minorTick.length = scaleOptions.tick.length = height;\n  }\n\n  scaleOptions.label.indentFromAxis = scaleOptions.label.topIndent + axisPosition;\n  return scaleOptions;\n}\n\nfunction createDateMarkersEvent(scaleOptions, markerTrackers, setSelectedRange) {\n  each(markerTrackers, function (_, value) {\n    value.on(\"dxpointerdown\", onPointerDown);\n  });\n\n  function onPointerDown(e) {\n    var range = e.target.range;\n    var minRange = scaleOptions.minRange ? dateUtils.addInterval(range.startValue, scaleOptions.minRange) : void 0;\n    var maxRange = scaleOptions.maxRange ? dateUtils.addInterval(range.startValue, scaleOptions.maxRange) : void 0;\n\n    if (!(minRange && minRange > range.endValue || maxRange && maxRange < range.endValue)) {\n      setSelectedRange(range, e);\n    }\n  }\n}\n\nfunction getSharpDirection() {\n  return 1;\n}\n\nfunction getTickStartPositionShift(length) {\n  return length % 2 === 1 ? -_floor(length / 2) : -length / 2;\n}\n\nfunction checkShiftedLabels(majorTicks, boxes, minSpacing, alignment) {\n  function checkLabelsOverlapping(nearestLabelsIndexes) {\n    if (2 === nearestLabelsIndexes.length && constants.areLabelsOverlap(boxes[nearestLabelsIndexes[0]], boxes[nearestLabelsIndexes[1]], minSpacing, alignment)) {\n      majorTicks[nearestLabelsIndexes[0]].removeLabel();\n    }\n  }\n\n  function getTwoVisibleLabels(startIndex) {\n    var labels = [];\n\n    for (var i = startIndex; labels.length < 2 && i < majorTicks.length; i++) {\n      majorTicks[i].label && labels.push(i);\n    }\n\n    return labels;\n  }\n\n  if (majorTicks.length < 3) {\n    return;\n  }\n\n  checkLabelsOverlapping(getTwoVisibleLabels(0));\n  checkLabelsOverlapping(getTwoVisibleLabels(majorTicks.length - 2).reverse());\n}\n\nfunction AxisWrapper(params) {\n  this._axis = new Axis({\n    renderer: params.renderer,\n    axesContainerGroup: params.root,\n    scaleBreaksGroup: params.scaleBreaksGroup,\n    labelsAxesGroup: params.labelsAxesGroup,\n    incidentOccurred: params.incidentOccurred,\n    axisType: \"xyAxes\",\n    drawingType: \"linear\",\n    widgetClass: \"dxrs\",\n    axisClass: \"range-selector\",\n    isArgumentAxis: true,\n    getTemplate: function getTemplate() {}\n  });\n  this._updateSelectedRangeCallback = params.updateSelectedRange;\n  this._axis.getAxisSharpDirection = this._axis.getSharpDirectionByCoords = getSharpDirection;\n  this._axis.getTickStartPositionShift = getTickStartPositionShift;\n  this._axis._checkShiftedLabels = checkShiftedLabels;\n}\n\nAxisWrapper.prototype = {\n  constructor: AxisWrapper,\n  update: function update(options, isCompactMode, canvas, businessRange, seriesDataSource) {\n    var axis = this._axis;\n    axis.updateOptions(prepareAxisOptions(options, isCompactMode, canvas.height, canvas.height / 2 - _ceil(options.width / 2)));\n    axis.validate();\n    axis.setBusinessRange(businessRange, true);\n\n    if (void 0 !== seriesDataSource && seriesDataSource.isShowChart()) {\n      axis.setMarginOptions(seriesDataSource.getMarginOptions(canvas));\n    }\n\n    axis.draw(canvas);\n    axis.shift({\n      left: 0,\n      bottom: -canvas.height / 2 + canvas.top\n    });\n\n    if (axis.getMarkerTrackers()) {\n      createDateMarkersEvent(options, axis.getMarkerTrackers(), this._updateSelectedRangeCallback);\n    }\n\n    axis.drawScaleBreaks({\n      start: canvas.top,\n      end: canvas.top + canvas.height\n    });\n  },\n  visualRange: function visualRange() {},\n  getViewport: function getViewport() {\n    return {};\n  },\n  allScaleSelected: function allScaleSelected(value) {\n    var _this$_axis$visualRan = this._axis.visualRange(),\n        startValue = _this$_axis$visualRan.startValue,\n        endValue = _this$_axis$visualRan.endValue;\n\n    return {\n      startValue: value[0].valueOf() === startValue.valueOf(),\n      endValue: value[1].valueOf() === endValue.valueOf()\n    };\n  },\n  getOptions: function getOptions() {\n    return this._axis.getOptions() || {};\n  }\n};\neach(Axis.prototype, function (field) {\n  if (\"constructor\" !== field && \"_\" !== field[0] && isFunction(Axis.prototype[field]) && !(field in AxisWrapper.prototype)) {\n    AxisWrapper.prototype[field] = function () {\n      var axis = this._axis;\n      return axis[field].apply(axis, arguments);\n    };\n  }\n});\nregisterComponent(\"dxRangeSelector\", dxRangeSelector);\nexport default dxRangeSelector;\nimport { plugin as exportPlugin } from \"../core/export\";\nimport { plugin as titlePlugin } from \"../core/title\";\nimport { plugin as LoadingIndicatorPlugin } from \"../core/loading_indicator\";\nimport { plugin as dataSourcePlugin } from \"../core/data_source\";\ndxRangeSelector.addPlugin(exportPlugin);\ndxRangeSelector.addPlugin(titlePlugin);\ndxRangeSelector.addPlugin(LoadingIndicatorPlugin);\ndxRangeSelector.addPlugin(dataSourcePlugin);","map":null,"metadata":{},"sourceType":"module"}