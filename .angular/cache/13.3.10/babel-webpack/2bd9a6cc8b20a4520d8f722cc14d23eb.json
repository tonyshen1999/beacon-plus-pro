{"ast":null,"code":"/**\r\n * DevExtreme (esm/core/utils/data.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport errors from \"../errors\";\nimport Class from \"../class\";\nimport { deepExtendArraySafe } from \"./object\";\nimport { isObject, isPlainObject, isFunction, isDefined } from \"./type\";\nimport { each } from \"./iterator\";\nimport variableWrapper from \"./variable_wrapper\";\nvar unwrapVariable = variableWrapper.unwrap;\nvar isWrapped = variableWrapper.isWrapped;\nvar assign = variableWrapper.assign;\n\nvar bracketsToDots = function bracketsToDots(expr) {\n  return expr.replace(/\\[/g, \".\").replace(/\\]/g, \"\");\n};\n\nexport var getPathParts = function getPathParts(name) {\n  return bracketsToDots(name).split(\".\");\n};\n\nvar readPropValue = function readPropValue(obj, propName, options) {\n  options = options || {};\n\n  if (\"this\" === propName) {\n    return unwrap(obj, options);\n  }\n\n  return unwrap(obj[propName], options);\n};\n\nvar assignPropValue = function assignPropValue(obj, propName, value, options) {\n  if (\"this\" === propName) {\n    throw new errors.Error(\"E4016\");\n  }\n\n  var propValue = obj[propName];\n\n  if (options.unwrapObservables && isWrapped(propValue)) {\n    assign(propValue, value);\n  } else {\n    obj[propName] = value;\n  }\n};\n\nvar prepareOptions = function prepareOptions(options) {\n  options = options || {};\n  options.unwrapObservables = void 0 !== options.unwrapObservables ? options.unwrapObservables : true;\n  return options;\n};\n\nfunction unwrap(value, options) {\n  return options.unwrapObservables ? unwrapVariable(value) : value;\n}\n\nexport var compileGetter = function compileGetter(expr) {\n  if (arguments.length > 1) {\n    expr = [].slice.call(arguments);\n  }\n\n  if (!expr || \"this\" === expr) {\n    return function (obj) {\n      return obj;\n    };\n  }\n\n  if (\"string\" === typeof expr) {\n    var path = getPathParts(expr);\n    return function (obj, options) {\n      options = prepareOptions(options);\n      var functionAsIs = options.functionsAsIs;\n      var hasDefaultValue = (\"defaultValue\" in options);\n      var current = unwrap(obj, options);\n\n      for (var i = 0; i < path.length; i++) {\n        if (!current) {\n          if (null == current && hasDefaultValue) {\n            return options.defaultValue;\n          }\n\n          break;\n        }\n\n        var pathPart = path[i];\n\n        if (hasDefaultValue && isObject(current) && !(pathPart in current)) {\n          return options.defaultValue;\n        }\n\n        var next = unwrap(current[pathPart], options);\n\n        if (!functionAsIs && isFunction(next)) {\n          next = next.call(current);\n        }\n\n        current = next;\n      }\n\n      return current;\n    };\n  }\n\n  if (Array.isArray(expr)) {\n    return combineGetters(expr);\n  }\n\n  if (isFunction(expr)) {\n    return expr;\n  }\n};\n\nfunction combineGetters(getters) {\n  var compiledGetters = {};\n\n  for (var i = 0, l = getters.length; i < l; i++) {\n    var getter = getters[i];\n    compiledGetters[getter] = compileGetter(getter);\n  }\n\n  return function (obj, options) {\n    var result;\n    each(compiledGetters, function (name) {\n      var value = this(obj, options);\n\n      if (void 0 === value) {\n        return;\n      }\n\n      var current = result || (result = {});\n      var path = name.split(\".\");\n      var last = path.length - 1;\n\n      for (var _i = 0; _i < last; _i++) {\n        var pathItem = path[_i];\n\n        if (!(pathItem in current)) {\n          current[pathItem] = {};\n        }\n\n        current = current[pathItem];\n      }\n\n      current[path[last]] = value;\n    });\n    return result;\n  };\n}\n\nvar ensurePropValueDefined = function ensurePropValueDefined(obj, propName, value, options) {\n  if (isDefined(value)) {\n    return value;\n  }\n\n  var newValue = {};\n  assignPropValue(obj, propName, newValue, options);\n  return newValue;\n};\n\nexport var compileSetter = function compileSetter(expr) {\n  expr = getPathParts(expr || \"this\");\n  var lastLevelIndex = expr.length - 1;\n  return function (obj, value, options) {\n    options = prepareOptions(options);\n    var currentValue = unwrap(obj, options);\n    expr.forEach(function (propertyName, levelIndex) {\n      var propertyValue = readPropValue(currentValue, propertyName, options);\n      var isPropertyFunc = !options.functionsAsIs && isFunction(propertyValue) && !isWrapped(propertyValue);\n\n      if (levelIndex === lastLevelIndex) {\n        if (options.merge && isPlainObject(value) && (!isDefined(propertyValue) || isPlainObject(propertyValue))) {\n          propertyValue = ensurePropValueDefined(currentValue, propertyName, propertyValue, options);\n          deepExtendArraySafe(propertyValue, value, false, true);\n        } else if (isPropertyFunc) {\n          currentValue[propertyName](value);\n        } else {\n          assignPropValue(currentValue, propertyName, value, options);\n        }\n      } else {\n        propertyValue = ensurePropValueDefined(currentValue, propertyName, propertyValue, options);\n\n        if (isPropertyFunc) {\n          propertyValue = propertyValue.call(currentValue);\n        }\n\n        currentValue = propertyValue;\n      }\n    });\n  };\n};\nexport var toComparable = function toComparable(value, caseSensitive) {\n  if (value instanceof Date) {\n    return value.getTime();\n  }\n\n  if (value && value instanceof Class && value.valueOf) {\n    return value.valueOf();\n  }\n\n  if (!caseSensitive && \"string\" === typeof value) {\n    return value.toLowerCase();\n  }\n\n  return value;\n};","map":null,"metadata":{},"sourceType":"module"}