{"ast":null,"code":"import _defineProperty from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\n\n/**\r\n * DevExtreme (esm/viz/chart_components/advanced_chart.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { extend as _extend } from \"../../core/utils/extend\";\nimport { inArray } from \"../../core/utils/array\";\nimport { each as _each, reverseEach as _reverseEach } from \"../../core/utils/iterator\";\nimport { Range } from \"../translators/range\";\nimport { Axis } from \"../axes/base_axis\";\nimport { SeriesFamily } from \"../core/series_family\";\nimport { BaseChart } from \"./base_chart\";\nimport rangeDataCalculator from \"../series/helpers/range_data_calculator\";\nimport { isDefined as _isDefined, type } from \"../../core/utils/type\";\nimport { noop as _noop } from \"../../core/utils/common\";\nimport { convertVisualRangeObject, rangesAreEqual, map as _map, mergeMarginOptions, setCanvasValues, unique } from \"../core/utils\";\nvar _isArray = Array.isArray;\nvar DEFAULT_AXIS_NAME = \"defaultAxisName\";\nvar FONT = \"font\";\nvar COMMON_AXIS_SETTINGS = \"commonAxisSettings\";\nvar DEFAULT_PANE_NAME = \"default\";\nvar VISUAL_RANGE = \"VISUAL_RANGE\";\n\nfunction prepareAxis(axisOptions) {\n  return _isArray(axisOptions) ? 0 === axisOptions.length ? [{}] : axisOptions : [axisOptions];\n}\n\nfunction processBubbleMargin(opt, bubbleSize) {\n  if (opt.processBubbleSize) {\n    opt.size = bubbleSize;\n  }\n\n  return opt;\n}\n\nfunction estimateBubbleSize(size, panesCount, maxSize, rotated) {\n  var width = rotated ? size.width / panesCount : size.width;\n  var height = rotated ? size.height : size.height / panesCount;\n  return Math.min(width, height) * maxSize;\n}\n\nfunction setAxisVisualRangeByOption(arg, axis, isDirectOption, index) {\n  var options;\n  var visualRange;\n\n  if (isDirectOption) {\n    visualRange = arg.value;\n    options = {\n      skipEventRising: true\n    };\n    var wrappedVisualRange = wrapVisualRange(arg.fullName, visualRange);\n\n    if (wrappedVisualRange) {\n      options = {\n        allowPartialUpdate: true\n      };\n      visualRange = wrappedVisualRange;\n    }\n  } else {\n    visualRange = (_isDefined(index) ? arg.value[index] : arg.value).visualRange;\n  }\n\n  axis.visualRange(visualRange, options);\n}\n\nfunction getAxisTypes(groupsData, axis, isArgumentAxes) {\n  if (isArgumentAxes) {\n    return {\n      argumentAxisType: groupsData.argumentAxisType,\n      argumentType: groupsData.argumentType\n    };\n  }\n\n  var _groupsData$groups$fi = groupsData.groups.filter(function (g) {\n    return g.valueAxis === axis;\n  })[0],\n      valueAxisType = _groupsData$groups$fi.valueAxisType,\n      valueType = _groupsData$groups$fi.valueType;\n  return {\n    valueAxisType: valueAxisType,\n    valueType: valueType\n  };\n}\n\nfunction wrapVisualRange(fullName, value) {\n  var pathElements = fullName.split(\".\");\n  var destElem = pathElements[pathElements.length - 1];\n\n  if (\"endValue\" === destElem || \"startValue\" === destElem) {\n    return _defineProperty({}, destElem, value);\n  }\n}\n\nexport var AdvancedChart = BaseChart.inherit({\n  _fontFields: [COMMON_AXIS_SETTINGS + \".label.\" + FONT, COMMON_AXIS_SETTINGS + \".title.\" + FONT],\n  _partialOptionChangesMap: {\n    visualRange: VISUAL_RANGE,\n    _customVisualRange: VISUAL_RANGE,\n    strips: \"REFRESH_AXES\",\n    constantLines: \"REFRESH_AXES\"\n  },\n  _partialOptionChangesPath: {\n    argumentAxis: [\"strips\", \"constantLines\", \"visualRange\", \"_customVisualRange\"],\n    valueAxis: [\"strips\", \"constantLines\", \"visualRange\", \"_customVisualRange\"]\n  },\n  _initCore: function _initCore() {\n    this._panesClipRects = {};\n    this.callBase();\n  },\n  _disposeCore: function _disposeCore() {\n    var disposeObjectsInArray = this._disposeObjectsInArray;\n    var panesClipRects = this._panesClipRects;\n    this.callBase();\n    disposeObjectsInArray.call(panesClipRects, \"fixed\");\n    disposeObjectsInArray.call(panesClipRects, \"base\");\n    disposeObjectsInArray.call(panesClipRects, \"wide\");\n    this._panesClipRects = null;\n\n    this._labelsAxesGroup.linkOff();\n\n    this._labelsAxesGroup.dispose();\n\n    this._labelsAxesGroup = null;\n  },\n  _dispose: function _dispose() {\n    var disposeObjectsInArray = this._disposeObjectsInArray;\n    this.callBase();\n    this.panes = null;\n\n    if (this._legend) {\n      this._legend.dispose();\n\n      this._legend = null;\n    }\n\n    disposeObjectsInArray.call(this, \"panesBackground\");\n    disposeObjectsInArray.call(this, \"seriesFamilies\");\n\n    this._disposeAxes();\n  },\n  _createPanes: function _createPanes() {\n    this._cleanPanesClipRects(\"fixed\");\n\n    this._cleanPanesClipRects(\"base\");\n\n    this._cleanPanesClipRects(\"wide\");\n  },\n  _cleanPanesClipRects: function _cleanPanesClipRects(clipArrayName) {\n    var clipArray = this._panesClipRects[clipArrayName];\n    (clipArray || []).forEach(function (clipRect) {\n      return clipRect && clipRect.dispose();\n    });\n    this._panesClipRects[clipArrayName] = [];\n  },\n  _getElementsClipRectID: function _getElementsClipRectID(paneName) {\n    var clipShape = this._panesClipRects.fixed[this._getPaneIndex(paneName)];\n\n    return clipShape && clipShape.id;\n  },\n  _getPaneIndex: function _getPaneIndex(paneName) {\n    var paneIndex;\n    var name = paneName || DEFAULT_PANE_NAME;\n\n    _each(this.panes, function (index, pane) {\n      if (pane.name === name) {\n        paneIndex = index;\n        return false;\n      }\n    });\n\n    return paneIndex;\n  },\n  _updateSize: function _updateSize() {\n    this.callBase();\n    setCanvasValues(this._canvas);\n  },\n  _reinitAxes: function _reinitAxes() {\n    this.panes = this._createPanes();\n\n    this._populateAxes();\n\n    this._axesReinitialized = true;\n  },\n  _populateAxes: function _populateAxes() {\n    var that = this;\n    var panes = that.panes;\n\n    var rotated = that._isRotated();\n\n    var argumentAxesOptions = prepareAxis(that.option(\"argumentAxis\") || {})[0];\n    var valueAxisOption = that.option(\"valueAxis\");\n    var valueAxesOptions = prepareAxis(valueAxisOption || {});\n    var argumentAxesPopulatedOptions;\n    var valueAxesPopulatedOptions = [];\n    var axisNames = [];\n    var valueAxesCounter = 0;\n    var paneWithNonVirtualAxis;\n\n    var crosshairMargins = that._getCrosshairMargins();\n\n    if (rotated) {\n      paneWithNonVirtualAxis = \"right\" === argumentAxesOptions.position ? panes[panes.length - 1].name : panes[0].name;\n    } else {\n      paneWithNonVirtualAxis = \"top\" === argumentAxesOptions.position ? panes[0].name : panes[panes.length - 1].name;\n    }\n\n    argumentAxesPopulatedOptions = _map(panes, function (pane) {\n      var virtual = pane.name !== paneWithNonVirtualAxis;\n      return that._populateAxesOptions(\"argumentAxis\", argumentAxesOptions, {\n        pane: pane.name,\n        name: null,\n        optionPath: \"argumentAxis\",\n        crosshairMargin: rotated ? crosshairMargins.x : crosshairMargins.y\n      }, rotated, virtual);\n    });\n\n    _each(valueAxesOptions, function (priority, axisOptions) {\n      var _axisOptions$panes;\n\n      var axisPanes = [];\n      var name = axisOptions.name;\n\n      if (name && -1 !== inArray(name, axisNames)) {\n        that._incidentOccurred(\"E2102\");\n\n        return;\n      }\n\n      name && axisNames.push(name);\n\n      if (axisOptions.pane) {\n        axisPanes.push(axisOptions.pane);\n      }\n\n      if (null !== (_axisOptions$panes = axisOptions.panes) && void 0 !== _axisOptions$panes && _axisOptions$panes.length) {\n        axisPanes = axisPanes.concat(axisOptions.panes.slice(0));\n      }\n\n      axisPanes = unique(axisPanes);\n\n      if (!axisPanes.length) {\n        axisPanes.push(void 0);\n      }\n\n      _each(axisPanes, function (_, pane) {\n        var optionPath = _isArray(valueAxisOption) ? \"valueAxis[\".concat(priority, \"]\") : \"valueAxis\";\n        valueAxesPopulatedOptions.push(that._populateAxesOptions(\"valueAxis\", axisOptions, {\n          name: name || DEFAULT_AXIS_NAME + valueAxesCounter++,\n          pane: pane,\n          priority: priority,\n          optionPath: optionPath,\n          crosshairMargin: rotated ? crosshairMargins.y : crosshairMargins.x\n        }, rotated));\n      });\n    });\n\n    that._redesignAxes(argumentAxesPopulatedOptions, true, paneWithNonVirtualAxis);\n\n    that._redesignAxes(valueAxesPopulatedOptions, false);\n  },\n  _redesignAxes: function _redesignAxes(options, isArgumentAxes, paneWithNonVirtualAxis) {\n    var that = this;\n    var axesBasis = [];\n    var axes = isArgumentAxes ? that._argumentAxes : that._valueAxes;\n\n    _each(options, function (_, opt) {\n      var curAxes = axes && axes.filter(function (a) {\n        return a.name === opt.name && (!_isDefined(opt.pane) && that.panes.some(function (p) {\n          return p.name === a.pane;\n        }) || a.pane === opt.pane);\n      });\n\n      if (curAxes && curAxes.length > 0) {\n        _each(curAxes, function (_, axis) {\n          var axisTypes = getAxisTypes(that._groupsData, axis, isArgumentAxes);\n          axis.updateOptions(opt);\n\n          if (isArgumentAxes) {\n            axis.setTypes(axisTypes.argumentAxisType, axisTypes.argumentType, \"argumentType\");\n          } else {\n            axis.setTypes(axisTypes.valueAxisType, axisTypes.valueType, \"valueType\");\n          }\n\n          axis.validate();\n          axesBasis.push({\n            axis: axis\n          });\n        });\n      } else {\n        axesBasis.push({\n          options: opt\n        });\n      }\n    });\n\n    if (axes) {\n      _reverseEach(axes, function (index, axis) {\n        if (!axesBasis.some(function (basis) {\n          return basis.axis && basis.axis === axis;\n        })) {\n          that._disposeAxis(index, isArgumentAxes);\n        }\n      });\n    } else if (isArgumentAxes) {\n      axes = that._argumentAxes = [];\n    } else {\n      axes = that._valueAxes = [];\n    }\n\n    _each(axesBasis, function (_, basis) {\n      var axis = basis.axis;\n\n      if (basis.axis && isArgumentAxes) {\n        basis.axis.isVirtual = basis.axis.pane !== paneWithNonVirtualAxis;\n      } else if (basis.options) {\n        axis = that._createAxis(isArgumentAxes, basis.options, isArgumentAxes ? basis.options.pane !== paneWithNonVirtualAxis : void 0);\n        axes.push(axis);\n      }\n\n      axis.applyVisualRangeSetter(that._getVisualRangeSetter());\n    });\n  },\n  _disposeAxis: function _disposeAxis(index, isArgumentAxis) {\n    var axes = isArgumentAxis ? this._argumentAxes : this._valueAxes;\n    var axis = axes[index];\n\n    if (!axis) {\n      return;\n    }\n\n    axis.dispose();\n    axes.splice(index, 1);\n  },\n  _disposeAxes: function _disposeAxes() {\n    var disposeObjectsInArray = this._disposeObjectsInArray;\n    disposeObjectsInArray.call(this, \"_argumentAxes\");\n    disposeObjectsInArray.call(this, \"_valueAxes\");\n  },\n  _appendAdditionalSeriesGroups: function _appendAdditionalSeriesGroups() {\n    this._crosshairCursorGroup.linkAppend();\n\n    this._scrollBar && this._scrollBarGroup.linkAppend();\n  },\n  _getLegendTargets: function _getLegendTargets() {\n    var _this = this;\n\n    return (this.series || []).map(function (s) {\n      var item = _this._getLegendOptions(s);\n\n      item.legendData.series = s;\n\n      if (!s.getOptions().showInLegend) {\n        item.legendData.visible = false;\n      }\n\n      return item;\n    });\n  },\n  _legendItemTextField: \"name\",\n  _seriesPopulatedHandlerCore: function _seriesPopulatedHandlerCore() {\n    this._processSeriesFamilies();\n\n    this._processValueAxisFormat();\n  },\n  _renderTrackers: function _renderTrackers() {\n    var i;\n\n    for (i = 0; i < this.series.length; ++i) {\n      this.series[i].drawTrackers();\n    }\n  },\n  _specialProcessSeries: function _specialProcessSeries() {\n    this._processSeriesFamilies();\n  },\n  _processSeriesFamilies: function _processSeriesFamilies() {\n    var _that$seriesFamilies;\n\n    var that = this;\n    var types = [];\n    var families = [];\n    var paneSeries;\n    var themeManager = that._themeManager;\n    var negativesAsZeroes = themeManager.getOptions(\"negativesAsZeroes\");\n    var negativesAsZeros = themeManager.getOptions(\"negativesAsZeros\");\n    var familyOptions = {\n      minBubbleSize: themeManager.getOptions(\"minBubbleSize\"),\n      maxBubbleSize: themeManager.getOptions(\"maxBubbleSize\"),\n      barGroupPadding: themeManager.getOptions(\"barGroupPadding\"),\n      barGroupWidth: themeManager.getOptions(\"barGroupWidth\"),\n      negativesAsZeroes: _isDefined(negativesAsZeroes) ? negativesAsZeroes : negativesAsZeros\n    };\n\n    if (null !== (_that$seriesFamilies = that.seriesFamilies) && void 0 !== _that$seriesFamilies && _that$seriesFamilies.length) {\n      _each(that.seriesFamilies, function (_, family) {\n        family.updateOptions(familyOptions);\n        family.adjustSeriesValues();\n      });\n\n      return;\n    }\n\n    _each(that.series, function (_, item) {\n      if (-1 === inArray(item.type, types)) {\n        types.push(item.type);\n      }\n    });\n\n    _each(that._getLayoutTargets(), function (_, pane) {\n      paneSeries = that._getSeriesForPane(pane.name);\n\n      _each(types, function (_, type) {\n        var family = new SeriesFamily({\n          type: type,\n          pane: pane.name,\n          minBubbleSize: familyOptions.minBubbleSize,\n          maxBubbleSize: familyOptions.maxBubbleSize,\n          barGroupPadding: familyOptions.barGroupPadding,\n          barGroupWidth: familyOptions.barGroupWidth,\n          negativesAsZeroes: familyOptions.negativesAsZeroes,\n          rotated: that._isRotated()\n        });\n        family.add(paneSeries);\n        family.adjustSeriesValues();\n        families.push(family);\n      });\n    });\n\n    that.seriesFamilies = families;\n  },\n  _updateSeriesDimensions: function _updateSeriesDimensions() {\n    var i;\n    var seriesFamilies = this.seriesFamilies || [];\n\n    for (i = 0; i < seriesFamilies.length; i++) {\n      var family = seriesFamilies[i];\n      family.updateSeriesValues();\n      family.adjustSeriesDimensions();\n    }\n  },\n  _getLegendCallBack: function _getLegendCallBack(series) {\n    return this._legend && this._legend.getActionCallback(series);\n  },\n  _appendAxesGroups: function _appendAxesGroups() {\n    this._stripsGroup.linkAppend();\n\n    this._gridGroup.linkAppend();\n\n    this._axesGroup.linkAppend();\n\n    this._labelsAxesGroup.linkAppend();\n\n    this._constantLinesGroup.linkAppend();\n\n    this._stripLabelAxesGroup.linkAppend();\n\n    this._scaleBreaksGroup.linkAppend();\n  },\n  _populateMarginOptions: function _populateMarginOptions() {\n    var that = this;\n    var bubbleSize = estimateBubbleSize(that.getSize(), that.panes.length, that._themeManager.getOptions(\"maxBubbleSize\"), that._isRotated());\n    var argumentMarginOptions = {};\n\n    that._valueAxes.forEach(function (valueAxis) {\n      var groupSeries = that.series.filter(function (series) {\n        return series.getValueAxis() === valueAxis;\n      });\n      var marginOptions = {};\n      groupSeries.forEach(function (series) {\n        if (series.isVisible()) {\n          var seriesMarginOptions = processBubbleMargin(series.getMarginOptions(), bubbleSize);\n          marginOptions = mergeMarginOptions(marginOptions, seriesMarginOptions);\n          argumentMarginOptions = mergeMarginOptions(argumentMarginOptions, seriesMarginOptions);\n        }\n      });\n      valueAxis.setMarginOptions(marginOptions);\n    });\n\n    that._argumentAxes.forEach(function (a) {\n      return a.setMarginOptions(argumentMarginOptions);\n    });\n  },\n  _populateBusinessRange: function _populateBusinessRange(updatedAxis, keepRange) {\n    var that = this;\n\n    var rotated = that._isRotated();\n\n    var series = that._getVisibleSeries();\n\n    var argRanges = {};\n    var commonArgRange = new Range({\n      rotated: !!rotated\n    });\n\n    var getPaneName = function getPaneName(axis) {\n      return axis.pane || DEFAULT_PANE_NAME;\n    };\n\n    that.panes.forEach(function (p) {\n      return argRanges[p.name] = new Range({\n        rotated: !!rotated\n      });\n    });\n\n    that._valueAxes.forEach(function (valueAxis) {\n      var groupRange = new Range({\n        rotated: !!rotated,\n        pane: valueAxis.pane,\n        axis: valueAxis.name\n      });\n      var groupSeries = series.filter(function (series) {\n        return series.getValueAxis() === valueAxis;\n      });\n      groupSeries.forEach(function (series) {\n        var seriesRange = series.getRangeData();\n        groupRange.addRange(seriesRange.val);\n        argRanges[getPaneName(valueAxis)].addRange(seriesRange.arg);\n      });\n\n      if (!updatedAxis || updatedAxis && groupSeries.length && valueAxis === updatedAxis) {\n        valueAxis.setGroupSeries(groupSeries);\n        valueAxis.setBusinessRange(groupRange, that._axesReinitialized || keepRange, that._argumentAxes[0]._lastVisualRangeUpdateMode);\n      }\n    });\n\n    if (!updatedAxis || updatedAxis && series.length) {\n      Object.keys(argRanges).forEach(function (p) {\n        return commonArgRange.addRange(argRanges[p]);\n      });\n      var commonInterval = commonArgRange.interval;\n\n      that._argumentAxes.forEach(function (a) {\n        var _argRanges$getPaneNam;\n\n        var currentInterval = null !== (_argRanges$getPaneNam = argRanges[getPaneName(a)].interval) && void 0 !== _argRanges$getPaneNam ? _argRanges$getPaneNam : commonInterval;\n        a.setBusinessRange(new Range(_extends({}, commonArgRange, {\n          interval: currentInterval\n        })), that._axesReinitialized, void 0, that._groupsData.categories);\n      });\n    }\n\n    that._populateMarginOptions();\n  },\n  getArgumentAxis: function getArgumentAxis() {\n    return (this._argumentAxes || []).filter(function (a) {\n      return !a.isVirtual;\n    })[0];\n  },\n  getValueAxis: function getValueAxis(name) {\n    var _this2 = this;\n\n    return (this._valueAxes || []).filter(_isDefined(name) ? function (a) {\n      return a.name === name;\n    } : function (a) {\n      return a.pane === _this2.defaultPane;\n    })[0];\n  },\n  _getGroupsData: function _getGroupsData() {\n    var that = this;\n    var groups = [];\n\n    that._valueAxes.forEach(function (axis) {\n      groups.push({\n        series: that.series.filter(function (series) {\n          return series.getValueAxis() === axis;\n        }),\n        valueAxis: axis,\n        valueOptions: axis.getOptions()\n      });\n    });\n\n    return {\n      groups: groups,\n      argumentAxes: that._argumentAxes,\n      argumentOptions: that._argumentAxes[0].getOptions()\n    };\n  },\n  _groupSeries: function _groupSeries() {\n    this._correctValueAxes(false);\n\n    this._groupsData = this._getGroupsData();\n  },\n  _processValueAxisFormat: function _processValueAxisFormat() {\n    var axesWithFullStackedFormat = [];\n    this.series.forEach(function (series) {\n      var axis = series.getValueAxis();\n\n      if (series.isFullStackedSeries()) {\n        axis.setPercentLabelFormat();\n        axesWithFullStackedFormat.push(axis);\n      }\n    });\n\n    this._valueAxes.forEach(function (axis) {\n      if (-1 === axesWithFullStackedFormat.indexOf(axis)) {\n        axis.resetAutoLabelFormat();\n      }\n    });\n  },\n  _populateAxesOptions: function _populateAxesOptions(typeSelector, userOptions, axisOptions, rotated, virtual) {\n    var preparedUserOptions = this._prepareStripsAndConstantLines(typeSelector, userOptions, rotated);\n\n    var options = _extend(true, {}, preparedUserOptions, axisOptions, this._prepareAxisOptions(typeSelector, preparedUserOptions, rotated));\n\n    if (virtual) {\n      options.visible = options.tick.visible = options.minorTick.visible = options.label.visible = false;\n      options.title = {};\n    }\n\n    return options;\n  },\n  _getValFilter: function _getValFilter(series) {\n    return rangeDataCalculator.getViewPortFilter(series.getValueAxis().visualRange() || {});\n  },\n  _createAxis: function _createAxis(isArgumentAxes, options, virtual) {\n    var that = this;\n    var typeSelector = isArgumentAxes ? \"argumentAxis\" : \"valueAxis\";\n\n    var renderingSettings = _extend({\n      renderer: that._renderer,\n      incidentOccurred: that._incidentOccurred,\n      eventTrigger: that._eventTrigger,\n      axisClass: isArgumentAxes ? \"arg\" : \"val\",\n      widgetClass: \"dxc\",\n      stripsGroup: that._stripsGroup,\n      stripLabelAxesGroup: that._stripLabelAxesGroup,\n      constantLinesGroup: that._constantLinesGroup,\n      scaleBreaksGroup: that._scaleBreaksGroup,\n      axesContainerGroup: that._axesGroup,\n      labelsAxesGroup: that._labelsAxesGroup,\n      gridGroup: that._gridGroup,\n      isArgumentAxis: isArgumentAxes,\n      getTemplate: function getTemplate(template) {\n        return that._getTemplate(template);\n      }\n    }, that._getAxisRenderingOptions(typeSelector));\n\n    var axis = new Axis(renderingSettings);\n    axis.updateOptions(options);\n    axis.isVirtual = virtual;\n    return axis;\n  },\n  _applyVisualRangeByVirtualAxes: function _applyVisualRangeByVirtualAxes(axis, range) {\n    return false;\n  },\n  _applyCustomVisualRangeOption: function _applyCustomVisualRangeOption(axis, range) {\n    if (axis.getOptions().optionPath) {\n      this._parseVisualRangeOption(\"\".concat(axis.getOptions().optionPath, \".visualRange\"), range);\n    }\n  },\n  _getVisualRangeSetter: function _getVisualRangeSetter() {\n    var chart = this;\n    return function (axis, _ref) {\n      var skipEventRising = _ref.skipEventRising,\n          range = _ref.range;\n\n      chart._applyCustomVisualRangeOption(axis, range);\n\n      axis.setCustomVisualRange(range);\n      axis.skipEventRising = skipEventRising;\n\n      if (!chart._applyVisualRangeByVirtualAxes(axis, range)) {\n        if (chart._applyingChanges) {\n          chart._change_VISUAL_RANGE();\n        } else {\n          chart._requestChange([VISUAL_RANGE]);\n        }\n      }\n    };\n  },\n  _getTrackerSettings: function _getTrackerSettings() {\n    return _extend(this.callBase(), {\n      argumentAxis: this.getArgumentAxis()\n    });\n  },\n  _prepareStripsAndConstantLines: function _prepareStripsAndConstantLines(typeSelector, userOptions, rotated) {\n    userOptions = this._themeManager.getOptions(typeSelector, userOptions, rotated);\n\n    if (userOptions.strips) {\n      _each(userOptions.strips, function (i) {\n        userOptions.strips[i] = _extend(true, {}, userOptions.stripStyle, userOptions.strips[i]);\n      });\n    }\n\n    if (userOptions.constantLines) {\n      _each(userOptions.constantLines, function (i, line) {\n        userOptions.constantLines[i] = _extend(true, {}, userOptions.constantLineStyle, line);\n      });\n    }\n\n    return userOptions;\n  },\n  refresh: function refresh() {\n    this._disposeAxes();\n\n    this.callBase();\n  },\n  _layoutAxes: function _layoutAxes(drawAxes) {\n    drawAxes();\n    var needSpace = this.checkForMoreSpaceForPanesCanvas();\n\n    if (needSpace) {\n      var rect = this._rect.slice();\n\n      var size = this._layout.backward(rect, rect, [needSpace.width, needSpace.height]);\n\n      needSpace.width = Math.max(0, size[0]);\n      needSpace.height = Math.max(0, size[1]);\n      this._canvas = this._createCanvasFromRect(rect);\n      drawAxes(needSpace);\n    }\n  },\n  checkForMoreSpaceForPanesCanvas: function checkForMoreSpaceForPanesCanvas() {\n    return this.layoutManager.needMoreSpaceForPanesCanvas(this._getLayoutTargets(), this._isRotated());\n  },\n  _parseVisualRangeOption: function _parseVisualRangeOption(fullName, value) {\n    var that = this;\n    var name = fullName.split(/[.[]/)[0];\n    var index = fullName.match(/\\d+/g);\n    index = _isDefined(index) ? parseInt(index[0]) : index;\n\n    if (fullName.indexOf(\"visualRange\") > 0) {\n      if (\"object\" !== type(value)) {\n        value = wrapVisualRange(fullName, value) || value;\n      }\n\n      that._setCustomVisualRange(name, index, value);\n    } else if ((\"object\" === type(value) || _isArray(value)) && name.indexOf(\"Axis\") > 0 && JSON.stringify(value).indexOf(\"visualRange\") > 0) {\n      if (_isDefined(value.visualRange)) {\n        that._setCustomVisualRange(name, index, value.visualRange);\n      } else if (_isArray(value)) {\n        value.forEach(function (a, i) {\n          return _isDefined(a.visualRange) && that._setCustomVisualRange(name, i, a.visualRange);\n        });\n      }\n    }\n  },\n  _setCustomVisualRange: function _setCustomVisualRange(axesName, index, value) {\n    var options = this._options.silent(axesName);\n\n    if (!options) {\n      return;\n    }\n\n    if (!_isDefined(index)) {\n      options._customVisualRange = value;\n    } else {\n      options[index]._customVisualRange = value;\n    }\n\n    this._axesReinitialized = true;\n  },\n  _raiseZoomEndHandlers: function _raiseZoomEndHandlers() {\n    this._valueAxes.forEach(function (axis) {\n      return axis.handleZoomEnd();\n    });\n  },\n  _setOptionsByReference: function _setOptionsByReference() {\n    this.callBase();\n\n    _extend(this._optionsByReference, {\n      \"valueAxis.visualRange\": true\n    });\n  },\n  _notifyOptionChanged: function _notifyOptionChanged(option, value, previousValue) {\n    this.callBase.apply(this, arguments);\n\n    if (!this._optionChangedLocker) {\n      this._parseVisualRangeOption(option, value);\n    }\n  },\n  _notifyVisualRange: function _notifyVisualRange() {\n    var that = this;\n\n    that._valueAxes.forEach(function (axis) {\n      var axisPath = axis.getOptions().optionPath;\n\n      if (axisPath) {\n        var path = \"\".concat(axisPath, \".visualRange\");\n        var visualRange = convertVisualRangeObject(axis.visualRange(), !_isArray(that.option(path)));\n\n        if (!axis.skipEventRising || !rangesAreEqual(visualRange, that.option(path))) {\n          if (!that.option(axisPath) && \"valueAxis\" !== axisPath) {\n            that.option(axisPath, {\n              name: axis.name,\n              visualRange: visualRange\n            });\n          } else {\n            that.option(path, visualRange);\n          }\n        } else {\n          axis.skipEventRising = null;\n        }\n      }\n    });\n  },\n  _notify: function _notify() {\n    this.callBase();\n    this._axesReinitialized = false;\n\n    if (true !== this.option(\"disableTwoWayBinding\")) {\n      this.skipOptionsRollBack = true;\n\n      this._notifyVisualRange();\n\n      this.skipOptionsRollBack = false;\n    }\n  },\n  _getAxesForScaling: function _getAxesForScaling() {\n    return this._valueAxes;\n  },\n  _getAxesByOptionPath: function _getAxesByOptionPath(arg, isDirectOption, optionName) {\n    var sourceAxes = this._getAxesForScaling();\n\n    var axes = [];\n\n    if (isDirectOption) {\n      var axisPath;\n\n      if (arg.fullName) {\n        axisPath = arg.fullName.slice(0, arg.fullName.indexOf(\".\"));\n      }\n\n      axes = sourceAxes.filter(function (a) {\n        return a.getOptions().optionPath === axisPath;\n      });\n    } else if (\"object\" === type(arg.value)) {\n      axes = sourceAxes.filter(function (a) {\n        return a.getOptions().optionPath === arg.name;\n      });\n    } else if (_isArray(arg.value)) {\n      arg.value.forEach(function (v, index) {\n        var axis = sourceAxes.filter(function (a) {\n          return a.getOptions().optionPath === \"\".concat(arg.name, \"[\").concat(index, \"]\");\n        })[0];\n        _isDefined(v[optionName]) && _isDefined(axis) && (axes[index] = axis);\n      });\n    }\n\n    return axes;\n  },\n  _optionChanged: function _optionChanged(arg) {\n    if (!this._optionChangedLocker) {\n      var axes;\n      var isDirectOption = arg.fullName.indexOf(\"visualRange\") > 0 ? true : this.getPartialChangeOptionsName(arg).indexOf(\"visualRange\") > -1 ? false : void 0;\n\n      if (_isDefined(isDirectOption)) {\n        axes = this._getAxesByOptionPath(arg, isDirectOption, \"visualRange\");\n\n        if (axes) {\n          if (axes.length > 1 || _isArray(arg.value)) {\n            axes.forEach(function (a, index) {\n              return setAxisVisualRangeByOption(arg, a, isDirectOption, index);\n            });\n          } else if (1 === axes.length) {\n            setAxisVisualRangeByOption(arg, axes[0], isDirectOption);\n          }\n        }\n      }\n    }\n\n    this.callBase(arg);\n  },\n  _change_VISUAL_RANGE: function _change_VISUAL_RANGE() {\n    this._recreateSizeDependentObjects(false);\n\n    if (!this._changes.has(\"FULL_RENDER\")) {\n      var resizePanesOnZoom = this.option(\"resizePanesOnZoom\");\n\n      this._doRender({\n        force: true,\n        drawTitle: false,\n        drawLegend: false,\n        adjustAxes: null !== resizePanesOnZoom && void 0 !== resizePanesOnZoom ? resizePanesOnZoom : this.option(\"adjustAxesOnZoom\") || false,\n        animate: false\n      });\n\n      this._raiseZoomEndHandlers();\n    }\n  },\n  resetVisualRange: function resetVisualRange() {\n    var that = this;\n\n    that._valueAxes.forEach(function (axis) {\n      axis.resetVisualRange(false);\n\n      that._applyCustomVisualRangeOption(axis);\n    });\n\n    that._requestChange([VISUAL_RANGE]);\n  },\n  _getCrosshairMargins: function _getCrosshairMargins() {\n    return {\n      x: 0,\n      y: 0\n    };\n  },\n  _legendDataField: \"series\",\n  _adjustSeriesLabels: _noop,\n  _correctValueAxes: _noop\n});","map":null,"metadata":{},"sourceType":"module"}