{"ast":null,"code":"/**\r\n * DevExtreme (esm/viz/vector_map/layout.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { inArray } from \"../../core/utils/array\";\nimport { each } from \"../../core/utils/iterator\";\nvar _round = Math.round;\nvar _min = Math.min;\nvar _max = Math.max;\nvar _each = each;\nvar _inArray = inArray;\nvar horizontalAlignmentMap = {\n  left: 0,\n  center: 1,\n  right: 2\n};\nvar verticalAlignmentMap = {\n  top: 0,\n  bottom: 1\n};\n\nfunction getCellIndex(options) {\n  return 3 * verticalAlignmentMap[options.verticalAlignment] + horizontalAlignmentMap[options.horizontalAlignment];\n}\n\nfunction createCells(canvas, items) {\n  var hStep = (canvas.right - canvas.left) / 3;\n  var vStep = (canvas.bottom - canvas.top) / 2;\n  var h1 = canvas.left;\n\n  var h2 = _round(h1 + hStep);\n\n  var h3 = _round(h1 + hStep + hStep);\n\n  var h4 = canvas.right;\n  var v1 = canvas.top;\n\n  var v2 = _round(v1 + vStep);\n\n  var v3 = canvas.bottom;\n  var cells = [{\n    rect: [h1, v1, h2, v2]\n  }, {\n    rect: [h2, v1, h3, v2],\n    center: true\n  }, {\n    rect: [h3, v1, h4, v2],\n    horInversion: true\n  }, {\n    rect: [h1, v2, h2, v3],\n    verInversion: true\n  }, {\n    rect: [h2, v2, h3, v3],\n    center: true,\n    verInversion: true\n  }, {\n    rect: [h3, v2, h4, v3],\n    horInversion: true,\n    verInversion: true\n  }];\n  var itemsList = [[], [], [], [], [], []];\n\n  _each(items, function (_, item) {\n    var options = item.getLayoutOptions();\n\n    if (options) {\n      itemsList[getCellIndex(options)].push({\n        item: item,\n        width: options.width,\n        height: options.height\n      });\n    }\n  });\n\n  _each(cells, function (i, cell) {\n    if (itemsList[i].length) {\n      cell.items = itemsList[i];\n    } else {\n      if (cell.center) {\n        cell.rect[0] = cell.rect[2] = (cell.rect[0] + cell.rect[2]) / 2;\n      } else {\n        cell.rect[cell.horInversion ? 0 : 2] = cell.rect[cell.horInversion ? 2 : 0];\n      }\n\n      cell.rect[cell.verInversion ? 1 : 3] = cell.rect[cell.verInversion ? 3 : 1];\n    }\n  });\n\n  return cells;\n}\n\nfunction adjustCellSizes(cells) {\n  _each([0, 1, 2, 3, 4, 5], function (_, index) {\n    var cell = cells[index];\n    var otherCell = cells[(index + 3) % 6];\n\n    if (cell.items) {\n      if (!otherCell.items) {\n        cell.rect[1] = _min(cell.rect[1], otherCell.rect[3]);\n        cell.rect[3] = _max(cell.rect[3], otherCell.rect[1]);\n      }\n    }\n  });\n\n  _each([1, 4], function (_, index) {\n    var cell = cells[index];\n    var otherCell1 = cells[index - 1];\n    var otherCell2 = cells[index + 1];\n    var size1;\n    var size2;\n\n    if (cell.items) {\n      if (!otherCell1.items && !otherCell2.items) {\n        size1 = cell.rect[0] - otherCell1.rect[2];\n        size2 = otherCell2.rect[0] - cell.rect[2];\n\n        if (size1 > size2) {\n          if (size1 / size2 >= 2) {\n            cell.rect[0] -= size1;\n            cell.right = true;\n          } else {\n            cell.rect[0] -= size2;\n            cell.rect[2] += size2;\n          }\n        } else if (size2 / size1 >= 2) {\n          cell.rect[2] += size2;\n          cell.center = null;\n        } else {\n          cell.rect[0] -= size1;\n          cell.rect[2] += size1;\n        }\n      }\n    } else {\n      if (otherCell1.items) {\n        otherCell1.rect[2] = (cell.rect[0] + cell.rect[2]) / 2;\n      }\n\n      if (otherCell2.items) {\n        otherCell2.rect[0] = (cell.rect[0] + cell.rect[2]) / 2;\n      }\n    }\n  });\n}\n\nfunction adjustCellsAndApplyLayout(cells, forceMode) {\n  var hasHiddenItems = false;\n  adjustCellSizes(cells);\n\n  _each(cells, function (_, cell) {\n    if (cell.items) {\n      hasHiddenItems = applyCellLayout(cell, forceMode) || hasHiddenItems;\n    }\n  });\n\n  return hasHiddenItems;\n}\n\nfunction applyCellLayout(cell, forceMode) {\n  var cellRect = cell.rect;\n  var cellWidth = cellRect[2] - cellRect[0];\n  var cellHeight = cellRect[3] - cellRect[1];\n  var xOffset = 0;\n  var yOffset = 0;\n  var currentHeight = 0;\n  var totalL = cellRect[2];\n  var totalT = cellRect[3];\n  var totalR = cellRect[0];\n  var totalB = cellRect[1];\n  var moves = [];\n  var hasHiddenItems = false;\n\n  _each(cell.items, function (_, item) {\n    if (item.width > cellWidth || item.height > cellHeight) {\n      moves.push(null);\n      hasHiddenItems = true;\n      return forceMode || false;\n    }\n\n    if (xOffset + item.width > cellWidth) {\n      yOffset += currentHeight;\n      xOffset = currentHeight = 0;\n    }\n\n    if (yOffset + item.height > cellHeight) {\n      moves.push(null);\n      hasHiddenItems = true;\n      return forceMode || false;\n    }\n\n    currentHeight = _max(currentHeight, item.height);\n    var dx = cell.horInversion ? cellRect[2] - item.width - xOffset : cellRect[0] + xOffset;\n    var dy = cell.verInversion ? cellRect[3] - item.height - yOffset : cellRect[1] + yOffset;\n    xOffset += item.width;\n    totalL = _min(totalL, dx);\n    totalT = _min(totalT, dy);\n    totalR = _max(totalR, dx + item.width);\n    totalB = _max(totalB, dy + item.height);\n    moves.push([dx, dy]);\n  });\n\n  if (forceMode || !hasHiddenItems) {\n    xOffset = 0;\n\n    if (cell.right) {\n      xOffset = cellRect[2] - cellRect[0] - totalR + totalL;\n    } else if (cell.center) {\n      xOffset = _round((cellRect[2] - cellRect[0] - totalR + totalL) / 2);\n    }\n\n    _each(cell.items, function (i, item) {\n      var move = moves[i];\n\n      if (move) {\n        item.item.locate(move[0] + xOffset, move[1]);\n      } else {\n        item.item.resize(null);\n      }\n    });\n\n    cell.rect = [totalL, totalT, totalR, totalB];\n    cell.items = null;\n  }\n\n  return hasHiddenItems;\n}\n\nfunction applyLayout(canvas, items) {\n  var cells = createCells(canvas, items);\n\n  if (adjustCellsAndApplyLayout(cells)) {\n    adjustCellsAndApplyLayout(cells, true);\n  }\n}\n\nexport function LayoutControl(widget) {\n  var that = this;\n  that._items = [];\n  that._suspended = 0;\n  that._widget = widget;\n\n  that._updateLayout = function () {\n    that._update();\n  };\n}\nLayoutControl.prototype = {\n  constructor: LayoutControl,\n  dispose: function dispose() {\n    this._items = this._updateLayout = null;\n  },\n  setSize: function setSize(canvas) {\n    this._canvas = canvas;\n\n    this._update();\n  },\n  suspend: function suspend() {\n    ++this._suspended;\n  },\n  resume: function resume() {\n    if (0 === --this._suspended) {\n      this._update();\n    }\n  },\n  addItem: function addItem(item) {\n    this._items.push(item);\n\n    item.updateLayout = this._updateLayout;\n  },\n  removeItem: function removeItem(item) {\n    this._items.splice(_inArray(item, this._items), 1);\n\n    item.updateLayout = null;\n  },\n  _update: function _update() {\n    var canvas;\n\n    if (0 === this._suspended) {\n      canvas = this._canvas;\n\n      _each(this._items, function (_, item) {\n        item.resize(canvas);\n      });\n\n      this._widget.resolveItemsDeferred(this._items.filter(function (el) {\n        return el.getTemplatesGroups && el.getTemplatesDef;\n      }));\n\n      applyLayout({\n        left: canvas.left,\n        top: canvas.top,\n        right: canvas.width + canvas.left,\n        bottom: canvas.height + canvas.top\n      }, this._items);\n    }\n  }\n};","map":null,"metadata":{},"sourceType":"module"}