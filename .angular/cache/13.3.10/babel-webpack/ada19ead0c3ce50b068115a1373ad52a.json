{"ast":null,"code":"/**\r\n * DevExtreme (esm/viz/chart_components/zoom_and_pan.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { isDefined } from \"../../core/utils/type\";\nimport { extend } from \"../../core/utils/extend\";\nimport { normalizeEnum, getVizRangeObject } from \"../core/utils\";\nimport { name as wheelEvent } from \"../../events/core/wheel\";\nimport * as transformEvents from \"../../events/transform\";\nimport { start as dragEventStart, move as dragEventMove, end as dragEventEnd } from \"../../events/drag\";\nvar EVENTS_NS = \".zoomAndPanNS\";\nvar DRAG_START_EVENT_NAME = dragEventStart + EVENTS_NS;\nvar DRAG_EVENT_NAME = dragEventMove + EVENTS_NS;\nvar DRAG_END_EVENT_NAME = dragEventEnd + EVENTS_NS;\nvar PINCH_START_EVENT_NAME = transformEvents.pinchstart + EVENTS_NS;\nvar PINCH_EVENT_NAME = transformEvents.pinch + EVENTS_NS;\nvar PINCH_END_EVENT_NAME = transformEvents.pinchend + EVENTS_NS;\nvar SCROLL_BAR_START_EVENT_NAME = \"dxc-scroll-start\" + EVENTS_NS;\nvar SCROLL_BAR_MOVE_EVENT_NAME = \"dxc-scroll-move\" + EVENTS_NS;\nvar SCROLL_BAR_END_EVENT_NAME = \"dxc-scroll-end\" + EVENTS_NS;\nvar GESTURE_TIMEOUT = 300;\nvar MIN_DRAG_DELTA = 5;\nvar _min = Math.min;\nvar _max = Math.max;\nvar _abs = Math.abs;\n\nfunction canvasToRect(canvas) {\n  return {\n    x: canvas.left,\n    y: canvas.top,\n    width: canvas.width - canvas.left - canvas.right,\n    height: canvas.height - canvas.top - canvas.bottom\n  };\n}\n\nfunction checkCoords(rect, coords) {\n  var x = coords.x;\n  var y = coords.y;\n  return x >= rect.x && x <= rect.width + rect.x && y >= rect.y && y <= rect.height + rect.y;\n}\n\nfunction sortAxes(axes, onlyAxisToNotify) {\n  if (onlyAxisToNotify) {\n    axes = axes.sort(function (a, b) {\n      if (a === onlyAxisToNotify) {\n        return -1;\n      }\n\n      if (b === onlyAxisToNotify) {\n        return 1;\n      }\n\n      return 0;\n    });\n  }\n\n  return axes;\n}\n\nfunction isNotEmptyAxisBusinessRange(axis) {\n  return !axis.getTranslator().getBusinessRange().isEmpty();\n}\n\nfunction axisZoom(axis, onlyAxisToNotify, getRange, getParameters, actionField, scale, e) {\n  var silent = onlyAxisToNotify && axis !== onlyAxisToNotify;\n  var range = getRange(axis);\n\n  var _axis$checkZoomingLow = axis.checkZoomingLowerLimitOvercome(actionField, scale, range),\n      stopInteraction = _axis$checkZoomingLow.stopInteraction,\n      correctedRange = _axis$checkZoomingLow.correctedRange;\n\n  var result = axis.handleZooming(stopInteraction ? null : correctedRange, getParameters(silent), e, actionField);\n  stopInteraction && axis.handleZoomEnd();\n  return {\n    stopInteraction: stopInteraction,\n    result: result\n  };\n}\n\nexport default {\n  name: \"zoom_and_pan\",\n  init: function init() {\n    var chart = this;\n    var renderer = this._renderer;\n\n    function cancelEvent(e) {\n      if (e.originalEvent) {\n        cancelEvent(e.originalEvent);\n      }\n\n      if (false !== e.cancelable) {\n        e.cancel = true;\n      }\n    }\n\n    function startAxesViewportChanging(zoomAndPan, actionField, e) {\n      var options = zoomAndPan.options;\n      var actionData = zoomAndPan.actionData;\n      var axes = [];\n\n      if (options.argumentAxis[actionField]) {\n        axes.push(chart.getArgumentAxis());\n      }\n\n      if (options.valueAxis[actionField]) {\n        axes = axes.concat(actionData.valueAxes);\n      }\n\n      axes.reduce(function (isPrevented, axis) {\n        if (isPrevented) {\n          return isPrevented;\n        }\n\n        if (isNotEmptyAxisBusinessRange(axis)) {\n          return axis.handleZooming(null, {\n            end: true\n          }, e, actionField).isPrevented;\n        }\n\n        return isPrevented;\n      }, false) && cancelEvent(e);\n    }\n\n    function axesViewportChanging(zoomAndPan, actionField, e, offsetCalc, centerCalc) {\n      function zoomAxes(axes, criteria, coordField, e, actionData) {\n        var zoom = {\n          zoomed: false\n        };\n        criteria && axes.filter(isNotEmptyAxisBusinessRange).forEach(function (axis) {\n          var options = axis.getOptions();\n          var viewport = axis.visualRange();\n          var scale = axis.getTranslator().getEventScale(e);\n          var translate = -offsetCalc(e, actionData, coordField, scale);\n          zoom = extend(true, zoom, axis.getTranslator().zoom(translate, scale, axis.getZoomBounds()));\n          var range = axis.adjustRange(getVizRangeObject([zoom.min, zoom.max]));\n\n          var _axis$checkZoomingLow2 = axis.checkZoomingLowerLimitOvercome(actionField, scale, range),\n              stopInteraction = _axis$checkZoomingLow2.stopInteraction,\n              correctedRange = _axis$checkZoomingLow2.correctedRange;\n\n          if (!isDefined(viewport) || viewport.startValue.valueOf() !== correctedRange.startValue.valueOf() || viewport.endValue.valueOf() !== correctedRange.endValue.valueOf()) {\n            axis.handleZooming(stopInteraction ? null : correctedRange, {\n              start: true,\n              end: true\n            }, e, actionField);\n\n            if (!stopInteraction) {\n              zoom.zoomed = true;\n              zoom.deltaTranslate = translate - zoom.translate;\n            }\n          } else if (\"touch\" === e.pointerType && \"discrete\" === options.type) {\n            var isMinPosition = axis.isExtremePosition(false);\n            var isMaxPosition = axis.isExtremePosition(true);\n            var zoomInEnabled = scale > 1 && !stopInteraction;\n            var zoomOutEnabled = scale < 1 && (!isMinPosition || !isMaxPosition);\n            var panningEnabled = 1 === scale && !(isMinPosition && (translate < 0 && !options.inverted || translate > 0 && options.inverted) || isMaxPosition && (translate > 0 && !options.inverted || translate < 0 && options.inverted));\n            zoom.enabled = zoomInEnabled || zoomOutEnabled || panningEnabled;\n          }\n        });\n        return zoom;\n      }\n\n      function storeOffset(e, actionData, zoom, coordField) {\n        if (zoom.zoomed) {\n          actionData.offset[coordField] = (e.offset ? e.offset[coordField] : actionData.offset[coordField]) + zoom.deltaTranslate;\n        }\n      }\n\n      function storeCenter(center, actionData, zoom, coordField) {\n        if (zoom.zoomed) {\n          actionData.center[coordField] = center[coordField] + zoom.deltaTranslate;\n        }\n      }\n\n      var rotated = chart.option(\"rotated\");\n      var actionData = zoomAndPan.actionData;\n      var options = zoomAndPan.options;\n      var argZoom = {};\n      var valZoom = {};\n\n      if (!actionData.fallback) {\n        argZoom = zoomAxes(chart._argumentAxes, options.argumentAxis[actionField], rotated ? \"y\" : \"x\", e, actionData);\n        valZoom = zoomAxes(actionData.valueAxes, options.valueAxis[actionField], rotated ? \"x\" : \"y\", e, actionData);\n\n        chart._requestChange([\"VISUAL_RANGE\"]);\n\n        storeOffset(e, actionData, argZoom, rotated ? \"y\" : \"x\");\n        storeOffset(e, actionData, valZoom, rotated ? \"x\" : \"y\");\n      }\n\n      var center = centerCalc(e);\n      storeCenter(center, actionData, argZoom, rotated ? \"y\" : \"x\");\n      storeCenter(center, actionData, valZoom, rotated ? \"x\" : \"y\");\n\n      if (!argZoom.zoomed && !valZoom.zoomed) {\n        actionData.center = center;\n      }\n\n      return argZoom.zoomed || valZoom.zoomed || actionData.fallback || argZoom.enabled || valZoom.enabled;\n    }\n\n    function finishAxesViewportChanging(zoomAndPan, actionField, e, offsetCalc) {\n      function zoomAxes(axes, criteria, coordField, actionData, onlyAxisToNotify) {\n        var zoomStarted = false;\n        var scale = e.scale || 1;\n\n        var getRange = function getRange(axis) {\n          var zoom = axis.getTranslator().zoom(-offsetCalc(e, actionData, coordField, scale), scale, axis.getZoomBounds());\n          return {\n            startValue: zoom.min,\n            endValue: zoom.max\n          };\n        };\n\n        var getParameters = function getParameters(silent) {\n          return {\n            start: true,\n            end: silent\n          };\n        };\n\n        criteria && axes.forEach(function (axis) {\n          zoomStarted = !axisZoom(axis, onlyAxisToNotify, getRange, getParameters, actionField, scale, e).stopInteraction;\n        });\n        return zoomStarted;\n      }\n\n      var rotated = chart.option(\"rotated\");\n      var actionData = zoomAndPan.actionData;\n      var options = zoomAndPan.options;\n      var zoomStarted = true;\n\n      if (actionData.fallback) {\n        zoomStarted &= zoomAxes(chart._argumentAxes, options.argumentAxis[actionField], rotated ? \"y\" : \"x\", actionData, chart.getArgumentAxis());\n        zoomStarted |= zoomAxes(actionData.valueAxes, options.valueAxis[actionField], rotated ? \"x\" : \"y\", actionData);\n      } else {\n        var axes = [];\n\n        if (options.argumentAxis[actionField]) {\n          axes.push(chart.getArgumentAxis());\n        }\n\n        if (options.valueAxis[actionField]) {\n          axes = axes.concat(actionData.valueAxes);\n        }\n\n        axes.filter(isNotEmptyAxisBusinessRange).forEach(function (axis) {\n          axis.handleZooming(null, {\n            start: true\n          }, e, actionField);\n        });\n        zoomStarted = axes.length;\n      }\n\n      zoomStarted && chart._requestChange([\"VISUAL_RANGE\"]);\n    }\n\n    function prepareActionData(coords, action) {\n      var axes = chart._argumentAxes.filter(function (axis) {\n        return checkCoords(canvasToRect(axis.getCanvas()), coords);\n      });\n\n      return {\n        fallback: chart._lastRenderingTime > GESTURE_TIMEOUT,\n        cancel: !axes.length || !isDefined(action),\n        action: action,\n        curAxisRect: axes.length && canvasToRect(axes[0].getCanvas()),\n        valueAxes: axes.length && chart._valueAxes.filter(function (axis) {\n          return checkCoords(canvasToRect(axis.getCanvas()), coords);\n        }),\n        offset: {\n          x: 0,\n          y: 0\n        },\n        center: coords,\n        startCenter: coords\n      };\n    }\n\n    function getPointerCoord(rect, e) {\n      var rootOffset = renderer.getRootOffset();\n      return {\n        x: _min(_max(e.pageX - rootOffset.left, rect.x), rect.width + rect.x),\n        y: _min(_max(e.pageY - rootOffset.top, rect.y), rect.height + rect.y)\n      };\n    }\n\n    function calcCenterForPinch(e) {\n      var rootOffset = renderer.getRootOffset();\n      var x1 = e.pointers[0].pageX;\n      var x2 = e.pointers[1].pageX;\n      var y1 = e.pointers[0].pageY;\n      var y2 = e.pointers[1].pageY;\n      return {\n        x: _min(x1, x2) + _abs(x2 - x1) / 2 - rootOffset.left,\n        y: _min(y1, y2) + _abs(y2 - y1) / 2 - rootOffset.top\n      };\n    }\n\n    function calcCenterForDrag(e) {\n      var rootOffset = renderer.getRootOffset();\n      return {\n        x: e.pageX - rootOffset.left,\n        y: e.pageY - rootOffset.top\n      };\n    }\n\n    function calcOffsetForDrag(e, actionData, coordField) {\n      return e.offset[coordField] - actionData.offset[coordField];\n    }\n\n    function preventDefaults(e) {\n      if (false !== e.cancelable) {\n        e.preventDefault();\n        e.stopPropagation();\n      }\n\n      chart._stopCurrentHandling();\n    }\n\n    var zoomAndPan = {\n      dragStartHandler: function dragStartHandler(e) {\n        var options = zoomAndPan.options;\n        var isTouch = \"touch\" === e.pointerType;\n        var wantPan = options.argumentAxis.pan || options.valueAxis.pan;\n        var wantZoom = options.argumentAxis.zoom || options.valueAxis.zoom;\n        var panKeyPressed = isDefined(options.panKey) && e[normalizeEnum(options.panKey) + \"Key\"];\n        var dragToZoom = options.dragToZoom;\n        var action;\n        e._cancelPreventDefault = true;\n\n        if (isTouch) {\n          if (options.allowTouchGestures && wantPan) {\n            var cancelPanning = !zoomAndPan.panningVisualRangeEnabled() || zoomAndPan.skipEvent;\n            action = cancelPanning ? null : \"pan\";\n          }\n        } else if (dragToZoom && wantPan && panKeyPressed) {\n          action = \"pan\";\n        } else if (!dragToZoom && wantPan) {\n          action = \"pan\";\n        } else if (dragToZoom && wantZoom) {\n          action = \"zoom\";\n        }\n\n        var actionData = prepareActionData(calcCenterForDrag(e), action);\n\n        if (actionData.cancel) {\n          zoomAndPan.skipEvent = false;\n\n          if (false !== e.cancelable) {\n            e.cancel = true;\n          }\n\n          return;\n        }\n\n        zoomAndPan.actionData = actionData;\n\n        if (\"zoom\" === action) {\n          actionData.startCoords = getPointerCoord(actionData.curAxisRect, e);\n          actionData.rect = renderer.rect(0, 0, 0, 0).attr(options.dragBoxStyle).append(renderer.root);\n        } else {\n          startAxesViewportChanging(zoomAndPan, \"pan\", e);\n        }\n      },\n      dragHandler: function dragHandler(e) {\n        var rotated = chart.option(\"rotated\");\n        var options = zoomAndPan.options;\n        var actionData = zoomAndPan.actionData;\n        var isTouch = \"touch\" === e.pointerType;\n        e._cancelPreventDefault = true;\n\n        if (!actionData || isTouch && !zoomAndPan.panningVisualRangeEnabled()) {\n          return;\n        }\n\n        if (\"zoom\" === actionData.action) {\n          preventDefaults(e);\n          var curCanvas = actionData.curAxisRect;\n          var startCoords = actionData.startCoords;\n          var curCoords = getPointerCoord(curCanvas, e);\n          var zoomArg = options.argumentAxis.zoom;\n          var zoomVal = options.valueAxis.zoom;\n          var rect = {\n            x: _min(startCoords.x, curCoords.x),\n            y: _min(startCoords.y, curCoords.y),\n            width: _abs(startCoords.x - curCoords.x),\n            height: _abs(startCoords.y - curCoords.y)\n          };\n\n          if (!zoomArg || !zoomVal) {\n            if (!zoomArg && !rotated || !zoomVal && rotated) {\n              rect.x = curCanvas.x;\n              rect.width = curCanvas.width;\n            } else {\n              rect.y = curCanvas.y;\n              rect.height = curCanvas.height;\n            }\n          }\n\n          actionData.rect.attr(rect);\n        } else if (\"pan\" === actionData.action) {\n          axesViewportChanging(zoomAndPan, \"pan\", e, calcOffsetForDrag, function (e) {\n            return e.offset;\n          });\n          var deltaOffsetY = Math.abs(e.offset.y - actionData.offset.y);\n          var deltaOffsetX = Math.abs(e.offset.x - actionData.offset.x);\n\n          if (isTouch && (deltaOffsetY > MIN_DRAG_DELTA && deltaOffsetY > Math.abs(actionData.offset.x) || deltaOffsetX > MIN_DRAG_DELTA && deltaOffsetX > Math.abs(actionData.offset.y))) {\n            return;\n          }\n\n          preventDefaults(e);\n        }\n      },\n      dragEndHandler: function dragEndHandler(e) {\n        var rotated = chart.option(\"rotated\");\n        var options = zoomAndPan.options;\n        var actionData = zoomAndPan.actionData;\n        var isTouch = \"touch\" === e.pointerType;\n        var panIsEmpty = actionData && \"pan\" === actionData.action && !actionData.fallback && 0 === actionData.offset.x && 0 === actionData.offset.y;\n\n        if (!actionData || isTouch && !zoomAndPan.panningVisualRangeEnabled() || panIsEmpty) {\n          return;\n        }\n\n        (!isTouch || !zoomAndPan.actionData.isNative) && preventDefaults(e);\n\n        if (\"zoom\" === actionData.action) {\n          var zoomAxes = function zoomAxes(axes, criteria, coordField, startCoords, curCoords, onlyAxisToNotify) {\n            axes = sortAxes(axes, onlyAxisToNotify);\n            var curCoord = curCoords[coordField];\n            var startCoord = startCoords[coordField];\n            var zoomStarted = false;\n\n            var getParameters = function getParameters(silent) {\n              return {\n                start: !!silent,\n                end: !!silent\n              };\n            };\n\n            if (criteria && _abs(curCoord - startCoord) > MIN_DRAG_DELTA) {\n              axes.some(function (axis) {\n                var tr = axis.getTranslator();\n\n                if (tr.getBusinessRange().isEmpty()) {\n                  return;\n                }\n\n                var _axisZoom = axisZoom(axis, onlyAxisToNotify, function () {\n                  return [tr.from(startCoord), tr.from(curCoord)];\n                }, getParameters, actionData.action, tr.getMinScale(true), e),\n                    stopInteraction = _axisZoom.stopInteraction,\n                    result = _axisZoom.result;\n\n                zoomStarted = !stopInteraction;\n                return onlyAxisToNotify && result.isPrevented;\n              });\n            }\n\n            return zoomStarted;\n          };\n\n          var curCoords = getPointerCoord(actionData.curAxisRect, e);\n          var argumentAxesZoomed = zoomAxes(chart._argumentAxes, options.argumentAxis.zoom, rotated ? \"y\" : \"x\", actionData.startCoords, curCoords, chart.getArgumentAxis());\n          var valueAxesZoomed = zoomAxes(actionData.valueAxes, options.valueAxis.zoom, rotated ? \"x\" : \"y\", actionData.startCoords, curCoords);\n\n          if (valueAxesZoomed || argumentAxesZoomed) {\n            chart._requestChange([\"VISUAL_RANGE\"]);\n          }\n\n          actionData.rect.dispose();\n        } else if (\"pan\" === actionData.action) {\n          finishAxesViewportChanging(zoomAndPan, \"pan\", e, calcOffsetForDrag);\n        }\n\n        zoomAndPan.actionData = null;\n      },\n      pinchStartHandler: function pinchStartHandler(e) {\n        var actionData = prepareActionData(calcCenterForPinch(e), \"zoom\");\n        actionData.isNative = !zoomAndPan.panningVisualRangeEnabled();\n\n        if (actionData.cancel) {\n          cancelEvent(e);\n          return;\n        }\n\n        zoomAndPan.actionData = actionData;\n        startAxesViewportChanging(zoomAndPan, \"zoom\", e);\n      },\n      pinchHandler: function pinchHandler(e) {\n        if (!zoomAndPan.actionData) {\n          return;\n        }\n\n        var viewportChanged = axesViewportChanging(zoomAndPan, \"zoom\", e, function (e, actionData, coordField, scale) {\n          return calcCenterForPinch(e)[coordField] - actionData.center[coordField] + (actionData.center[coordField] - actionData.center[coordField] * scale);\n        }, calcCenterForPinch);\n        zoomAndPan.defineTouchBehavior(!viewportChanged, e);\n        !viewportChanged && (zoomAndPan.actionData = null);\n      },\n      pinchEndHandler: function pinchEndHandler(e) {\n        if (!zoomAndPan.actionData) {\n          return;\n        }\n\n        finishAxesViewportChanging(zoomAndPan, \"zoom\", e, function (e, actionData, coordField, scale) {\n          return actionData.center[coordField] - actionData.startCenter[coordField] + (actionData.startCenter[coordField] - actionData.startCenter[coordField] * scale);\n        });\n        zoomAndPan.actionData = null;\n      },\n      cleanup: function cleanup() {\n        renderer.root.off(EVENTS_NS);\n        zoomAndPan.actionData && zoomAndPan.actionData.rect && zoomAndPan.actionData.rect.dispose();\n        zoomAndPan.actionData = null;\n        renderer.root.css({\n          \"touch-action\": \"\",\n          \"-ms-touch-action\": \"\"\n        });\n      },\n      setup: function setup(options) {\n        zoomAndPan.cleanup();\n\n        if (!options.argumentAxis.pan) {\n          renderer.root.on(SCROLL_BAR_START_EVENT_NAME, cancelEvent);\n        }\n\n        if (options.argumentAxis.none && options.valueAxis.none) {\n          return;\n        }\n\n        zoomAndPan.options = options;\n        var rotated = chart.option(\"rotated\");\n\n        if ((options.argumentAxis.zoom || options.valueAxis.zoom) && options.allowMouseWheel) {\n          renderer.root.on(wheelEvent + EVENTS_NS, function (e) {\n            function zoomAxes(axes, coord, delta, onlyAxisToNotify) {\n              axes = sortAxes(axes, onlyAxisToNotify);\n              var zoomStarted = false;\n\n              var getParameters = function getParameters(silent) {\n                return {\n                  start: !!silent,\n                  end: !!silent\n                };\n              };\n\n              axes.some(function (axis) {\n                var translator = axis.getTranslator();\n\n                if (translator.getBusinessRange().isEmpty()) {\n                  return;\n                }\n\n                var scale = translator.getMinScale(delta > 0);\n\n                var _axisZoom2 = axisZoom(axis, onlyAxisToNotify, function () {\n                  var zoom = translator.zoom(-(coord - coord * scale), scale, axis.getZoomBounds());\n                  return {\n                    startValue: zoom.min,\n                    endValue: zoom.max\n                  };\n                }, getParameters, \"zoom\", scale, e),\n                    stopInteraction = _axisZoom2.stopInteraction,\n                    result = _axisZoom2.result;\n\n                zoomStarted = !stopInteraction;\n                return onlyAxisToNotify && result.isPrevented;\n              });\n              return zoomStarted;\n            }\n\n            var coords = calcCenterForDrag(e);\n            var axesZoomed = false;\n            var targetAxes;\n\n            if (options.valueAxis.zoom) {\n              targetAxes = chart._valueAxes.filter(function (axis) {\n                return checkCoords(canvasToRect(axis.getCanvas()), coords);\n              });\n\n              if (0 === targetAxes.length) {\n                var targetCanvas = chart._valueAxes.reduce(function (r, axis) {\n                  if (!r && axis.coordsIn(coords.x, coords.y)) {\n                    r = axis.getCanvas();\n                  }\n\n                  return r;\n                }, null);\n\n                if (targetCanvas) {\n                  targetAxes = chart._valueAxes.filter(function (axis) {\n                    return checkCoords(canvasToRect(axis.getCanvas()), {\n                      x: targetCanvas.left,\n                      y: targetCanvas.top\n                    });\n                  });\n                }\n              }\n\n              axesZoomed |= zoomAxes(targetAxes, rotated ? coords.x : coords.y, e.delta);\n            }\n\n            if (options.argumentAxis.zoom) {\n              var canZoom = chart._argumentAxes.some(function (axis) {\n                if (checkCoords(canvasToRect(axis.getCanvas()), coords) || axis.coordsIn(coords.x, coords.y)) {\n                  return true;\n                }\n\n                return false;\n              });\n\n              axesZoomed |= canZoom && zoomAxes(chart._argumentAxes, rotated ? coords.y : coords.x, e.delta, chart.getArgumentAxis());\n            }\n\n            if (axesZoomed) {\n              chart._requestChange([\"VISUAL_RANGE\"]);\n\n              zoomAndPan.panningVisualRangeEnabled(targetAxes) && preventDefaults(e);\n            }\n          });\n        }\n\n        if (options.allowTouchGestures) {\n          if (options.argumentAxis.zoom || options.valueAxis.zoom) {\n            renderer.root.on(PINCH_START_EVENT_NAME, {\n              passive: false\n            }, zoomAndPan.pinchStartHandler).on(PINCH_EVENT_NAME, {\n              passive: false\n            }, zoomAndPan.pinchHandler).on(PINCH_END_EVENT_NAME, zoomAndPan.pinchEndHandler);\n          }\n        }\n\n        renderer.root.on(DRAG_START_EVENT_NAME, {\n          immediate: true,\n          passive: false\n        }, zoomAndPan.dragStartHandler).on(DRAG_EVENT_NAME, {\n          immediate: true,\n          passive: false\n        }, zoomAndPan.dragHandler).on(DRAG_END_EVENT_NAME, zoomAndPan.dragEndHandler);\n\n        if (options.argumentAxis.pan) {\n          renderer.root.on(SCROLL_BAR_START_EVENT_NAME, function (e) {\n            zoomAndPan.actionData = {\n              valueAxes: [],\n              offset: {\n                x: 0,\n                y: 0\n              },\n              center: {\n                x: 0,\n                y: 0\n              }\n            };\n            preventDefaults(e);\n            startAxesViewportChanging(zoomAndPan, \"pan\", e);\n          }).on(SCROLL_BAR_MOVE_EVENT_NAME, function (e) {\n            preventDefaults(e);\n            axesViewportChanging(zoomAndPan, \"pan\", e, calcOffsetForDrag, function (e) {\n              return e.offset;\n            });\n          }).on(SCROLL_BAR_END_EVENT_NAME, function (e) {\n            preventDefaults(e);\n            finishAxesViewportChanging(zoomAndPan, \"pan\", e, calcOffsetForDrag);\n            zoomAndPan.actionData = null;\n          });\n        }\n      },\n      defineTouchBehavior: function defineTouchBehavior(isDefault, e) {\n        zoomAndPan.actionData && (zoomAndPan.actionData.isNative = isDefault);\n\n        if (!isDefault) {\n          preventDefaults(e);\n        }\n      },\n      panningVisualRangeEnabled: function panningVisualRangeEnabled(targetAxes) {\n        if (null !== targetAxes && void 0 !== targetAxes && targetAxes.length) {\n          return targetAxes.some(function (axis) {\n            return !axis.isExtremePosition(false) || !axis.isExtremePosition(true);\n          });\n        }\n\n        var enablePanByValueAxis = chart._valueAxes.some(function (axis) {\n          return !axis.isExtremePosition(false) || !axis.isExtremePosition(true);\n        });\n\n        var enablePanByArgumentAxis = chart._argumentAxes.some(function (axis) {\n          return !axis.isExtremePosition(false) || !axis.isExtremePosition(true);\n        });\n\n        return enablePanByValueAxis || enablePanByArgumentAxis;\n      }\n    };\n    this._zoomAndPan = zoomAndPan;\n  },\n  members: {\n    _setupZoomAndPan: function _setupZoomAndPan() {\n      this._zoomAndPan.setup(this._themeManager.getOptions(\"zoomAndPan\"));\n    }\n  },\n  dispose: function dispose() {\n    this._zoomAndPan.cleanup();\n  },\n  customize: function customize(constructor) {\n    constructor.addChange({\n      code: \"ZOOM_AND_PAN\",\n      handler: function handler() {\n        this._setupZoomAndPan();\n      },\n      isThemeDependent: true,\n      isOptionChange: true,\n      option: \"zoomAndPan\"\n    });\n  }\n};","map":null,"metadata":{},"sourceType":"module"}