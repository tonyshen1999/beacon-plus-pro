{"ast":null,"code":"import _slicedToArray from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _toConsumableArray from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\n\n/**\r\n * DevExtreme (esm/viz/funnel/label.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { Label } from \"../series/points/label\";\nimport { normalizeEnum } from \"../core/utils\";\nimport { extend } from \"../../core/utils/extend\";\nimport { noop } from \"../../core/utils/common\";\nvar OUTSIDE_POSITION = \"outside\";\nvar INSIDE_POSITION = \"inside\";\nvar OUTSIDE_LABEL_INDENT = 5;\nvar COLUMNS_LABEL_INDENT = 20;\nvar CONNECTOR_INDENT = 4;\nvar PREVENT_EMPTY_PIXEL_OFFSET = 1;\n\nfunction getLabelIndent(pos) {\n  pos = normalizeEnum(pos);\n\n  if (pos === OUTSIDE_POSITION) {\n    return OUTSIDE_LABEL_INDENT;\n  } else if (pos === INSIDE_POSITION) {\n    return 0;\n  }\n\n  return COLUMNS_LABEL_INDENT;\n}\n\nfunction isOutsidePosition(pos) {\n  pos = normalizeEnum(pos);\n  return pos === OUTSIDE_POSITION || pos !== INSIDE_POSITION;\n}\n\nfunction correctYForInverted(y, bBox, inverted) {\n  return inverted ? y - bBox.height : y;\n}\n\nfunction getOutsideRightLabelPosition(coords, bBox, options, inverted) {\n  return {\n    x: coords[2] + options.horizontalOffset + OUTSIDE_LABEL_INDENT,\n    y: correctYForInverted(coords[3] + options.verticalOffset, bBox, inverted)\n  };\n}\n\nfunction getOutsideLeftLabelPosition(coords, bBox, options, inverted) {\n  return {\n    x: coords[0] - bBox.width - options.horizontalOffset - OUTSIDE_LABEL_INDENT,\n    y: correctYForInverted(coords[1] + options.verticalOffset, bBox, inverted)\n  };\n}\n\nfunction getInsideLabelPosition(coords, bBox, options) {\n  var width = coords[2] - coords[0];\n  var height = coords[7] - coords[1];\n  return {\n    x: coords[0] + width / 2 + options.horizontalOffset - bBox.width / 2,\n    y: coords[1] + options.verticalOffset + height / 2 - bBox.height / 2\n  };\n}\n\nfunction getColumnLabelRightPosition(labelRect, rect, textAlignment) {\n  return function (coords, bBox, options, inverted) {\n    return {\n      x: \"left\" === textAlignment ? rect[2] + options.horizontalOffset + COLUMNS_LABEL_INDENT : labelRect[2] - bBox.width,\n      y: correctYForInverted(coords[3] + options.verticalOffset, bBox, inverted)\n    };\n  };\n}\n\nfunction getColumnLabelLeftPosition(labelRect, rect, textAlignment) {\n  return function (coords, bBox, options, inverted) {\n    return {\n      x: \"left\" === textAlignment ? labelRect[0] : rect[0] - bBox.width - options.horizontalOffset - COLUMNS_LABEL_INDENT,\n      y: correctYForInverted(coords[3] + options.verticalOffset, bBox, inverted)\n    };\n  };\n}\n\nfunction getConnectorStrategy(options, inverted) {\n  var isLeftPos = \"left\" === options.horizontalAlignment;\n  var connectorIndent = isLeftPos ? CONNECTOR_INDENT : -CONNECTOR_INDENT;\n  var verticalCorrection = inverted ? -PREVENT_EMPTY_PIXEL_OFFSET : 0;\n\n  function getFigureCenter(figure) {\n    return isLeftPos ? [figure[0] + PREVENT_EMPTY_PIXEL_OFFSET, figure[1] + verticalCorrection] : [figure[2] - PREVENT_EMPTY_PIXEL_OFFSET, figure[3] + verticalCorrection];\n  }\n\n  return {\n    isLabelInside: function isLabelInside() {\n      return !isOutsidePosition(options.position);\n    },\n    getFigureCenter: getFigureCenter,\n    prepareLabelPoints: function prepareLabelPoints(bBox) {\n      var x = bBox.x + connectorIndent;\n      var y = bBox.y;\n      var x1 = x + bBox.width;\n      return _toConsumableArray(Array(bBox.height + 1)).map(function (_, i) {\n        return [x, y + i];\n      }).concat(_toConsumableArray(Array(bBox.height + 1)).map(function (_, i) {\n        return [x1, y + i];\n      }));\n    },\n    isHorizontal: function isHorizontal() {\n      return true;\n    },\n    findFigurePoint: function findFigurePoint(figure) {\n      return getFigureCenter(figure);\n    },\n    adjustPoints: function adjustPoints(points) {\n      return points.map(Math.round);\n    }\n  };\n}\n\nfunction getLabelOptions(labelOptions, defaultColor, defaultTextAlignment) {\n  var opt = labelOptions || {};\n  var labelFont = extend({}, opt.font) || {};\n  var labelBorder = opt.border || {};\n  var labelConnector = opt.connector || {};\n  var backgroundAttr = {\n    fill: opt.backgroundColor || defaultColor,\n    \"stroke-width\": labelBorder.visible ? labelBorder.width || 0 : 0,\n    stroke: labelBorder.visible && labelBorder.width ? labelBorder.color : \"none\",\n    dashStyle: labelBorder.dashStyle\n  };\n  var connectorAttr = {\n    stroke: labelConnector.visible && labelConnector.width ? labelConnector.color || defaultColor : \"none\",\n    \"stroke-width\": labelConnector.visible ? labelConnector.width || 0 : 0,\n    opacity: labelConnector.opacity\n  };\n  labelFont.color = \"none\" === opt.backgroundColor && \"#ffffff\" === normalizeEnum(labelFont.color) && \"inside\" !== opt.position ? defaultColor : labelFont.color;\n  return {\n    format: opt.format,\n    textAlignment: opt.textAlignment || (isOutsidePosition(opt.position) ? defaultTextAlignment : \"center\"),\n    customizeText: opt.customizeText,\n    attributes: {\n      font: labelFont\n    },\n    visible: 0 !== labelFont.size ? opt.visible : false,\n    showForZeroValues: opt.showForZeroValues,\n    horizontalOffset: opt.horizontalOffset,\n    verticalOffset: opt.verticalOffset,\n    background: backgroundAttr,\n    connector: connectorAttr,\n    wordWrap: labelOptions.wordWrap,\n    textOverflow: labelOptions.textOverflow\n  };\n}\n\nfunction correctLabelPosition(pos, bBox, rect) {\n  if (pos.x < rect[0]) {\n    pos.x = rect[0];\n  }\n\n  if (pos.x + bBox.width > rect[2]) {\n    pos.x = rect[2] - bBox.width;\n  }\n\n  if (pos.y < rect[1]) {\n    pos.y = rect[1];\n  }\n\n  if (pos.y + bBox.height > rect[3]) {\n    pos.y = rect[3] - bBox.height;\n  }\n\n  return pos;\n}\n\nfunction removeEmptySpace(labels, requiredSpace, startPoint) {\n  labels.reduce(function (requiredSpace, label, index, labels) {\n    var prevLabel = labels[index + 1];\n\n    if (requiredSpace > 0) {\n      var bBox = label.getBoundingRect();\n      var point = prevLabel ? prevLabel.getBoundingRect().y + prevLabel.getBoundingRect().height : startPoint;\n      var emptySpace = bBox.y - point;\n      var shift = Math.min(emptySpace, requiredSpace);\n      labels.slice(0, index + 1).forEach(function (label) {\n        var bBox = label.getBoundingRect();\n        label.shift(bBox.x, bBox.y - shift);\n      });\n      requiredSpace -= shift;\n    }\n\n    return requiredSpace;\n  }, requiredSpace);\n}\n\nexport var plugin = {\n  name: \"lables\",\n  init: noop,\n  dispose: noop,\n  extenders: {\n    _initCore: function _initCore() {\n      this._labelsGroup = this._renderer.g().attr({\n        class: this._rootClassPrefix + \"-labels\"\n      }).append(this._renderer.root);\n      this._labels = [];\n    },\n    _applySize: function _applySize() {\n      var options = this._getOption(\"label\");\n\n      var adaptiveLayout = this._getOption(\"adaptiveLayout\");\n\n      var rect = this._rect;\n      var labelWidth = 0;\n      var width = rect[2] - rect[0];\n      this._labelRect = rect.slice();\n\n      if (!this._labels.length || !isOutsidePosition(options.position)) {\n        if (normalizeEnum(\"none\" !== this._getOption(\"resolveLabelOverlapping\", true))) {\n          this._labels.forEach(function (l) {\n            return !l.isVisible() && l.draw(true);\n          });\n        }\n\n        return;\n      }\n\n      var groupWidth = this._labels.map(function (label) {\n        label.resetEllipsis();\n        return label.getBoundingRect().width;\n      }).reduce(function (max, width) {\n        return Math.max(max, width);\n      }, 0);\n\n      labelWidth = groupWidth + options.horizontalOffset + getLabelIndent(options.position);\n\n      if (!adaptiveLayout.keepLabels && width - labelWidth < adaptiveLayout.width) {\n        this._labels.forEach(function (label) {\n          label.draw(false);\n        });\n\n        return;\n      } else {\n        if (width - labelWidth < adaptiveLayout.width) {\n          labelWidth = width - adaptiveLayout.width;\n          labelWidth = labelWidth > 0 ? labelWidth : 0;\n        }\n\n        this._labels.forEach(function (label) {\n          label.draw(true);\n        });\n      }\n\n      if (\"left\" === options.horizontalAlignment) {\n        rect[0] += labelWidth;\n      } else {\n        rect[2] -= labelWidth;\n      }\n    },\n    _buildNodes: function _buildNodes() {\n      this._createLabels();\n    },\n    _change_TILING: function _change_TILING() {\n      var that = this;\n\n      var options = that._getOption(\"label\");\n\n      var getCoords = getInsideLabelPosition;\n\n      var inverted = that._getOption(\"inverted\", true);\n\n      var textAlignment;\n\n      if (isOutsidePosition(options.position)) {\n        if (normalizeEnum(options.position) === OUTSIDE_POSITION) {\n          getCoords = \"left\" === options.horizontalAlignment ? getOutsideLeftLabelPosition : getOutsideRightLabelPosition;\n        } else {\n          textAlignment = this._defaultLabelTextAlignment();\n          getCoords = \"left\" === options.horizontalAlignment ? getColumnLabelLeftPosition(this._labelRect, this._rect, textAlignment) : getColumnLabelRightPosition(this._labelRect, this._rect, textAlignment);\n        }\n      }\n\n      that._labels.forEach(function (label, index) {\n        var item = that._items[index];\n        var borderWidth = item.getNormalStyle()[\"stroke-width\"];\n        var halfBorderWidth = inverted ? borderWidth / 2 : -borderWidth / 2;\n        var coords = halfBorderWidth ? item.coords.map(function (coord, index) {\n          if (1 === index || 3 === index) {\n            return coord - halfBorderWidth;\n          } else if (2 === index) {\n            return coord - borderWidth;\n          } else if (0 === index) {\n            return coord + borderWidth;\n          }\n\n          return coord;\n        }) : item.coords;\n\n        if (!options.showForZeroValues && 0 === item.value) {\n          label.draw(false);\n          return;\n        }\n\n        if (isOutsidePosition(options.position)) {\n          that._correctLabelWidth(label, item.coords, options);\n        }\n\n        var bBox = label.getBoundingRect();\n        var pos = correctLabelPosition(getCoords(coords, bBox, options, inverted), bBox, that._labelRect);\n        label.setFigureToDrawConnector(coords);\n        label.shift(pos.x, pos.y);\n      });\n\n      that._resolveLabelOverlapping();\n    }\n  },\n  members: {\n    _resolveLabelOverlapping: function _resolveLabelOverlapping() {\n      var that = this;\n      var resolveLabelOverlapping = normalizeEnum(that._getOption(\"resolveLabelOverlapping\", true));\n      var labels = this._getOption(\"inverted\", true) ? that._labels.slice().reverse() : that._labels;\n\n      if (\"hide\" === resolveLabelOverlapping) {\n        labels.reduce(function (height, label) {\n          if (label.getBoundingRect().y < height) {\n            label.hide();\n          } else {\n            height = label.getBoundingRect().y + label.getBoundingRect().height;\n          }\n\n          return height;\n        }, 0);\n      } else if (\"shift\" === resolveLabelOverlapping) {\n        var maxHeight = this._labelRect[3];\n        labels.reduce(function (_ref, label, index, labels) {\n          var _ref2 = _slicedToArray(_ref, 2),\n              height = _ref2[0],\n              emptySpace = _ref2[1];\n\n          var bBox = label.getBoundingRect();\n          var y = bBox.y;\n\n          if (bBox.y < height) {\n            label.shift(bBox.x, height);\n            y = height;\n          }\n\n          if (y - height > 0) {\n            emptySpace += y - height;\n          }\n\n          if (y + bBox.height > maxHeight) {\n            if (emptySpace && emptySpace > y + bBox.height - maxHeight) {\n              removeEmptySpace(labels.slice(0, index).reverse(), y + bBox.height - maxHeight, that._labelRect[1]);\n              emptySpace -= y + bBox.height - maxHeight;\n              label.shift(bBox.x, y - (y + bBox.height - maxHeight));\n              height = y - (y + bBox.height - maxHeight) + bBox.height;\n            } else {\n              label.hide();\n            }\n          } else {\n            height = y + bBox.height;\n          }\n\n          return [height, emptySpace];\n        }, [this._labelRect[1], 0]);\n      }\n    },\n    _defaultLabelTextAlignment: function _defaultLabelTextAlignment() {\n      return this._getOption(\"rtlEnabled\", true) ? \"right\" : \"left\";\n    },\n    _correctLabelWidth: function _correctLabelWidth(label, item, options) {\n      var isLeftPos = \"left\" === options.horizontalAlignment;\n      var minX = isLeftPos ? this._labelRect[0] : item[2];\n      var maxX = isLeftPos ? item[0] : this._labelRect[2];\n      var maxWidth = maxX - minX;\n\n      if (label.getBoundingRect().width > maxWidth) {\n        label.fit(maxWidth);\n      }\n    },\n    _createLabels: function _createLabels() {\n      var that = this;\n\n      var labelOptions = that._getOption(\"label\");\n\n      var connectorStrategy = getConnectorStrategy(labelOptions, that._getOption(\"inverted\", true));\n\n      this._labelsGroup.clear();\n\n      if (!labelOptions.visible) {\n        return;\n      }\n\n      this._labels = that._items.map(function (item) {\n        var label = new Label({\n          renderer: that._renderer,\n          labelsGroup: that._labelsGroup,\n          strategy: connectorStrategy\n        });\n        label.setOptions(getLabelOptions(labelOptions, item.color, that._defaultLabelTextAlignment()));\n        label.setData({\n          item: item,\n          value: item.value,\n          percent: item.percent\n        });\n        label.draw(true);\n        return label;\n      });\n\n      if (this._labels.length && isOutsidePosition(labelOptions.position)) {\n        this._requestChange([\"LAYOUT\"]);\n      }\n    }\n  },\n  customize: function customize(constructor) {\n    constructor.prototype._proxyData.push(function (x, y) {\n      var that = this;\n      var data;\n\n      that._labels.forEach(function (label, index) {\n        var rect = label.getBoundingRect();\n\n        if (x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height) {\n          var pos = isOutsidePosition(that._getOption(\"label\").position) ? \"outside\" : \"inside\";\n          data = {\n            id: index,\n            type: pos + \"-label\"\n          };\n          return true;\n        }\n      });\n\n      return data;\n    });\n\n    [\"label\", \"resolveLabelOverlapping\"].forEach(function (optionName) {\n      constructor.addChange({\n        code: optionName.toUpperCase(),\n        handler: function handler() {\n          this._createLabels();\n\n          this._requestChange([\"LAYOUT\"]);\n        },\n        isThemeDependent: true,\n        isOptionChange: true,\n        option: optionName\n      });\n    });\n  },\n  fontFields: [\"label.font\"]\n};","map":null,"metadata":{},"sourceType":"module"}