{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/text_box/ui.text_editor.mask.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport $ from \"../../core/renderer\";\nimport caretUtils from \"./utils.caret\";\nimport { isInputEventsL2Supported } from \"./utils.support\";\nimport { each } from \"../../core/utils/iterator\";\nimport { addNamespace, createEvent, isCommandKeyPressed, normalizeKeyName } from \"../../events/utils/index\";\nimport eventsEngine from \"../../events/core/events_engine\";\nimport { extend } from \"../../core/utils/extend\";\nimport { focused } from \"../widget/selectors\";\nimport { isDefined } from \"../../core/utils/type\";\nimport messageLocalization from \"../../localization/message\";\nimport { noop } from \"../../core/utils/common\";\nimport { isEmpty } from \"../../core/utils/string\";\nimport { name as wheelEventName } from \"../../events/core/wheel\";\nimport { EmptyMaskRule, StubMaskRule, MaskRule } from \"./ui.text_editor.mask.rule\";\nimport TextEditorBase from \"./ui.text_editor.base\";\nimport DefaultMaskStrategy from \"./ui.text_editor.mask.strategy.default\";\nimport InputEventsMaskStrategy from \"./ui.text_editor.mask.strategy.input_events\";\n\nvar stubCaret = function stubCaret() {\n  return {};\n};\n\nvar caret = caretUtils;\nvar EMPTY_CHAR = \" \";\nvar ESCAPED_CHAR = \"\\\\\";\nvar TEXTEDITOR_MASKED_CLASS = \"dx-texteditor-masked\";\nvar FORWARD_DIRECTION = \"forward\";\nvar BACKWARD_DIRECTION = \"backward\";\nvar buildInMaskRules = {\n  0: /[0-9]/,\n  9: /[0-9\\s]/,\n  \"#\": /[-+0-9\\s]/,\n  L: function L(char) {\n    return isLiteralChar(char);\n  },\n  l: function l(char) {\n    return isLiteralChar(char) || isSpaceChar(char);\n  },\n  C: /\\S/,\n  c: /./,\n  A: function A(char) {\n    return isLiteralChar(char) || isNumericChar(char);\n  },\n  a: function a(char) {\n    return isLiteralChar(char) || isNumericChar(char) || isSpaceChar(char);\n  }\n};\n\nfunction isNumericChar(char) {\n  return /[0-9]/.test(char);\n}\n\nfunction isLiteralChar(char) {\n  var code = char.charCodeAt();\n  return 64 < code && code < 91 || 96 < code && code < 123 || code > 127;\n}\n\nfunction isSpaceChar(char) {\n  return \" \" === char;\n}\n\nvar TextEditorMask = TextEditorBase.inherit({\n  _getDefaultOptions: function _getDefaultOptions() {\n    return extend(this.callBase(), {\n      mask: \"\",\n      maskChar: \"_\",\n      maskRules: {},\n      maskInvalidMessage: messageLocalization.format(\"validation-mask\"),\n      useMaskedValue: false,\n      showMaskMode: \"always\"\n    });\n  },\n  _supportedKeys: function _supportedKeys() {\n    var that = this;\n    var keyHandlerMap = {\n      backspace: that._maskStrategy.getHandler(\"backspace\"),\n      del: that._maskStrategy.getHandler(\"del\"),\n      enter: that._changeHandler\n    };\n    var result = that.callBase();\n    each(keyHandlerMap, function (key, callback) {\n      var parentHandler = result[key];\n\n      result[key] = function (e) {\n        that.option(\"mask\") && callback.call(that, e);\n        parentHandler && parentHandler(e);\n      };\n    });\n    return result;\n  },\n  _getSubmitElement: function _getSubmitElement() {\n    return !this.option(\"mask\") ? this.callBase() : this._$hiddenElement;\n  },\n  _init: function _init() {\n    this.callBase();\n\n    this._initMaskStrategy();\n  },\n  _initMaskStrategy: function _initMaskStrategy() {\n    this._maskStrategy = isInputEventsL2Supported() ? new InputEventsMaskStrategy(this) : new DefaultMaskStrategy(this);\n  },\n  _initMarkup: function _initMarkup() {\n    this._renderHiddenElement();\n\n    this.callBase();\n  },\n  _attachMouseWheelEventHandlers: function _attachMouseWheelEventHandlers() {\n    var hasMouseWheelHandler = this._onMouseWheel !== noop;\n\n    if (!hasMouseWheelHandler) {\n      return;\n    }\n\n    var input = this._input();\n\n    var eventName = addNamespace(wheelEventName, this.NAME);\n\n    var mouseWheelAction = this._createAction(function (e) {\n      var event = e.event;\n\n      if (focused(input) && !isCommandKeyPressed(event)) {\n        this._onMouseWheel(event);\n\n        event.preventDefault();\n        event.stopPropagation();\n      }\n    }.bind(this));\n\n    eventsEngine.off(input, eventName);\n    eventsEngine.on(input, eventName, function (e) {\n      mouseWheelAction({\n        event: e\n      });\n    });\n  },\n  _onMouseWheel: noop,\n  _render: function _render() {\n    this._renderMask();\n\n    this.callBase();\n\n    this._attachMouseWheelEventHandlers();\n  },\n  _renderHiddenElement: function _renderHiddenElement() {\n    if (this.option(\"mask\")) {\n      this._$hiddenElement = $(\"<input>\").attr(\"type\", \"hidden\").appendTo(this._inputWrapper());\n    }\n  },\n  _removeHiddenElement: function _removeHiddenElement() {\n    this._$hiddenElement && this._$hiddenElement.remove();\n  },\n  _renderMask: function _renderMask() {\n    this.$element().removeClass(TEXTEDITOR_MASKED_CLASS);\n    this._maskRulesChain = null;\n\n    this._maskStrategy.detachEvents();\n\n    if (!this.option(\"mask\")) {\n      return;\n    }\n\n    this.$element().addClass(TEXTEDITOR_MASKED_CLASS);\n\n    this._maskStrategy.attachEvents();\n\n    this._parseMask();\n\n    this._renderMaskedValue();\n  },\n  _suppressCaretChanging: function _suppressCaretChanging(callback, args) {\n    caret = stubCaret;\n\n    try {\n      callback.apply(this, args);\n    } finally {\n      caret = caretUtils;\n    }\n  },\n  _changeHandler: function _changeHandler(e) {\n    var $input = this._input();\n\n    var inputValue = $input.val();\n\n    if (inputValue === this._changedValue) {\n      return;\n    }\n\n    this._changedValue = inputValue;\n    var changeEvent = createEvent(e, {\n      type: \"change\"\n    });\n    eventsEngine.trigger($input, changeEvent);\n  },\n  _parseMask: function _parseMask() {\n    this._maskRules = extend({}, buildInMaskRules, this.option(\"maskRules\"));\n    this._maskRulesChain = this._parseMaskRule(0);\n  },\n  _parseMaskRule: function _parseMaskRule(index) {\n    var mask = this.option(\"mask\");\n\n    if (index >= mask.length) {\n      return new EmptyMaskRule();\n    }\n\n    var currentMaskChar = mask[index];\n    var isEscapedChar = currentMaskChar === ESCAPED_CHAR;\n    var result = isEscapedChar ? new StubMaskRule({\n      maskChar: mask[index + 1]\n    }) : this._getMaskRule(currentMaskChar);\n    result.next(this._parseMaskRule(index + 1 + isEscapedChar));\n    return result;\n  },\n  _getMaskRule: function _getMaskRule(pattern) {\n    var ruleConfig;\n    each(this._maskRules, function (rulePattern, allowedChars) {\n      if (rulePattern === pattern) {\n        ruleConfig = {\n          pattern: rulePattern,\n          allowedChars: allowedChars\n        };\n        return false;\n      }\n    });\n    return isDefined(ruleConfig) ? new MaskRule(extend({\n      maskChar: this.option(\"maskChar\")\n    }, ruleConfig)) : new StubMaskRule({\n      maskChar: pattern\n    });\n  },\n  _renderMaskedValue: function _renderMaskedValue() {\n    if (!this._maskRulesChain) {\n      return;\n    }\n\n    var value = this.option(\"value\") || \"\";\n\n    this._maskRulesChain.clear(this._normalizeChainArguments());\n\n    var chainArgs = {\n      length: value.length\n    };\n    chainArgs[this._isMaskedValueMode() ? \"text\" : \"value\"] = value;\n\n    this._handleChain(chainArgs);\n\n    this._displayMask();\n  },\n  _replaceSelectedText: function _replaceSelectedText(text, selection, char) {\n    if (void 0 === char) {\n      return text;\n    }\n\n    var textBefore = text.slice(0, selection.start);\n    var textAfter = text.slice(selection.end);\n    var edited = textBefore + char + textAfter;\n    return edited;\n  },\n  _isMaskedValueMode: function _isMaskedValueMode() {\n    return this.option(\"useMaskedValue\");\n  },\n  _displayMask: function _displayMask(caret) {\n    caret = caret || this._caret();\n\n    this._renderValue();\n\n    this._caret(caret);\n  },\n  _isValueEmpty: function _isValueEmpty() {\n    return isEmpty(this._value);\n  },\n  _shouldShowMask: function _shouldShowMask() {\n    var showMaskMode = this.option(\"showMaskMode\");\n\n    if (\"onFocus\" === showMaskMode) {\n      return focused(this._input()) || !this._isValueEmpty();\n    }\n\n    return true;\n  },\n  _showMaskPlaceholder: function _showMaskPlaceholder() {\n    if (this._shouldShowMask()) {\n      var text = this._maskRulesChain.text();\n\n      this.option(\"text\", text);\n\n      if (\"onFocus\" === this.option(\"showMaskMode\")) {\n        this._renderDisplayText(text);\n      }\n    }\n  },\n  _renderValue: function _renderValue() {\n    if (this._maskRulesChain) {\n      this._showMaskPlaceholder();\n\n      if (this._$hiddenElement) {\n        var value = this._maskRulesChain.value();\n\n        var submitElementValue = !isEmpty(value) ? this._getPreparedValue() : \"\";\n\n        this._$hiddenElement.val(submitElementValue);\n      }\n    }\n\n    return this.callBase();\n  },\n  _getPreparedValue: function _getPreparedValue() {\n    return this._convertToValue().replace(/\\s+$/, \"\");\n  },\n  _valueChangeEventHandler: function _valueChangeEventHandler(e) {\n    if (!this._maskRulesChain) {\n      this.callBase.apply(this, arguments);\n      return;\n    }\n\n    this._saveValueChangeEvent(e);\n\n    this.option(\"value\", this._getPreparedValue());\n  },\n  _isControlKeyFired: function _isControlKeyFired(e) {\n    return this._isControlKey(normalizeKeyName(e)) || isCommandKeyPressed(e);\n  },\n  _handleChain: function _handleChain(args) {\n    var handledCount = this._maskRulesChain.handle(this._normalizeChainArguments(args));\n\n    this._value = this._maskRulesChain.value();\n    this._textValue = this._maskRulesChain.text();\n    return handledCount;\n  },\n  _normalizeChainArguments: function _normalizeChainArguments(args) {\n    args = args || {};\n    args.index = 0;\n    args.fullText = this._maskRulesChain.text();\n    return args;\n  },\n  _convertToValue: function _convertToValue(text) {\n    if (this._isMaskedValueMode()) {\n      text = this._replaceMaskCharWithEmpty(text || this._textValue || \"\");\n    } else {\n      text = text || this._value || \"\";\n    }\n\n    return text;\n  },\n  _replaceMaskCharWithEmpty: function _replaceMaskCharWithEmpty(text) {\n    return text.replace(new RegExp(this.option(\"maskChar\"), \"g\"), EMPTY_CHAR);\n  },\n  _maskKeyHandler: function _maskKeyHandler(e, keyHandler) {\n    var _this = this;\n\n    if (this.option(\"readOnly\")) {\n      return;\n    }\n\n    this.setForwardDirection();\n    e.preventDefault();\n\n    this._handleSelection();\n\n    var previousText = this._input().val();\n\n    var raiseInputEvent = function raiseInputEvent() {\n      if (previousText !== _this._input().val()) {\n        _this._maskStrategy.runWithoutEventProcessing(function () {\n          return eventsEngine.trigger(_this._input(), \"input\");\n        });\n      }\n    };\n\n    var handled = keyHandler();\n\n    if (handled) {\n      handled.then(raiseInputEvent);\n    } else {\n      this.setForwardDirection();\n\n      this._adjustCaret();\n\n      this._displayMask();\n\n      this._maskRulesChain.reset();\n\n      raiseInputEvent();\n    }\n  },\n  _handleKey: function _handleKey(key, direction) {\n    this._direction(direction || FORWARD_DIRECTION);\n\n    this._adjustCaret(key);\n\n    this._handleKeyChain(key);\n\n    this._moveCaret();\n  },\n  _handleSelection: function _handleSelection() {\n    if (!this._hasSelection()) {\n      return;\n    }\n\n    var caret = this._caret();\n\n    var emptyChars = new Array(caret.end - caret.start + 1).join(EMPTY_CHAR);\n\n    this._handleKeyChain(emptyChars);\n  },\n  _handleKeyChain: function _handleKeyChain(chars) {\n    var caret = this._caret();\n\n    var start = this.isForwardDirection() ? caret.start : caret.start - 1;\n    var end = this.isForwardDirection() ? caret.end : caret.end - 1;\n    var length = start === end ? 1 : end - start;\n\n    this._handleChain({\n      text: chars,\n      start: start,\n      length: length\n    });\n  },\n  _tryMoveCaretBackward: function _tryMoveCaretBackward() {\n    this.setBackwardDirection();\n\n    var currentCaret = this._caret().start;\n\n    this._adjustCaret();\n\n    return !currentCaret || currentCaret !== this._caret().start;\n  },\n  _adjustCaret: function _adjustCaret(char) {\n    var caretStart = this._caret().start;\n\n    var isForwardDirection = this.isForwardDirection();\n\n    var caret = this._maskRulesChain.adjustedCaret(caretStart, isForwardDirection, char);\n\n    this._caret({\n      start: caret,\n      end: caret\n    });\n  },\n  _moveCaret: function _moveCaret() {\n    var currentCaret = this._caret().start;\n\n    var maskRuleIndex = currentCaret + (this.isForwardDirection() ? 0 : -1);\n    var caret = this._maskRulesChain.isAccepted(maskRuleIndex) ? currentCaret + (this.isForwardDirection() ? 1 : -1) : currentCaret;\n\n    this._caret({\n      start: caret,\n      end: caret\n    });\n  },\n  _caret: function _caret(position, force) {\n    var $input = this._input();\n\n    if (!$input.length) {\n      return;\n    }\n\n    if (!arguments.length) {\n      return caret($input);\n    }\n\n    caret($input, position, force);\n  },\n  _hasSelection: function _hasSelection() {\n    var caret = this._caret();\n\n    return caret.start !== caret.end;\n  },\n  _direction: function _direction(direction) {\n    if (!arguments.length) {\n      return this._typingDirection;\n    }\n\n    this._typingDirection = direction;\n  },\n  setForwardDirection: function setForwardDirection() {\n    this._direction(FORWARD_DIRECTION);\n  },\n  setBackwardDirection: function setBackwardDirection() {\n    this._direction(BACKWARD_DIRECTION);\n  },\n  isForwardDirection: function isForwardDirection() {\n    return this._direction() === FORWARD_DIRECTION;\n  },\n  _clean: function _clean() {\n    this._maskStrategy && this._maskStrategy.clean();\n    this.callBase();\n  },\n  _validateMask: function _validateMask() {\n    if (!this._maskRulesChain) {\n      return;\n    }\n\n    var isValid = isEmpty(this.option(\"value\")) || this._maskRulesChain.isValid(this._normalizeChainArguments());\n\n    this.option({\n      isValid: isValid,\n      validationError: isValid ? null : {\n        editorSpecific: true,\n        message: this.option(\"maskInvalidMessage\")\n      }\n    });\n  },\n  _updateHiddenElement: function _updateHiddenElement() {\n    this._removeHiddenElement();\n\n    if (this.option(\"mask\")) {\n      this._input().removeAttr(\"name\");\n\n      this._renderHiddenElement();\n    }\n\n    this._setSubmitElementName(this.option(\"name\"));\n  },\n  _updateMaskOption: function _updateMaskOption() {\n    this._updateHiddenElement();\n\n    this._renderMask();\n\n    this._validateMask();\n  },\n  _processEmptyMask: function _processEmptyMask(mask) {\n    if (mask) {\n      return;\n    }\n\n    var value = this.option(\"value\");\n    this.option({\n      text: value,\n      isValid: true\n    });\n    this.validationRequest.fire({\n      value: value,\n      editor: this\n    });\n\n    this._renderValue();\n  },\n  _optionChanged: function _optionChanged(args) {\n    switch (args.name) {\n      case \"mask\":\n        this._updateMaskOption();\n\n        this._processEmptyMask(args.value);\n\n        break;\n\n      case \"maskChar\":\n      case \"maskRules\":\n      case \"useMaskedValue\":\n        this._updateMaskOption();\n\n        break;\n\n      case \"value\":\n        this._renderMaskedValue();\n\n        this._validateMask();\n\n        this.callBase(args);\n        this._changedValue = this._input().val();\n        break;\n\n      case \"maskInvalidMessage\":\n        break;\n\n      case \"showMaskMode\":\n        this.option(\"text\", \"\");\n\n        this._renderValue();\n\n        break;\n\n      default:\n        this.callBase(args);\n    }\n  }\n});\nexport default TextEditorMask;","map":null,"metadata":{},"sourceType":"module"}