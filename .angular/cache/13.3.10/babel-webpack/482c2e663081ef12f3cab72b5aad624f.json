{"ast":null,"code":"/**\r\n * DevExtreme (esm/viz/gauges/bar_gauge.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nvar PI_DIV_180 = Math.PI / 180;\nvar _abs = Math.abs;\nvar _round = Math.round;\nvar _floor = Math.floor;\nvar _min = Math.min;\nvar _max = Math.max;\nimport registerComponent from \"../../core/component_registrator\";\nimport { clone } from \"../../core/utils/object\";\nimport { noop } from \"../../core/utils/common\";\nimport { extend } from \"../../core/utils/extend\";\nimport { normalizeEnum as _normalizeEnum, convertAngleToRendererSpace, getCosAndSin, patchFontOptions } from \"../core/utils\";\nimport { BaseGauge, getSampleText, formatValue, compareArrays } from \"./base_gauge\";\nvar _getSampleText = getSampleText;\nvar _formatValue = formatValue;\nvar _compareArrays = compareArrays;\nimport dxCircularGauge from \"./circular_gauge\";\nvar _isArray = Array.isArray;\nvar _convertAngleToRendererSpace = convertAngleToRendererSpace;\nvar _getCosAndSin = getCosAndSin;\nvar _patchFontOptions = patchFontOptions;\nvar _Number = Number;\nvar _isFinite = isFinite;\nvar _noop = noop;\nvar _extend = extend;\nimport { plugin as pluginLegend } from \"../components/legend\";\nvar OPTION_VALUES = \"values\";\nvar BarWrapper;\nexport var dxBarGauge = BaseGauge.inherit({\n  _rootClass: \"dxbg-bar-gauge\",\n  _themeSection: \"barGauge\",\n  _fontFields: [\"label.font\", \"legend.font\", \"legend.title.font\", \"legend.title.subtitle.font\"],\n  _initCore: function _initCore() {\n    var that = this;\n    that.callBase.apply(that, arguments);\n    that._barsGroup = that._renderer.g().attr({\n      class: \"dxbg-bars\"\n    }).linkOn(that._renderer.root, \"bars\");\n    that._values = [];\n    that._context = {\n      renderer: that._renderer,\n      translator: that._translator,\n      tracker: that._tracker,\n      group: that._barsGroup\n    };\n\n    that._animateStep = function (pos) {\n      var bars = that._bars;\n      var i;\n      var ii;\n\n      for (i = 0, ii = bars.length; i < ii; ++i) {\n        bars[i].animate(pos);\n      }\n    };\n\n    that._animateComplete = function () {\n      that._bars.forEach(function (bar) {\n        return bar.endAnimation();\n      });\n\n      that._checkOverlap();\n    };\n  },\n  _disposeCore: function _disposeCore() {\n    var that = this;\n\n    that._barsGroup.linkOff();\n\n    that._barsGroup = that._values = that._context = that._animateStep = that._animateComplete = null;\n    that.callBase.apply(that, arguments);\n  },\n  _setupDomainCore: function _setupDomainCore() {\n    var startValue = this.option(\"startValue\");\n    var endValue = this.option(\"endValue\");\n    _isFinite(startValue) || (startValue = 0);\n    _isFinite(endValue) || (endValue = 100);\n\n    this._translator.setDomain(startValue, endValue);\n\n    this._baseValue = this._translator.adjust(this.option(\"baseValue\"));\n    _isFinite(this._baseValue) || (this._baseValue = startValue < endValue ? startValue : endValue);\n  },\n  _getDefaultSize: function _getDefaultSize() {\n    return {\n      width: 300,\n      height: 300\n    };\n  },\n  _setupCodomain: dxCircularGauge.prototype._setupCodomain,\n  _getApproximateScreenRange: function _getApproximateScreenRange() {\n    var sides = this._area.sides;\n    var width = this._canvas.width / (sides.right - sides.left);\n    var height = this._canvas.height / (sides.down - sides.up);\n    var r = width < height ? width : height;\n    return -this._translator.getCodomainRange() * r * PI_DIV_180;\n  },\n  _setupAnimationSettings: function _setupAnimationSettings() {\n    var that = this;\n    that.callBase.apply(that, arguments);\n\n    if (that._animationSettings) {\n      that._animationSettings.step = that._animateStep;\n      that._animationSettings.complete = that._animateComplete;\n    }\n  },\n  _cleanContent: function _cleanContent() {\n    this._barsGroup.linkRemove();\n\n    this._animationSettings && this._barsGroup.stopAnimation();\n\n    this._barsGroup.clear();\n  },\n  _renderContent: function _renderContent() {\n    var labelOptions = this.option(\"label\");\n    var text;\n    var bBox;\n    var context = this._context;\n\n    this._barsGroup.linkAppend();\n\n    context.textEnabled = void 0 === labelOptions || labelOptions && (!(\"visible\" in labelOptions) || labelOptions.visible);\n\n    if (context.textEnabled) {\n      context.textColor = labelOptions && labelOptions.font && labelOptions.font.color || null;\n      labelOptions = _extend(true, {}, this._themeManager.theme().label, labelOptions);\n      context.formatOptions = {\n        format: void 0 !== labelOptions.format ? labelOptions.format : this._defaultFormatOptions,\n        customizeText: labelOptions.customizeText\n      };\n      context.textOptions = {\n        align: \"center\"\n      };\n      context.fontStyles = _patchFontOptions(_extend({}, this._themeManager.theme().label.font, labelOptions.font, {\n        color: null\n      }));\n      this._textIndent = labelOptions.indent > 0 ? _Number(labelOptions.indent) : 0;\n      context.lineWidth = labelOptions.connectorWidth > 0 ? _Number(labelOptions.connectorWidth) : 0;\n      context.lineColor = labelOptions.connectorColor || null;\n      text = this._renderer.text(_getSampleText(this._translator, context.formatOptions), 0, 0).attr(context.textOptions).css(context.fontStyles).append(this._barsGroup);\n      bBox = text.getBBox();\n      text.remove();\n      context.textY = bBox.y;\n      context.textWidth = bBox.width;\n      context.textHeight = bBox.height;\n    }\n\n    dxCircularGauge.prototype._applyMainLayout.call(this);\n\n    this._renderBars();\n  },\n  _measureMainElements: function _measureMainElements() {\n    var result = {\n      maxRadius: this._area.radius\n    };\n\n    if (this._context.textEnabled) {\n      result.horizontalMargin = this._context.textWidth;\n      result.verticalMargin = this._context.textHeight;\n      result.inverseHorizontalMargin = this._context.textWidth / 2;\n      result.inverseVerticalMargin = this._context.textHeight / 2;\n    }\n\n    return result;\n  },\n  _renderBars: function _renderBars() {\n    var options = _extend({}, this._themeManager.theme(), this.option());\n\n    var radius;\n    var area = this._area;\n    var relativeInnerRadius = options.relativeInnerRadius > 0 && options.relativeInnerRadius < 1 ? _Number(options.relativeInnerRadius) : .1;\n    radius = area.radius;\n\n    if (this._context.textEnabled) {\n      this._textIndent = _round(_min(this._textIndent, radius / 2));\n      radius -= this._textIndent;\n    }\n\n    this._outerRadius = _floor(radius);\n    this._innerRadius = _floor(radius * relativeInnerRadius);\n    this._barSpacing = options.barSpacing > 0 ? _Number(options.barSpacing) : 0;\n\n    _extend(this._context, {\n      backgroundColor: options.backgroundColor,\n      x: area.x,\n      y: area.y,\n      startAngle: area.startCoord,\n      endAngle: area.endCoord,\n      baseAngle: this._translator.translate(this._baseValue)\n    });\n\n    this._arrangeBars();\n  },\n  _arrangeBars: function _arrangeBars() {\n    var radius = this._outerRadius - this._innerRadius;\n    var context = this._context;\n    var i;\n    var count = this._bars.length;\n\n    this._beginValueChanging();\n\n    context.barSize = count > 0 ? _max((radius - (count - 1) * this._barSpacing) / count, 1) : 0;\n    var spacing = count > 1 ? _max(_min((radius - count * context.barSize) / (count - 1), this._barSpacing), 0) : 0;\n\n    var _count = _min(_floor((radius + spacing) / context.barSize), count);\n\n    this._setBarsCount(count);\n\n    radius = this._outerRadius;\n    context.textRadius = radius;\n    context.textIndent = this._textIndent;\n\n    this._palette.reset();\n\n    var unitOffset = context.barSize + spacing;\n\n    var colors = this._palette.generateColors(_count);\n\n    for (i = 0; i < _count; ++i, radius -= unitOffset) {\n      this._bars[i].arrange({\n        radius: radius,\n        color: colors[i]\n      });\n    }\n\n    for (var _i = _count; _i < count; _i++) {\n      this._bars[_i].hide();\n    }\n\n    if (this._animationSettings && !this._noAnimation) {\n      this._animateBars();\n    } else {\n      this._updateBars();\n    }\n\n    this._endValueChanging();\n  },\n  _setBarsCount: function _setBarsCount() {\n    if (this._bars.length > 0) {\n      if (this._dummyBackground) {\n        this._dummyBackground.dispose();\n\n        this._dummyBackground = null;\n      }\n    } else {\n      if (!this._dummyBackground) {\n        this._dummyBackground = this._renderer.arc().attr({\n          \"stroke-linejoin\": \"round\"\n        });\n      }\n\n      this._dummyBackground.attr({\n        x: this._context.x,\n        y: this._context.y,\n        outerRadius: this._outerRadius,\n        innerRadius: this._innerRadius,\n        startAngle: this._context.endAngle,\n        endAngle: this._context.startAngle,\n        fill: this._context.backgroundColor\n      }).append(this._barsGroup);\n    }\n  },\n  _updateBars: function _updateBars() {\n    this._bars.forEach(function (bar) {\n      return bar.applyValue();\n    });\n\n    this._checkOverlap();\n  },\n  _checkOverlap: function _checkOverlap() {\n    var bars = this._bars;\n\n    var overlapStrategy = _normalizeEnum(this._getOption(\"resolveLabelOverlapping\", true));\n\n    if (\"none\" === overlapStrategy) {\n      return;\n    }\n\n    var sortedBars = bars.concat().sort(function (a, b) {\n      return a.getValue() - b.getValue();\n    });\n    var currentIndex = 0;\n    var nextIndex = 1;\n\n    while (currentIndex < sortedBars.length && nextIndex < sortedBars.length) {\n      var current = sortedBars[currentIndex];\n      var next = sortedBars[nextIndex];\n\n      if (current.checkIntersect(next)) {\n        next.hideLabel();\n        nextIndex++;\n      } else {\n        currentIndex = nextIndex;\n        nextIndex = currentIndex + 1;\n      }\n    }\n  },\n  _animateBars: function _animateBars() {\n    var i;\n    var ii = this._bars.length;\n\n    if (ii > 0) {\n      for (i = 0; i < ii; ++i) {\n        this._bars[i].beginAnimation();\n      }\n\n      this._barsGroup.animate({\n        _: 0\n      }, this._animationSettings);\n    }\n  },\n  _buildNodes: function _buildNodes() {\n    var that = this;\n\n    var options = that._options.silent();\n\n    that._palette = that._themeManager.createPalette(options.palette, {\n      useHighlight: true,\n      extensionMode: options.paletteExtensionMode\n    });\n\n    that._palette.reset();\n\n    that._bars = that._bars || [];\n    that._animationSettings && that._barsGroup.stopAnimation();\n\n    var barValues = that._values.filter(_isFinite);\n\n    var count = barValues.length;\n\n    if (that._bars.length > count) {\n      var ii = that._bars.length;\n\n      for (var i = count; i < ii; ++i) {\n        that._bars[i].dispose();\n      }\n\n      that._bars.splice(count, ii - count);\n    } else if (that._bars.length < count) {\n      for (var _i2 = that._bars.length; _i2 < count; ++_i2) {\n        that._bars.push(new BarWrapper(_i2, that._context));\n      }\n    }\n\n    that._bars.forEach(function (bar, index) {\n      bar.update({\n        color: that._palette.getNextColor(count),\n        value: barValues[index]\n      });\n    });\n  },\n  _updateValues: function _updateValues(values) {\n    var list = _isArray(values) && values || _isFinite(values) && [values] || [];\n    var i;\n    var ii = list.length;\n    var value;\n    this._values.length = ii;\n\n    for (i = 0; i < ii; ++i) {\n      value = list[i];\n      this._values[i] = _Number(_isFinite(value) ? value : this._values[i]);\n    }\n\n    if (!this._resizing) {\n      if (!_compareArrays(this._values, this.option(OPTION_VALUES))) {\n        this.option(OPTION_VALUES, this._values.slice());\n      }\n    }\n\n    this._change([\"NODES\"]);\n  },\n  values: function values(arg) {\n    if (void 0 !== arg) {\n      this._updateValues(arg);\n\n      return this;\n    } else {\n      return this._values.slice(0);\n    }\n  },\n  _optionChangesMap: {\n    backgroundColor: \"MOSTLY_TOTAL\",\n    relativeInnerRadius: \"MOSTLY_TOTAL\",\n    barSpacing: \"MOSTLY_TOTAL\",\n    label: \"MOSTLY_TOTAL\",\n    resolveLabelOverlapping: \"MOSTLY_TOTAL\",\n    palette: \"MOSTLY_TOTAL\",\n    paletteExtensionMode: \"MOSTLY_TOTAL\",\n    values: \"VALUES\"\n  },\n  _change_VALUES: function _change_VALUES() {\n    this._updateValues(this.option(OPTION_VALUES));\n  },\n  _factory: clone(BaseGauge.prototype._factory),\n  _optionChangesOrder: [\"VALUES\", \"NODES\"],\n  _initialChanges: [\"VALUES\"],\n  _change_NODES: function _change_NODES() {\n    this._buildNodes();\n  },\n  _change_MOSTLY_TOTAL: function _change_MOSTLY_TOTAL() {\n    this._change([\"NODES\"]);\n\n    this.callBase();\n  },\n  _proxyData: [],\n  _getLegendData: function _getLegendData() {\n    var formatOptions = {};\n\n    var options = this._options.silent();\n\n    var labelFormatOptions = (options.label || {}).format;\n    var legendFormatOptions = (options.legend || {}).itemTextFormat;\n\n    if (legendFormatOptions) {\n      formatOptions.format = legendFormatOptions;\n    } else {\n      formatOptions.format = labelFormatOptions || this._defaultFormatOptions;\n    }\n\n    return (this._bars || []).map(function (b) {\n      return {\n        id: b.index,\n        item: {\n          value: b.getValue(),\n          color: b.getColor(),\n          index: b.index\n        },\n        text: _formatValue(b.getValue(), formatOptions),\n        visible: true,\n        states: {\n          normal: {\n            fill: b.getColor()\n          }\n        }\n      };\n    });\n  }\n});\n\nBarWrapper = function BarWrapper(index, context) {\n  this._context = context;\n  this._tracker = context.renderer.arc().attr({\n    \"stroke-linejoin\": \"round\"\n  });\n  this.index = index;\n};\n\n_extend(BarWrapper.prototype, {\n  dispose: function dispose() {\n    this._background.dispose();\n\n    this._bar.dispose();\n\n    if (this._context.textEnabled) {\n      this._line.dispose();\n\n      this._text.dispose();\n    }\n\n    this._context.tracker.detach(this._tracker);\n\n    this._context = this._settings = this._background = this._bar = this._line = this._text = this._tracker = null;\n    return this;\n  },\n  arrange: function arrange(options) {\n    var context = this._context;\n    this._visible = true;\n    context.tracker.attach(this._tracker, this, {\n      index: this.index\n    });\n    this._background = context.renderer.arc().attr({\n      \"stroke-linejoin\": \"round\",\n      fill: context.backgroundColor\n    }).append(context.group);\n    this._settings = this._settings || {\n      x: context.x,\n      y: context.y,\n      startAngle: context.baseAngle,\n      endAngle: context.baseAngle\n    };\n    this._bar = context.renderer.arc().attr(_extend({\n      \"stroke-linejoin\": \"round\"\n    }, this._settings)).append(context.group);\n\n    if (context.textEnabled) {\n      this._line = context.renderer.path([], \"line\").attr({\n        \"stroke-width\": context.lineWidth\n      }).append(context.group);\n      this._text = context.renderer.text().css(context.fontStyles).attr(context.textOptions).append(context.group);\n    }\n\n    this._angle = isFinite(this._angle) ? this._angle : context.baseAngle;\n    this._settings.outerRadius = options.radius;\n    this._settings.innerRadius = options.radius - context.barSize;\n    this._settings.x = context.x;\n    this._settings.y = context.y;\n\n    this._background.attr(_extend({}, this._settings, {\n      startAngle: context.endAngle,\n      endAngle: context.startAngle,\n      fill: this._context.backgroundColor\n    }));\n\n    this._bar.attr({\n      x: context.x,\n      y: context.y,\n      outerRadius: this._settings.outerRadius,\n      innerRadius: this._settings.innerRadius,\n      fill: this._color\n    });\n\n    this._tracker.attr(this._settings);\n\n    if (context.textEnabled) {\n      this._line.attr({\n        points: [context.x, context.y - this._settings.innerRadius, context.x, context.y - context.textRadius - context.textIndent],\n        stroke: context.lineColor || this._color\n      }).sharp();\n\n      this._text.css({\n        fill: context.textColor || this._color\n      });\n    }\n\n    return this;\n  },\n  getTooltipParameters: function getTooltipParameters() {\n    var cosSin = _getCosAndSin((this._angle + this._context.baseAngle) / 2);\n\n    return {\n      x: _round(this._context.x + (this._settings.outerRadius + this._settings.innerRadius) / 2 * cosSin.cos),\n      y: _round(this._context.y - (this._settings.outerRadius + this._settings.innerRadius) / 2 * cosSin.sin),\n      offset: 0,\n      color: this._color,\n      value: this._value\n    };\n  },\n  setAngle: function setAngle(angle) {\n    var context = this._context;\n    var settings = this._settings;\n    var cosSin;\n    this._angle = angle;\n    setAngles(settings, context.baseAngle, angle);\n\n    this._bar.attr(settings);\n\n    this._tracker.attr(settings);\n\n    if (context.textEnabled) {\n      cosSin = _getCosAndSin(angle);\n      var indent = context.textIndent;\n      var radius = context.textRadius + indent;\n      var x = context.x + radius * cosSin.cos;\n      var y = context.y - radius * cosSin.sin;\n      var halfWidth = .5 * context.textWidth;\n      var textHeight = context.textHeight;\n      var textY = context.textY;\n\n      if (_abs(x - context.x) > indent) {\n        x += x < context.x ? -halfWidth : halfWidth;\n      }\n\n      if (_abs(y - context.y) <= indent) {\n        y -= textY + .5 * textHeight;\n      } else {\n        y -= y < context.y ? textY + textHeight : textY;\n      }\n\n      var text = _formatValue(this._value, context.formatOptions, {\n        index: this.index\n      });\n\n      var visibility = \"\" === text ? \"hidden\" : null;\n\n      this._text.attr({\n        text: text,\n        x: x,\n        y: y,\n        visibility: visibility\n      });\n\n      this._line.attr({\n        visibility: visibility\n      });\n\n      this._line.rotate(_convertAngleToRendererSpace(angle), context.x, context.y);\n    }\n\n    return this;\n  },\n  hideLabel: function hideLabel() {\n    this._text.attr({\n      visibility: \"hidden\"\n    });\n\n    this._line.attr({\n      visibility: \"hidden\"\n    });\n  },\n  checkIntersect: function checkIntersect(anotherBar) {\n    var coords = this.calculateLabelCoords();\n    var anotherCoords = anotherBar.calculateLabelCoords();\n\n    if (!coords || !anotherCoords) {\n      return false;\n    }\n\n    var width = Math.max(0, Math.min(coords.bottomRight.x, anotherCoords.bottomRight.x) - Math.max(coords.topLeft.x, anotherCoords.topLeft.x));\n    var height = Math.max(0, Math.min(coords.bottomRight.y, anotherCoords.bottomRight.y) - Math.max(coords.topLeft.y, anotherCoords.topLeft.y));\n    return width * height !== 0;\n  },\n  calculateLabelCoords: function calculateLabelCoords() {\n    if (!this._text) {\n      return;\n    }\n\n    var box = this._text.getBBox();\n\n    return {\n      topLeft: {\n        x: box.x,\n        y: box.y\n      },\n      bottomRight: {\n        x: box.x + box.width,\n        y: box.y + box.height\n      }\n    };\n  },\n  _processValue: function _processValue(value) {\n    return this._context.translator.translate(this._context.translator.adjust(value));\n  },\n  applyValue: function applyValue() {\n    if (!this._visible) {\n      return this;\n    }\n\n    return this.setAngle(this._processValue(this.getValue()));\n  },\n  update: function update(_ref) {\n    var color = _ref.color,\n        value = _ref.value;\n    this._color = color;\n    this._value = value;\n  },\n  hide: function hide() {\n    this._visible = false;\n  },\n  getColor: function getColor() {\n    return this._color;\n  },\n  getValue: function getValue() {\n    return this._value;\n  },\n  beginAnimation: function beginAnimation() {\n    if (!this._visible) {\n      return this;\n    }\n\n    var angle = this._processValue(this.getValue());\n\n    if (!compareFloats(this._angle, angle)) {\n      this._start = this._angle;\n      this._delta = angle - this._angle;\n\n      this._tracker.attr({\n        visibility: \"hidden\"\n      });\n\n      if (this._context.textEnabled) {\n        this._line.attr({\n          visibility: \"hidden\"\n        });\n\n        this._text.attr({\n          visibility: \"hidden\"\n        });\n      }\n    } else {\n      this.animate = _noop;\n      this.setAngle(this._angle);\n    }\n  },\n  animate: function animate(pos) {\n    if (!this._visible) {\n      return this;\n    }\n\n    this._angle = this._start + this._delta * pos;\n    setAngles(this._settings, this._context.baseAngle, this._angle);\n\n    this._bar.attr(this._settings);\n  },\n  endAnimation: function endAnimation() {\n    if (void 0 !== this._delta) {\n      if (compareFloats(this._angle, this._start + this._delta)) {\n        this._tracker.attr({\n          visibility: null\n        });\n\n        this.setAngle(this._angle);\n      }\n    } else {\n      delete this.animate;\n    }\n\n    delete this._start;\n    delete this._delta;\n  }\n});\n\nfunction setAngles(target, angle1, angle2) {\n  target.startAngle = angle1 < angle2 ? angle1 : angle2;\n  target.endAngle = angle1 < angle2 ? angle2 : angle1;\n}\n\nfunction compareFloats(value1, value2) {\n  return _abs(value1 - value2) < 1e-4;\n}\n\nregisterComponent(\"dxBarGauge\", dxBarGauge);\ndxBarGauge.addPlugin(pluginLegend);","map":null,"metadata":{},"sourceType":"module"}