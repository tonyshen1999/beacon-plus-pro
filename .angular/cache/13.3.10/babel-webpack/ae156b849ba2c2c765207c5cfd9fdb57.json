{"ast":null,"code":"/**\r\n * DevExtreme (esm/viz/sankey/graph.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nvar WHITE = \"white\";\nvar GRAY = \"gray\";\nvar BLACK = \"black\";\nvar routines = {\n  maxOfArray: function maxOfArray(arr, callback) {\n    var m = 0;\n\n    var callback_function = function callback_function(v) {\n      return v;\n    };\n\n    if (callback) {\n      callback_function = callback;\n    }\n\n    for (var i = 0; i < arr.length; i++) {\n      if (callback_function(arr[i]) > m) {\n        m = callback_function(arr[i]);\n      }\n    }\n\n    return m;\n  }\n};\n\nvar getVertices = function getVertices(links) {\n  var vert = [];\n  links.forEach(function (link) {\n    if (-1 === vert.indexOf(link[0])) {\n      vert.push(link[0]);\n    }\n\n    if (-1 === vert.indexOf(link[1])) {\n      vert.push(link[1]);\n    }\n  });\n  return vert;\n};\n\nvar getAdjacentVertices = function getAdjacentVertices(links, vertex) {\n  var avert = [];\n  links.forEach(function (link) {\n    if (link[0] === vertex && -1 === avert.indexOf(link[1])) {\n      avert.push(link[1]);\n    }\n  });\n  return avert;\n};\n\nvar getReverseAdjacentVertices = function getReverseAdjacentVertices(links, vertex) {\n  var avert = [];\n  links.forEach(function (link) {\n    if (link[1] === vertex && -1 === avert.indexOf(link[0])) {\n      avert.push(link[0]);\n    }\n  });\n  return avert;\n};\n\nvar struct = {\n  _hasCycle: false,\n  _sortedList: [],\n  hasCycle: function hasCycle(links) {\n    var _this = this;\n\n    this._hasCycle = false;\n    this._sortedList = [];\n    var vertices = {};\n    var allVertices = getVertices(links);\n    allVertices.forEach(function (vertex) {\n      vertices[vertex] = {\n        color: WHITE\n      };\n    });\n    allVertices.forEach(function (vertex) {\n      if (vertices[vertex].color === WHITE) {\n        _this._depthFirstSearch(links, vertices, vertex);\n      }\n    });\n\n    this._sortedList.reverse();\n\n    return this._hasCycle;\n  },\n  _depthFirstSearch: function _depthFirstSearch(links, vertices, vertex) {\n    vertices[vertex].color = GRAY;\n    var averts = getAdjacentVertices(links, vertex);\n\n    for (var a = 0; a < averts.length; a++) {\n      if (vertices[averts[a]].color === WHITE) {\n        this._depthFirstSearch(links, vertices, averts[a]);\n      } else if (vertices[averts[a]].color === GRAY) {\n        this._hasCycle = true;\n      }\n    }\n\n    this._sortedList.push({\n      name: vertex,\n      lp: null,\n      incoming: getReverseAdjacentVertices(links, vertex),\n      outgoing: getAdjacentVertices(links, vertex)\n    });\n\n    vertices[vertex].color = BLACK;\n  },\n  computeLongestPaths: function computeLongestPaths(links) {\n    var sortedVertices = this._sortedList;\n    sortedVertices.forEach(function (vertex) {\n      var averts = getReverseAdjacentVertices(links, vertex.name);\n\n      if (0 === averts.length) {\n        vertex.lp = 0;\n      } else {\n        var maxLP = [];\n        averts.forEach(function (adjacentVertex) {\n          maxLP.push(sortedVertices.filter(function (sv) {\n            return sv.name === adjacentVertex;\n          })[0].lp);\n        });\n        vertex.lp = routines.maxOfArray(maxLP) + 1;\n      }\n    });\n    return this._sortedList;\n  }\n};\nexport default {\n  struct: struct,\n  routines: routines,\n  getVertices: getVertices,\n  getAdjacentVertices: getAdjacentVertices,\n  getReverseAdjacentVertices: getReverseAdjacentVertices\n};","map":null,"metadata":{},"sourceType":"module"}