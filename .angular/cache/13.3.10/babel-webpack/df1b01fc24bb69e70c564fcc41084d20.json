{"ast":null,"code":"/**\r\n * DevExtreme (esm/viz/axes/datetime_breaks.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport dateUtils from \"../../core/utils/date\";\nvar days = [0, 1, 2, 3, 4, 5, 6];\n\nfunction getWeekendDays(workdays) {\n  return days.filter(function (day) {\n    return !workdays.some(function (workDay) {\n      return workDay === day;\n    });\n  });\n}\n\nfunction getNextDayIndex(dayIndex) {\n  return (dayIndex + 1) % 7;\n}\n\nfunction dayBetweenWeekend(weekend, day) {\n  var start = weekend.start;\n  var end = weekend.end;\n\n  while (start !== end) {\n    if (start === day) {\n      return true;\n    }\n\n    start = getNextDayIndex(start);\n  }\n\n  return false;\n}\n\nfunction getDaysDistance(day, end) {\n  var length = 0;\n\n  while (day !== end) {\n    day = getNextDayIndex(day);\n    length++;\n  }\n\n  return length;\n}\n\nfunction separateBreak(scaleBreak, day) {\n  var result = [];\n  var dayEnd = new Date(day);\n  dayEnd.setDate(day.getDate() + 1);\n\n  if (day > scaleBreak.from) {\n    result.push({\n      from: scaleBreak.from,\n      to: day\n    });\n  }\n\n  if (dayEnd < scaleBreak.to) {\n    result.push({\n      from: dayEnd,\n      to: scaleBreak.to\n    });\n  }\n\n  return result;\n}\n\nfunction getWeekEndDayIndices(workDays) {\n  var indices = getWeekendDays(workDays);\n\n  if (indices.length < 7) {\n    while (getNextDayIndex(indices[indices.length - 1]) === indices[0]) {\n      indices.unshift(indices.pop());\n    }\n  }\n\n  return indices;\n}\n\nfunction generateDateBreaksForWeekend(min, max, weekendDayIndices) {\n  var day = min.getDate();\n  var breaks = [];\n  var weekends = weekendDayIndices.reduce(function (obj, day) {\n    var currentWeekEnd = obj[1];\n\n    if (void 0 === currentWeekEnd.start) {\n      currentWeekEnd = {\n        start: day,\n        end: getNextDayIndex(day)\n      };\n      obj[0].push(currentWeekEnd);\n      return [obj[0], currentWeekEnd];\n    } else if (currentWeekEnd.end === day) {\n      currentWeekEnd.end = getNextDayIndex(day);\n      return obj;\n    }\n\n    currentWeekEnd = {\n      start: day,\n      end: getNextDayIndex(day)\n    };\n    obj[0].push(currentWeekEnd);\n    return [obj[0], currentWeekEnd];\n  }, [[], {}]);\n  weekends[0].forEach(function (weekend) {\n    var currentDate = new Date(min);\n    currentDate = dateUtils.trimTime(currentDate);\n\n    while (currentDate < max) {\n      day = currentDate.getDay();\n      var date = currentDate.getDate();\n\n      if (dayBetweenWeekend(weekend, day)) {\n        var from = new Date(currentDate);\n        currentDate.setDate(date + getDaysDistance(day, weekend.end));\n        var to = new Date(currentDate);\n        breaks.push({\n          from: from,\n          to: to\n        });\n      }\n\n      currentDate.setDate(currentDate.getDate() + 1);\n    }\n  });\n  return breaks;\n}\n\nfunction excludeWorkDaysFromWeekEndBreaks(breaks, exactWorkDays) {\n  var result = breaks.slice();\n  var i;\n\n  var processWorkDay = function processWorkDay(workday) {\n    workday = dateUtils.trimTime(new Date(workday));\n\n    if (result[i].from <= workday && result[i].to > workday) {\n      var separatedBreak = separateBreak(result[i], workday);\n\n      if (2 === separatedBreak.length) {\n        result.splice(i, 1, separatedBreak[0], separatedBreak[1]);\n      } else if (1 === separatedBreak.length) {\n        result.splice(i, 1, separatedBreak[0]);\n      } else {\n        result.splice(i, 1);\n      }\n    }\n  };\n\n  for (i = 0; i < result.length; i++) {\n    exactWorkDays.forEach(processWorkDay);\n  }\n\n  return result;\n}\n\nfunction generateBreaksForHolidays(min, max, holidays, weekendDayIndices) {\n  var day;\n\n  var dayInWeekend = function dayInWeekend(dayIndex) {\n    return dayIndex === day;\n  };\n\n  var adjustedMin = dateUtils.trimTime(min);\n  var adjustedMax = dateUtils.trimTime(max);\n  adjustedMax.setDate(max.getDate() + 1);\n  return holidays.reduce(function (breaks, holiday) {\n    var holidayStart;\n    var holidayEnd;\n    holiday = new Date(holiday);\n    day = holiday.getDay();\n\n    if (!weekendDayIndices.some(dayInWeekend) && holiday >= adjustedMin && holiday <= adjustedMax) {\n      holidayStart = dateUtils.trimTime(holiday);\n      holidayEnd = new Date(holidayStart);\n      holidayEnd.setDate(holidayStart.getDate() + 1);\n      breaks.push({\n        from: holidayStart,\n        to: holidayEnd\n      });\n    }\n\n    return breaks;\n  }, []);\n}\n\nfunction calculateGaps(breaks) {\n  return breaks.map(function (b) {\n    return {\n      from: b.from,\n      to: b.to,\n      gapSize: dateUtils.convertMillisecondsToDateUnits(b.to - b.from)\n    };\n  });\n}\n\nexport function generateDateBreaks(min, max, workWeek, singleWorkdays, holidays) {\n  var weekendDayIndices = getWeekEndDayIndices(workWeek);\n  var breaks = generateDateBreaksForWeekend(min, max, weekendDayIndices);\n  breaks.push.apply(breaks, generateBreaksForHolidays(min, max, holidays || [], weekendDayIndices));\n  return calculateGaps(excludeWorkDaysFromWeekEndBreaks(breaks, singleWorkdays || []));\n}","map":null,"metadata":{},"sourceType":"module"}