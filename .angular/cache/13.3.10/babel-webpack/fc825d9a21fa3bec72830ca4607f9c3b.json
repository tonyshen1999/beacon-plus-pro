{"ast":null,"code":"/**\r\n * DevExtreme (esm/viz/series/points/base_point.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nvar mixins = {};\nimport consts from \"../../components/consts\";\nimport symbolPoint from \"./symbol_point\";\nimport barPoint from \"./bar_point\";\nimport bubblePoint from \"./bubble_point\";\nimport piePoint from \"./pie_point\";\nimport rangeSymbolPoint from \"./range_symbol_point\";\nimport rangeBarPoint from \"./range_bar_point\";\nimport candlestickPoint from \"./candlestick_point\";\nimport stockPoint from \"./stock_point\";\nimport { polarSymbolPoint, polarBarPoint } from \"./polar_point\";\nimport { normalizeEnum as _normalizeEnum } from \"../../core/utils\";\nimport { extend } from \"../../../core/utils/extend\";\nvar _extend = extend;\nimport { isDefined as _isDefined } from \"../../../core/utils/type\";\nimport { noop as _noop } from \"../../../core/utils/common\";\nvar statesConsts = consts.states;\nvar SYMBOL_POINT = \"symbolPoint\";\nvar POLAR_SYMBOL_POINT = \"polarSymbolPoint\";\nvar BAR_POINT = \"barPoint\";\nvar POLAR_BAR_POINT = \"polarBarPoint\";\nvar PIE_POINT = \"piePoint\";\nvar SELECTED_STATE = statesConsts.selectedMark;\nvar HOVER_STATE = statesConsts.hoverMark;\nvar NORMAL_STATE = statesConsts.normalMark;\nvar HOVER = statesConsts.hover;\nvar NORMAL = statesConsts.normal;\nvar SELECTION = statesConsts.selection;\nvar pointTypes = {\n  chart: {\n    scatter: SYMBOL_POINT,\n    line: SYMBOL_POINT,\n    spline: SYMBOL_POINT,\n    stepline: SYMBOL_POINT,\n    stackedline: SYMBOL_POINT,\n    fullstackedline: SYMBOL_POINT,\n    stackedspline: SYMBOL_POINT,\n    fullstackedspline: SYMBOL_POINT,\n    stackedsplinearea: SYMBOL_POINT,\n    fullstackedsplinearea: SYMBOL_POINT,\n    area: SYMBOL_POINT,\n    splinearea: SYMBOL_POINT,\n    steparea: SYMBOL_POINT,\n    stackedarea: SYMBOL_POINT,\n    fullstackedarea: SYMBOL_POINT,\n    rangearea: \"rangeSymbolPoint\",\n    bar: BAR_POINT,\n    stackedbar: BAR_POINT,\n    fullstackedbar: BAR_POINT,\n    rangebar: \"rangeBarPoint\",\n    bubble: \"bubblePoint\",\n    stock: \"stockPoint\",\n    candlestick: \"candlestickPoint\"\n  },\n  pie: {\n    pie: PIE_POINT,\n    doughnut: PIE_POINT,\n    donut: PIE_POINT\n  },\n  polar: {\n    scatter: POLAR_SYMBOL_POINT,\n    line: POLAR_SYMBOL_POINT,\n    area: POLAR_SYMBOL_POINT,\n    bar: POLAR_BAR_POINT,\n    stackedbar: POLAR_BAR_POINT\n  }\n};\n\nfunction isNoneMode(mode) {\n  return \"none\" === _normalizeEnum(mode);\n}\n\nexport function Point(series, dataItem, options) {\n  this.fullState = NORMAL_STATE;\n  this.series = series;\n  this.update(dataItem, options);\n  this._viewCounters = {\n    hover: 0,\n    selection: 0\n  };\n  this._emptySettings = {\n    fill: null,\n    stroke: null,\n    dashStyle: null\n  };\n}\nmixins.symbolPoint = symbolPoint;\nmixins.barPoint = barPoint;\nmixins.bubblePoint = bubblePoint;\nmixins.piePoint = piePoint;\nmixins.rangeSymbolPoint = rangeSymbolPoint;\nmixins.rangeBarPoint = rangeBarPoint;\nmixins.candlestickPoint = candlestickPoint;\nmixins.stockPoint = stockPoint;\nmixins.polarSymbolPoint = polarSymbolPoint;\nmixins.polarBarPoint = polarBarPoint;\nPoint.prototype = {\n  constructor: Point,\n  getColor: function getColor() {\n    if (!this.hasValue() && !this._styles.usePointCustomOptions) {\n      this.series.customizePoint(this, this._dataItem);\n    }\n\n    return this._styles.normal.fill || this.series.getColor();\n  },\n  _getStyle: function _getStyle() {\n    return this._styles[this._currentStyle || \"normal\"];\n  },\n  update: function update(dataItem, options) {\n    this.updateOptions(options);\n    this.updateData(dataItem);\n  },\n  updateData: function updateData(dataItem) {\n    var argumentWasChanged = this.argument !== dataItem.argument;\n    this.argument = this.initialArgument = this.originalArgument = dataItem.argument;\n    this.tag = dataItem.tag;\n    this.index = dataItem.index;\n    this._dataItem = dataItem;\n    this.data = dataItem.data;\n    this.lowError = dataItem.lowError;\n    this.highError = dataItem.highError;\n    this.aggregationInfo = dataItem.aggregationInfo;\n\n    this._updateData(dataItem, argumentWasChanged);\n\n    !this.hasValue() && this.setInvisibility();\n\n    this._fillStyle();\n\n    this._updateLabelData();\n  },\n  deleteMarker: function deleteMarker() {\n    if (this.graphic) {\n      this.graphic.dispose();\n    }\n\n    this.graphic = null;\n  },\n  draw: function draw(renderer, groups, animationEnabled, firstDrawing) {\n    if (this._needDeletingOnDraw || this.series.autoHidePointMarkers && !this.isSelected()) {\n      this.deleteMarker();\n      this._needDeletingOnDraw = false;\n    }\n\n    if (this._needClearingOnDraw) {\n      this.clearMarker();\n      this._needClearingOnDraw = false;\n    }\n\n    if (!this._hasGraphic()) {\n      this.getMarkerVisibility() && !this.series.autoHidePointMarkers && this._drawMarker(renderer, groups.markers, animationEnabled, firstDrawing);\n    } else {\n      this._updateMarker(animationEnabled, this._getStyle(), groups.markers);\n    }\n\n    this._drawLabel();\n\n    this._drawErrorBar(renderer, groups.errorBars, animationEnabled);\n\n    return this;\n  },\n  _getViewStyle: function _getViewStyle() {\n    var state = NORMAL_STATE;\n    var fullState = this.fullState;\n    var styles = [NORMAL, HOVER, SELECTION, SELECTION];\n\n    if (this._viewCounters.hover) {\n      state |= HOVER_STATE;\n    }\n\n    if (this._viewCounters.selection) {\n      state |= SELECTED_STATE;\n    }\n\n    if (isNoneMode(this.getOptions().selectionMode)) {\n      fullState &= ~SELECTED_STATE;\n    }\n\n    if (isNoneMode(this.getOptions().hoverMode)) {\n      fullState &= ~HOVER_STATE;\n    }\n\n    state |= fullState;\n    return styles[state];\n  },\n  applyView: function applyView(legendCallback) {\n    var style = this._getViewStyle();\n\n    this._currentStyle = style;\n\n    if (!this.graphic && this.getMarkerVisibility() && this.series.autoHidePointMarkers && (style === SELECTION || style === HOVER)) {\n      this._drawMarker(this.series.getRenderer(), this.series.getMarkersGroup());\n    }\n\n    if (this.graphic) {\n      if (this.series.autoHidePointMarkers && style !== SELECTION && style !== HOVER) {\n        this.deleteMarker();\n      } else {\n        if (\"normal\" === style) {\n          this.clearMarker();\n        } else {\n          this.graphic.toForeground();\n        }\n\n        this._updateMarker(true, this._styles[style], void 0, legendCallback);\n      }\n    }\n  },\n  setView: function setView(style) {\n    this._viewCounters[style]++;\n    this.applyView();\n  },\n  resetView: function resetView(style) {\n    var viewCounters = this._viewCounters;\n    --viewCounters[style];\n\n    if (viewCounters[style] < 0) {\n      viewCounters[style] = 0;\n    }\n\n    this.applyView();\n  },\n  releaseHoverState: function releaseHoverState() {\n    if (this.graphic && !this.isSelected()) {\n      this.graphic.toBackground();\n    }\n  },\n  select: function select() {\n    this.series.selectPoint(this);\n  },\n  clearSelection: function clearSelection() {\n    this.series.deselectPoint(this);\n  },\n  hover: function hover() {\n    this.series.hoverPoint(this);\n  },\n  clearHover: function clearHover() {\n    this.series.clearPointHover();\n  },\n  showTooltip: function showTooltip() {\n    this.series.showPointTooltip(this);\n  },\n  hideTooltip: function hideTooltip() {\n    this.series.hidePointTooltip(this);\n  },\n  _checkLabelsChanging: function _checkLabelsChanging(oldType, newType) {\n    var isNewRange = ~newType.indexOf(\"range\");\n    var isOldRange = ~oldType.indexOf(\"range\");\n    return isOldRange && !isNewRange || !isOldRange && isNewRange;\n  },\n  updateOptions: function updateOptions(newOptions) {\n    if (!newOptions) {\n      return;\n    }\n\n    var oldOptions = this._options;\n    var widgetType = newOptions.widgetType;\n    var oldType = oldOptions && oldOptions.type;\n    var newType = newOptions.type;\n    var newPointTypeMixin = pointTypes[widgetType][newType];\n\n    if (oldType !== newType) {\n      this._needDeletingOnDraw = true;\n      this._needClearingOnDraw = false;\n\n      if (oldType) {\n        this._checkLabelsChanging(oldType, newType) && this.deleteLabel();\n\n        this._resetType(mixins[pointTypes[oldType]]);\n      }\n\n      this._setType(mixins[newPointTypeMixin]);\n    } else {\n      this._needDeletingOnDraw = this._checkSymbol(oldOptions, newOptions);\n      this._needClearingOnDraw = this._checkCustomize(oldOptions, newOptions);\n    }\n\n    this._options = newOptions;\n\n    this._fillStyle();\n\n    this._updateLabelOptions(newPointTypeMixin);\n  },\n  translate: function translate() {\n    if (this.hasValue()) {\n      this._translate();\n\n      this.translated = true;\n    }\n  },\n  _checkCustomize: function _checkCustomize(oldOptions, newOptions) {\n    return oldOptions.styles.usePointCustomOptions && !newOptions.styles.usePointCustomOptions;\n  },\n  _getCustomLabelVisibility: function _getCustomLabelVisibility() {\n    return this._styles.useLabelCustomOptions ? !!this._options.label.visible : null;\n  },\n  getBoundingRect: function getBoundingRect() {\n    return this._getGraphicBBox();\n  },\n  _resetType: function _resetType(methods) {\n    for (var methodName in methods) {\n      delete this[methodName];\n    }\n  },\n  _setType: function _setType(methods) {\n    for (var methodName in methods) {\n      this[methodName] = methods[methodName];\n    }\n  },\n  isInVisibleArea: function isInVisibleArea() {\n    return this.inVisibleArea;\n  },\n  isSelected: function isSelected() {\n    return !!(this.fullState & SELECTED_STATE);\n  },\n  isHovered: function isHovered() {\n    return !!(this.fullState & HOVER_STATE);\n  },\n  getOptions: function getOptions() {\n    return this._options;\n  },\n  animate: function animate(complete, settings, partitionDuration) {\n    if (!this.graphic) {\n      complete && complete();\n      return;\n    }\n\n    this.graphic.animate(settings, {\n      partitionDuration: partitionDuration\n    }, complete);\n  },\n  getCoords: function getCoords(min) {\n    if (!min) {\n      return {\n        x: this.x,\n        y: this.y\n      };\n    }\n\n    if (!this._options.rotated) {\n      return {\n        x: this.x,\n        y: this.minY + (this.y - this.minY ? 0 : 1)\n      };\n    }\n\n    return {\n      x: this.minX - (this.x - this.minX ? 0 : 1),\n      y: this.y\n    };\n  },\n  getDefaultCoords: function getDefaultCoords() {\n    return !this._options.rotated ? {\n      x: this.x,\n      y: this.defaultY\n    } : {\n      x: this.defaultX,\n      y: this.y\n    };\n  },\n  setDefaultCoords: function setDefaultCoords() {\n    var coords = this.getDefaultCoords();\n    this.x = coords.x;\n    this.y = coords.y;\n  },\n  _getVisibleArea: function _getVisibleArea() {\n    return this.series.getVisibleArea();\n  },\n  _getArgTranslator: function _getArgTranslator() {\n    return this.series.getArgumentAxis().getTranslator();\n  },\n  _getValTranslator: function _getValTranslator() {\n    return this.series.getValueAxis().getTranslator();\n  },\n  _calculateVisibility: function _calculateVisibility(x, y, width, height) {\n    var visibleArea = this._getVisibleArea();\n\n    var rotated = this._options.rotated;\n\n    if (visibleArea.minX > x + (width || 0) || visibleArea.maxX < x || visibleArea.minY > y + (height || 0) || visibleArea.maxY < y || rotated && _isDefined(width) && 0 !== width && (visibleArea.minX === x + width || visibleArea.maxX === x) || !rotated && _isDefined(height) && 0 !== height && (visibleArea.minY === y + height || visibleArea.maxY === y)) {\n      this.inVisibleArea = false;\n    } else {\n      this.inVisibleArea = true;\n    }\n  },\n  isArgumentCorrect: function isArgumentCorrect() {\n    return this.series._argumentChecker(this.argument);\n  },\n  isValueCorrect: function isValueCorrect() {\n    var valueChecker = this.series._valueChecker;\n    return valueChecker(this.getMinValue()) && valueChecker(this.getMaxValue());\n  },\n  hasValue: function hasValue() {\n    return null !== this.value && null !== this.minValue && this.isArgumentCorrect() && this.isValueCorrect();\n  },\n  hasCoords: _noop,\n  correctPosition: _noop,\n  correctRadius: _noop,\n  correctLabelRadius: _noop,\n  getCrosshairData: _noop,\n  getPointRadius: _noop,\n  _populatePointShape: _noop,\n  _checkSymbol: _noop,\n  getMarkerCoords: _noop,\n  hide: _noop,\n  show: _noop,\n  hideMarker: _noop,\n  setInvisibility: _noop,\n  clearVisibility: _noop,\n  isVisible: _noop,\n  resetCorrection: _noop,\n  correctValue: _noop,\n  resetValue: _noop,\n  setPercentValue: _noop,\n  correctCoordinates: _noop,\n  coordsIn: _noop,\n  getTooltipParams: _noop,\n  applyWordWrap: _noop,\n  setLabelTrackerData: _noop,\n  updateLabelCoord: _noop,\n  drawLabel: _noop,\n  correctLabelPosition: _noop,\n  getMinValue: _noop,\n  getMaxValue: _noop,\n  _drawErrorBar: _noop,\n  getMarkerVisibility: _noop,\n  dispose: function dispose() {\n    this.deleteMarker();\n    this.deleteLabel();\n    this._errorBar && this._errorBar.dispose();\n    this._options = this._styles = this.series = this._errorBar = null;\n  },\n  getTooltipFormatObject: function getTooltipFormatObject(tooltip, stackPoints) {\n    var tooltipFormatObject = this._getFormatObject(tooltip);\n\n    var sharedTooltipValuesArray = [];\n    var tooltipStackPointsFormatObject = [];\n\n    if (stackPoints) {\n      stackPoints.forEach(function (point) {\n        if (!point.isVisible()) {\n          return;\n        }\n\n        var formatObject = point._getFormatObject(tooltip);\n\n        tooltipStackPointsFormatObject.push(formatObject);\n        sharedTooltipValuesArray.push(formatObject.seriesName + \": \" + formatObject.valueText);\n      });\n\n      _extend(tooltipFormatObject, {\n        points: tooltipStackPointsFormatObject,\n        valueText: sharedTooltipValuesArray.join(\"\\n\"),\n        stackName: this.series.getStackName() || null\n      });\n    }\n\n    var aggregationInfo = this.aggregationInfo;\n\n    if (aggregationInfo) {\n      var axis = this.series.getArgumentAxis();\n      var rangeText = axis.formatRange(aggregationInfo.intervalStart, aggregationInfo.intervalEnd, aggregationInfo.aggregationInterval, tooltip.getOptions().argumentFormat);\n\n      if (rangeText) {\n        tooltipFormatObject.valueText += \"\\n\".concat(rangeText);\n      }\n    }\n\n    return tooltipFormatObject;\n  },\n  setHole: function setHole(holeValue, position) {\n    var minValue = isFinite(this.minValue) ? this.minValue : 0;\n\n    if (_isDefined(holeValue)) {\n      if (\"left\" === position) {\n        this.leftHole = this.value - holeValue;\n        this.minLeftHole = minValue - holeValue;\n      } else {\n        this.rightHole = this.value - holeValue;\n        this.minRightHole = minValue - holeValue;\n      }\n    }\n  },\n  resetHoles: function resetHoles() {\n    this.leftHole = null;\n    this.minLeftHole = null;\n    this.rightHole = null;\n    this.minRightHole = null;\n  },\n  getLabel: function getLabel() {\n    return this._label;\n  },\n  getLabels: function getLabels() {\n    return [this._label];\n  },\n  getCenterCoord: function getCenterCoord() {\n    return {\n      x: this.x,\n      y: this.y\n    };\n  }\n};","map":null,"metadata":{},"sourceType":"module"}