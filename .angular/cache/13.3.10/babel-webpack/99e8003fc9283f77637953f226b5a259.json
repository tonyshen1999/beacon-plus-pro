{"ast":null,"code":"/**\r\n * DevExtreme (esm/data/array_query.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport Class from \"../core/class\";\nimport { isFunction, isDefined } from \"../core/utils/type\";\nimport { each, map } from \"../core/utils/iterator\";\nimport { compileGetter, toComparable } from \"../core/utils/data\";\nimport { Deferred } from \"../core/utils/deferred\";\nimport { errors, handleError as handleDataError } from \"./errors\";\nimport { aggregators, isGroupCriterion, isUnaryOperation, normalizeBinaryCriterion, isConjunctiveOperator as isConjunctiveOperatorChecker } from \"./utils\";\nvar Iterator = Class.inherit({\n  toArray: function toArray() {\n    var result = [];\n    this.reset();\n\n    while (this.next()) {\n      result.push(this.current());\n    }\n\n    return result;\n  },\n  countable: function countable() {\n    return false;\n  }\n});\nvar ArrayIterator = Iterator.inherit({\n  ctor: function ctor(array) {\n    this.array = array;\n    this.index = -1;\n  },\n  next: function next() {\n    if (this.index + 1 < this.array.length) {\n      this.index++;\n      return true;\n    }\n\n    return false;\n  },\n  current: function current() {\n    return this.array[this.index];\n  },\n  reset: function reset() {\n    this.index = -1;\n  },\n  toArray: function toArray() {\n    return this.array.slice(0);\n  },\n  countable: function countable() {\n    return true;\n  },\n  count: function count() {\n    return this.array.length;\n  }\n});\nvar WrappedIterator = Iterator.inherit({\n  ctor: function ctor(iter) {\n    this.iter = iter;\n  },\n  next: function next() {\n    return this.iter.next();\n  },\n  current: function current() {\n    return this.iter.current();\n  },\n  reset: function reset() {\n    return this.iter.reset();\n  }\n});\nvar MapIterator = WrappedIterator.inherit({\n  ctor: function ctor(iter, mapper) {\n    this.callBase(iter);\n    this.index = -1;\n    this.mapper = mapper;\n  },\n  current: function current() {\n    return this.mapper(this.callBase(), this.index);\n  },\n  next: function next() {\n    var hasNext = this.callBase();\n\n    if (hasNext) {\n      this.index++;\n    }\n\n    return hasNext;\n  }\n});\n\nvar defaultCompare = function defaultCompare(xValue, yValue) {\n  xValue = toComparable(xValue);\n  yValue = toComparable(yValue);\n\n  if (null === xValue && null !== yValue) {\n    return -1;\n  }\n\n  if (null !== xValue && null === yValue) {\n    return 1;\n  }\n\n  if (void 0 === xValue && void 0 !== yValue) {\n    return 1;\n  }\n\n  if (void 0 !== xValue && void 0 === yValue) {\n    return -1;\n  }\n\n  if (xValue < yValue) {\n    return -1;\n  }\n\n  if (xValue > yValue) {\n    return 1;\n  }\n\n  return 0;\n};\n\nvar SortIterator = Iterator.inherit({\n  ctor: function ctor(iter, getter, desc, compare) {\n    if (!(iter instanceof MapIterator)) {\n      iter = new MapIterator(iter, this._wrap);\n    }\n\n    this.iter = iter;\n    this.rules = [{\n      getter: getter,\n      desc: desc,\n      compare: compare\n    }];\n  },\n  thenBy: function thenBy(getter, desc, compare) {\n    var result = new SortIterator(this.sortedIter || this.iter, getter, desc, compare);\n\n    if (!this.sortedIter) {\n      result.rules = this.rules.concat(result.rules);\n    }\n\n    return result;\n  },\n  next: function next() {\n    this._ensureSorted();\n\n    return this.sortedIter.next();\n  },\n  current: function current() {\n    this._ensureSorted();\n\n    return this.sortedIter.current();\n  },\n  reset: function reset() {\n    delete this.sortedIter;\n  },\n  countable: function countable() {\n    return this.sortedIter || this.iter.countable();\n  },\n  count: function count() {\n    if (this.sortedIter) {\n      return this.sortedIter.count();\n    }\n\n    return this.iter.count();\n  },\n  _ensureSorted: function _ensureSorted() {\n    var that = this;\n\n    if (that.sortedIter) {\n      return;\n    }\n\n    each(that.rules, function () {\n      this.getter = compileGetter(this.getter);\n    });\n    that.sortedIter = new MapIterator(new ArrayIterator(this.iter.toArray().sort(function (x, y) {\n      return that._compare(x, y);\n    })), that._unwrap);\n  },\n  _wrap: function _wrap(record, index) {\n    return {\n      index: index,\n      value: record\n    };\n  },\n  _unwrap: function _unwrap(wrappedItem) {\n    return wrappedItem.value;\n  },\n  _compare: function _compare(x, y) {\n    var xIndex = x.index;\n    var yIndex = y.index;\n    x = x.value;\n    y = y.value;\n\n    if (x === y) {\n      return xIndex - yIndex;\n    }\n\n    for (var i = 0, rulesCount = this.rules.length; i < rulesCount; i++) {\n      var rule = this.rules[i];\n      var xValue = rule.getter(x);\n      var yValue = rule.getter(y);\n      var compare = rule.compare || defaultCompare;\n      var compareResult = compare(xValue, yValue);\n\n      if (compareResult) {\n        return rule.desc ? -compareResult : compareResult;\n      }\n    }\n\n    return xIndex - yIndex;\n  }\n});\n\nvar compileCriteria = function () {\n  var toString = function toString(value) {\n    return isDefined(value) ? value.toString() : \"\";\n  };\n\n  function compileEquals(getter, value, negate) {\n    return function (obj) {\n      obj = toComparable(getter(obj));\n      var result = function (value) {\n        return \"\" === value || 0 === value || false === value;\n      }(value) ? obj === value : obj == value;\n\n      if (negate) {\n        result = !result;\n      }\n\n      return result;\n    };\n  }\n\n  return function (crit) {\n    if (isFunction(crit)) {\n      return crit;\n    }\n\n    if (isGroupCriterion(crit)) {\n      return function (crit) {\n        var ops = [];\n        var isConjunctiveOperator = false;\n        var isConjunctiveNextOperator = false;\n        each(crit, function () {\n          if (Array.isArray(this) || isFunction(this)) {\n            if (ops.length > 1 && isConjunctiveOperator !== isConjunctiveNextOperator) {\n              throw new errors.Error(\"E4019\");\n            }\n\n            ops.push(compileCriteria(this));\n            isConjunctiveOperator = isConjunctiveNextOperator;\n            isConjunctiveNextOperator = true;\n          } else {\n            isConjunctiveNextOperator = isConjunctiveOperatorChecker(this);\n          }\n        });\n        return function (d) {\n          var result = isConjunctiveOperator;\n\n          for (var i = 0; i < ops.length; i++) {\n            if (ops[i](d) !== isConjunctiveOperator) {\n              result = !isConjunctiveOperator;\n              break;\n            }\n          }\n\n          return result;\n        };\n      }(crit);\n    }\n\n    if (isUnaryOperation(crit)) {\n      return function (crit) {\n        var op = crit[0];\n        var criteria = compileCriteria(crit[1]);\n\n        if (\"!\" === op) {\n          return function (obj) {\n            return !criteria(obj);\n          };\n        }\n\n        throw errors.Error(\"E4003\", op);\n      }(crit);\n    }\n\n    return function (crit) {\n      crit = normalizeBinaryCriterion(crit);\n      var getter = compileGetter(crit[0]);\n      var op = crit[1];\n      var value = crit[2];\n      value = toComparable(value);\n\n      switch (op.toLowerCase()) {\n        case \"=\":\n          return compileEquals(getter, value);\n\n        case \"<>\":\n          return compileEquals(getter, value, true);\n\n        case \">\":\n          return function (obj) {\n            return toComparable(getter(obj)) > value;\n          };\n\n        case \"<\":\n          return function (obj) {\n            return toComparable(getter(obj)) < value;\n          };\n\n        case \">=\":\n          return function (obj) {\n            return toComparable(getter(obj)) >= value;\n          };\n\n        case \"<=\":\n          return function (obj) {\n            return toComparable(getter(obj)) <= value;\n          };\n\n        case \"startswith\":\n          return function (obj) {\n            return 0 === toComparable(toString(getter(obj))).indexOf(value);\n          };\n\n        case \"endswith\":\n          return function (obj) {\n            var getterValue = toComparable(toString(getter(obj)));\n            var searchValue = toString(value);\n\n            if (getterValue.length < searchValue.length) {\n              return false;\n            }\n\n            var index = getterValue.lastIndexOf(value);\n            return -1 !== index && index === getterValue.length - value.length;\n          };\n\n        case \"contains\":\n          return function (obj) {\n            return toComparable(toString(getter(obj))).indexOf(value) > -1;\n          };\n\n        case \"notcontains\":\n          return function (obj) {\n            return -1 === toComparable(toString(getter(obj))).indexOf(value);\n          };\n      }\n\n      throw errors.Error(\"E4003\", op);\n    }(crit);\n  };\n}();\n\nvar FilterIterator = WrappedIterator.inherit({\n  ctor: function ctor(iter, criteria) {\n    this.callBase(iter);\n    this.criteria = compileCriteria(criteria);\n  },\n  next: function next() {\n    while (this.iter.next()) {\n      if (this.criteria(this.current())) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n});\nvar GroupIterator = Iterator.inherit({\n  ctor: function ctor(iter, getter) {\n    this.iter = iter;\n    this.getter = getter;\n  },\n  next: function next() {\n    this._ensureGrouped();\n\n    return this.groupedIter.next();\n  },\n  current: function current() {\n    this._ensureGrouped();\n\n    return this.groupedIter.current();\n  },\n  reset: function reset() {\n    delete this.groupedIter;\n  },\n  countable: function countable() {\n    return !!this.groupedIter;\n  },\n  count: function count() {\n    return this.groupedIter.count();\n  },\n  _ensureGrouped: function _ensureGrouped() {\n    if (this.groupedIter) {\n      return;\n    }\n\n    var hash = {};\n    var keys = [];\n    var iter = this.iter;\n    var getter = compileGetter(this.getter);\n    iter.reset();\n\n    while (iter.next()) {\n      var current = iter.current();\n      var key = getter(current);\n\n      if (key in hash) {\n        hash[key].push(current);\n      } else {\n        hash[key] = [current];\n        keys.push(key);\n      }\n    }\n\n    this.groupedIter = new ArrayIterator(map(keys, function (key) {\n      return {\n        key: key,\n        items: hash[key]\n      };\n    }));\n  }\n});\nvar SelectIterator = WrappedIterator.inherit({\n  ctor: function ctor(iter, getter) {\n    this.callBase(iter);\n    this.getter = compileGetter(getter);\n  },\n  current: function current() {\n    return this.getter(this.callBase());\n  },\n  countable: function countable() {\n    return this.iter.countable();\n  },\n  count: function count() {\n    return this.iter.count();\n  }\n});\nvar SliceIterator = WrappedIterator.inherit({\n  ctor: function ctor(iter, skip, take) {\n    this.callBase(iter);\n    this.skip = Math.max(0, skip);\n    this.take = Math.max(0, take);\n    this.pos = 0;\n  },\n  next: function next() {\n    if (this.pos >= this.skip + this.take) {\n      return false;\n    }\n\n    while (this.pos < this.skip && this.iter.next()) {\n      this.pos++;\n    }\n\n    this.pos++;\n    return this.iter.next();\n  },\n  reset: function reset() {\n    this.callBase();\n    this.pos = 0;\n  },\n  countable: function countable() {\n    return this.iter.countable();\n  },\n  count: function count() {\n    return Math.min(this.iter.count() - this.skip, this.take);\n  }\n});\n\nvar arrayQueryImpl = function arrayQueryImpl(iter, queryOptions) {\n  queryOptions = queryOptions || {};\n\n  if (!(iter instanceof Iterator)) {\n    iter = new ArrayIterator(iter);\n  }\n\n  var handleError = function handleError(error) {\n    var handler = queryOptions.errorHandler;\n\n    if (handler) {\n      handler(error);\n    }\n\n    handleDataError(error);\n  };\n\n  var aggregateCore = function aggregateCore(aggregator) {\n    var d = new Deferred().fail(handleError);\n    var seed;\n    var step = aggregator.step;\n    var finalize = aggregator.finalize;\n\n    try {\n      iter.reset();\n\n      if (\"seed\" in aggregator) {\n        seed = aggregator.seed;\n      } else {\n        seed = iter.next() ? iter.current() : NaN;\n      }\n\n      var accumulator = seed;\n\n      while (iter.next()) {\n        accumulator = step(accumulator, iter.current());\n      }\n\n      d.resolve(finalize ? finalize(accumulator) : accumulator);\n    } catch (x) {\n      d.reject(x);\n    }\n\n    return d.promise();\n  };\n\n  var standardAggregate = function standardAggregate(name) {\n    return aggregateCore(aggregators[name]);\n  };\n\n  var select = function select(getter) {\n    if (!isFunction(getter) && !Array.isArray(getter)) {\n      getter = [].slice.call(arguments);\n    }\n\n    return chainQuery(new SelectIterator(iter, getter));\n  };\n\n  var selectProp = function selectProp(name) {\n    return select(compileGetter(name));\n  };\n\n  function chainQuery(iter) {\n    return arrayQueryImpl(iter, queryOptions);\n  }\n\n  return {\n    toArray: function toArray() {\n      return iter.toArray();\n    },\n    enumerate: function enumerate() {\n      var d = new Deferred().fail(handleError);\n\n      try {\n        d.resolve(iter.toArray());\n      } catch (x) {\n        d.reject(x);\n      }\n\n      return d.promise();\n    },\n    sortBy: function sortBy(getter, desc, compare) {\n      return chainQuery(new SortIterator(iter, getter, desc, compare));\n    },\n    thenBy: function thenBy(getter, desc, compare) {\n      if (iter instanceof SortIterator) {\n        return chainQuery(iter.thenBy(getter, desc, compare));\n      }\n\n      throw errors.Error(\"E4004\");\n    },\n    filter: function filter(criteria) {\n      if (!Array.isArray(criteria)) {\n        criteria = [].slice.call(arguments);\n      }\n\n      return chainQuery(new FilterIterator(iter, criteria));\n    },\n    slice: function slice(skip, take) {\n      if (void 0 === take) {\n        take = Number.MAX_VALUE;\n      }\n\n      return chainQuery(new SliceIterator(iter, skip, take));\n    },\n    select: select,\n    groupBy: function groupBy(getter) {\n      return chainQuery(new GroupIterator(iter, getter));\n    },\n    aggregate: function aggregate(seed, step, finalize) {\n      if (arguments.length < 2) {\n        return aggregateCore({\n          step: arguments[0]\n        });\n      }\n\n      return aggregateCore({\n        seed: seed,\n        step: step,\n        finalize: finalize\n      });\n    },\n    count: function count() {\n      if (iter.countable()) {\n        var d = new Deferred().fail(handleError);\n\n        try {\n          d.resolve(iter.count());\n        } catch (x) {\n          d.reject(x);\n        }\n\n        return d.promise();\n      }\n\n      return standardAggregate(\"count\");\n    },\n    sum: function sum(getter) {\n      if (getter) {\n        return selectProp(getter).sum();\n      }\n\n      return standardAggregate(\"sum\");\n    },\n    min: function min(getter) {\n      if (getter) {\n        return selectProp(getter).min();\n      }\n\n      return standardAggregate(\"min\");\n    },\n    max: function max(getter) {\n      if (getter) {\n        return selectProp(getter).max();\n      }\n\n      return standardAggregate(\"max\");\n    },\n    avg: function avg(getter) {\n      if (getter) {\n        return selectProp(getter).avg();\n      }\n\n      return standardAggregate(\"avg\");\n    }\n  };\n};\n\nexport default arrayQueryImpl;","map":null,"metadata":{},"sourceType":"module"}