{"ast":null,"code":"/**\r\n * DevExtreme (esm/viz/range_selector/slider_marker.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { patchFontOptions } from \"../core/utils\";\nimport { consts } from \"./common\";\nvar POINTER_SIZE = consts.pointerSize;\nvar SLIDER_MARKER_UPDATE_DELAY = 75;\n\nfunction SliderMarker(renderer, root, isLeftPointer) {\n  this._isLeftPointer = isLeftPointer;\n  this._isOverlapped = false;\n  this._group = renderer.g().attr({\n    class: \"slider-marker\"\n  }).append(root);\n  this._area = renderer.path(null, \"area\").append(this._group);\n  this._label = renderer.text().attr({\n    align: \"left\"\n  }).append(this._group);\n  this._tracker = renderer.rect().attr({\n    class: \"slider-marker-tracker\",\n    fill: \"#000000\",\n    opacity: 1e-4\n  }).css({\n    cursor: \"pointer\"\n  }).append(this._group);\n  this._border = renderer.rect(0, 0, 1, 0);\n}\n\nSliderMarker.prototype = {\n  constructor: SliderMarker,\n  _getRectSize: function _getRectSize(textSize) {\n    return {\n      width: Math.round(2 * this._paddingLeftRight + textSize.width),\n      height: Math.round(2 * this._paddingTopBottom + textSize.height)\n    };\n  },\n  _getTextSize: function _getTextSize() {\n    var textSize = this._label.getBBox();\n\n    if (!this._textHeight && isFinite(textSize.height)) {\n      this._textHeight = textSize.height;\n    }\n\n    return {\n      width: textSize.width,\n      height: this._textHeight,\n      y: textSize.y\n    };\n  },\n  _getAreaPointsInfo: function _getAreaPointsInfo(textSize) {\n    var rectSize = this._getRectSize(textSize);\n\n    var rectWidth = rectSize.width;\n    var rectHeight = rectSize.height;\n    var rectLeftBorder = -rectWidth;\n    var rectRightBorder = 0;\n    var pointerRightPoint = POINTER_SIZE;\n    var pointerCenterPoint = 0;\n    var pointerLeftPoint = -POINTER_SIZE;\n    var position = this._position;\n    var isLeft = this._isLeftPointer;\n\n    var correctCloudBorders = function correctCloudBorders() {\n      rectLeftBorder++;\n      rectRightBorder++;\n      pointerRightPoint++;\n      pointerCenterPoint++;\n      pointerLeftPoint++;\n    };\n\n    var checkPointerBorders = function checkPointerBorders() {\n      if (pointerRightPoint > rectRightBorder) {\n        pointerRightPoint = rectRightBorder;\n      } else if (pointerLeftPoint < rectLeftBorder) {\n        pointerLeftPoint = rectLeftBorder;\n      }\n\n      isLeft && correctCloudBorders();\n    };\n\n    var borderPosition = position;\n\n    if (isLeft) {\n      if (position > this._range[1] - rectWidth) {\n        rectRightBorder = -position + this._range[1];\n        rectLeftBorder = rectRightBorder - rectWidth;\n        checkPointerBorders();\n        borderPosition += rectLeftBorder;\n      } else {\n        rectLeftBorder = pointerLeftPoint = 0;\n        rectRightBorder = rectWidth;\n      }\n    } else if (position - this._range[0] < rectWidth) {\n      rectLeftBorder = -(position - this._range[0]);\n      rectRightBorder = rectLeftBorder + rectWidth;\n      checkPointerBorders();\n      borderPosition += rectRightBorder;\n    } else {\n      pointerRightPoint = 0;\n      correctCloudBorders();\n    }\n\n    this._borderPosition = borderPosition;\n    return {\n      offset: rectLeftBorder,\n      isCut: (!isLeft || pointerCenterPoint !== pointerLeftPoint) && (isLeft || pointerCenterPoint !== pointerRightPoint),\n      points: [rectLeftBorder, 0, rectRightBorder, 0, rectRightBorder, rectHeight, pointerRightPoint, rectHeight, pointerCenterPoint, rectHeight + POINTER_SIZE, pointerLeftPoint, rectHeight, rectLeftBorder, rectHeight]\n    };\n  },\n  _update: function _update() {\n    var that = this;\n    var textSize;\n    clearTimeout(that._timeout);\n\n    that._label.attr({\n      text: that._text || \"\"\n    });\n\n    var currentTextSize = that._getTextSize();\n\n    var rectSize = that._getRectSize(currentTextSize);\n\n    textSize = that._textSize || currentTextSize;\n    textSize = that._textSize = currentTextSize.width > textSize.width || currentTextSize.height > textSize.height ? currentTextSize : textSize;\n    that._timeout = setTimeout(function () {\n      updateSliderMarker(currentTextSize, rectSize);\n      that._textSize = currentTextSize;\n    }, SLIDER_MARKER_UPDATE_DELAY);\n\n    function updateSliderMarker(size, rectSize) {\n      rectSize = rectSize || that._getRectSize(size);\n\n      that._group.attr({\n        translateY: -(rectSize.height + POINTER_SIZE)\n      });\n\n      var pointsData = that._getAreaPointsInfo(size);\n\n      var points = pointsData.points;\n      var offset = pointsData.offset;\n\n      that._area.attr({\n        points: points\n      });\n\n      that._border.attr({\n        x: that._isLeftPointer ? points[0] - 1 : points[2],\n        height: pointsData.isCut ? rectSize.height : rectSize.height + POINTER_SIZE\n      });\n\n      that._tracker.attr({\n        translateX: offset,\n        width: rectSize.width,\n        height: rectSize.height + POINTER_SIZE\n      });\n\n      that._label.attr({\n        translateX: that._paddingLeftRight + offset,\n        translateY: rectSize.height / 2 - (size.y + size.height / 2)\n      });\n    }\n\n    updateSliderMarker(textSize);\n  },\n  setText: function setText(value) {\n    this._text = value;\n  },\n  setPosition: function setPosition(position) {\n    this._position = position;\n\n    this._update();\n  },\n  applyOptions: function applyOptions(options, screenRange) {\n    this._range = screenRange;\n    this._paddingLeftRight = options.paddingLeftRight;\n    this._paddingTopBottom = options.paddingTopBottom;\n    this._textHeight = null;\n    this._colors = [options.invalidRangeColor, options.color];\n\n    this._area.attr({\n      fill: options.color\n    });\n\n    this._border.attr({\n      fill: options.borderColor\n    });\n\n    this._label.css(patchFontOptions(options.font));\n\n    this._update();\n  },\n  getTracker: function getTracker() {\n    return this._tracker;\n  },\n  setValid: function setValid(isValid) {\n    this._area.attr({\n      fill: this._colors[Number(isValid)]\n    });\n  },\n  setColor: function setColor(color) {\n    this._area.attr({\n      fill: color\n    });\n  },\n  dispose: function dispose() {\n    clearTimeout(this._timeout);\n  },\n  setOverlapped: function setOverlapped(isOverlapped) {\n    if (this._isOverlapped !== isOverlapped) {\n      if (isOverlapped) {\n        this._border.append(this._group);\n      } else {\n        this._isOverlapped && this._border.remove();\n      }\n\n      this._isOverlapped = isOverlapped;\n    }\n  },\n  getBorderPosition: function getBorderPosition() {\n    return this._borderPosition;\n  }\n};\nexport default SliderMarker;","map":null,"metadata":{},"sourceType":"module"}