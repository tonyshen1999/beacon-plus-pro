{"ast":null,"code":"import _toConsumableArray from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\n\n/**\r\n * DevExtreme (esm/data/array_utils.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { isPlainObject, isEmptyObject, isDefined, isObject } from \"../core/utils/type\";\nimport config from \"../core/config\";\nimport Guid from \"../core/guid\";\nimport { extend, extendFromObject } from \"../core/utils/extend\";\nimport { errors } from \"./errors\";\nimport { deepExtendArraySafe } from \"../core/utils/object\";\nimport { compileGetter } from \"../core/utils/data\";\nimport { keysEqual, rejectedPromise, trivialPromise } from \"./utils\";\n\nfunction hasKey(target, keyOrKeys) {\n  var key;\n  var keys = \"string\" === typeof keyOrKeys ? keyOrKeys.split() : keyOrKeys.slice();\n\n  while (keys.length) {\n    key = keys.shift();\n\n    if (key in target) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction findItems(keyInfo, items, key, groupCount) {\n  var childItems;\n  var result;\n\n  if (groupCount) {\n    for (var i = 0; i < items.length; i++) {\n      childItems = items[i].items || items[i].collapsedItems || [];\n      result = findItems(keyInfo, childItems || [], key, groupCount - 1);\n\n      if (result) {\n        return result;\n      }\n    }\n  } else if (indexByKey(keyInfo, items, key) >= 0) {\n    return items;\n  }\n}\n\nfunction getItems(keyInfo, items, key, groupCount) {\n  if (groupCount) {\n    return findItems(keyInfo, items, key, groupCount) || [];\n  }\n\n  return items;\n}\n\nfunction generateDataByKeyMap(keyInfo, array) {\n  if (keyInfo.key() && (!array._dataByKeyMap || array._dataByKeyMapLength !== array.length)) {\n    var dataByKeyMap = {};\n    var arrayLength = array.length;\n\n    for (var i = 0; i < arrayLength; i++) {\n      dataByKeyMap[JSON.stringify(keyInfo.keyOf(array[i]))] = array[i];\n    }\n\n    array._dataByKeyMap = dataByKeyMap;\n    array._dataByKeyMapLength = arrayLength;\n  }\n}\n\nfunction getCacheValue(array, key) {\n  if (array._dataByKeyMap) {\n    return array._dataByKeyMap[JSON.stringify(key)];\n  }\n}\n\nfunction getHasKeyCacheValue(array, key) {\n  if (array._dataByKeyMap) {\n    return array._dataByKeyMap[JSON.stringify(key)];\n  }\n\n  return true;\n}\n\nfunction setDataByKeyMapValue(array, key, data) {\n  if (array._dataByKeyMap) {\n    array._dataByKeyMap[JSON.stringify(key)] = data;\n    array._dataByKeyMapLength += data ? 1 : -1;\n  }\n}\n\nfunction cloneInstance(instance, clonedInstances) {\n  clonedInstances = clonedInstances || new WeakMap();\n  var result = instance ? Object.create(Object.getPrototypeOf(instance)) : {};\n\n  if (instance) {\n    clonedInstances.set(instance, result);\n  }\n\n  var instanceWithoutPrototype = extendFromObject({}, instance);\n\n  for (var name in instanceWithoutPrototype) {\n    var prop = instanceWithoutPrototype[name];\n\n    if (isObject(prop) && !isPlainObject(prop) && !clonedInstances.has(prop)) {\n      instanceWithoutPrototype[name] = cloneInstance(prop, clonedInstances);\n    }\n  }\n\n  deepExtendArraySafe(result, instanceWithoutPrototype, true, true);\n\n  for (var _name in result) {\n    var _prop = result[_name];\n\n    if (isObject(_prop) && clonedInstances.has(_prop)) {\n      result[_name] = clonedInstances.get(_prop);\n    }\n  }\n\n  return result;\n}\n\nfunction createObjectWithChanges(target, changes) {\n  var result = cloneInstance(target);\n  return deepExtendArraySafe(result, changes, true, true);\n}\n\nfunction applyBatch(_ref) {\n  var keyInfo = _ref.keyInfo,\n      data = _ref.data,\n      changes = _ref.changes,\n      groupCount = _ref.groupCount,\n      useInsertIndex = _ref.useInsertIndex,\n      immutable = _ref.immutable,\n      disableCache = _ref.disableCache,\n      logError = _ref.logError;\n  var resultItems = true === immutable ? _toConsumableArray(data) : data;\n  changes.forEach(function (item) {\n    var items = \"insert\" === item.type ? resultItems : getItems(keyInfo, resultItems, item.key, groupCount);\n    !disableCache && generateDataByKeyMap(keyInfo, items);\n\n    switch (item.type) {\n      case \"update\":\n        update(keyInfo, items, item.key, item.data, true, immutable, logError);\n        break;\n\n      case \"insert\":\n        insert(keyInfo, items, item.data, useInsertIndex && isDefined(item.index) ? item.index : -1, true, logError);\n        break;\n\n      case \"remove\":\n        remove(keyInfo, items, item.key, true, logError);\n    }\n  });\n  return resultItems;\n}\n\nfunction getErrorResult(isBatch, logError, errorCode) {\n  return !isBatch ? rejectedPromise(errors.Error(errorCode)) : logError && errors.log(errorCode);\n}\n\nfunction applyChanges(data, changes) {\n  var options = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};\n  var _options$keyExpr = options.keyExpr,\n      keyExpr = _options$keyExpr === void 0 ? \"id\" : _options$keyExpr,\n      _options$immutable = options.immutable,\n      immutable = _options$immutable === void 0 ? true : _options$immutable;\n  var keyGetter = compileGetter(keyExpr);\n  var keyInfo = {\n    key: function key() {\n      return keyExpr;\n    },\n    keyOf: function keyOf(obj) {\n      return keyGetter(obj);\n    }\n  };\n  return applyBatch({\n    keyInfo: keyInfo,\n    data: data,\n    changes: changes,\n    immutable: immutable,\n    disableCache: true,\n    logError: true\n  });\n}\n\nfunction update(keyInfo, array, key, data, isBatch, immutable, logError) {\n  var target;\n  var keyExpr = keyInfo.key();\n\n  if (keyExpr) {\n    if (hasKey(data, keyExpr) && !keysEqual(keyExpr, key, keyInfo.keyOf(data))) {\n      return getErrorResult(isBatch, logError, \"E4017\");\n    }\n\n    target = getCacheValue(array, key);\n\n    if (!target) {\n      var index = indexByKey(keyInfo, array, key);\n\n      if (index < 0) {\n        return getErrorResult(isBatch, logError, \"E4009\");\n      }\n\n      target = array[index];\n\n      if (true === immutable && isDefined(target)) {\n        var newTarget = createObjectWithChanges(target, data);\n        array[index] = newTarget;\n        return !isBatch && trivialPromise(newTarget, key);\n      }\n    }\n  } else {\n    target = key;\n  }\n\n  deepExtendArraySafe(target, data, true);\n\n  if (!isBatch) {\n    if (config().useLegacyStoreResult) {\n      return trivialPromise(key, data);\n    } else {\n      return trivialPromise(target, key);\n    }\n  }\n}\n\nfunction insert(keyInfo, array, data, index, isBatch, logError) {\n  var keyValue;\n  var keyExpr = keyInfo.key();\n  var obj = isPlainObject(data) ? extend({}, data) : data;\n\n  if (keyExpr) {\n    keyValue = keyInfo.keyOf(obj);\n\n    if (void 0 === keyValue || \"object\" === typeof keyValue && isEmptyObject(keyValue)) {\n      if (Array.isArray(keyExpr)) {\n        throw errors.Error(\"E4007\");\n      }\n\n      keyValue = obj[keyExpr] = String(new Guid());\n    } else if (void 0 !== array[indexByKey(keyInfo, array, keyValue)]) {\n      return getErrorResult(isBatch, logError, \"E4008\");\n    }\n  } else {\n    keyValue = obj;\n  }\n\n  if (index >= 0) {\n    array.splice(index, 0, obj);\n  } else {\n    array.push(obj);\n  }\n\n  setDataByKeyMapValue(array, keyValue, obj);\n\n  if (!isBatch) {\n    return trivialPromise(config().useLegacyStoreResult ? data : obj, keyValue);\n  }\n}\n\nfunction remove(keyInfo, array, key, isBatch, logError) {\n  var index = indexByKey(keyInfo, array, key);\n\n  if (index > -1) {\n    array.splice(index, 1);\n    setDataByKeyMapValue(array, key, null);\n  }\n\n  if (!isBatch) {\n    return trivialPromise(key);\n  } else if (index < 0) {\n    return getErrorResult(isBatch, logError, \"E4009\");\n  }\n}\n\nfunction indexByKey(keyInfo, array, key) {\n  var keyExpr = keyInfo.key();\n\n  if (!getHasKeyCacheValue(array, key)) {\n    return -1;\n  }\n\n  for (var i = 0, arrayLength = array.length; i < arrayLength; i++) {\n    if (keysEqual(keyExpr, keyInfo.keyOf(array[i]), key)) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\nexport { applyBatch, createObjectWithChanges, update, insert, remove, indexByKey, applyChanges };","map":null,"metadata":{},"sourceType":"module"}