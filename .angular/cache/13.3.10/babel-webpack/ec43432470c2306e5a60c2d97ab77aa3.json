{"ast":null,"code":"import _toConsumableArray from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _get from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _slicedToArray from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _classCallCheck from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n\n/**\r\n * DevExtreme (esm/ui/scheduler/appointments/settingsGenerator.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport dateUtils from \"../../../core/utils/date\";\nimport { isEmptyObject } from \"../../../core/utils/type\";\nimport { extend } from \"../../../core/utils/extend\";\nimport { getRecurrenceProcessor } from \"../recurrence\";\nimport timeZoneUtils from \"../utils.timeZone\";\nimport { createResourcesTree, getDataAccessors, getGroupCount, getResourceTreeLeaves } from \"../resources/utils\";\nimport { createAppointmentAdapter } from \"../appointmentAdapter\";\nimport { CellPositionCalculator } from \"./cellPositionCalculator\";\nimport { ExpressionUtils } from \"../expressionUtils\";\nimport { isDateAndTimeView } from \"../../../renovation/ui/scheduler/view_model/to_test/views/utils/base\";\nimport { createFormattedDateText } from \"./textUtils\";\nvar toMs = dateUtils.dateToMilliseconds;\nvar APPOINTMENT_DATE_TEXT_FORMAT = \"TIME\";\nexport var DateGeneratorBaseStrategy = /*#__PURE__*/function () {\n  function DateGeneratorBaseStrategy(options) {\n    _classCallCheck(this, DateGeneratorBaseStrategy);\n\n    this.options = options;\n  }\n\n  _createClass(DateGeneratorBaseStrategy, [{\n    key: \"rawAppointment\",\n    get: function get() {\n      return this.options.rawAppointment;\n    }\n  }, {\n    key: \"timeZoneCalculator\",\n    get: function get() {\n      return this.options.timeZoneCalculator;\n    }\n  }, {\n    key: \"viewDataProvider\",\n    get: function get() {\n      return this.options.viewDataProvider;\n    }\n  }, {\n    key: \"appointmentTakesAllDay\",\n    get: function get() {\n      return this.options.appointmentTakesAllDay;\n    }\n  }, {\n    key: \"supportAllDayRow\",\n    get: function get() {\n      return this.options.supportAllDayRow;\n    }\n  }, {\n    key: \"isAllDayRowAppointment\",\n    get: function get() {\n      return this.options.isAllDayRowAppointment;\n    }\n  }, {\n    key: \"timeZone\",\n    get: function get() {\n      return this.options.timeZone;\n    }\n  }, {\n    key: \"dateRange\",\n    get: function get() {\n      return this.options.dateRange;\n    }\n  }, {\n    key: \"firstDayOfWeek\",\n    get: function get() {\n      return this.options.firstDayOfWeek;\n    }\n  }, {\n    key: \"viewStartDayHour\",\n    get: function get() {\n      return this.options.viewStartDayHour;\n    }\n  }, {\n    key: \"viewEndDayHour\",\n    get: function get() {\n      return this.options.viewEndDayHour;\n    }\n  }, {\n    key: \"endViewDate\",\n    get: function get() {\n      return this.options.endViewDate;\n    }\n  }, {\n    key: \"viewType\",\n    get: function get() {\n      return this.options.viewType;\n    }\n  }, {\n    key: \"isGroupedByDate\",\n    get: function get() {\n      return this.options.isGroupedByDate;\n    }\n  }, {\n    key: \"isVerticalOrientation\",\n    get: function get() {\n      return this.options.isVerticalOrientation;\n    }\n  }, {\n    key: \"dataAccessors\",\n    get: function get() {\n      return this.options.dataAccessors;\n    }\n  }, {\n    key: \"loadedResources\",\n    get: function get() {\n      return this.options.loadedResources;\n    }\n  }, {\n    key: \"isDateAppointment\",\n    get: function get() {\n      return !isDateAndTimeView(this.viewType) && this.appointmentTakesAllDay;\n    }\n  }, {\n    key: \"getIntervalDuration\",\n    value: function getIntervalDuration() {\n      return this.appointmentTakesAllDay ? this.options.allDayIntervalDuration : this.options.intervalDuration;\n    }\n  }, {\n    key: \"generate\",\n    value: function generate(appointmentAdapter) {\n      var itemGroupIndices = this._getGroupIndices(this.rawAppointment);\n\n      var appointmentList = this._createAppointments(appointmentAdapter, itemGroupIndices);\n\n      appointmentList = this._getProcessedByAppointmentTimeZone(appointmentList, appointmentAdapter);\n\n      if (this._canProcessNotNativeTimezoneDates(appointmentAdapter)) {\n        appointmentList = this._getProcessedNotNativeTimezoneDates(appointmentList, appointmentAdapter);\n      }\n\n      var dateSettings = this._createGridAppointmentList(appointmentList, appointmentAdapter);\n\n      dateSettings = this._cropAppointmentsByStartDayHour(dateSettings, this.rawAppointment);\n      dateSettings = this._fillNormalizedEndDate(dateSettings, this.rawAppointment);\n\n      if (this._needSeparateLongParts()) {\n        dateSettings = this._separateLongParts(dateSettings, appointmentAdapter);\n      }\n\n      var isRecurrent = appointmentAdapter.isRecurrent;\n      return {\n        dateSettings: dateSettings,\n        itemGroupIndices: itemGroupIndices,\n        isRecurrent: isRecurrent\n      };\n    }\n  }, {\n    key: \"_getProcessedByAppointmentTimeZone\",\n    value: function _getProcessedByAppointmentTimeZone(appointmentList, appointment) {\n      var _this = this;\n\n      var hasAppointmentTimeZone = !isEmptyObject(appointment.startDateTimeZone) || !isEmptyObject(appointment.endDateTimeZone);\n\n      if (hasAppointmentTimeZone) {\n        var appointmentOffsets = {\n          startDate: this.timeZoneCalculator.getOffsets(appointment.startDate, appointment.startDateTimeZone),\n          endDate: this.timeZoneCalculator.getOffsets(appointment.endDate, appointment.endDateTimeZone)\n        };\n        appointmentList.forEach(function (a) {\n          var sourceOffsets_startDate = _this.timeZoneCalculator.getOffsets(a.startDate, appointment.startDateTimeZone),\n              sourceOffsets_endDate = _this.timeZoneCalculator.getOffsets(a.endDate, appointment.endDateTimeZone);\n\n          var startDateOffsetDiff = appointmentOffsets.startDate.appointment - sourceOffsets_startDate.appointment;\n          var endDateOffsetDiff = appointmentOffsets.endDate.appointment - sourceOffsets_endDate.appointment;\n\n          if (sourceOffsets_startDate.appointment !== sourceOffsets_startDate.common) {\n            a.startDate = new Date(a.startDate.getTime() + startDateOffsetDiff * toMs(\"hour\"));\n          }\n\n          if (sourceOffsets_endDate.appointment !== sourceOffsets_endDate.common) {\n            a.endDate = new Date(a.endDate.getTime() + endDateOffsetDiff * toMs(\"hour\"));\n          }\n        });\n      }\n\n      return appointmentList;\n    }\n  }, {\n    key: \"_createAppointments\",\n    value: function _createAppointments(appointment, groupIndices) {\n      var appointments = this._createRecurrenceAppointments(appointment, groupIndices);\n\n      if (!appointment.isRecurrent && 0 === appointments.length) {\n        appointments.push({\n          startDate: appointment.startDate,\n          endDate: appointment.endDate\n        });\n      }\n\n      appointments = appointments.map(function (item) {\n        var _item$endDate;\n\n        var resultEndTime = null === (_item$endDate = item.endDate) || void 0 === _item$endDate ? void 0 : _item$endDate.getTime();\n\n        if (item.startDate.getTime() === resultEndTime) {\n          item.endDate.setTime(resultEndTime + toMs(\"minute\"));\n        }\n\n        return _extends({}, item, {\n          exceptionDate: new Date(item.startDate)\n        });\n      });\n      return appointments;\n    }\n  }, {\n    key: \"_canProcessNotNativeTimezoneDates\",\n    value: function _canProcessNotNativeTimezoneDates(appointment) {\n      var isTimeZoneSet = !isEmptyObject(this.timeZone);\n\n      if (!isTimeZoneSet) {\n        return false;\n      }\n\n      if (!appointment.isRecurrent) {\n        return false;\n      }\n\n      return !timeZoneUtils.isEqualLocalTimeZone(this.timeZone, appointment.startDate);\n    }\n  }, {\n    key: \"_getProcessedNotNativeDateIfCrossDST\",\n    value: function _getProcessedNotNativeDateIfCrossDST(date, offset) {\n      if (offset < 0) {\n        var newDate = new Date(date);\n        var newDateMinusOneHour = new Date(newDate);\n        newDateMinusOneHour.setHours(newDateMinusOneHour.getHours() - 1);\n        var newDateOffset = this.timeZoneCalculator.getOffsets(newDate).common;\n        var newDateMinusOneHourOffset = this.timeZoneCalculator.getOffsets(newDateMinusOneHour).common;\n\n        if (newDateOffset !== newDateMinusOneHourOffset) {\n          return 0;\n        }\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"_getCommonOffset\",\n    value: function _getCommonOffset(date) {\n      return this.timeZoneCalculator.getOffsets(date).common;\n    }\n  }, {\n    key: \"_getProcessedNotNativeTimezoneDates\",\n    value: function _getProcessedNotNativeTimezoneDates(appointmentList, appointment) {\n      var _this2 = this;\n\n      return appointmentList.map(function (item) {\n        var diffStartDateOffset = _this2._getCommonOffset(appointment.startDate) - _this2._getCommonOffset(item.startDate);\n\n        var diffEndDateOffset = _this2._getCommonOffset(appointment.endDate) - _this2._getCommonOffset(item.endDate);\n\n        if (0 === diffStartDateOffset && 0 === diffEndDateOffset) {\n          return item;\n        }\n\n        diffStartDateOffset = _this2._getProcessedNotNativeDateIfCrossDST(item.startDate, diffStartDateOffset);\n        diffEndDateOffset = _this2._getProcessedNotNativeDateIfCrossDST(item.endDate, diffEndDateOffset);\n        var newStartDate = new Date(item.startDate.getTime() + diffStartDateOffset * toMs(\"hour\"));\n        var newEndDate = new Date(item.endDate.getTime() + diffEndDateOffset * toMs(\"hour\"));\n\n        var testNewStartDate = _this2.timeZoneCalculator.createDate(newStartDate, {\n          path: \"toGrid\"\n        });\n\n        var testNewEndDate = _this2.timeZoneCalculator.createDate(newEndDate, {\n          path: \"toGrid\"\n        });\n\n        if (appointment.duration > testNewEndDate.getTime() - testNewStartDate.getTime()) {\n          newEndDate = new Date(newStartDate.getTime() + appointment.duration);\n        }\n\n        return _extends({}, item, {\n          startDate: newStartDate,\n          endDate: newEndDate,\n          exceptionDate: new Date(newStartDate)\n        });\n      });\n    }\n  }, {\n    key: \"_needSeparateLongParts\",\n    value: function _needSeparateLongParts() {\n      return this.isVerticalOrientation ? this.isGroupedByDate : this.isGroupedByDate && this.appointmentTakesAllDay;\n    }\n  }, {\n    key: \"normalizeEndDateByViewEnd\",\n    value: function normalizeEndDateByViewEnd(rawAppointment, endDate) {\n      var result = new Date(endDate.getTime());\n      var isAllDay = isDateAndTimeView(this.viewType) && this.appointmentTakesAllDay;\n\n      if (!isAllDay) {\n        var roundedEndViewDate = dateUtils.roundToHour(this.endViewDate);\n\n        if (result > roundedEndViewDate) {\n          result = roundedEndViewDate;\n        }\n      }\n\n      var endDayHour = this.viewEndDayHour;\n      var allDay = ExpressionUtils.getField(this.dataAccessors, \"allDay\", rawAppointment);\n      var currentViewEndTime = new Date(new Date(endDate.getTime()).setHours(endDayHour, 0, 0, 0));\n\n      if (result.getTime() > currentViewEndTime.getTime() || allDay && result.getHours() < endDayHour) {\n        result = currentViewEndTime;\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_fillNormalizedEndDate\",\n    value: function _fillNormalizedEndDate(dateSettings, rawAppointment) {\n      var _this3 = this;\n\n      return dateSettings.map(function (item) {\n        var endDate = item.endDate;\n\n        var normalizedEndDate = _this3.normalizeEndDateByViewEnd(rawAppointment, endDate);\n\n        return _extends({}, item, {\n          normalizedEndDate: normalizedEndDate\n        });\n      });\n    }\n  }, {\n    key: \"_separateLongParts\",\n    value: function _separateLongParts(gridAppointmentList, appointmentAdapter) {\n      var _this4 = this;\n\n      var result = [];\n      gridAppointmentList.forEach(function (gridAppointment) {\n        var maxDate = new Date(_this4.dateRange[1]);\n        var endDateOfPart = gridAppointment.normalizedEndDate;\n        var longStartDateParts = dateUtils.getDatesOfInterval(gridAppointment.startDate, endDateOfPart, {\n          milliseconds: _this4.getIntervalDuration(_this4.appointmentTakesAllDay)\n        });\n        var list = longStartDateParts.filter(function (startDatePart) {\n          return new Date(startDatePart) < maxDate;\n        }).map(function (date) {\n          var endDate = new Date(new Date(date).setMilliseconds(appointmentAdapter.duration));\n\n          var normalizedEndDate = _this4.normalizeEndDateByViewEnd(_this4.rawAppointment, endDate);\n\n          return {\n            startDate: date,\n            endDate: endDate,\n            normalizedEndDate: normalizedEndDate,\n            source: gridAppointment.source\n          };\n        });\n        result = result.concat(list);\n      });\n      return result;\n    }\n  }, {\n    key: \"_createGridAppointmentList\",\n    value: function _createGridAppointmentList(appointmentList, appointment) {\n      var _this5 = this;\n\n      return appointmentList.map(function (source) {\n        var offsetDifference = appointment.startDate.getTimezoneOffset() - source.startDate.getTimezoneOffset();\n\n        if (0 !== offsetDifference && _this5._canProcessNotNativeTimezoneDates(appointment)) {\n          source.startDate = new Date(source.startDate.getTime() + offsetDifference * toMs(\"minute\"));\n          source.endDate = new Date(source.endDate.getTime() + offsetDifference * toMs(\"minute\"));\n          source.exceptionDate = new Date(source.startDate);\n        }\n\n        var startDate = _this5.timeZoneCalculator.createDate(source.startDate, {\n          path: \"toGrid\"\n        });\n\n        var endDate = _this5.timeZoneCalculator.createDate(source.endDate, {\n          path: \"toGrid\"\n        });\n\n        return {\n          startDate: startDate,\n          endDate: endDate,\n          source: source\n        };\n      });\n    }\n  }, {\n    key: \"_createExtremeRecurrenceDates\",\n    value: function _createExtremeRecurrenceDates() {\n      var startViewDate = this.appointmentTakesAllDay ? dateUtils.trimTime(this.dateRange[0]) : this.dateRange[0];\n      var endViewDateByEndDayHour = this.dateRange[1];\n\n      if (this.timeZone) {\n        startViewDate = this.timeZoneCalculator.createDate(startViewDate, {\n          path: \"fromGrid\"\n        });\n        endViewDateByEndDayHour = this.timeZoneCalculator.createDate(endViewDateByEndDayHour, {\n          path: \"fromGrid\"\n        });\n        var daylightOffset = timeZoneUtils.getDaylightOffsetInMs(startViewDate, endViewDateByEndDayHour);\n\n        if (daylightOffset) {\n          endViewDateByEndDayHour = new Date(endViewDateByEndDayHour.getTime() + daylightOffset);\n        }\n      }\n\n      return [startViewDate, endViewDateByEndDayHour];\n    }\n  }, {\n    key: \"_createRecurrenceOptions\",\n    value: function _createRecurrenceOptions(appointment, groupIndex) {\n      var _this6 = this;\n\n      var _this$_createExtremeR = this._createExtremeRecurrenceDates(groupIndex),\n          _this$_createExtremeR2 = _slicedToArray(_this$_createExtremeR, 2),\n          minRecurrenceDate = _this$_createExtremeR2[0],\n          maxRecurrenceDate = _this$_createExtremeR2[1];\n\n      return {\n        rule: appointment.recurrenceRule,\n        exception: appointment.recurrenceException,\n        min: minRecurrenceDate,\n        max: maxRecurrenceDate,\n        firstDayOfWeek: this.firstDayOfWeek,\n        start: appointment.startDate,\n        end: appointment.endDate,\n        getPostProcessedException: function getPostProcessedException(date) {\n          if (isEmptyObject(_this6.timeZone) || timeZoneUtils.isEqualLocalTimeZone(_this6.timeZone, date)) {\n            return date;\n          }\n\n          var appointmentOffset = _this6.timeZoneCalculator.getOffsets(appointment.startDate).common;\n\n          var exceptionAppointmentOffset = _this6.timeZoneCalculator.getOffsets(date).common;\n\n          var diff = appointmentOffset - exceptionAppointmentOffset;\n          diff = _this6._getProcessedNotNativeDateIfCrossDST(date, diff);\n          return new Date(date.getTime() - diff * dateUtils.dateToMilliseconds(\"hour\"));\n        }\n      };\n    }\n  }, {\n    key: \"_createRecurrenceAppointments\",\n    value: function _createRecurrenceAppointments(appointment, groupIndices) {\n      var duration = appointment.duration;\n\n      var option = this._createRecurrenceOptions(appointment);\n\n      var generatedStartDates = getRecurrenceProcessor().generateDates(option);\n      return generatedStartDates.map(function (date) {\n        var utcDate = timeZoneUtils.createUTCDateWithLocalOffset(date);\n        utcDate.setTime(utcDate.getTime() + duration);\n        var endDate = timeZoneUtils.createDateFromUTCWithLocalOffset(utcDate);\n        return {\n          startDate: new Date(date),\n          endDate: endDate\n        };\n      });\n    }\n  }, {\n    key: \"_cropAppointmentsByStartDayHour\",\n    value: function _cropAppointmentsByStartDayHour(appointments, rawAppointment) {\n      var _this7 = this;\n\n      return appointments.filter(function (appointment) {\n        var firstViewDate = _this7._getAppointmentFirstViewDate(appointment);\n\n        if (!firstViewDate) {\n          return false;\n        }\n\n        var startDayHour = _this7._getViewStartDayHour(firstViewDate);\n\n        var startDate = new Date(appointment.startDate);\n        appointment.startDate = _this7._getAppointmentResultDate({\n          appointment: appointment,\n          rawAppointment: rawAppointment,\n          startDate: startDate,\n          startDayHour: startDayHour,\n          firstViewDate: firstViewDate\n        });\n        return !_this7.isAllDayRowAppointment ? appointment.endDate > appointment.startDate : true;\n      });\n    }\n  }, {\n    key: \"_getViewStartDayHour\",\n    value: function _getViewStartDayHour() {\n      return this.viewStartDayHour;\n    }\n  }, {\n    key: \"_getAppointmentResultDate\",\n    value: function _getAppointmentResultDate(options) {\n      var appointment = options.appointment,\n          startDayHour = options.startDayHour,\n          firstViewDate = options.firstViewDate;\n      var startDate = options.startDate;\n      var resultDate = new Date(appointment.startDate);\n\n      if (this.appointmentTakesAllDay) {\n        resultDate = dateUtils.normalizeDate(startDate, firstViewDate);\n      } else {\n        if (startDate < firstViewDate) {\n          startDate = firstViewDate;\n        }\n\n        resultDate = dateUtils.normalizeDate(appointment.startDate, startDate);\n      }\n\n      return !this.isDateAppointment ? dateUtils.roundDateByStartDayHour(resultDate, startDayHour) : resultDate;\n    }\n  }, {\n    key: \"_getAppointmentFirstViewDate\",\n    value: function _getAppointmentFirstViewDate(appointment) {\n      var groupIndex = appointment.source.groupIndex || 0;\n      var startDate = appointment.startDate,\n          endDate = appointment.endDate;\n      return this.viewDataProvider.findGroupCellStartDate(groupIndex, startDate, endDate, this.isAllDayRowAppointment, this.isDateAppointment);\n    }\n  }, {\n    key: \"_getGroupIndices\",\n    value: function _getGroupIndices(rawAppointment) {\n      var _this8 = this;\n\n      var result = [];\n\n      if (rawAppointment && this.loadedResources.length) {\n        var tree = createResourcesTree(this.loadedResources);\n        result = getResourceTreeLeaves(function (field, action) {\n          return getDataAccessors(_this8.options.dataAccessors.resources, field, action);\n        }, tree, rawAppointment);\n      }\n\n      return result;\n    }\n  }]);\n\n  return DateGeneratorBaseStrategy;\n}();\nexport var DateGeneratorVirtualStrategy = /*#__PURE__*/function (_DateGeneratorBaseStr) {\n  _inherits(DateGeneratorVirtualStrategy, _DateGeneratorBaseStr);\n\n  var _super = _createSuper(DateGeneratorVirtualStrategy);\n\n  function DateGeneratorVirtualStrategy() {\n    _classCallCheck(this, DateGeneratorVirtualStrategy);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(DateGeneratorVirtualStrategy, [{\n    key: \"groupCount\",\n    get: function get() {\n      return getGroupCount(this.loadedResources);\n    }\n  }, {\n    key: \"_createRecurrenceAppointments\",\n    value: function _createRecurrenceAppointments(appointment, groupIndices) {\n      var _this9 = this;\n\n      var duration = appointment.duration;\n      var result = [];\n      var validGroupIndices = this.groupCount ? groupIndices : [0];\n      validGroupIndices.forEach(function (groupIndex) {\n        var option = _this9._createRecurrenceOptions(appointment, groupIndex);\n\n        var generatedStartDates = getRecurrenceProcessor().generateDates(option);\n        var recurrentInfo = generatedStartDates.map(function (date) {\n          var startDate = new Date(date);\n          var utcDate = timeZoneUtils.createUTCDateWithLocalOffset(date);\n          utcDate.setTime(utcDate.getTime() + duration);\n          var endDate = timeZoneUtils.createDateFromUTCWithLocalOffset(utcDate);\n          return {\n            startDate: startDate,\n            endDate: endDate,\n            groupIndex: groupIndex\n          };\n        });\n        result.push.apply(result, _toConsumableArray(recurrentInfo));\n      });\n      return result;\n    }\n  }, {\n    key: \"_getViewStartDayHour\",\n    value: function _getViewStartDayHour(firstViewDate) {\n      return firstViewDate.getHours();\n    }\n  }, {\n    key: \"_updateGroupIndices\",\n    value: function _updateGroupIndices(appointments, groupIndices) {\n      var _this10 = this;\n\n      var result = [];\n      groupIndices.forEach(function (groupIndex) {\n        var groupStartDate = _this10.viewDataProvider.getGroupStartDate(groupIndex);\n\n        if (groupStartDate) {\n          appointments.forEach(function (appointment) {\n            var appointmentCopy = extend({}, appointment);\n            appointmentCopy.groupIndex = groupIndex;\n            result.push(appointmentCopy);\n          });\n        }\n      });\n      return result;\n    }\n  }, {\n    key: \"_getGroupIndices\",\n    value: function _getGroupIndices(resources) {\n      var _groupIndices;\n\n      var groupIndices = _get(_getPrototypeOf(DateGeneratorVirtualStrategy.prototype), \"_getGroupIndices\", this).call(this, resources);\n\n      var viewDataGroupIndices = this.viewDataProvider.getGroupIndices();\n\n      if (!(null !== (_groupIndices = groupIndices) && void 0 !== _groupIndices && _groupIndices.length)) {\n        groupIndices = [0];\n      }\n\n      return groupIndices.filter(function (groupIndex) {\n        return -1 !== viewDataGroupIndices.indexOf(groupIndex);\n      });\n    }\n  }, {\n    key: \"_createAppointments\",\n    value: function _createAppointments(appointment, groupIndices) {\n      var appointments = _get(_getPrototypeOf(DateGeneratorVirtualStrategy.prototype), \"_createAppointments\", this).call(this, appointment, groupIndices);\n\n      return !appointment.isRecurrent ? this._updateGroupIndices(appointments, groupIndices) : appointments;\n    }\n  }]);\n\n  return DateGeneratorVirtualStrategy;\n}(DateGeneratorBaseStrategy);\nexport var AppointmentSettingsGenerator = /*#__PURE__*/function () {\n  function AppointmentSettingsGenerator(options) {\n    _classCallCheck(this, AppointmentSettingsGenerator);\n\n    this.options = options;\n    this.appointmentAdapter = createAppointmentAdapter(this.rawAppointment, this.dataAccessors, this.timeZoneCalculator);\n  }\n\n  _createClass(AppointmentSettingsGenerator, [{\n    key: \"rawAppointment\",\n    get: function get() {\n      return this.options.rawAppointment;\n    }\n  }, {\n    key: \"dataAccessors\",\n    get: function get() {\n      return this.options.dataAccessors;\n    }\n  }, {\n    key: \"timeZoneCalculator\",\n    get: function get() {\n      return this.options.timeZoneCalculator;\n    }\n  }, {\n    key: \"isAllDayRowAppointment\",\n    get: function get() {\n      return this.options.appointmentTakesAllDay && this.options.supportAllDayRow;\n    }\n  }, {\n    key: \"modelGroups\",\n    get: function get() {\n      return this.options.modelGroups;\n    }\n  }, {\n    key: \"dateSettingsStrategy\",\n    get: function get() {\n      var options = _extends({}, this.options, {\n        isAllDayRowAppointment: this.isAllDayRowAppointment\n      });\n\n      return this.options.isVirtualScrolling ? new DateGeneratorVirtualStrategy(options) : new DateGeneratorBaseStrategy(options);\n    }\n  }, {\n    key: \"create\",\n    value: function create() {\n      var _this$_generateDateSe = this._generateDateSettings(),\n          dateSettings = _this$_generateDateSe.dateSettings,\n          itemGroupIndices = _this$_generateDateSe.itemGroupIndices,\n          isRecurrent = _this$_generateDateSe.isRecurrent;\n\n      var cellPositions = this._calculateCellPositions(dateSettings, itemGroupIndices);\n\n      var result = this._prepareAppointmentInfos(dateSettings, cellPositions, isRecurrent);\n\n      return result;\n    }\n  }, {\n    key: \"_generateDateSettings\",\n    value: function _generateDateSettings() {\n      return this.dateSettingsStrategy.generate(this.appointmentAdapter);\n    }\n  }, {\n    key: \"_calculateCellPositions\",\n    value: function _calculateCellPositions(dateSettings, itemGroupIndices) {\n      var cellPositionCalculator = new CellPositionCalculator(_extends({}, this.options, {\n        dateSettings: dateSettings\n      }));\n      return cellPositionCalculator.calculateCellPositions(itemGroupIndices, this.isAllDayRowAppointment, this.appointmentAdapter.isRecurrent);\n    }\n  }, {\n    key: \"_prepareAppointmentInfos\",\n    value: function _prepareAppointmentInfos(dateSettings, cellPositions, isRecurrent) {\n      var _this11 = this;\n\n      var infos = [];\n      cellPositions.forEach(function (_ref) {\n        var coordinates = _ref.coordinates,\n            dateSettingIndex = _ref.dateSettingIndex;\n        var dateSetting = dateSettings[dateSettingIndex];\n\n        var dateText = _this11._getAppointmentDateText(dateSetting);\n\n        var info = {\n          appointment: dateSetting,\n          sourceAppointment: dateSetting.source,\n          dateText: dateText,\n          isRecurrent: isRecurrent\n        };\n\n        _this11._setResourceColor(info, coordinates.groupIndex);\n\n        infos.push(_extends({}, coordinates, {\n          info: info\n        }));\n      });\n      return infos;\n    }\n  }, {\n    key: \"_getAppointmentDateText\",\n    value: function _getAppointmentDateText(sourceAppointment) {\n      var startDate = sourceAppointment.startDate,\n          endDate = sourceAppointment.endDate,\n          allDay = sourceAppointment.allDay;\n      return createFormattedDateText({\n        startDate: startDate,\n        endDate: endDate,\n        allDay: allDay,\n        format: APPOINTMENT_DATE_TEXT_FORMAT\n      });\n    }\n  }, {\n    key: \"_setResourceColor\",\n    value: function _setResourceColor(info, groupIndex) {\n      var appointmentConfig = {\n        itemData: this.rawAppointment,\n        groupIndex: groupIndex,\n        groups: this.modelGroups\n      };\n      this.options.getAppointmentColor(appointmentConfig).done(function (color) {\n        return info.resourceColor = color;\n      });\n    }\n  }]);\n\n  return AppointmentSettingsGenerator;\n}();","map":null,"metadata":{},"sourceType":"module"}