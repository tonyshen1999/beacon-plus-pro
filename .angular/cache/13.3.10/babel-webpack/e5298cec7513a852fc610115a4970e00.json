{"ast":null,"code":"/**\r\n * DevExtreme (esm/viz/translators/category_translator.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { isDefined } from \"../../core/utils/type\";\nimport { adjust } from \"../../core/utils/math\";\nvar round = Math.round;\n\nfunction getValue(value) {\n  return value;\n}\n\nexport default {\n  translate: function translate(category, directionOffset) {\n    var canvasOptions = this._canvasOptions;\n    var categoryIndex = this._categoriesToPoints[null === category || void 0 === category ? void 0 : category.valueOf()];\n    var specialValue = this.translateSpecialCase(category);\n    var startPointIndex = canvasOptions.startPointIndex || 0;\n    var stickInterval = this._options.stick ? 0 : .5;\n\n    if (isDefined(specialValue)) {\n      return round(specialValue);\n    }\n\n    if (!categoryIndex && 0 !== categoryIndex) {\n      return null;\n    }\n\n    directionOffset = directionOffset || 0;\n    var stickDelta = categoryIndex + stickInterval - startPointIndex + .5 * directionOffset;\n    return round(this._calculateProjection(canvasOptions.interval * stickDelta));\n  },\n  getInterval: function getInterval() {\n    return this._canvasOptions.interval;\n  },\n  getEventScale: function getEventScale(zoomEvent) {\n    var scale = zoomEvent.deltaScale || 1;\n    return 1 - (1 - scale) / (.75 + this.visibleCategories.length / this._categories.length);\n  },\n  zoom: function zoom(translate, scale) {\n    var categories = this._categories;\n    var canvasOptions = this._canvasOptions;\n    var stick = this._options.stick;\n    var invert = canvasOptions.invert;\n    var interval = canvasOptions.interval * scale;\n    var translateCategories = translate / interval;\n    var visibleCount = (this.visibleCategories || []).length;\n    var startCategoryIndex = parseInt((canvasOptions.startPointIndex || 0) + translateCategories + .5);\n    var categoriesLength = parseInt(adjust(canvasOptions.canvasLength / interval) + (stick ? 1 : 0)) || 1;\n    var endCategoryIndex;\n\n    if (invert) {\n      startCategoryIndex = parseInt((canvasOptions.startPointIndex || 0) + visibleCount - translateCategories + .5) - categoriesLength;\n    }\n\n    if (startCategoryIndex < 0) {\n      startCategoryIndex = 0;\n    }\n\n    endCategoryIndex = startCategoryIndex + categoriesLength;\n\n    if (endCategoryIndex > categories.length) {\n      endCategoryIndex = categories.length;\n      startCategoryIndex = endCategoryIndex - categoriesLength;\n\n      if (startCategoryIndex < 0) {\n        startCategoryIndex = 0;\n      }\n    }\n\n    var newVisibleCategories = categories.slice(parseInt(startCategoryIndex), parseInt(endCategoryIndex));\n\n    var newInterval = this._getDiscreteInterval(newVisibleCategories.length, canvasOptions);\n\n    scale = newInterval / canvasOptions.interval;\n    translate = this.translate(!invert ? newVisibleCategories[0] : newVisibleCategories[newVisibleCategories.length - 1]) * scale - (canvasOptions.startPoint + (stick ? 0 : newInterval / 2));\n    return {\n      min: newVisibleCategories[0],\n      max: newVisibleCategories[newVisibleCategories.length - 1],\n      translate: translate,\n      scale: scale\n    };\n  },\n  getMinScale: function getMinScale(zoom) {\n    var canvasOptions = this._canvasOptions;\n    var categoriesLength = (this.visibleCategories || this._categories).length;\n    categoriesLength += (parseInt(.1 * categoriesLength) || 1) * (zoom ? -2 : 2);\n    return canvasOptions.canvasLength / (Math.max(categoriesLength, 1) * canvasOptions.interval);\n  },\n  getScale: function getScale(min, max) {\n    var canvasOptions = this._canvasOptions;\n    var visibleArea = this.getCanvasVisibleArea();\n    var stickOffset = !this._options.stick && 1;\n    var minPoint = isDefined(min) ? this.translate(min, -stickOffset) : null;\n    var maxPoint = isDefined(max) ? this.translate(max, +stickOffset) : null;\n\n    if (null === minPoint) {\n      minPoint = canvasOptions.invert ? visibleArea.max : visibleArea.min;\n    }\n\n    if (null === maxPoint) {\n      maxPoint = canvasOptions.invert ? visibleArea.min : visibleArea.max;\n    }\n\n    return this.canvasLength / Math.abs(maxPoint - minPoint);\n  },\n  isValid: function isValid(value) {\n    return isDefined(value) ? this._categoriesToPoints[value.valueOf()] >= 0 : false;\n  },\n  getCorrectValue: getValue,\n  to: function to(value, direction) {\n    var canvasOptions = this._canvasOptions;\n    var categoryIndex = this._categoriesToPoints[null === value || void 0 === value ? void 0 : value.valueOf()];\n    var startPointIndex = canvasOptions.startPointIndex || 0;\n    var stickDelta = categoryIndex + (this._options.stick ? 0 : .5) - startPointIndex + (this._businessRange.invert ? -1 : 1) * direction * .5;\n    return round(this._calculateProjection(canvasOptions.interval * stickDelta));\n  },\n  from: function from(position) {\n    var direction = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;\n    var canvasOptions = this._canvasOptions;\n    var startPoint = canvasOptions.startPoint;\n    var categories = this.visibleCategories || this._categories;\n    var categoriesLength = categories.length;\n    var stickInterval = this._options.stick ? .5 : 0;\n    var result = round((position - startPoint) / canvasOptions.interval + stickInterval - .5 - .5 * direction);\n\n    if (result >= categoriesLength) {\n      result = categoriesLength - 1;\n    }\n\n    if (result < 0) {\n      result = 0;\n    }\n\n    if (canvasOptions.invert) {\n      result = categoriesLength - result - 1;\n    }\n\n    return categories[result];\n  },\n  _add: function _add() {\n    return NaN;\n  },\n  toValue: getValue,\n  isValueProlonged: true,\n  getRangeByMinZoomValue: function getRangeByMinZoomValue(minZoom, visualRange) {\n    var categories = this._categories;\n    var minVisibleIndex = categories.indexOf(visualRange.minVisible);\n    var maxVisibleIndex = categories.indexOf(visualRange.maxVisible);\n    var startIndex = minVisibleIndex + minZoom - 1;\n    var endIndex = maxVisibleIndex - minZoom + 1;\n\n    if (categories[startIndex]) {\n      return [visualRange.minVisible, categories[startIndex]];\n    } else {\n      return [categories[endIndex], visualRange.maxVisible];\n    }\n  }\n};","map":null,"metadata":{},"sourceType":"module"}