{"ast":null,"code":"/**\r\n * DevExtreme (esm/viz/components/legend.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { enumParser, normalizeEnum, patchFontOptions } from \"../core/utils\";\nimport { extend } from \"../../core/utils/extend\";\nimport { LayoutElement, WrapperLayoutElement } from \"../core/layout_element\";\nimport { isDefined, isFunction } from \"../../core/utils/type\";\nimport { Title } from \"../core/title\";\nimport { clone } from \"../../core/utils/object\";\nimport { noop } from \"../../core/utils/common\";\nimport { processHatchingAttrs, getFuncIri } from \"../core/renderers/renderer\";\nimport { Deferred } from \"../../core/utils/deferred\";\nvar _Number = Number;\nvar _math = Math;\nvar _round = _math.round;\nvar _max = _math.max;\nvar _min = _math.min;\nvar _ceil = _math.ceil;\nvar _isDefined = isDefined;\nvar _isFunction = isFunction;\nvar _enumParser = enumParser;\nvar _normalizeEnum = normalizeEnum;\nvar _extend = extend;\nvar DEFAULT_MARGIN = 10;\nvar DEFAULT_MARKER_HATCHING_WIDTH = 2;\nvar DEFAULT_MARKER_HATCHING_STEP = 5;\nvar CENTER = \"center\";\nvar RIGHT = \"right\";\nvar LEFT = \"left\";\nvar TOP = \"top\";\nvar BOTTOM = \"bottom\";\nvar HORIZONTAL = \"horizontal\";\nvar VERTICAL = \"vertical\";\nvar INSIDE = \"inside\";\nvar OUTSIDE = \"outside\";\nvar NONE = \"none\";\nvar HEIGHT = \"height\";\nvar WIDTH = \"width\";\n\nvar parseHorizontalAlignment = _enumParser([LEFT, CENTER, RIGHT]);\n\nvar parseVerticalAlignment = _enumParser([TOP, BOTTOM]);\n\nvar parseOrientation = _enumParser([VERTICAL, HORIZONTAL]);\n\nvar parseItemTextPosition = _enumParser([LEFT, RIGHT, TOP, BOTTOM]);\n\nvar parsePosition = _enumParser([OUTSIDE, INSIDE]);\n\nvar parseItemsAlignment = _enumParser([LEFT, CENTER, RIGHT]);\n\nfunction getState(state, color, stateName) {\n  if (!state) {\n    return;\n  }\n\n  var colorFromAction = state.fill;\n  return extend({}, {\n    state: stateName,\n    fill: colorFromAction === NONE ? color : colorFromAction,\n    opacity: state.opacity,\n    hatching: _extend({}, state.hatching, {\n      step: DEFAULT_MARKER_HATCHING_STEP,\n      width: DEFAULT_MARKER_HATCHING_WIDTH\n    })\n  });\n}\n\nfunction getAttributes(item, state, size) {\n  var attrs = processHatchingAttrs(item, state);\n\n  if (attrs.fill && 0 === attrs.fill.indexOf(\"DevExpress\")) {\n    attrs.fill = getFuncIri(attrs.fill);\n  }\n\n  attrs.opacity = attrs.opacity >= 0 ? attrs.opacity : 1;\n  return extend({}, attrs, {\n    size: size\n  });\n}\n\nfunction parseMargins(options) {\n  var margin = options.margin;\n\n  if (margin >= 0) {\n    margin = _Number(options.margin);\n    margin = {\n      top: margin,\n      bottom: margin,\n      left: margin,\n      right: margin\n    };\n  } else {\n    margin = {\n      top: margin.top >= 0 ? _Number(margin.top) : DEFAULT_MARGIN,\n      bottom: margin.bottom >= 0 ? _Number(margin.bottom) : DEFAULT_MARGIN,\n      left: margin.left >= 0 ? _Number(margin.left) : DEFAULT_MARGIN,\n      right: margin.right >= 0 ? _Number(margin.right) : DEFAULT_MARGIN\n    };\n  }\n\n  options.margin = margin;\n}\n\nfunction getSizeItem(options, markerBBox, labelBBox) {\n  var width;\n  var height;\n\n  switch (options.itemTextPosition) {\n    case LEFT:\n    case RIGHT:\n      width = markerBBox.width + 7 + labelBBox.width;\n      height = _max(markerBBox.height, labelBBox.height);\n      break;\n\n    case TOP:\n    case BOTTOM:\n      width = _max(markerBBox.width, labelBBox.width);\n      height = markerBBox.height + 4 + labelBBox.height;\n  }\n\n  return {\n    width: width,\n    height: height\n  };\n}\n\nfunction calculateBBoxLabelAndMarker(markerBBox, labelBBox) {\n  var bBox = {};\n  bBox.left = _min(markerBBox.x, labelBBox.x);\n  bBox.top = _min(markerBBox.y, labelBBox.y);\n  bBox.right = _max(markerBBox.x + markerBBox.width, labelBBox.x + labelBBox.width);\n  bBox.bottom = _max(markerBBox.y + markerBBox.height, labelBBox.y + labelBBox.height);\n  return bBox;\n}\n\nfunction applyMarkerState(id, idToIndexMap, items, stateName) {\n  var item = idToIndexMap && items[idToIndexMap[id]];\n\n  if (item) {\n    item.renderMarker(item.states[stateName]);\n  }\n}\n\nfunction parseOptions(options, textField, allowInsidePosition) {\n  if (!options) {\n    return null;\n  }\n\n  parseMargins(options);\n  options.horizontalAlignment = parseHorizontalAlignment(options.horizontalAlignment, RIGHT);\n  options.verticalAlignment = parseVerticalAlignment(options.verticalAlignment, options.horizontalAlignment === CENTER ? BOTTOM : TOP);\n  options.orientation = parseOrientation(options.orientation, options.horizontalAlignment === CENTER ? HORIZONTAL : VERTICAL);\n  options.itemTextPosition = parseItemTextPosition(options.itemTextPosition, options.orientation === HORIZONTAL ? BOTTOM : RIGHT);\n  options.position = allowInsidePosition ? parsePosition(options.position, OUTSIDE) : OUTSIDE;\n  options.itemsAlignment = parseItemsAlignment(options.itemsAlignment, null);\n  options.hoverMode = _normalizeEnum(options.hoverMode);\n  options.customizeText = _isFunction(options.customizeText) ? options.customizeText : function () {\n    return this[textField];\n  };\n  options.customizeHint = _isFunction(options.customizeHint) ? options.customizeHint : noop;\n  options._incidentOccurred = options._incidentOccurred || noop;\n  return options;\n}\n\nfunction createSquareMarker(renderer, size) {\n  return renderer.rect(0, 0, size, size);\n}\n\nfunction createCircleMarker(renderer, size) {\n  return renderer.circle(size / 2, size / 2, size / 2);\n}\n\nfunction isCircle(type) {\n  return \"circle\" === _normalizeEnum(type);\n}\n\nfunction inRect(rect, x, y) {\n  return x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;\n}\n\nfunction checkLinesSize(lines, layoutOptions, countItems, margins) {\n  var position = {\n    x: 0,\n    y: 0\n  };\n  var maxMeasureLength = 0;\n  var maxAltMeasureLength = 0;\n  var margin = 0;\n\n  if (\"y\" === layoutOptions.direction) {\n    margin = margins.top + margins.bottom;\n  } else {\n    margin = margins.left + margins.right;\n  }\n\n  lines.forEach(function (line, i) {\n    var firstItem = line[0];\n    var lineLength = line.length;\n    line.forEach(function (item, index) {\n      var offset = item.offset || layoutOptions.spacing;\n      position[layoutOptions.direction] += item[layoutOptions.measure] + (index !== lineLength - 1 ? offset : 0);\n      maxMeasureLength = _max(maxMeasureLength, position[layoutOptions.direction]);\n    });\n    position[layoutOptions.direction] = 0;\n    position[layoutOptions.altDirection] += firstItem[layoutOptions.altMeasure] + firstItem.altOffset || layoutOptions.altSpacing;\n    maxAltMeasureLength = _max(maxAltMeasureLength, position[layoutOptions.altDirection]);\n  });\n\n  if (maxMeasureLength + margin > layoutOptions.length) {\n    layoutOptions.countItem = decreaseItemCount(layoutOptions, countItems);\n    return true;\n  }\n}\n\nfunction decreaseItemCount(layoutOptions, countItems) {\n  layoutOptions.altCountItem++;\n  return _ceil(countItems / layoutOptions.altCountItem);\n}\n\nfunction getLineLength(line, layoutOptions) {\n  return line.reduce(function (lineLength, item) {\n    var offset = item.offset || layoutOptions.spacing;\n    return lineLength + item[layoutOptions.measure] + offset;\n  }, 0);\n}\n\nfunction getMaxLineLength(lines, layoutOptions) {\n  return lines.reduce(function (maxLineLength, line) {\n    return _max(maxLineLength, getLineLength(line, layoutOptions));\n  }, 0);\n}\n\nfunction getInitPositionForDirection(line, layoutOptions, maxLineLength) {\n  var lineLength = getLineLength(line, layoutOptions);\n  var initPosition;\n\n  switch (layoutOptions.itemsAlignment) {\n    case RIGHT:\n      initPosition = maxLineLength - lineLength;\n      break;\n\n    case CENTER:\n      initPosition = (maxLineLength - lineLength) / 2;\n      break;\n\n    default:\n      initPosition = 0;\n  }\n\n  return initPosition;\n}\n\nfunction getPos(layoutOptions) {\n  switch (layoutOptions.itemTextPosition) {\n    case BOTTOM:\n      return {\n        horizontal: CENTER,\n        vertical: TOP\n      };\n\n    case TOP:\n      return {\n        horizontal: CENTER,\n        vertical: BOTTOM\n      };\n\n    case LEFT:\n      return {\n        horizontal: RIGHT,\n        vertical: CENTER\n      };\n\n    case RIGHT:\n      return {\n        horizontal: LEFT,\n        vertical: CENTER\n      };\n  }\n}\n\nfunction getLines(lines, layoutOptions, itemIndex) {\n  var tableLine = {};\n\n  if (itemIndex % layoutOptions.countItem === 0) {\n    if (layoutOptions.markerOffset) {\n      lines.push([], []);\n    } else {\n      lines.push([]);\n    }\n  }\n\n  if (layoutOptions.markerOffset) {\n    tableLine.firstLine = lines[lines.length - 1];\n    tableLine.secondLine = lines[lines.length - 2];\n  } else {\n    tableLine.firstLine = tableLine.secondLine = lines[lines.length - 1];\n  }\n\n  return tableLine;\n}\n\nfunction setMaxInLine(line, measure) {\n  var maxLineSize = line.reduce(function (maxLineSize, item) {\n    var itemMeasure = item ? item[measure] : maxLineSize;\n    return _max(maxLineSize, itemMeasure);\n  }, 0);\n  line.forEach(function (item) {\n    if (item) {\n      item[measure] = maxLineSize;\n    }\n  });\n}\n\nfunction transpose(array) {\n  var width = array.length;\n  var height = array[0].length;\n  var i;\n  var j;\n  var transposeArray = [];\n\n  for (i = 0; i < height; i++) {\n    transposeArray[i] = [];\n\n    for (j = 0; j < width; j++) {\n      transposeArray[i][j] = array[j][i];\n    }\n  }\n\n  return transposeArray;\n}\n\nfunction getAlign(position) {\n  switch (position) {\n    case TOP:\n    case BOTTOM:\n      return CENTER;\n\n    case LEFT:\n      return RIGHT;\n\n    case RIGHT:\n      return LEFT;\n  }\n}\n\nvar getMarkerCreator = function getMarkerCreator(type) {\n  return isCircle(type) ? createCircleMarker : createSquareMarker;\n};\n\nfunction getTitleHorizontalAlignment(options) {\n  if (options.horizontalAlignment === CENTER) {\n    return CENTER;\n  } else if (options.itemTextPosition === RIGHT) {\n    return LEFT;\n  } else if (options.itemTextPosition === LEFT) {\n    return RIGHT;\n  } else {\n    return CENTER;\n  }\n}\n\nexport var Legend = function Legend(settings) {\n  this._renderer = settings.renderer;\n  this._legendGroup = settings.group;\n  this._backgroundClass = settings.backgroundClass;\n  this._itemGroupClass = settings.itemGroupClass;\n  this._textField = settings.textField;\n  this._getCustomizeObject = settings.getFormatObject;\n  this._titleGroupClass = settings.titleGroupClass;\n  this._allowInsidePosition = settings.allowInsidePosition;\n  this._widget = settings.widget;\n  this._updated = false;\n};\nvar _Legend = Legend;\nvar legendPrototype = _Legend.prototype = clone(LayoutElement.prototype);\nextend(legendPrototype, {\n  constructor: _Legend,\n  getOptions: function getOptions() {\n    return this._options;\n  },\n  update: function update() {\n    var data = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];\n    var options = arguments.length > 1 ? arguments[1] : void 0;\n    var themeManagerTitleOptions = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};\n    var that = this;\n    options = that._options = parseOptions(options, that._textField, that._allowInsidePosition) || {};\n    var initMarkerSize = options.markerSize;\n    this._updated = true;\n    this._data = data.map(function (dataItem) {\n      dataItem.size = _Number(dataItem.size > 0 ? dataItem.size : initMarkerSize);\n      dataItem.marker = getAttributes(dataItem, dataItem.states.normal);\n      Object.defineProperty(dataItem.marker, \"size\", {\n        get: function get() {\n          return dataItem.size;\n        },\n        set: function set(value) {\n          dataItem.size = value;\n        }\n      });\n      Object.defineProperty(dataItem.marker, \"opacity\", {\n        get: function get() {\n          return dataItem.states.normal.opacity;\n        },\n        set: function set(value) {\n          dataItem.states.normal.opacity = dataItem.states.hover.opacity = dataItem.states.selection.opacity = value;\n        }\n      });\n      return dataItem;\n    });\n\n    if (options.customizeItems) {\n      that._data = options.customizeItems(data.slice()) || data;\n    }\n\n    that._boundingRect = {\n      width: 0,\n      height: 0,\n      x: 0,\n      y: 0\n    };\n\n    if (that.isVisible() && !that._title) {\n      that._title = new Title({\n        renderer: that._renderer,\n        cssClass: that._titleGroupClass,\n        root: that._legendGroup\n      });\n    }\n\n    if (that._title) {\n      var titleOptions = options.title;\n      themeManagerTitleOptions.horizontalAlignment = getTitleHorizontalAlignment(options);\n\n      that._title.update(themeManagerTitleOptions, titleOptions);\n    }\n\n    this.erase();\n    return that;\n  },\n  isVisible: function isVisible() {\n    return this._options && this._options.visible;\n  },\n  draw: function draw(width, height) {\n    var items = this._getItemData();\n\n    this.erase();\n\n    if (!(this.isVisible() && items && items.length)) {\n      return this;\n    }\n\n    this._insideLegendGroup = this._renderer.g().enableLinks().append(this._legendGroup);\n\n    this._title.changeLink(this._insideLegendGroup);\n\n    this._createBackground();\n\n    if (this._title.hasText()) {\n      var horizontalPadding = this._background ? 2 * this._options.paddingLeftRight : 0;\n\n      this._title.draw(width - horizontalPadding, height);\n    }\n\n    this._markersGroup = this._renderer.g().attr({\n      class: this._itemGroupClass\n    }).append(this._insideLegendGroup);\n\n    this._createItems(items);\n\n    this._updateElementsPosition(width, height);\n\n    return this;\n  },\n  _measureElements: function _measureElements() {\n    var options = this._options;\n    var maxBBoxHeight = 0;\n\n    this._items.forEach(function (item) {\n      var labelBBox = item.label.getBBox();\n      var markerBBox = item.marker.getBBox();\n      item.markerBBox = markerBBox;\n      item.markerSize = Math.max(markerBBox.width, markerBBox.height);\n      var bBox = getSizeItem(options, markerBBox, labelBBox);\n      item.labelBBox = labelBBox;\n      item.bBox = bBox;\n      maxBBoxHeight = _max(maxBBoxHeight, bBox.height);\n    });\n\n    if (options.equalRowHeight) {\n      this._items.forEach(function (item) {\n        return item.bBox.height = maxBBoxHeight;\n      });\n    }\n  },\n  _updateElementsPosition: function _updateElementsPosition(width, height) {\n    var options = this._options;\n    this._size = {\n      width: width,\n      height: height\n    };\n\n    this._measureElements();\n\n    this._locateElements(options);\n\n    this._finalUpdate(options);\n\n    var size = this.getLayoutOptions();\n\n    if (size.width > width || size.height > height) {\n      this.freeSpace();\n    }\n  },\n  _createItems: function _createItems(items) {\n    var that = this;\n    var options = that._options;\n    var renderer = that._renderer;\n    var createMarker = getMarkerCreator(options.markerShape);\n    that._markersId = {};\n    var templateFunction = !options.markerTemplate ? function (dataItem, group) {\n      var attrs = dataItem.marker;\n      createMarker(renderer, attrs.size).attr({\n        fill: attrs.fill,\n        opacity: attrs.opacity\n      }).append({\n        element: group\n      });\n    } : options.markerTemplate;\n\n    var template = that._widget._getTemplate(templateFunction);\n\n    var markersGroup = that._markersGroup;\n    markersGroup.css(patchFontOptions(options.font));\n    that._deferredItems = [];\n    that._templatesGroups = [];\n    that._items = (items || []).map(function (dataItem, i) {\n      var stateOfDataItem = dataItem.states;\n      var normalState = stateOfDataItem.normal;\n      var normalStateFill = normalState.fill;\n      dataItem.size = dataItem.marker.size;\n      var states = {\n        normal: extend(normalState, {\n          fill: normalStateFill || options.markerColor || options.defaultColor,\n          state: \"normal\"\n        }),\n        hover: getState(stateOfDataItem.hover, normalStateFill, \"hovered\"),\n        selection: getState(stateOfDataItem.selection, normalStateFill, \"selected\")\n      };\n      dataItem.states = states;\n      var itemGroup = renderer.g().append(markersGroup);\n      var markerGroup = renderer.g().attr({\n        class: \"dxl-marker\"\n      }).append(itemGroup);\n      that._deferredItems[i] = new Deferred();\n\n      that._templatesGroups.push(markerGroup);\n\n      var item = {\n        label: that._createLabel(dataItem, itemGroup),\n        marker: markerGroup,\n        renderer: renderer,\n        group: itemGroup,\n        tracker: {\n          id: dataItem.id,\n          argument: dataItem.argument,\n          argumentIndex: dataItem.argumentIndex\n        },\n        states: states,\n        itemTextPosition: options.itemTextPosition,\n        markerOffset: 0,\n        bBoxes: [],\n        renderMarker: function renderMarker(state) {\n          dataItem.marker = getAttributes(item, state, dataItem.size);\n          markerGroup.clear();\n          template.render({\n            model: dataItem,\n            container: markerGroup.element,\n            onRendered: that._deferredItems[i].resolve\n          });\n        }\n      };\n      item.renderMarker(states.normal);\n\n      that._createHint(dataItem, itemGroup);\n\n      if (void 0 !== dataItem.id) {\n        that._markersId[dataItem.id] = i;\n      }\n\n      return item;\n    });\n  },\n  getTemplatesGroups: function getTemplatesGroups() {\n    return this._templatesGroups || [];\n  },\n  getTemplatesDef: function getTemplatesDef() {\n    return this._deferredItems || [];\n  },\n  _getItemData: function _getItemData() {\n    var items = this._data || [];\n    var options = this._options || {};\n\n    if (options.inverted) {\n      items = items.slice().reverse();\n    }\n\n    return items.filter(function (i) {\n      return i.visible;\n    });\n  },\n  _finalUpdate: function _finalUpdate(options) {\n    this._adjustBackgroundSettings(options);\n\n    this._setBoundingRect(options.margin);\n  },\n  erase: function erase() {\n    var insideLegendGroup = this._insideLegendGroup;\n    insideLegendGroup && insideLegendGroup.dispose();\n    this._insideLegendGroup = this._markersGroup = this._x1 = this._x2 = this._y2 = this._y2 = null;\n    return this;\n  },\n  _locateElements: function _locateElements(locationOptions) {\n    this._moveInInitialValues();\n\n    this._locateRowsColumns(locationOptions);\n  },\n  _moveInInitialValues: function _moveInInitialValues() {\n    this._title.hasText() && this._title.move([0, 0]);\n    this._legendGroup && this._legendGroup.move(0, 0);\n    this._background && this._background.attr({\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0\n    });\n  },\n  applySelected: function applySelected(id) {\n    applyMarkerState(id, this._markersId, this._items, \"selection\");\n    return this;\n  },\n  applyHover: function applyHover(id) {\n    applyMarkerState(id, this._markersId, this._items, \"hover\");\n    return this;\n  },\n  resetItem: function resetItem(id) {\n    applyMarkerState(id, this._markersId, this._items, \"normal\");\n    return this;\n  },\n  _createLabel: function _createLabel(data, group) {\n    var labelFormatObject = this._getCustomizeObject(data);\n\n    var options = this._options;\n    var align = getAlign(options.itemTextPosition);\n    var text = options.customizeText.call(labelFormatObject, labelFormatObject);\n    var fontStyle = _isDefined(data.textOpacity) ? {\n      color: options.font.color,\n      opacity: data.textOpacity\n    } : {};\n    return this._renderer.text(text, 0, 0).css(patchFontOptions(fontStyle)).attr({\n      align: align,\n      class: options.cssClass\n    }).append(group);\n  },\n  _createHint: function _createHint(data, group) {\n    var labelFormatObject = this._getCustomizeObject(data);\n\n    var text = this._options.customizeHint.call(labelFormatObject, labelFormatObject);\n\n    if (_isDefined(text) && \"\" !== text) {\n      group.setTitle(text);\n    }\n  },\n  _createBackground: function _createBackground() {\n    var isInside = this._options.position === INSIDE;\n    var color = this._options.backgroundColor;\n    var fill = color || (isInside ? this._options.containerBackgroundColor : NONE);\n\n    if (this._options.border.visible || (isInside || color) && color !== NONE) {\n      this._background = this._renderer.rect(0, 0, 0, 0).attr({\n        fill: fill,\n        class: this._backgroundClass\n      }).append(this._insideLegendGroup);\n    }\n  },\n  _locateRowsColumns: function _locateRowsColumns(options) {\n    var iteration = 0;\n\n    var layoutOptions = this._getItemsLayoutOptions();\n\n    var countItems = this._items.length;\n    var lines;\n\n    do {\n      lines = [];\n\n      this._createLines(lines, layoutOptions);\n\n      this._alignLines(lines, layoutOptions);\n\n      iteration++;\n    } while (checkLinesSize(lines, layoutOptions, countItems, options.margin) && iteration < countItems);\n\n    this._applyItemPosition(lines, layoutOptions);\n  },\n  _createLines: function _createLines(lines, layoutOptions) {\n    this._items.forEach(function (item, i) {\n      var tableLine = getLines(lines, layoutOptions, i);\n      var labelBox = {\n        width: item.labelBBox.width,\n        height: item.labelBBox.height,\n        element: item.label,\n        bBox: item.labelBBox,\n        pos: getPos(layoutOptions),\n        itemIndex: i\n      };\n      var markerBox = {\n        width: item.markerBBox.width,\n        height: item.markerBBox.height,\n        element: item.marker,\n        pos: {\n          horizontal: CENTER,\n          vertical: CENTER\n        },\n        bBox: {\n          width: item.markerBBox.width,\n          height: item.markerBBox.height,\n          x: item.markerBBox.x,\n          y: item.markerBBox.y\n        },\n        itemIndex: i\n      };\n      var firstItem;\n      var secondItem;\n      var offsetDirection = layoutOptions.markerOffset ? \"altOffset\" : \"offset\";\n\n      if (layoutOptions.inverseLabelPosition) {\n        firstItem = labelBox;\n        secondItem = markerBox;\n      } else {\n        firstItem = markerBox;\n        secondItem = labelBox;\n      }\n\n      firstItem[offsetDirection] = layoutOptions.labelOffset;\n      tableLine.secondLine.push(firstItem);\n      tableLine.firstLine.push(secondItem);\n    });\n  },\n  _alignLines: function _alignLines(lines, layoutOptions) {\n    var i;\n    var measure = layoutOptions.altMeasure;\n    lines.forEach(function (line) {\n      return setMaxInLine(line, measure);\n    });\n    measure = layoutOptions.measure;\n\n    if (layoutOptions.itemsAlignment) {\n      if (layoutOptions.markerOffset) {\n        for (i = 0; i < lines.length;) {\n          transpose([lines[i++], lines[i++]]).forEach(processLine);\n        }\n      }\n    } else {\n      transpose(lines).forEach(processLine);\n    }\n\n    function processLine(line) {\n      setMaxInLine(line, measure);\n    }\n  },\n  _applyItemPosition: function _applyItemPosition(lines, layoutOptions) {\n    var that = this;\n    var position = {\n      x: 0,\n      y: 0\n    };\n    var maxLineLength = getMaxLineLength(lines, layoutOptions);\n    lines.forEach(function (line) {\n      var firstItem = line[0];\n      var altOffset = firstItem.altOffset || layoutOptions.altSpacing;\n      position[layoutOptions.direction] = getInitPositionForDirection(line, layoutOptions, maxLineLength);\n      line.forEach(function (item) {\n        var offset = item.offset || layoutOptions.spacing;\n        var wrap = new WrapperLayoutElement(item.element, item.bBox);\n        var itemBBoxOptions = {\n          x: position.x,\n          y: position.y,\n          width: item.width,\n          height: item.height\n        };\n        var itemBBox = new WrapperLayoutElement(null, itemBBoxOptions);\n        var itemLegend = that._items[item.itemIndex];\n        wrap.position({\n          of: itemBBox,\n          my: item.pos,\n          at: item.pos\n        });\n        itemLegend.bBoxes.push(itemBBox);\n        position[layoutOptions.direction] += item[layoutOptions.measure] + offset;\n      });\n      position[layoutOptions.altDirection] += firstItem[layoutOptions.altMeasure] + altOffset;\n    });\n\n    this._items.forEach(function (item) {\n      var itemBBox = calculateBBoxLabelAndMarker(item.bBoxes[0].getLayoutOptions(), item.bBoxes[1].getLayoutOptions());\n      var horizontal = that._options.columnItemSpacing / 2;\n      var vertical = that._options.rowItemSpacing / 2;\n      item.tracker.left = itemBBox.left - horizontal;\n      item.tracker.right = itemBBox.right + horizontal;\n      item.tracker.top = itemBBox.top - vertical;\n      item.tracker.bottom = itemBBox.bottom + vertical;\n    });\n  },\n  _getItemsLayoutOptions: function _getItemsLayoutOptions() {\n    var options = this._options;\n    var orientation = options.orientation;\n    var layoutOptions = {\n      itemsAlignment: options.itemsAlignment,\n      orientation: options.orientation\n    };\n    var width = this._size.width - (this._background ? 2 * options.paddingLeftRight : 0);\n    var height = this._size.height - (this._background ? 2 * options.paddingTopBottom : 0);\n\n    if (orientation === HORIZONTAL) {\n      layoutOptions.length = width;\n      layoutOptions.spacing = options.columnItemSpacing;\n      layoutOptions.direction = \"x\";\n      layoutOptions.measure = WIDTH;\n      layoutOptions.altMeasure = HEIGHT;\n      layoutOptions.altDirection = \"y\";\n      layoutOptions.altSpacing = options.rowItemSpacing;\n      layoutOptions.countItem = options.columnCount;\n      layoutOptions.altCountItem = options.rowCount;\n      layoutOptions.marginTextLabel = 4;\n      layoutOptions.labelOffset = 7;\n\n      if (options.itemTextPosition === BOTTOM || options.itemTextPosition === TOP) {\n        layoutOptions.labelOffset = 4;\n        layoutOptions.markerOffset = true;\n      }\n    } else {\n      layoutOptions.length = height;\n      layoutOptions.spacing = options.rowItemSpacing;\n      layoutOptions.direction = \"y\";\n      layoutOptions.measure = HEIGHT;\n      layoutOptions.altMeasure = WIDTH;\n      layoutOptions.altDirection = \"x\";\n      layoutOptions.altSpacing = options.columnItemSpacing;\n      layoutOptions.countItem = options.rowCount;\n      layoutOptions.altCountItem = options.columnCount;\n      layoutOptions.marginTextLabel = 7;\n      layoutOptions.labelOffset = 4;\n\n      if (options.itemTextPosition === RIGHT || options.itemTextPosition === LEFT) {\n        layoutOptions.labelOffset = 7;\n        layoutOptions.markerOffset = true;\n      }\n    }\n\n    if (!layoutOptions.countItem) {\n      if (layoutOptions.altCountItem) {\n        layoutOptions.countItem = _ceil(this._items.length / layoutOptions.altCountItem);\n      } else {\n        layoutOptions.countItem = this._items.length;\n      }\n    }\n\n    if (options.itemTextPosition === TOP || options.itemTextPosition === LEFT) {\n      layoutOptions.inverseLabelPosition = true;\n    }\n\n    layoutOptions.itemTextPosition = options.itemTextPosition;\n    layoutOptions.altCountItem = layoutOptions.altCountItem || _ceil(this._items.length / layoutOptions.countItem);\n    return layoutOptions;\n  },\n  _adjustBackgroundSettings: function _adjustBackgroundSettings(locationOptions) {\n    if (!this._background) {\n      return;\n    }\n\n    var border = locationOptions.border;\n\n    var legendBox = this._calculateTotalBox();\n\n    var backgroundSettings = {\n      x: _round(legendBox.x - locationOptions.paddingLeftRight),\n      y: _round(legendBox.y - locationOptions.paddingTopBottom),\n      width: _round(legendBox.width) + 2 * locationOptions.paddingLeftRight,\n      height: _round(legendBox.height),\n      opacity: locationOptions.backgroundOpacity\n    };\n\n    if (border.visible && border.width && border.color && border.color !== NONE) {\n      backgroundSettings[\"stroke-width\"] = border.width;\n      backgroundSettings.stroke = border.color;\n      backgroundSettings[\"stroke-opacity\"] = border.opacity;\n      backgroundSettings.dashStyle = border.dashStyle;\n      backgroundSettings.rx = border.cornerRadius || 0;\n      backgroundSettings.ry = border.cornerRadius || 0;\n    }\n\n    this._background.attr(backgroundSettings);\n  },\n  _setBoundingRect: function _setBoundingRect(margin) {\n    if (!this._insideLegendGroup) {\n      return;\n    }\n\n    var box = this._calculateTotalBox();\n\n    box.height += margin.top + margin.bottom;\n    box.widthWithoutMargins = box.width;\n    box.width += margin.left + margin.right;\n    box.x -= margin.left;\n    box.y -= margin.top;\n    this._boundingRect = box;\n  },\n  _calculateTotalBox: function _calculateTotalBox() {\n    var markerBox = this._markersGroup.getBBox();\n\n    var titleBox = this._title.getCorrectedLayoutOptions();\n\n    var box = this._insideLegendGroup.getBBox();\n\n    var verticalPadding = this._background ? 2 * this._options.paddingTopBottom : 0;\n    box.height = markerBox.height + titleBox.height + verticalPadding;\n    titleBox.width > box.width && (box.width = titleBox.width);\n    return box;\n  },\n  getActionCallback: function getActionCallback(point) {\n    var that = this;\n\n    if (that._options.visible) {\n      return function (act) {\n        that[act](point.index);\n      };\n    } else {\n      return noop;\n    }\n  },\n  getLayoutOptions: function getLayoutOptions() {\n    var options = this._options;\n    var boundingRect = this._insideLegendGroup ? this._boundingRect : {\n      width: 0,\n      height: 0,\n      x: 0,\n      y: 0\n    };\n\n    if (options) {\n      boundingRect.verticalAlignment = options.verticalAlignment;\n      boundingRect.horizontalAlignment = options.horizontalAlignment;\n\n      if (options.orientation === HORIZONTAL) {\n        boundingRect.cutLayoutSide = options.verticalAlignment;\n        boundingRect.cutSide = \"vertical\";\n      } else if (options.horizontalAlignment === CENTER) {\n        boundingRect.cutLayoutSide = options.verticalAlignment;\n        boundingRect.cutSide = \"vertical\";\n      } else {\n        boundingRect.cutLayoutSide = options.horizontalAlignment;\n        boundingRect.cutSide = \"horizontal\";\n      }\n\n      boundingRect.position = {\n        horizontal: options.horizontalAlignment,\n        vertical: options.verticalAlignment\n      };\n      return boundingRect;\n    }\n\n    return null;\n  },\n  shift: function shift(x, y) {\n    var box = {};\n\n    if (this._insideLegendGroup) {\n      this._insideLegendGroup.attr({\n        translateX: x - this._boundingRect.x,\n        translateY: y - this._boundingRect.y\n      });\n    }\n\n    this._title && this._shiftTitle(this._boundingRect.widthWithoutMargins);\n    this._markersGroup && this._shiftMarkers();\n\n    if (this._insideLegendGroup) {\n      box = this._legendGroup.getBBox();\n    }\n\n    this._x1 = box.x;\n    this._y1 = box.y;\n    this._x2 = box.x + box.width;\n    this._y2 = box.y + box.height;\n    return this;\n  },\n  _shiftTitle: function _shiftTitle(boxWidth) {\n    var title = this._title;\n    var titleBox = title.getCorrectedLayoutOptions();\n\n    if (!titleBox || !title.hasText()) {\n      return;\n    }\n\n    var width = boxWidth - (this._background ? 2 * this._options.paddingLeftRight : 0);\n    var titleOptions = title.getOptions();\n    var titleY = titleBox.y + titleOptions.margin.top;\n    var titleX = 0;\n\n    if (titleOptions.verticalAlignment === BOTTOM && this._markersGroup) {\n      titleY += this._markersGroup.getBBox().height;\n    }\n\n    if (titleOptions.horizontalAlignment === RIGHT) {\n      titleX = width - titleBox.width;\n    } else if (titleOptions.horizontalAlignment === CENTER) {\n      titleX = (width - titleBox.width) / 2;\n    }\n\n    title.shift(titleX, titleY);\n  },\n  _shiftMarkers: function _shiftMarkers() {\n    var titleBox = this._title.getLayoutOptions();\n\n    var markerBox = this._markersGroup.getBBox();\n\n    var titleOptions = this._title.getOptions() || {};\n    var center = 0;\n    var y = 0;\n\n    if (titleBox.width > markerBox.width && this._options.horizontalAlignment === CENTER) {\n      center = titleBox.width / 2 - markerBox.width / 2;\n    }\n\n    if (titleOptions.verticalAlignment === TOP) {\n      y = titleBox.height;\n    }\n\n    if (0 !== center || 0 !== y) {\n      this._markersGroup.attr({\n        translateX: center,\n        translateY: y\n      });\n\n      this._items.forEach(function (item) {\n        item.tracker.left += center;\n        item.tracker.right += center;\n        item.tracker.top += y;\n        item.tracker.bottom += y;\n      });\n    }\n  },\n  getPosition: function getPosition() {\n    return this._options.position;\n  },\n  coordsIn: function coordsIn(x, y) {\n    return x >= this._x1 && x <= this._x2 && y >= this._y1 && y <= this._y2;\n  },\n  getItemByCoord: function getItemByCoord(x, y) {\n    var items = this._items;\n    var legendGroup = this._insideLegendGroup;\n    x -= legendGroup.attr(\"translateX\");\n    y -= legendGroup.attr(\"translateY\");\n\n    for (var i = 0; i < items.length; i++) {\n      if (inRect(items[i].tracker, x, y)) {\n        return items[i].tracker;\n      }\n    }\n\n    return null;\n  },\n  dispose: function dispose() {\n    this._title && this._title.dispose();\n    this._legendGroup = this._insideLegendGroup = this._title = this._renderer = this._options = this._data = this._items = null;\n    return this;\n  },\n  layoutOptions: function layoutOptions() {\n    if (!this.isVisible()) {\n      return null;\n    }\n\n    var pos = this.getLayoutOptions();\n    return {\n      horizontalAlignment: this._options.horizontalAlignment,\n      verticalAlignment: this._options.verticalAlignment,\n      side: pos.cutSide,\n      priority: 1,\n      position: this.getPosition()\n    };\n  },\n  measure: function measure(size) {\n    if (this._updated || !this._insideLegendGroup) {\n      this.draw(size[0], size[1]);\n      this._updated = false;\n    } else {\n      this._items.forEach(function (item) {\n        item.bBoxes = [];\n      });\n\n      this._updateElementsPosition(size[0], size[1]);\n    }\n\n    var rect = this.getLayoutOptions();\n    return [rect.width, rect.height];\n  },\n  move: function move(rect) {\n    this.shift(rect[0], rect[1]);\n  },\n  freeSpace: function freeSpace() {\n    this._options._incidentOccurred(\"W2104\");\n\n    this.erase();\n  }\n});\nexport var plugin = {\n  name: \"legend\",\n  init: function init() {\n    var group = this._renderer.g().attr({\n      class: this._rootClassPrefix + \"-legend\"\n    }).enableLinks().append(this._renderer.root);\n\n    this._legend = new Legend({\n      renderer: this._renderer,\n      group: group,\n      widget: this,\n      itemGroupClass: this._rootClassPrefix + \"-item\",\n      titleGroupClass: this._rootClassPrefix + \"-title\",\n      textField: \"text\",\n      getFormatObject: function getFormatObject(data) {\n        return {\n          item: data.item,\n          text: data.text\n        };\n      }\n    });\n\n    this._layout.add(this._legend);\n  },\n  extenders: {\n    _applyTilesAppearance: function _applyTilesAppearance() {\n      var that = this;\n\n      this._items.forEach(function (item) {\n        that._applyLegendItemStyle(item.id, item.getState());\n      });\n    },\n    _buildNodes: function _buildNodes() {\n      this._createLegendItems();\n    }\n  },\n  members: {\n    _applyLegendItemStyle: function _applyLegendItemStyle(id, state) {\n      var legend = this._legend;\n\n      switch (state) {\n        case \"hover\":\n          legend.applyHover(id);\n          break;\n\n        case \"selection\":\n          legend.applySelected(id);\n          break;\n\n        default:\n          legend.resetItem(id);\n      }\n    },\n    _createLegendItems: function _createLegendItems() {\n      if (this._legend.update(this._getLegendData(), this._getOption(\"legend\"), this._themeManager.theme(\"legend\").title)) {\n        this._requestChange([\"LAYOUT\"]);\n      }\n    }\n  },\n  dispose: function dispose() {\n    this._legend.dispose();\n  },\n  customize: function customize(constructor) {\n    constructor.prototype._proxyData.push(function (x, y) {\n      if (this._legend.coordsIn(x, y)) {\n        var item = this._legend.getItemByCoord(x, y);\n\n        if (item) {\n          return {\n            id: item.id,\n            type: \"legend\"\n          };\n        }\n      }\n    });\n\n    constructor.addChange({\n      code: \"LEGEND\",\n      handler: function handler() {\n        this._createLegendItems();\n      },\n      isThemeDependent: true,\n      option: \"legend\",\n      isOptionChange: true\n    });\n  }\n};","map":null,"metadata":{},"sourceType":"module"}