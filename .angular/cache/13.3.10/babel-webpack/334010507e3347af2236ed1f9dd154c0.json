{"ast":null,"code":"/**\r\n * DevExtreme (esm/viz/series/points/pie_point.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { extend } from \"../../../core/utils/extend\";\nimport symbolPoint from \"./symbol_point\";\nvar _extend = extend;\nvar _round = Math.round;\nvar _sqrt = Math.sqrt;\nvar _acos = Math.acos;\nvar DEG = 180 / Math.PI;\nvar _abs = Math.abs;\nimport { getVerticallyShiftedAngularCoords, normalizeAngle as _normalizeAngle, getCosAndSin as _getCosAndSin } from \"../../core/utils\";\nimport { isDefined as _isDefined } from \"../../../core/utils/type\";\nimport consts from \"../../components/consts\";\nvar RADIAL_LABEL_INDENT = consts.radialLabelIndent;\nexport default _extend({}, symbolPoint, {\n  _updateData: function _updateData(data, argumentChanged) {\n    symbolPoint._updateData.call(this, data);\n\n    if (argumentChanged || !_isDefined(this._visible)) {\n      this._visible = true;\n    }\n\n    this.minValue = this.initialMinValue = this.originalMinValue = _isDefined(data.minValue) ? data.minValue : 0;\n  },\n  animate: function animate(complete, duration, delay) {\n    this.graphic.animate({\n      x: this.centerX,\n      y: this.centerY,\n      outerRadius: this.radiusOuter,\n      innerRadius: this.radiusInner,\n      startAngle: this.toAngle,\n      endAngle: this.fromAngle\n    }, {\n      delay: delay,\n      partitionDuration: duration\n    }, complete);\n  },\n  correctPosition: function correctPosition(correction) {\n    this.correctRadius(correction);\n    this.correctLabelRadius(correction.radiusOuter + RADIAL_LABEL_INDENT);\n    this.centerX = correction.centerX;\n    this.centerY = correction.centerY;\n  },\n  correctRadius: function correctRadius(correction) {\n    this.radiusInner = correction.radiusInner;\n    this.radiusOuter = correction.radiusOuter;\n  },\n  correctLabelRadius: function correctLabelRadius(radiusLabels) {\n    this.radiusLabels = radiusLabels;\n  },\n  correctValue: function correctValue(correction, percent, base) {\n    this.value = (base || this.normalInitialValue) + correction;\n    this.minValue = correction;\n    this.percent = percent;\n\n    this._label.setDataField(\"percent\", percent);\n  },\n  _updateLabelData: function _updateLabelData() {\n    this._label.setData(this._getLabelFormatObject());\n  },\n  _getShiftLabelCoords: function _getShiftLabelCoords() {\n    var bBox = this._label.getBoundingRect();\n\n    var coord = this._getLabelCoords(this._label);\n\n    var visibleArea = this._getVisibleArea();\n\n    if (this._isLabelDrawingWithoutPoints) {\n      return this._checkLabelPosition(coord, bBox, visibleArea);\n    } else {\n      return this._getLabelExtraCoord(coord, this._checkVerticalLabelPosition(coord, bBox, visibleArea), bBox);\n    }\n  },\n  _getLabelPosition: function _getLabelPosition(options) {\n    return options.position;\n  },\n  getAnnotationCoords: function getAnnotationCoords(location) {\n    return this._getElementCoords(\"edge\" !== location ? \"inside\" : \"outside\", this.radiusOuter, 0);\n  },\n  _getElementCoords: function _getElementCoords(position, elementRadius, radialOffset) {\n    var bBox = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0\n    };\n    var that = this;\n\n    var angleFunctions = _getCosAndSin(that.middleAngle);\n\n    var radiusInner = that.radiusInner;\n    var radiusOuter = that.radiusOuter;\n    var columnsPosition = \"columns\" === position;\n    var rad;\n    var x;\n\n    if (\"inside\" === position) {\n      rad = radiusInner + (radiusOuter - radiusInner) / 2 + radialOffset;\n      x = that.centerX + rad * angleFunctions.cos - bBox.width / 2;\n    } else {\n      rad = elementRadius + radialOffset;\n\n      if (angleFunctions.cos > .1 || columnsPosition && angleFunctions.cos >= 0) {\n        x = that.centerX + rad * angleFunctions.cos;\n      } else if (angleFunctions.cos < -.1 || columnsPosition && angleFunctions.cos < 0) {\n        x = that.centerX + rad * angleFunctions.cos - bBox.width;\n      } else {\n        x = that.centerX + rad * angleFunctions.cos - bBox.width / 2;\n      }\n    }\n\n    return {\n      x: x,\n      y: _round(that.centerY - rad * angleFunctions.sin - bBox.height / 2)\n    };\n  },\n  _getLabelCoords: function _getLabelCoords(label) {\n    var bBox = label.getBoundingRect();\n    var options = label.getLayoutOptions();\n\n    var position = this._getLabelPosition(options);\n\n    return this._getElementCoords(position, this.radiusLabels, options.radialOffset, bBox);\n  },\n  _correctLabelCoord: function _correctLabelCoord(coord, moveLabelsFromCenter) {\n    var label = this._label;\n    var bBox = label.getBoundingRect();\n    var labelWidth = bBox.width;\n    var options = label.getLayoutOptions();\n\n    var visibleArea = this._getVisibleArea();\n\n    var rightBorderX = visibleArea.maxX - labelWidth;\n    var leftBorderX = visibleArea.minX;\n\n    var angleOfPoint = _normalizeAngle(this.middleAngle);\n\n    var centerX = this.centerX;\n    var connectorOffset = options.connectorOffset;\n    var x = coord.x;\n\n    if (\"columns\" === options.position) {\n      if (angleOfPoint <= 90 || angleOfPoint >= 270) {\n        x = rightBorderX;\n      } else {\n        x = leftBorderX;\n      }\n\n      coord.x = x;\n    } else if (\"inside\" !== options.position && moveLabelsFromCenter) {\n      if (angleOfPoint <= 90 || angleOfPoint >= 270) {\n        if (x - connectorOffset < centerX) {\n          x = centerX + connectorOffset;\n        }\n      } else if (x + labelWidth + connectorOffset > centerX) {\n        x = centerX - labelWidth - connectorOffset;\n      }\n\n      coord.x = x;\n    }\n\n    return coord;\n  },\n  drawLabel: function drawLabel() {\n    this.translate();\n    this._isLabelDrawingWithoutPoints = true;\n\n    this._drawLabel();\n\n    this._isLabelDrawingWithoutPoints = false;\n  },\n  updateLabelCoord: function updateLabelCoord(moveLabelsFromCenter) {\n    var bBox = this._label.getBoundingRect();\n\n    var coord = this._correctLabelCoord(bBox, moveLabelsFromCenter);\n\n    coord = this._checkHorizontalLabelPosition(coord, bBox, this._getVisibleArea());\n\n    this._label.shift(_round(coord.x), _round(bBox.y));\n  },\n  _checkVerticalLabelPosition: function _checkVerticalLabelPosition(coord, box, visibleArea) {\n    var x = coord.x;\n    var y = coord.y;\n\n    if (coord.y + box.height > visibleArea.maxY) {\n      y = visibleArea.maxY - box.height;\n    } else if (coord.y < visibleArea.minY) {\n      y = visibleArea.minY;\n    }\n\n    return {\n      x: x,\n      y: y\n    };\n  },\n  _getLabelExtraCoord: function _getLabelExtraCoord(coord, shiftCoord, box) {\n    return coord.y !== shiftCoord.y ? getVerticallyShiftedAngularCoords({\n      x: coord.x,\n      y: coord.y,\n      width: box.width,\n      height: box.height\n    }, shiftCoord.y - coord.y, {\n      x: this.centerX,\n      y: this.centerY\n    }) : coord;\n  },\n  _checkHorizontalLabelPosition: function _checkHorizontalLabelPosition(coord, box, visibleArea) {\n    var x = coord.x;\n    var y = coord.y;\n\n    if (coord.x + box.width > visibleArea.maxX) {\n      x = visibleArea.maxX - box.width;\n    } else if (coord.x < visibleArea.minX) {\n      x = visibleArea.minX;\n    }\n\n    return {\n      x: x,\n      y: y\n    };\n  },\n  applyWordWrap: function applyWordWrap(moveLabelsFromCenter) {\n    var label = this._label;\n    var box = label.getBoundingRect();\n\n    var visibleArea = this._getVisibleArea();\n\n    var position = label.getLayoutOptions().position;\n    var width = box.width;\n    var rowCountChanged = false;\n\n    if (\"columns\" === position && this.series.index > 0) {\n      width = visibleArea.maxX - this.centerX - this.radiusLabels;\n    } else if (\"inside\" === position) {\n      if (width > visibleArea.maxX - visibleArea.minX) {\n        width = visibleArea.maxX - visibleArea.minX;\n      }\n    } else if (moveLabelsFromCenter && box.x < this.centerX && box.width + box.x > this.centerX) {\n      width = Math.floor((visibleArea.maxX - visibleArea.minX) / 2);\n    } else if (box.x + width > visibleArea.maxX) {\n      width = visibleArea.maxX - box.x;\n    } else if (box.x < visibleArea.minX) {\n      width = box.x + width - visibleArea.minX;\n    }\n\n    if (width < box.width) {\n      rowCountChanged = label.fit(width);\n    }\n\n    return rowCountChanged;\n  },\n  setLabelTrackerData: function setLabelTrackerData() {\n    this._label.setTrackerData(this);\n  },\n  _checkLabelPosition: function _checkLabelPosition(coord, bBox, visibleArea) {\n    coord = this._checkHorizontalLabelPosition(coord, bBox, visibleArea);\n    return this._checkVerticalLabelPosition(coord, bBox, visibleArea);\n  },\n  _getLabelConnector: function _getLabelConnector() {\n    var rad = this.radiusOuter;\n    var seriesStyle = this._options.styles.normal;\n    var strokeWidthBy2 = seriesStyle[\"stroke-width\"] / 2;\n    var borderWidth = this.series.getOptions().containerBackgroundColor === seriesStyle.stroke ? _round(strokeWidthBy2) : _round(-strokeWidthBy2);\n\n    var angleFunctions = _getCosAndSin(_round(this.middleAngle));\n\n    return {\n      x: _round(this.centerX + (rad - borderWidth) * angleFunctions.cos),\n      y: _round(this.centerY - (rad - borderWidth) * angleFunctions.sin),\n      angle: this.middleAngle\n    };\n  },\n  _drawMarker: function _drawMarker(renderer, group, animationEnabled, firstDrawing) {\n    var radiusOuter = this.radiusOuter;\n    var radiusInner = this.radiusInner;\n    var fromAngle = this.fromAngle;\n    var toAngle = this.toAngle;\n\n    if (animationEnabled) {\n      radiusInner = radiusOuter = 0;\n\n      if (!firstDrawing) {\n        fromAngle = toAngle = this.shiftedAngle;\n      }\n    }\n\n    this.graphic = renderer.arc(this.centerX, this.centerY, radiusInner, radiusOuter, toAngle, fromAngle).attr({\n      \"stroke-linejoin\": \"round\"\n    }).smartAttr(this._getStyle()).data({\n      \"chart-data-point\": this\n    }).sharp().append(group);\n  },\n  getTooltipParams: function getTooltipParams() {\n    var angleFunctions = _getCosAndSin(this.middleAngle);\n\n    var radiusInner = this.radiusInner;\n    var radiusOuter = this.radiusOuter;\n    return {\n      x: this.centerX + (radiusInner + (radiusOuter - radiusInner) / 2) * angleFunctions.cos,\n      y: this.centerY - (radiusInner + (radiusOuter - radiusInner) / 2) * angleFunctions.sin,\n      offset: 0\n    };\n  },\n  _translate: function _translate() {\n    var angle = this.shiftedAngle || 0;\n    var value = this.value;\n    var minValue = this.minValue;\n\n    var translator = this._getValTranslator();\n\n    this.fromAngle = translator.translate(minValue) + angle;\n    this.toAngle = translator.translate(value) + angle;\n    this.middleAngle = translator.translate((value - minValue) / 2 + minValue) + angle;\n\n    if (!this.isVisible()) {\n      this.middleAngle = this.toAngle = this.fromAngle = this.fromAngle || angle;\n    }\n  },\n  getMarkerVisibility: function getMarkerVisibility() {\n    return true;\n  },\n  _updateMarker: function _updateMarker(animationEnabled, style, _, callback) {\n    if (!animationEnabled) {\n      style = _extend({\n        x: this.centerX,\n        y: this.centerY,\n        outerRadius: this.radiusOuter,\n        innerRadius: this.radiusInner,\n        startAngle: this.toAngle,\n        endAngle: this.fromAngle\n      }, style);\n    }\n\n    this.graphic.smartAttr(style).sharp();\n    callback && callback();\n  },\n  getLegendStyles: function getLegendStyles() {\n    return this._styles.legendStyles;\n  },\n  isInVisibleArea: function isInVisibleArea() {\n    return true;\n  },\n  hide: function hide() {\n    if (this._visible) {\n      this._visible = false;\n      this.hideTooltip();\n\n      this._options.visibilityChanged();\n    }\n  },\n  show: function show() {\n    if (!this._visible) {\n      this._visible = true;\n\n      this._options.visibilityChanged();\n    }\n  },\n  setInvisibility: function setInvisibility() {\n    this._label.draw(false);\n  },\n  isVisible: function isVisible() {\n    return this._visible;\n  },\n  _getFormatObject: function _getFormatObject(tooltip) {\n    var formatObject = symbolPoint._getFormatObject.call(this, tooltip);\n\n    var percent = this.percent;\n    formatObject.percent = percent;\n    formatObject.percentText = tooltip.formatValue(percent, \"percent\");\n    return formatObject;\n  },\n  getColor: function getColor() {\n    return this._styles.normal.fill;\n  },\n  coordsIn: function coordsIn(x, y) {\n    var lx = x - this.centerX;\n    var ly = y - this.centerY;\n\n    var r = _sqrt(lx * lx + ly * ly);\n\n    var fromAngle = this.fromAngle % 360;\n    var toAngle = this.toAngle % 360;\n    var angle;\n\n    if (r < this.radiusInner || r > this.radiusOuter || 0 === r) {\n      return false;\n    }\n\n    angle = _acos(lx / r) * DEG * (ly > 0 ? -1 : 1);\n\n    if (angle < 0) {\n      angle += 360;\n    }\n\n    if (fromAngle === toAngle && _abs(this.toAngle - this.fromAngle) > 1e-4) {\n      return true;\n    } else {\n      return fromAngle >= toAngle ? angle <= fromAngle && angle >= toAngle : !(angle >= fromAngle && angle <= toAngle);\n    }\n  }\n});","map":null,"metadata":{},"sourceType":"module"}