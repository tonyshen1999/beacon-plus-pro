{"ast":null,"code":"/**\r\n * DevExtreme (esm/events/drag.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport $ from \"../core/renderer\";\nimport { data as elementData, removeData } from \"../core/element_data\";\nimport { wrapToArray, inArray } from \"../core/utils/array\";\nimport * as iteratorUtils from \"../core/utils/iterator\";\nimport { contains } from \"../core/utils/dom\";\nimport registerEvent from \"./core/event_registrator\";\nimport { eventData as eData, fireEvent } from \"./utils/index\";\nimport GestureEmitter from \"./gesture/emitter.gesture\";\nimport registerEmitter from \"./core/emitter_registrator\";\nvar DRAG_START_EVENT = \"dxdragstart\";\nvar DRAG_EVENT = \"dxdrag\";\nvar DRAG_END_EVENT = \"dxdragend\";\nvar DRAG_ENTER_EVENT = \"dxdragenter\";\nvar DRAG_LEAVE_EVENT = \"dxdragleave\";\nvar DROP_EVENT = \"dxdrop\";\nvar DX_DRAG_EVENTS_COUNT_KEY = \"dxDragEventsCount\";\nvar knownDropTargets = [];\nvar knownDropTargetSelectors = [];\nvar knownDropTargetConfigs = [];\nvar dropTargetRegistration = {\n  setup: function setup(element, data) {\n    var knownDropTarget = -1 !== inArray(element, knownDropTargets);\n\n    if (!knownDropTarget) {\n      knownDropTargets.push(element);\n      knownDropTargetSelectors.push([]);\n      knownDropTargetConfigs.push(data || {});\n    }\n  },\n  add: function add(element, handleObj) {\n    var index = inArray(element, knownDropTargets);\n    this.updateEventsCounter(element, handleObj.type, 1);\n    var selector = handleObj.selector;\n\n    if (-1 === inArray(selector, knownDropTargetSelectors[index])) {\n      knownDropTargetSelectors[index].push(selector);\n    }\n  },\n  updateEventsCounter: function updateEventsCounter(element, event, value) {\n    if ([DRAG_ENTER_EVENT, DRAG_LEAVE_EVENT, DROP_EVENT].indexOf(event) > -1) {\n      var eventsCount = elementData(element, DX_DRAG_EVENTS_COUNT_KEY) || 0;\n      elementData(element, DX_DRAG_EVENTS_COUNT_KEY, Math.max(0, eventsCount + value));\n    }\n  },\n  remove: function remove(element, handleObj) {\n    this.updateEventsCounter(element, handleObj.type, -1);\n  },\n  teardown: function teardown(element) {\n    var handlersCount = elementData(element, DX_DRAG_EVENTS_COUNT_KEY);\n\n    if (!handlersCount) {\n      var index = inArray(element, knownDropTargets);\n      knownDropTargets.splice(index, 1);\n      knownDropTargetSelectors.splice(index, 1);\n      knownDropTargetConfigs.splice(index, 1);\n      removeData(element, DX_DRAG_EVENTS_COUNT_KEY);\n    }\n  }\n};\nregisterEvent(DRAG_ENTER_EVENT, dropTargetRegistration);\nregisterEvent(DRAG_LEAVE_EVENT, dropTargetRegistration);\nregisterEvent(DROP_EVENT, dropTargetRegistration);\n\nvar getItemDelegatedTargets = function getItemDelegatedTargets($element) {\n  var dropTargetIndex = inArray($element.get(0), knownDropTargets);\n  var dropTargetSelectors = knownDropTargetSelectors[dropTargetIndex].filter(function (selector) {\n    return selector;\n  });\n  var $delegatedTargets = $element.find(dropTargetSelectors.join(\", \"));\n\n  if (-1 !== inArray(void 0, knownDropTargetSelectors[dropTargetIndex])) {\n    $delegatedTargets = $delegatedTargets.add($element);\n  }\n\n  return $delegatedTargets;\n};\n\nvar getItemConfig = function getItemConfig($element) {\n  var dropTargetIndex = inArray($element.get(0), knownDropTargets);\n  return knownDropTargetConfigs[dropTargetIndex];\n};\n\nvar getItemPosition = function getItemPosition(dropTargetConfig, $element) {\n  if (dropTargetConfig.itemPositionFunc) {\n    return dropTargetConfig.itemPositionFunc($element);\n  } else {\n    return $element.offset();\n  }\n};\n\nvar getItemSize = function getItemSize(dropTargetConfig, $element) {\n  if (dropTargetConfig.itemSizeFunc) {\n    return dropTargetConfig.itemSizeFunc($element);\n  }\n\n  return {\n    width: $element.get(0).getBoundingClientRect().width,\n    height: $element.get(0).getBoundingClientRect().height\n  };\n};\n\nvar DragEmitter = GestureEmitter.inherit({\n  ctor: function ctor(element) {\n    this.callBase(element);\n    this.direction = \"both\";\n  },\n  _init: function _init(e) {\n    this._initEvent = e;\n  },\n  _start: function _start(e) {\n    e = this._fireEvent(DRAG_START_EVENT, this._initEvent);\n    this._maxLeftOffset = e.maxLeftOffset;\n    this._maxRightOffset = e.maxRightOffset;\n    this._maxTopOffset = e.maxTopOffset;\n    this._maxBottomOffset = e.maxBottomOffset;\n    var dropTargets = wrapToArray(e.targetElements || (null === e.targetElements ? [] : knownDropTargets));\n    this._dropTargets = iteratorUtils.map(dropTargets, function (element) {\n      return $(element).get(0);\n    });\n  },\n  _move: function _move(e) {\n    var eventData = eData(e);\n\n    var dragOffset = this._calculateOffset(eventData);\n\n    e = this._fireEvent(DRAG_EVENT, e, {\n      offset: dragOffset\n    });\n\n    this._processDropTargets(e);\n\n    if (!e._cancelPreventDefault) {\n      e.preventDefault();\n    }\n  },\n  _calculateOffset: function _calculateOffset(eventData) {\n    return {\n      x: this._calculateXOffset(eventData),\n      y: this._calculateYOffset(eventData)\n    };\n  },\n  _calculateXOffset: function _calculateXOffset(eventData) {\n    if (\"vertical\" !== this.direction) {\n      var offset = eventData.x - this._startEventData.x;\n      return this._fitOffset(offset, this._maxLeftOffset, this._maxRightOffset);\n    }\n\n    return 0;\n  },\n  _calculateYOffset: function _calculateYOffset(eventData) {\n    if (\"horizontal\" !== this.direction) {\n      var offset = eventData.y - this._startEventData.y;\n      return this._fitOffset(offset, this._maxTopOffset, this._maxBottomOffset);\n    }\n\n    return 0;\n  },\n  _fitOffset: function _fitOffset(offset, minOffset, maxOffset) {\n    if (null != minOffset) {\n      offset = Math.max(offset, -minOffset);\n    }\n\n    if (null != maxOffset) {\n      offset = Math.min(offset, maxOffset);\n    }\n\n    return offset;\n  },\n  _processDropTargets: function _processDropTargets(e) {\n    var target = this._findDropTarget(e);\n\n    var sameTarget = target === this._currentDropTarget;\n\n    if (!sameTarget) {\n      this._fireDropTargetEvent(e, DRAG_LEAVE_EVENT);\n\n      this._currentDropTarget = target;\n\n      this._fireDropTargetEvent(e, DRAG_ENTER_EVENT);\n    }\n  },\n  _fireDropTargetEvent: function _fireDropTargetEvent(event, eventName) {\n    if (!this._currentDropTarget) {\n      return;\n    }\n\n    var eventData = {\n      type: eventName,\n      originalEvent: event,\n      draggingElement: this._$element.get(0),\n      target: this._currentDropTarget\n    };\n    fireEvent(eventData);\n  },\n  _findDropTarget: function _findDropTarget(e) {\n    var that = this;\n    var result;\n    iteratorUtils.each(knownDropTargets, function (_, target) {\n      if (!that._checkDropTargetActive(target)) {\n        return;\n      }\n\n      var $target = $(target);\n      iteratorUtils.each(getItemDelegatedTargets($target), function (_, delegatedTarget) {\n        var $delegatedTarget = $(delegatedTarget);\n\n        if (that._checkDropTarget(getItemConfig($target), $delegatedTarget, $(result), e)) {\n          result = delegatedTarget;\n        }\n      });\n    });\n    return result;\n  },\n  _checkDropTargetActive: function _checkDropTargetActive(target) {\n    var active = false;\n    iteratorUtils.each(this._dropTargets, function (_, activeTarget) {\n      active = active || activeTarget === target || contains(activeTarget, target);\n      return !active;\n    });\n    return active;\n  },\n  _checkDropTarget: function _checkDropTarget(config, $target, $prevTarget, e) {\n    var isDraggingElement = $target.get(0) === $(e.target).get(0);\n\n    if (isDraggingElement) {\n      return false;\n    }\n\n    var targetPosition = getItemPosition(config, $target);\n\n    if (e.pageX < targetPosition.left) {\n      return false;\n    }\n\n    if (e.pageY < targetPosition.top) {\n      return false;\n    }\n\n    var targetSize = getItemSize(config, $target);\n\n    if (e.pageX > targetPosition.left + targetSize.width) {\n      return false;\n    }\n\n    if (e.pageY > targetPosition.top + targetSize.height) {\n      return false;\n    }\n\n    if ($prevTarget.length && $prevTarget.closest($target).length) {\n      return false;\n    }\n\n    if (config.checkDropTarget && !config.checkDropTarget($target, e)) {\n      return false;\n    }\n\n    return $target;\n  },\n  _end: function _end(e) {\n    var eventData = eData(e);\n\n    this._fireEvent(DRAG_END_EVENT, e, {\n      offset: this._calculateOffset(eventData)\n    });\n\n    this._fireDropTargetEvent(e, DROP_EVENT);\n\n    delete this._currentDropTarget;\n  }\n});\nregisterEmitter({\n  emitter: DragEmitter,\n  events: [DRAG_START_EVENT, DRAG_EVENT, DRAG_END_EVENT]\n});\nexport { DRAG_EVENT as move, DRAG_START_EVENT as start, DRAG_END_EVENT as end, DRAG_ENTER_EVENT as enter, DRAG_LEAVE_EVENT as leave, DROP_EVENT as drop };","map":null,"metadata":{},"sourceType":"module"}