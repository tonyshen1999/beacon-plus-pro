{"ast":null,"code":"import _inherits from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _slicedToArray from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _classCallCheck from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n\n/**\r\n * DevExtreme (esm/ui/scheduler/appointments/dataProvider/appointmentFilter.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport config from \"../../../../core/config\";\nimport dateUtils from \"../../../../core/utils/date\";\nimport { equalByValue } from \"../../../../core/utils/common\";\nimport dateSerialization from \"../../../../core/utils/date_serialization\";\nimport { getRecurrenceProcessor } from \"../../recurrence\";\nimport { inArray, wrapToArray } from \"../../../../core/utils/array\";\nimport { extend } from \"../../../../core/utils/extend\";\nimport { map, each } from \"../../../../core/utils/iterator\";\nimport { isFunction, isDefined, isString } from \"../../../../core/utils/type\";\nimport query from \"../../../../data/query\";\nimport { createAppointmentAdapter } from \"../../appointmentAdapter\";\nimport { isDateAndTimeView as calculateIsDateAndTimeView, isSupportMultiDayAppointments } from \"../../../../renovation/ui/scheduler/view_model/to_test/views/utils/base\";\nimport { getResourcesDataByGroups } from \"../../resources/utils\";\nimport { compareDateWithStartDayHour, compareDateWithEndDayHour, getTrimDates, getAppointmentTakesSeveralDays, _appointmentPartInInterval, getRecurrenceException, getAppointmentTakesAllDay } from \"./utils\";\nvar toMs = dateUtils.dateToMilliseconds;\nvar DATE_FILTER_POSITION = 0;\nvar USER_FILTER_POSITION = 1;\nvar FilterStrategies = {\n  virtual: \"virtual\",\n  standard: \"standard\"\n};\n\nvar FilterMaker = /*#__PURE__*/function () {\n  function FilterMaker(dataAccessors) {\n    _classCallCheck(this, FilterMaker);\n\n    this._filterRegistry = null;\n    this.dataAccessors = dataAccessors;\n  }\n\n  _createClass(FilterMaker, [{\n    key: \"isRegistered\",\n    value: function isRegistered() {\n      return !!this._filterRegistry;\n    }\n  }, {\n    key: \"clearRegistry\",\n    value: function clearRegistry() {\n      delete this._filterRegistry;\n    }\n  }, {\n    key: \"make\",\n    value: function make(type, args) {\n      if (!this._filterRegistry) {\n        this._filterRegistry = {};\n      }\n\n      this._make(type).apply(this, args);\n    }\n  }, {\n    key: \"_make\",\n    value: function _make(type) {\n      var _this = this;\n\n      switch (type) {\n        case \"date\":\n          return function (min, max, useAccessors) {\n            var startDate = useAccessors ? _this.dataAccessors.getter.startDate : _this.dataAccessors.expr.startDateExpr;\n            var endDate = useAccessors ? _this.dataAccessors.getter.endDate : _this.dataAccessors.expr.endDateExpr;\n            var recurrenceRule = _this.dataAccessors.expr.recurrenceRuleExpr;\n            _this._filterRegistry.date = [[[endDate, \">=\", min], [startDate, \"<\", max]], \"or\", [recurrenceRule, \"startswith\", \"freq\"], \"or\", [[endDate, min], [startDate, min]]];\n\n            if (!recurrenceRule) {\n              _this._filterRegistry.date.splice(1, 2);\n            }\n          };\n\n        case \"user\":\n          return function (userFilter) {\n            _this._filterRegistry.user = userFilter;\n          };\n      }\n    }\n  }, {\n    key: \"combine\",\n    value: function combine() {\n      var filter = [];\n      this._filterRegistry.date && filter.push(this._filterRegistry.date);\n      this._filterRegistry.user && filter.push(this._filterRegistry.user);\n      return filter;\n    }\n  }, {\n    key: \"dateFilter\",\n    value: function dateFilter() {\n      var _this$_filterRegistry;\n\n      return null === (_this$_filterRegistry = this._filterRegistry) || void 0 === _this$_filterRegistry ? void 0 : _this$_filterRegistry.date;\n    }\n  }]);\n\n  return FilterMaker;\n}();\n\nexport var AppointmentFilterBaseStrategy = /*#__PURE__*/function () {\n  function AppointmentFilterBaseStrategy(options) {\n    _classCallCheck(this, AppointmentFilterBaseStrategy);\n\n    this.options = options;\n    this.dataSource = this.options.dataSource;\n    this.dataAccessors = this.options.dataAccessors;\n\n    this._init();\n  }\n\n  _createClass(AppointmentFilterBaseStrategy, [{\n    key: \"strategyName\",\n    get: function get() {\n      return FilterStrategies.standard;\n    }\n  }, {\n    key: \"timeZoneCalculator\",\n    get: function get() {\n      return this.options.timeZoneCalculator;\n    }\n  }, {\n    key: \"viewStartDayHour\",\n    get: function get() {\n      return this.options.startDayHour;\n    }\n  }, {\n    key: \"viewEndDayHour\",\n    get: function get() {\n      return this.options.endDayHour;\n    }\n  }, {\n    key: \"timezone\",\n    get: function get() {\n      return this.options.timezone;\n    }\n  }, {\n    key: \"firstDayOfWeek\",\n    get: function get() {\n      return this.options.firstDayOfWeek;\n    }\n  }, {\n    key: \"showAllDayPanel\",\n    get: function get() {\n      return this.options.showAllDayPanel;\n    }\n  }, {\n    key: \"loadedResources\",\n    get: function get() {\n      return this._resolveOption(\"loadedResources\");\n    }\n  }, {\n    key: \"supportAllDayRow\",\n    get: function get() {\n      return this._resolveOption(\"supportAllDayRow\");\n    }\n  }, {\n    key: \"viewType\",\n    get: function get() {\n      return this._resolveOption(\"viewType\");\n    }\n  }, {\n    key: \"viewDirection\",\n    get: function get() {\n      return this._resolveOption(\"viewDirection\");\n    }\n  }, {\n    key: \"dateRange\",\n    get: function get() {\n      return this._resolveOption(\"dateRange\");\n    }\n  }, {\n    key: \"groupCount\",\n    get: function get() {\n      return this._resolveOption(\"groupCount\");\n    }\n  }, {\n    key: \"viewDataProvider\",\n    get: function get() {\n      return this._resolveOption(\"viewDataProvider\");\n    }\n  }, {\n    key: \"_resolveOption\",\n    value: function _resolveOption(name) {\n      var result = this.options[name];\n      return \"function\" === typeof result ? result() : result;\n    }\n  }, {\n    key: \"_init\",\n    value: function _init() {\n      this.setDataAccessors(this.dataAccessors);\n      this.setDataSource(this.dataSource);\n    }\n  }, {\n    key: \"filter\",\n    value: function filter(preparedItems) {\n      var dateRange = this.dateRange;\n      var allDay;\n\n      if (!this.showAllDayPanel && this.supportAllDayRow) {\n        allDay = false;\n      }\n\n      return this.filterLoadedAppointments({\n        startDayHour: this.viewStartDayHour,\n        endDayHour: this.viewEndDayHour,\n        viewStartDayHour: this.viewStartDayHour,\n        viewEndDayHour: this.viewEndDayHour,\n        min: dateRange[0],\n        max: dateRange[1],\n        resources: this.loadedResources,\n        allDay: allDay,\n        supportMultiDayAppointments: isSupportMultiDayAppointments(this.viewType),\n        firstDayOfWeek: this.firstDayOfWeek\n      }, preparedItems);\n    }\n  }, {\n    key: \"filterByDate\",\n    value: function filterByDate(min, max, remoteFiltering, dateSerializationFormat) {\n      if (!this.dataSource) {\n        return;\n      }\n\n      var _getTrimDates = getTrimDates(min, max),\n          _getTrimDates2 = _slicedToArray(_getTrimDates, 2),\n          trimMin = _getTrimDates2[0],\n          trimMax = _getTrimDates2[1];\n\n      if (!this.filterMaker.isRegistered()) {\n        this._createFilter(trimMin, trimMax, remoteFiltering, dateSerializationFormat);\n      } else {\n        var _this$dataSource$filt;\n\n        if ((null === (_this$dataSource$filt = this.dataSource.filter()) || void 0 === _this$dataSource$filt ? void 0 : _this$dataSource$filt.length) > 1) {\n          var userFilter = this._serializeRemoteFilter([this.dataSource.filter()[1]], dateSerializationFormat);\n\n          this.filterMaker.make(\"user\", userFilter);\n        }\n\n        if (remoteFiltering) {\n          this.filterMaker.make(\"date\", [trimMin, trimMax]);\n          this.dataSource.filter(this._combineRemoteFilter(dateSerializationFormat));\n        }\n      }\n    }\n  }, {\n    key: \"hasAllDayAppointments\",\n    value: function hasAllDayAppointments(filteredItems, preparedItems) {\n      var _this2 = this;\n\n      var adapters = filteredItems.map(function (item) {\n        return createAppointmentAdapter(item, _this2.dataAccessors, _this2.timeZoneCalculator);\n      });\n      var result = false;\n      each(adapters, function (_, item) {\n        if (getAppointmentTakesAllDay(item, _this2.viewStartDayHour, _this2.viewEndDayHour)) {\n          result = true;\n          return false;\n        }\n      });\n      return result;\n    }\n  }, {\n    key: \"setDataAccessors\",\n    value: function setDataAccessors(dataAccessors) {\n      this.dataAccessors = dataAccessors;\n      this.filterMaker = new FilterMaker(this.dataAccessors);\n    }\n  }, {\n    key: \"setDataSource\",\n    value: function setDataSource(dataSource) {\n      var _this$filterMaker;\n\n      this.dataSource = dataSource;\n      null === (_this$filterMaker = this.filterMaker) || void 0 === _this$filterMaker ? void 0 : _this$filterMaker.clearRegistry();\n    }\n  }, {\n    key: \"_createAllDayAppointmentFilter\",\n    value: function _createAllDayAppointmentFilter(filterOptions) {\n      var viewStartDayHour = filterOptions.viewStartDayHour,\n          viewEndDayHour = filterOptions.viewEndDayHour;\n      return [[function (appointment) {\n        return getAppointmentTakesAllDay(appointment, viewStartDayHour, viewEndDayHour);\n      }]];\n    }\n  }, {\n    key: \"_createCombinedFilter\",\n    value: function _createCombinedFilter(filterOptions) {\n      var _this3 = this;\n\n      var min = new Date(filterOptions.min);\n      var max = new Date(filterOptions.max);\n      var startDayHour = filterOptions.startDayHour,\n          endDayHour = filterOptions.endDayHour,\n          viewStartDayHour = filterOptions.viewStartDayHour,\n          viewEndDayHour = filterOptions.viewEndDayHour,\n          resources = filterOptions.resources,\n          firstDayOfWeek = filterOptions.firstDayOfWeek,\n          checkIntersectViewport = filterOptions.checkIntersectViewport,\n          supportMultiDayAppointments = filterOptions.supportMultiDayAppointments;\n\n      var _getTrimDates3 = getTrimDates(min, max),\n          _getTrimDates4 = _slicedToArray(_getTrimDates3, 2),\n          trimMin = _getTrimDates4[0],\n          trimMax = _getTrimDates4[1];\n\n      var useRecurrence = isDefined(this.dataAccessors.getter.recurrenceRule);\n      return [[function (appointment) {\n        var _appointment$visible;\n\n        var appointmentVisible = null !== (_appointment$visible = appointment.visible) && void 0 !== _appointment$visible ? _appointment$visible : true;\n\n        if (!appointmentVisible) {\n          return false;\n        }\n\n        var startDate = appointment.startDate,\n            endDate = appointment.endDate,\n            hasRecurrenceRule = appointment.hasRecurrenceRule;\n\n        if (!hasRecurrenceRule) {\n          if (!(endDate >= trimMin && startDate < trimMax || dateUtils.sameDate(endDate, trimMin) && dateUtils.sameDate(startDate, trimMin))) {\n            return false;\n          }\n        }\n\n        var recurrenceRule;\n\n        if (useRecurrence) {\n          recurrenceRule = appointment.recurrenceRule;\n        }\n\n        var appointmentTakesAllDay = getAppointmentTakesAllDay(appointment, viewStartDayHour, viewEndDayHour);\n        var appointmentTakesSeveralDays = getAppointmentTakesSeveralDays(appointment);\n        var isAllDay = appointment.allDay;\n        var isLongAppointment = appointmentTakesSeveralDays || appointmentTakesAllDay;\n\n        if (null !== resources && void 0 !== resources && resources.length && !_this3._filterAppointmentByResources(appointment.rawAppointment, resources)) {\n          return false;\n        }\n\n        if (appointmentTakesAllDay && false === filterOptions.allDay) {\n          return false;\n        }\n\n        if (hasRecurrenceRule) {\n          var recurrenceException = getRecurrenceException(appointment, _this3.timeZoneCalculator, _this3.timezone);\n\n          if (!_this3._filterAppointmentByRRule({\n            startDate: startDate,\n            endDate: endDate,\n            recurrenceRule: recurrenceRule,\n            recurrenceException: recurrenceException,\n            allDay: appointmentTakesAllDay\n          }, min, max, startDayHour, endDayHour, firstDayOfWeek)) {\n            return false;\n          }\n        }\n\n        if (!isAllDay && supportMultiDayAppointments && isLongAppointment) {\n          if (endDate < min && (!useRecurrence || useRecurrence && !hasRecurrenceRule)) {\n            return false;\n          }\n        }\n\n        if (isDefined(startDayHour) && (!useRecurrence || !filterOptions.isVirtualScrolling)) {\n          if (!compareDateWithStartDayHour(startDate, endDate, startDayHour, appointmentTakesAllDay, appointmentTakesSeveralDays)) {\n            return false;\n          }\n        }\n\n        if (isDefined(endDayHour)) {\n          if (!compareDateWithEndDayHour({\n            startDate: startDate,\n            endDate: endDate,\n            startDayHour: startDayHour,\n            endDayHour: endDayHour,\n            viewStartDayHour: viewStartDayHour,\n            viewEndDayHour: viewEndDayHour,\n            allDay: appointmentTakesAllDay,\n            severalDays: appointmentTakesSeveralDays,\n            min: min,\n            max: max,\n            checkIntersectViewport: checkIntersectViewport\n          })) {\n            return false;\n          }\n        }\n\n        if (!isAllDay && (!isLongAppointment || supportMultiDayAppointments)) {\n          if (endDate < min && useRecurrence && !hasRecurrenceRule) {\n            return false;\n          }\n        }\n\n        return true;\n      }]];\n    }\n  }, {\n    key: \"_createAppointmentFilter\",\n    value: function _createAppointmentFilter(filterOptions) {\n      if (this.filterMaker.isRegistered()) {\n        this.filterMaker.make(\"user\", void 0);\n      }\n\n      return this._createCombinedFilter(filterOptions);\n    }\n  }, {\n    key: \"_excessFiltering\",\n    value: function _excessFiltering() {\n      var dateFilter = this.filterMaker.dateFilter();\n      var dataSourceFilter = this.dataSource.filter();\n      return dateFilter && dataSourceFilter && (equalByValue(dataSourceFilter, dateFilter) || dataSourceFilter.length && equalByValue(dataSourceFilter[DATE_FILTER_POSITION], dateFilter));\n    }\n  }, {\n    key: \"_combineRemoteFilter\",\n    value: function _combineRemoteFilter(dateSerializationFormat) {\n      var combinedFilter = this.filterMaker.combine();\n      return this._serializeRemoteFilter(combinedFilter, dateSerializationFormat);\n    }\n  }, {\n    key: \"_serializeRemoteFilter\",\n    value: function _serializeRemoteFilter(filter, dateSerializationFormat) {\n      if (!Array.isArray(filter)) {\n        return filter;\n      }\n\n      filter = extend([], filter);\n      var startDate = this.dataAccessors.expr.startDateExpr;\n      var endDate = this.dataAccessors.expr.endDateExpr;\n\n      if (isString(filter[0])) {\n        if (config().forceIsoDateParsing && filter.length > 1) {\n          if (filter[0] === startDate || filter[0] === endDate) {\n            filter[filter.length - 1] = dateSerialization.serializeDate(new Date(filter[filter.length - 1]), dateSerializationFormat);\n          }\n        }\n      }\n\n      for (var i = 0; i < filter.length; i++) {\n        filter[i] = this._serializeRemoteFilter(filter[i], dateSerializationFormat);\n      }\n\n      return filter;\n    }\n  }, {\n    key: \"_createFilter\",\n    value: function _createFilter(min, max, remoteFiltering, dateSerializationFormat) {\n      if (remoteFiltering) {\n        this.filterMaker.make(\"date\", [min, max]);\n        var userFilterPosition = this._excessFiltering() ? this.dataSource.filter()[USER_FILTER_POSITION] : this.dataSource.filter();\n        this.filterMaker.make(\"user\", [userFilterPosition]);\n        this.dataSource.filter(this._combineRemoteFilter(dateSerializationFormat));\n      }\n    }\n  }, {\n    key: \"_filterAppointmentByResources\",\n    value: function _filterAppointmentByResources(appointment, resources) {\n      var _this4 = this;\n\n      var checkAppointmentResourceValues = function checkAppointmentResourceValues(resourceName, resourceIndex) {\n        var resourceGetter = _this4.dataAccessors.resources.getter[resourceName];\n        var resource;\n\n        if (isFunction(resourceGetter)) {\n          resource = resourceGetter(appointment);\n        }\n\n        var appointmentResourceValues = wrapToArray(resource);\n        var resourceData = map(resources[resourceIndex].items, function (item) {\n          return item.id;\n        });\n\n        for (var j = 0; j < appointmentResourceValues.length; j++) {\n          if (inArray(appointmentResourceValues[j], resourceData) > -1) {\n            return true;\n          }\n        }\n\n        return false;\n      };\n\n      var result = false;\n\n      for (var i = 0; i < resources.length; i++) {\n        var resourceName = resources[i].name;\n        result = checkAppointmentResourceValues(resourceName, i);\n\n        if (!result) {\n          return false;\n        }\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_filterAppointmentByRRule\",\n    value: function _filterAppointmentByRRule(appointment, min, max, startDayHour, endDayHour, firstDayOfWeek) {\n      var recurrenceRule = appointment.recurrenceRule;\n      var recurrenceException = appointment.recurrenceException;\n      var allDay = appointment.allDay;\n      var result = true;\n      var appointmentStartDate = appointment.startDate;\n      var appointmentEndDate = appointment.endDate;\n      var recurrenceProcessor = getRecurrenceProcessor();\n\n      if (allDay || _appointmentPartInInterval(appointmentStartDate, appointmentEndDate, startDayHour, endDayHour)) {\n        var _getTrimDates5 = getTrimDates(min, max),\n            _getTrimDates6 = _slicedToArray(_getTrimDates5, 2),\n            trimMin = _getTrimDates6[0],\n            trimMax = _getTrimDates6[1];\n\n        min = trimMin;\n        max = new Date(trimMax.getTime() - toMs(\"minute\"));\n      }\n\n      if (recurrenceRule && !recurrenceProcessor.isValidRecurrenceRule(recurrenceRule)) {\n        result = appointmentEndDate > min && appointmentStartDate <= max;\n      }\n\n      if (result && recurrenceProcessor.isValidRecurrenceRule(recurrenceRule)) {\n        result = recurrenceProcessor.hasRecurrence({\n          rule: recurrenceRule,\n          exception: recurrenceException,\n          start: appointmentStartDate,\n          end: appointmentEndDate,\n          min: min,\n          max: max,\n          firstDayOfWeek: firstDayOfWeek\n        });\n      }\n\n      return result;\n    }\n  }, {\n    key: \"filterLoadedAppointments\",\n    value: function filterLoadedAppointments(filterOptions, preparedItems) {\n      var filteredItems = this.filterPreparedItems(filterOptions, preparedItems);\n      return filteredItems.map(function (_ref) {\n        var rawAppointment = _ref.rawAppointment;\n        return rawAppointment;\n      });\n    }\n  }, {\n    key: \"filterPreparedItems\",\n    value: function filterPreparedItems(filterOptions, preparedItems) {\n      var combinedFilter = this._createAppointmentFilter(filterOptions);\n\n      return query(preparedItems).filter(combinedFilter).toArray();\n    }\n  }, {\n    key: \"filterAllDayAppointments\",\n    value: function filterAllDayAppointments(filterOptions, preparedItems) {\n      var combinedFilter = this._createAllDayAppointmentFilter(filterOptions);\n\n      return query(preparedItems).filter(combinedFilter).toArray().map(function (_ref2) {\n        var rawAppointment = _ref2.rawAppointment;\n        return rawAppointment;\n      });\n    }\n  }]);\n\n  return AppointmentFilterBaseStrategy;\n}();\nexport var AppointmentFilterVirtualStrategy = /*#__PURE__*/function (_AppointmentFilterBas) {\n  _inherits(AppointmentFilterVirtualStrategy, _AppointmentFilterBas);\n\n  var _super = _createSuper(AppointmentFilterVirtualStrategy);\n\n  function AppointmentFilterVirtualStrategy() {\n    _classCallCheck(this, AppointmentFilterVirtualStrategy);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(AppointmentFilterVirtualStrategy, [{\n    key: \"strategyName\",\n    get: function get() {\n      return FilterStrategies.virtual;\n    }\n  }, {\n    key: \"resources\",\n    get: function get() {\n      return this.options.resources;\n    }\n  }, {\n    key: \"filter\",\n    value: function filter(preparedItems) {\n      var _this5 = this;\n\n      var hourMs = toMs(\"hour\");\n      var isCalculateStartAndEndDayHour = calculateIsDateAndTimeView(this.viewType);\n      var checkIntersectViewport = isCalculateStartAndEndDayHour && \"horizontal\" === this.viewDirection;\n      var isAllDayWorkspace = !this.supportAllDayRow;\n      var showAllDayAppointments = this.showAllDayPanel || isAllDayWorkspace;\n      var endViewDate = this.viewDataProvider.getLastViewDateByEndDayHour(this.viewEndDayHour);\n      var filterOptions = [];\n      var groupsInfo = this.viewDataProvider.getCompletedGroupsInfo();\n      groupsInfo.forEach(function (item) {\n        var groupIndex = item.groupIndex;\n        var groupStartDate = item.startDate;\n        var groupEndDate = new Date(Math.min(item.endDate, endViewDate));\n        var startDayHour = isCalculateStartAndEndDayHour ? groupStartDate.getHours() : _this5.viewStartDayHour;\n        var endDayHour = isCalculateStartAndEndDayHour ? startDayHour + groupStartDate.getMinutes() / 60 + (groupEndDate - groupStartDate) / hourMs : _this5.viewEndDayHour;\n\n        var resources = _this5._getPrerenderFilterResources(groupIndex);\n\n        var allDayPanel = _this5.viewDataProvider.getAllDayPanel(groupIndex);\n\n        var supportAllDayAppointment = isAllDayWorkspace || !!showAllDayAppointments && (null === allDayPanel || void 0 === allDayPanel ? void 0 : allDayPanel.length) > 0;\n        filterOptions.push({\n          isVirtualScrolling: true,\n          startDayHour: startDayHour,\n          endDayHour: endDayHour,\n          viewStartDayHour: _this5.viewStartDayHour,\n          viewEndDayHour: _this5.viewEndDayHour,\n          min: groupStartDate,\n          max: groupEndDate,\n          supportMultiDayAppointments: isSupportMultiDayAppointments(_this5.viewType),\n          allDay: supportAllDayAppointment,\n          resources: resources,\n          firstDayOfWeek: _this5.firstDayOfWeek,\n          checkIntersectViewport: checkIntersectViewport\n        });\n      });\n      return this.filterLoadedAppointments({\n        filterOptions: filterOptions,\n        groupCount: this.groupCount\n      }, preparedItems);\n    }\n  }, {\n    key: \"filterPreparedItems\",\n    value: function filterPreparedItems(_ref3, preparedItems) {\n      var _this6 = this;\n\n      var filterOptions = _ref3.filterOptions,\n          groupCount = _ref3.groupCount;\n      var combinedFilters = [];\n      var itemsToFilter = preparedItems;\n      var needPreFilter = groupCount > 0;\n\n      if (needPreFilter) {\n        itemsToFilter = itemsToFilter.filter(function (_ref4) {\n          var rawAppointment = _ref4.rawAppointment;\n\n          for (var i = 0; i < filterOptions.length; ++i) {\n            var resources = filterOptions[i].resources;\n\n            if (_this6._filterAppointmentByResources(rawAppointment, resources)) {\n              return true;\n            }\n          }\n        });\n      }\n\n      filterOptions.forEach(function (option) {\n        combinedFilters.length && combinedFilters.push(\"or\");\n\n        var filter = _this6._createAppointmentFilter(option);\n\n        combinedFilters.push(filter);\n      });\n      return query(itemsToFilter).filter(combinedFilters).toArray();\n    }\n  }, {\n    key: \"hasAllDayAppointments\",\n    value: function hasAllDayAppointments(adapters, preparedItems) {\n      return this.filterAllDayAppointments({\n        viewStartDayHour: this.viewStartDayHour,\n        viewEndDayHour: this.viewEndDayHour\n      }, preparedItems).length > 0;\n    }\n  }, {\n    key: \"_getPrerenderFilterResources\",\n    value: function _getPrerenderFilterResources(groupIndex) {\n      var cellGroup = this.viewDataProvider.getCellsGroup(groupIndex);\n      return getResourcesDataByGroups(this.loadedResources, this.resources, [cellGroup]);\n    }\n  }]);\n\n  return AppointmentFilterVirtualStrategy;\n}(AppointmentFilterBaseStrategy);","map":null,"metadata":{},"sourceType":"module"}