{"ast":null,"code":"import _classCallCheck from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\n\n/**\r\n * DevExtreme (esm/ui/scheduler/appointments/rendering_strategies/strategy_agenda.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport dateUtils from \"../../../../core/utils/date\";\nimport { each } from \"../../../../core/utils/iterator\";\nimport { merge } from \"../../../../core/utils/array\";\nimport BaseRenderingStrategy from \"./strategy.base\";\nimport { ExpressionUtils } from \"../../expressionUtils\";\nimport { groupAppointmentsByResources } from \"../../resources/utils\";\nimport { createAppointmentAdapter } from \"../../appointmentAdapter\";\nimport { replaceWrongEndDate, getAppointmentTakesSeveralDays } from \"../dataProvider/utils\";\n\nvar AgendaRenderingStrategy = /*#__PURE__*/function (_BaseRenderingStrateg) {\n  _inherits(AgendaRenderingStrategy, _BaseRenderingStrateg);\n\n  var _super = _createSuper(AgendaRenderingStrategy);\n\n  function AgendaRenderingStrategy() {\n    _classCallCheck(this, AgendaRenderingStrategy);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(AgendaRenderingStrategy, [{\n    key: \"instance\",\n    get: function get() {\n      return this.options.instance;\n    }\n  }, {\n    key: \"agendaDuration\",\n    get: function get() {\n      return this.options.agendaDuration;\n    }\n  }, {\n    key: \"getAppointmentMinSize\",\n    value: function getAppointmentMinSize() {}\n  }, {\n    key: \"getDeltaTime\",\n    value: function getDeltaTime() {}\n  }, {\n    key: \"keepAppointmentSettings\",\n    value: function keepAppointmentSettings() {\n      return true;\n    }\n  }, {\n    key: \"getAppointmentGeometry\",\n    value: function getAppointmentGeometry(geometry) {\n      return geometry;\n    }\n  }, {\n    key: \"groupAppointmentByResources\",\n    value: function groupAppointmentByResources(appointments) {\n      var groups = this.instance._getCurrentViewOption(\"groups\");\n\n      var config = {\n        loadedResources: this.options.loadedResources,\n        resources: this.options.resources,\n        dataAccessors: this.dataAccessors.resources\n      };\n      return groupAppointmentsByResources(config, appointments, groups);\n    }\n  }, {\n    key: \"createTaskPositionMap\",\n    value: function createTaskPositionMap(appointments) {\n      var height;\n      var appointmentsByResources;\n      this.calculateRows(appointments, this.agendaDuration, this.currentDate);\n\n      if (appointments.length) {\n        height = this.instance.fire(\"getAgendaVerticalStepHeight\");\n        appointmentsByResources = this.groupAppointmentByResources(appointments);\n        var groupedAppts = [];\n        each(appointmentsByResources, function (i, appts) {\n          var additionalAppointments = [];\n          var recurrentIndexes = [];\n          each(appts, function (index, appointment) {\n            var recurrenceBatch = this.instance.getAppointmentsInstance()._processRecurrenceAppointment(appointment, index);\n\n            var appointmentBatch = null;\n\n            if (!recurrenceBatch.indexes.length) {\n              appointmentBatch = {\n                parts: []\n              };\n              appointmentBatch = this.instance.getAppointmentsInstance()._processLongAppointment(appointment);\n              additionalAppointments = additionalAppointments.concat(appointmentBatch.parts);\n            }\n\n            additionalAppointments = additionalAppointments.concat(recurrenceBatch.parts);\n            recurrentIndexes = recurrentIndexes.concat(recurrenceBatch.indexes);\n          }.bind(this));\n\n          this.instance.getAppointmentsInstance()._reduceRecurrenceAppointments(recurrentIndexes, appts);\n\n          this.instance.getAppointmentsInstance()._combineAppointments(appts, additionalAppointments);\n\n          groupedAppts = groupedAppts.concat(appts);\n        }.bind(this));\n        Array.prototype.splice.apply(appointments, [0, appointments.length].concat(groupedAppts));\n      }\n\n      var result = [];\n      var sortedIndex = 0;\n      appointments.forEach(function (appt, index) {\n        result.push([{\n          height: height,\n          width: \"100%\",\n          sortedIndex: sortedIndex++,\n          groupIndex: this._calculateGroupIndex(index, appointmentsByResources),\n          agendaSettings: appt.settings\n        }]);\n        delete appt.settings;\n      }.bind(this));\n      return result;\n    }\n  }, {\n    key: \"_calculateGroupIndex\",\n    value: function _calculateGroupIndex(apptIndex, appointmentsByResources) {\n      var resultInd;\n      var counter = 0;\n\n      for (var i in appointmentsByResources) {\n        var countApptInGroup = appointmentsByResources[i].length;\n\n        if (apptIndex >= counter && apptIndex < counter + countApptInGroup) {\n          resultInd = Number(i);\n          break;\n        }\n\n        counter += countApptInGroup;\n      }\n\n      return resultInd;\n    }\n  }, {\n    key: \"_getDeltaWidth\",\n    value: function _getDeltaWidth() {}\n  }, {\n    key: \"_getAppointmentMaxWidth\",\n    value: function _getAppointmentMaxWidth() {\n      return this.cellWidth;\n    }\n  }, {\n    key: \"_needVerifyItemSize\",\n    value: function _needVerifyItemSize() {\n      return false;\n    }\n  }, {\n    key: \"_getAppointmentParts\",\n    value: function _getAppointmentParts() {}\n  }, {\n    key: \"_reduceMultiWeekAppointment\",\n    value: function _reduceMultiWeekAppointment() {}\n  }, {\n    key: \"calculateAppointmentHeight\",\n    value: function calculateAppointmentHeight() {\n      return 0;\n    }\n  }, {\n    key: \"calculateAppointmentWidth\",\n    value: function calculateAppointmentWidth() {\n      return 0;\n    }\n  }, {\n    key: \"isAppointmentGreaterThan\",\n    value: function isAppointmentGreaterThan() {}\n  }, {\n    key: \"isAllDay\",\n    value: function isAllDay() {\n      return false;\n    }\n  }, {\n    key: \"_sortCondition\",\n    value: function _sortCondition() {}\n  }, {\n    key: \"_rowCondition\",\n    value: function _rowCondition() {}\n  }, {\n    key: \"_columnCondition\",\n    value: function _columnCondition() {}\n  }, {\n    key: \"_findIndexByKey\",\n    value: function _findIndexByKey() {}\n  }, {\n    key: \"_markAppointmentAsVirtual\",\n    value: function _markAppointmentAsVirtual() {}\n  }, {\n    key: \"getDropDownAppointmentWidth\",\n    value: function getDropDownAppointmentWidth() {}\n  }, {\n    key: \"getCollectorLeftOffset\",\n    value: function getCollectorLeftOffset() {}\n  }, {\n    key: \"getCollectorTopOffset\",\n    value: function getCollectorTopOffset() {}\n  }, {\n    key: \"replaceWrongAppointmentEndDate\",\n    value: function replaceWrongAppointmentEndDate(rawAppointment, startDate, endDate) {\n      var adapter = createAppointmentAdapter(rawAppointment, this.dataAccessors, this.timeZoneCalculator);\n      replaceWrongEndDate(adapter, startDate, endDate, this.cellDuration, this.dataAccessors);\n    }\n  }, {\n    key: \"calculateRows\",\n    value: function calculateRows(appointments, agendaDuration, currentDate, needClearSettings) {\n      this._rows = [];\n      currentDate = dateUtils.trimTime(new Date(currentDate));\n      var groupedAppointments = this.groupAppointmentByResources(appointments);\n      each(groupedAppointments, function (_, currentAppointments) {\n        var groupResult = [];\n        var appts = {\n          indexes: [],\n          parts: []\n        };\n\n        if (!currentAppointments.length) {\n          this._rows.push([]);\n\n          return true;\n        }\n\n        each(currentAppointments, function (index, appointment) {\n          var startDate = ExpressionUtils.getField(this.dataAccessors, \"startDate\", appointment);\n          var endDate = ExpressionUtils.getField(this.dataAccessors, \"endDate\", appointment);\n          this.replaceWrongAppointmentEndDate(appointment, startDate, endDate);\n          needClearSettings && delete appointment.settings;\n\n          var result = this.instance.getAppointmentsInstance()._processRecurrenceAppointment(appointment, index, false);\n\n          appts.parts = appts.parts.concat(result.parts);\n          appts.indexes = appts.indexes.concat(result.indexes);\n        }.bind(this));\n\n        this.instance.getAppointmentsInstance()._reduceRecurrenceAppointments(appts.indexes, currentAppointments);\n\n        merge(currentAppointments, appts.parts);\n        var appointmentCount = currentAppointments.length;\n\n        for (var i = 0; i < agendaDuration; i++) {\n          var day = new Date(currentDate);\n          day.setMilliseconds(day.getMilliseconds() + 864e5 * i);\n\n          if (void 0 === groupResult[i]) {\n            groupResult[i] = 0;\n          }\n\n          for (var j = 0; j < appointmentCount; j++) {\n            var appointmentData = currentAppointments[j].settings || currentAppointments[j];\n            var adapter = createAppointmentAdapter(currentAppointments[j], this.dataAccessors, this.timeZoneCalculator);\n            var appointmentIsLong = getAppointmentTakesSeveralDays(adapter);\n            var appointmentIsRecurrence = ExpressionUtils.getField(this.dataAccessors, \"recurrenceRule\", currentAppointments[j]);\n\n            if (this.instance.fire(\"dayHasAppointment\", day, appointmentData, true) || !appointmentIsRecurrence && appointmentIsLong && this.instance.fire(\"dayHasAppointment\", day, currentAppointments[j], true)) {\n              groupResult[i] += 1;\n            }\n          }\n        }\n\n        this._rows.push(groupResult);\n      }.bind(this));\n      return this._rows;\n    }\n  }, {\n    key: \"_iterateRow\",\n    value: function _iterateRow(row, obj, index) {\n      for (var i = 0; i < row.length; i++) {\n        obj.counter = obj.counter + row[i];\n\n        if (obj.counter >= index) {\n          obj.indexInRow = i;\n          break;\n        }\n      }\n    }\n  }, {\n    key: \"getDateByIndex\",\n    value: function getDateByIndex(index, rows, startViewDate) {\n      var obj = {\n        counter: 0,\n        indexInRow: 0\n      };\n      index++;\n\n      for (var i = 0; i < rows.length; i++) {\n        this._iterateRow(rows[i], obj, index);\n\n        if (obj.indexInRow) {\n          break;\n        }\n      }\n\n      return new Date(new Date(startViewDate).setDate(startViewDate.getDate() + obj.indexInRow));\n    }\n  }, {\n    key: \"getAppointmentDataCalculator\",\n    value: function getAppointmentDataCalculator() {\n      return function ($appointment, originalStartDate) {\n        var apptIndex = $appointment.index();\n        var startViewDate = this.instance.getStartViewDate();\n        var calculatedStartDate = this.getDateByIndex(apptIndex, this._rows, startViewDate);\n        var wrappedOriginalStartDate = new Date(originalStartDate);\n        return {\n          startDate: new Date(calculatedStartDate.setHours(wrappedOriginalStartDate.getHours(), wrappedOriginalStartDate.getMinutes(), wrappedOriginalStartDate.getSeconds(), wrappedOriginalStartDate.getMilliseconds()))\n        };\n      }.bind(this);\n    }\n  }]);\n\n  return AgendaRenderingStrategy;\n}(BaseRenderingStrategy);\n\nexport default AgendaRenderingStrategy;","map":null,"metadata":{},"sourceType":"module"}