{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/toolbar/ui.toolbar.base.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { getWidth, getOuterWidth, getHeight } from \"../../core/utils/size\";\nimport $ from \"../../core/renderer\";\nimport { isMaterial, waitWebFont } from \"../themes\";\nimport { noop } from \"../../core/utils/common\";\nimport { isPlainObject, isDefined } from \"../../core/utils/type\";\nimport registerComponent from \"../../core/component_registrator\";\nimport { inArray } from \"../../core/utils/array\";\nimport { extend } from \"../../core/utils/extend\";\nimport { each } from \"../../core/utils/iterator\";\nimport { getBoundingRect } from \"../../core/utils/position\";\nimport AsyncCollectionWidget from \"../collection/ui.collection_widget.async\";\nimport Promise from \"../../core/polyfills/promise\";\nimport { BindableTemplate } from \"../../core/templates/bindable_template\";\nimport errors from \"../../core/errors\";\nimport fx from \"../../animation/fx\";\nimport { TOOLBAR_CLASS } from \"./constants\";\nvar TOOLBAR_BEFORE_CLASS = \"dx-toolbar-before\";\nvar TOOLBAR_CENTER_CLASS = \"dx-toolbar-center\";\nvar TOOLBAR_AFTER_CLASS = \"dx-toolbar-after\";\nvar TOOLBAR_MINI_CLASS = \"dx-toolbar-mini\";\nvar TOOLBAR_ITEM_CLASS = \"dx-toolbar-item\";\nvar TOOLBAR_LABEL_CLASS = \"dx-toolbar-label\";\nvar TOOLBAR_BUTTON_CLASS = \"dx-toolbar-button\";\nvar TOOLBAR_ITEMS_CONTAINER_CLASS = \"dx-toolbar-items-container\";\nvar TOOLBAR_GROUP_CLASS = \"dx-toolbar-group\";\nvar TOOLBAR_COMPACT_CLASS = \"dx-toolbar-compact\";\nvar TOOLBAR_LABEL_SELECTOR = \".\" + TOOLBAR_LABEL_CLASS;\nvar TOOLBAR_MULTILINE_CLASS = \"dx-toolbar-multiline\";\nvar TEXT_BUTTON_MODE = \"text\";\nvar DEFAULT_BUTTON_TYPE = \"default\";\nvar DEFAULT_DROPDOWNBUTTON_STYLING_MODE = \"contained\";\nvar TOOLBAR_ITEM_DATA_KEY = \"dxToolbarItemDataKey\";\nvar ToolbarBase = AsyncCollectionWidget.inherit({\n  compactMode: false,\n  ctor: function ctor(element, options) {\n    this._userOptions = options || {};\n    this.callBase(element, options);\n\n    if (\"height\" in this._userOptions) {\n      errors.log(\"W0001\", this.NAME, \"height\", \"20.1\", \"Functionality associated with this option is not intended for the Toolbar widget.\");\n    }\n  },\n  _getSynchronizableOptionsForCreateComponent: function _getSynchronizableOptionsForCreateComponent() {\n    return this.callBase().filter(function (item) {\n      return \"disabled\" !== item;\n    });\n  },\n  _initTemplates: function _initTemplates() {\n    this.callBase();\n    var template = new BindableTemplate(function ($container, data, rawModel) {\n      if (isPlainObject(data)) {\n        if (data.text) {\n          $container.text(data.text).wrapInner(\"<div>\");\n        }\n\n        if (data.html) {\n          $container.html(data.html);\n        }\n\n        if (\"dxDropDownButton\" === data.widget) {\n          data.options = data.options || {};\n\n          if (!isDefined(data.options.stylingMode)) {\n            data.options.stylingMode = this.option(\"useFlatButtons\") ? TEXT_BUTTON_MODE : DEFAULT_DROPDOWNBUTTON_STYLING_MODE;\n          }\n        }\n\n        if (\"dxButton\" === data.widget) {\n          if (this.option(\"useFlatButtons\")) {\n            data.options = data.options || {};\n            data.options.stylingMode = data.options.stylingMode || TEXT_BUTTON_MODE;\n          }\n\n          if (this.option(\"useDefaultButtons\")) {\n            data.options = data.options || {};\n            data.options.type = data.options.type || DEFAULT_BUTTON_TYPE;\n          }\n        }\n      } else {\n        $container.text(String(data));\n      }\n\n      this._getTemplate(\"dx-polymorph-widget\").render({\n        container: $container,\n        model: rawModel,\n        parent: this\n      });\n    }.bind(this), [\"text\", \"html\", \"widget\", \"options\"], this.option(\"integrationOptions.watchMethod\"));\n\n    this._templateManager.addDefaultTemplates({\n      item: template,\n      menuItem: template\n    });\n  },\n  _getDefaultOptions: function _getDefaultOptions() {\n    return extend(this.callBase(), {\n      renderAs: \"topToolbar\",\n      grouped: false,\n      useFlatButtons: false,\n      useDefaultButtons: false,\n      multiline: false\n    });\n  },\n  _defaultOptionsRules: function _defaultOptionsRules() {\n    return this.callBase().concat([{\n      device: function device() {\n        return isMaterial();\n      },\n      options: {\n        useFlatButtons: true\n      }\n    }]);\n  },\n  _itemContainer: function _itemContainer() {\n    return this._$toolbarItemsContainer.find([\".\" + TOOLBAR_BEFORE_CLASS, \".\" + TOOLBAR_CENTER_CLASS, \".\" + TOOLBAR_AFTER_CLASS].join(\",\"));\n  },\n  _itemClass: function _itemClass() {\n    return TOOLBAR_ITEM_CLASS;\n  },\n  _itemDataKey: function _itemDataKey() {\n    return TOOLBAR_ITEM_DATA_KEY;\n  },\n  _buttonClass: function _buttonClass() {\n    return TOOLBAR_BUTTON_CLASS;\n  },\n  _dimensionChanged: function _dimensionChanged() {\n    this._arrangeItems();\n\n    this._applyCompactMode();\n  },\n  _initMarkup: function _initMarkup() {\n    this._renderToolbar();\n\n    this._renderSections();\n\n    this.callBase();\n    this.setAria(\"role\", \"toolbar\");\n  },\n  _waitParentAnimationFinished: function _waitParentAnimationFinished() {\n    var _this = this;\n\n    var $element = this.$element();\n    return new Promise(function (resolve) {\n      var runCheck = function runCheck() {\n        clearTimeout(_this._waitParentAnimationTimeout);\n        _this._waitParentAnimationTimeout = setTimeout(function () {\n          return function () {\n            var readyToResolve = true;\n            $element.parents().each(function (_, parent) {\n              if (fx.isAnimating($(parent))) {\n                readyToResolve = false;\n                return false;\n              }\n            });\n\n            if (readyToResolve) {\n              resolve();\n            }\n\n            return readyToResolve;\n          }() || runCheck();\n        }, 15);\n      };\n\n      runCheck();\n    });\n  },\n  _render: function _render() {\n    this.callBase();\n\n    this._renderItemsAsync();\n\n    if (isMaterial()) {\n      Promise.all([this._waitParentAnimationFinished(), this._checkWebFontForLabelsLoaded()]).then(this._dimensionChanged.bind(this));\n    }\n  },\n  _postProcessRenderItems: function _postProcessRenderItems() {\n    this._arrangeItems();\n  },\n  _renderToolbar: function _renderToolbar() {\n    this.$element().addClass(TOOLBAR_CLASS).toggleClass(TOOLBAR_MULTILINE_CLASS, this.option(\"multiline\"));\n    this._$toolbarItemsContainer = $(\"<div>\").addClass(TOOLBAR_ITEMS_CONTAINER_CLASS).appendTo(this.$element());\n  },\n  _renderSections: function _renderSections() {\n    var $container = this._$toolbarItemsContainer;\n    var that = this;\n    each([\"before\", \"center\", \"after\"], function () {\n      var sectionClass = \"dx-toolbar-\" + this;\n      var $section = $container.find(\".\" + sectionClass);\n\n      if (!$section.length) {\n        that[\"_$\" + this + \"Section\"] = $section = $(\"<div>\").addClass(sectionClass).appendTo($container);\n      }\n    });\n  },\n  _checkWebFontForLabelsLoaded: function _checkWebFontForLabelsLoaded() {\n    var $labels = this.$element().find(TOOLBAR_LABEL_SELECTOR);\n    var promises = [];\n    $labels.each(function (_, label) {\n      var text = $(label).text();\n      var fontWeight = $(label).css(\"fontWeight\");\n      promises.push(waitWebFont(text, fontWeight));\n    });\n    return Promise.all(promises);\n  },\n  _arrangeItems: function _arrangeItems(elementWidth) {\n    elementWidth = elementWidth || getWidth(this.$element());\n\n    this._$centerSection.css({\n      margin: \"0 auto\",\n      float: \"none\"\n    });\n\n    var beforeRect = getBoundingRect(this._$beforeSection.get(0));\n    var afterRect = getBoundingRect(this._$afterSection.get(0));\n\n    this._alignCenterSection(beforeRect, afterRect, elementWidth);\n\n    var $label = this._$toolbarItemsContainer.find(TOOLBAR_LABEL_SELECTOR).eq(0);\n\n    var $section = $label.parent();\n\n    if (!$label.length) {\n      return;\n    }\n\n    var labelOffset = beforeRect.width ? beforeRect.width : $label.position().left;\n    var widthBeforeSection = $section.hasClass(TOOLBAR_BEFORE_CLASS) ? 0 : labelOffset;\n    var widthAfterSection = $section.hasClass(TOOLBAR_AFTER_CLASS) ? 0 : afterRect.width;\n    var elemsAtSectionWidth = 0;\n    $section.children().not(TOOLBAR_LABEL_SELECTOR).each(function () {\n      elemsAtSectionWidth += getOuterWidth(this);\n    });\n    var freeSpace = elementWidth - elemsAtSectionWidth;\n    var sectionMaxWidth = Math.max(freeSpace - widthBeforeSection - widthAfterSection, 0);\n\n    if ($section.hasClass(TOOLBAR_BEFORE_CLASS)) {\n      this._alignSection(this._$beforeSection, sectionMaxWidth);\n    } else {\n      var labelPaddings = getOuterWidth($label) - getWidth($label);\n      $label.css(\"maxWidth\", sectionMaxWidth - labelPaddings);\n    }\n  },\n  _alignCenterSection: function _alignCenterSection(beforeRect, afterRect, elementWidth) {\n    this._alignSection(this._$centerSection, elementWidth - beforeRect.width - afterRect.width);\n\n    var isRTL = this.option(\"rtlEnabled\");\n    var leftRect = isRTL ? afterRect : beforeRect;\n    var rightRect = isRTL ? beforeRect : afterRect;\n    var centerRect = getBoundingRect(this._$centerSection.get(0));\n\n    if (leftRect.right > centerRect.left || centerRect.right > rightRect.left) {\n      this._$centerSection.css({\n        marginLeft: leftRect.width,\n        marginRight: rightRect.width,\n        float: leftRect.width > rightRect.width ? \"none\" : \"right\"\n      });\n    }\n  },\n  _alignSection: function _alignSection($section, maxWidth) {\n    var $labels = $section.find(TOOLBAR_LABEL_SELECTOR);\n    var labels = $labels.toArray();\n    maxWidth -= this._getCurrentLabelsPaddings(labels);\n\n    var currentWidth = this._getCurrentLabelsWidth(labels);\n\n    var difference = Math.abs(currentWidth - maxWidth);\n\n    if (maxWidth < currentWidth) {\n      labels = labels.reverse();\n\n      this._alignSectionLabels(labels, difference, false);\n    } else {\n      this._alignSectionLabels(labels, difference, true);\n    }\n  },\n  _alignSectionLabels: function _alignSectionLabels(labels, difference, expanding) {\n    var getRealLabelWidth = function getRealLabelWidth(label) {\n      return getBoundingRect(label).width;\n    };\n\n    for (var i = 0; i < labels.length; i++) {\n      var $label = $(labels[i]);\n      var currentLabelWidth = Math.ceil(getRealLabelWidth(labels[i]));\n      var labelMaxWidth = void 0;\n\n      if (expanding) {\n        $label.css(\"maxWidth\", \"inherit\");\n      }\n\n      var possibleLabelWidth = Math.ceil(expanding ? getRealLabelWidth(labels[i]) : currentLabelWidth);\n\n      if (possibleLabelWidth < difference) {\n        labelMaxWidth = expanding ? possibleLabelWidth : 0;\n        difference -= possibleLabelWidth;\n      } else {\n        labelMaxWidth = expanding ? currentLabelWidth + difference : currentLabelWidth - difference;\n        $label.css(\"maxWidth\", labelMaxWidth);\n        break;\n      }\n\n      $label.css(\"maxWidth\", labelMaxWidth);\n    }\n  },\n  _applyCompactMode: function _applyCompactMode() {\n    var $element = this.$element();\n    $element.removeClass(TOOLBAR_COMPACT_CLASS);\n\n    if (this.option(\"compactMode\") && this._getSummaryItemsWidth(this.itemElements(), true) > getWidth($element)) {\n      $element.addClass(TOOLBAR_COMPACT_CLASS);\n    }\n  },\n  _getCurrentLabelsWidth: function _getCurrentLabelsWidth(labels) {\n    var width = 0;\n    labels.forEach(function (label, index) {\n      width += getOuterWidth(label);\n    });\n    return width;\n  },\n  _getCurrentLabelsPaddings: function _getCurrentLabelsPaddings(labels) {\n    var padding = 0;\n    labels.forEach(function (label, index) {\n      padding += getOuterWidth(label) - getWidth(label);\n    });\n    return padding;\n  },\n  _renderItem: function _renderItem(index, item, itemContainer, $after) {\n    var location = item.location || \"center\";\n    var container = itemContainer || this[\"_$\" + location + \"Section\"];\n    var itemHasText = !!(item.text || item.html);\n    var itemElement = this.callBase(index, item, container, $after);\n    itemElement.toggleClass(this._buttonClass(), !itemHasText).toggleClass(TOOLBAR_LABEL_CLASS, itemHasText).addClass(item.cssClass);\n    return itemElement;\n  },\n  _renderGroupedItems: function _renderGroupedItems() {\n    var that = this;\n    each(this.option(\"items\"), function (groupIndex, group) {\n      var groupItems = group.items;\n      var $container = $(\"<div>\").addClass(TOOLBAR_GROUP_CLASS);\n      var location = group.location || \"center\";\n\n      if (!groupItems || !groupItems.length) {\n        return;\n      }\n\n      each(groupItems, function (itemIndex, item) {\n        that._renderItem(itemIndex, item, $container, null);\n      });\n\n      that._$toolbarItemsContainer.find(\".dx-toolbar-\" + location).append($container);\n    });\n  },\n  _renderItems: function _renderItems(items) {\n    var grouped = this.option(\"grouped\") && items.length && items[0].items;\n    grouped ? this._renderGroupedItems() : this.callBase(items);\n  },\n  _getToolbarItems: function _getToolbarItems() {\n    return this.option(\"items\") || [];\n  },\n  _renderContentImpl: function _renderContentImpl() {\n    var items = this._getToolbarItems();\n\n    this.$element().toggleClass(TOOLBAR_MINI_CLASS, 0 === items.length);\n\n    if (this._renderedItemsCount) {\n      this._renderItems(items.slice(this._renderedItemsCount));\n    } else {\n      this._renderItems(items);\n    }\n\n    this._applyCompactMode();\n  },\n  _renderEmptyMessage: noop,\n  _clean: function _clean() {\n    this._$toolbarItemsContainer.children().empty();\n\n    this.$element().empty();\n  },\n  _visibilityChanged: function _visibilityChanged(visible) {\n    if (visible) {\n      this._arrangeItems();\n    }\n  },\n  _isVisible: function _isVisible() {\n    return getWidth(this.$element()) > 0 && getHeight(this.$element()) > 0;\n  },\n  _getIndexByItem: function _getIndexByItem(item) {\n    return inArray(item, this._getToolbarItems());\n  },\n  _itemOptionChanged: function _itemOptionChanged(item, property, value) {\n    this.callBase.apply(this, [item, property, value]);\n\n    this._arrangeItems();\n  },\n  _optionChanged: function _optionChanged(args) {\n    var name = args.name;\n\n    switch (name) {\n      case \"width\":\n        this.callBase.apply(this, arguments);\n\n        this._dimensionChanged();\n\n        break;\n\n      case \"multiline\":\n        this.$element().toggleClass(TOOLBAR_MULTILINE_CLASS, args.value);\n        break;\n\n      case \"renderAs\":\n      case \"useFlatButtons\":\n      case \"useDefaultButtons\":\n        this._invalidate();\n\n        break;\n\n      case \"compactMode\":\n        this._applyCompactMode();\n\n        break;\n\n      case \"grouped\":\n        break;\n\n      default:\n        this.callBase.apply(this, arguments);\n    }\n  },\n  _dispose: function _dispose() {\n    this.callBase();\n    clearTimeout(this._waitParentAnimationTimeout);\n  }\n});\nregisterComponent(\"dxToolbarBase\", ToolbarBase);\nexport default ToolbarBase;","map":null,"metadata":{},"sourceType":"module"}