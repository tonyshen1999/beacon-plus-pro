{"ast":null,"code":"import _classCallCheck from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n\n/**\r\n * DevExtreme (esm/ui/scheduler/workspaces/view_model/grouped_data_map_provider.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport dateUtils from \"../../../../core/utils/date\";\nimport { isDateAndTimeView } from \"../../../../renovation/ui/scheduler/view_model/to_test/views/utils/base\";\nexport var GroupedDataMapProvider = /*#__PURE__*/function () {\n  function GroupedDataMapProvider(viewDataGenerator, viewDataMap, completeViewDataMap, viewOptions) {\n    _classCallCheck(this, GroupedDataMapProvider);\n\n    this.groupedDataMap = viewDataGenerator.generateGroupedDataMap(viewDataMap);\n    this.completeViewDataMap = completeViewDataMap;\n    this._viewOptions = viewOptions;\n  }\n\n  _createClass(GroupedDataMapProvider, [{\n    key: \"getGroupStartDate\",\n    value: function getGroupStartDate(groupIndex) {\n      var firstRow = this.getFirstGroupRow(groupIndex);\n\n      if (firstRow) {\n        var startDate = firstRow[0].cellData.startDate;\n        return startDate;\n      }\n    }\n  }, {\n    key: \"getGroupEndDate\",\n    value: function getGroupEndDate(groupIndex) {\n      var lastRow = this.getLastGroupRow(groupIndex);\n\n      if (lastRow) {\n        var lastColumnIndex = lastRow.length - 1;\n        var cellData = lastRow[lastColumnIndex].cellData;\n        var endDate = cellData.endDate;\n        return endDate;\n      }\n    }\n  }, {\n    key: \"findGroupCellStartDate\",\n    value: function findGroupCellStartDate(groupIndex, startDate, endDate, isAllDay, isFindByDate) {\n      if (isAllDay) {\n        return this.findAllDayGroupCellStartDate(groupIndex, startDate);\n      }\n\n      var groupData = this.getGroupFromDateTableGroupMap(groupIndex);\n\n      var checkCellStartDate = function checkCellStartDate(rowIndex, columnIndex) {\n        var cellData = groupData[rowIndex][columnIndex].cellData;\n        var secondMin = cellData.startDate,\n            secondMax = cellData.endDate;\n\n        if (isFindByDate) {\n          secondMin = dateUtils.trimTime(secondMin);\n          secondMax = dateUtils.setToDayEnd(secondMin);\n        }\n\n        if (dateUtils.intervalsOverlap({\n          firstMin: startDate,\n          firstMax: endDate,\n          secondMin: secondMin,\n          secondMax: secondMax\n        })) {\n          return secondMin;\n        }\n      };\n\n      var startDateVerticalSearch = function () {\n        var cellCount = groupData[0].length;\n\n        for (var columnIndex = 0; columnIndex < cellCount; ++columnIndex) {\n          for (var rowIndex = 0; rowIndex < groupData.length; ++rowIndex) {\n            var result = checkCellStartDate(rowIndex, columnIndex);\n\n            if (result) {\n              return result;\n            }\n          }\n        }\n      }();\n\n      var startDateHorizontalSearch = function () {\n        for (var rowIndex = 0; rowIndex < groupData.length; ++rowIndex) {\n          var row = groupData[rowIndex];\n\n          for (var columnIndex = 0; columnIndex < row.length; ++columnIndex) {\n            var result = checkCellStartDate(rowIndex, columnIndex);\n\n            if (result) {\n              return result;\n            }\n          }\n        }\n      }();\n\n      return startDateVerticalSearch > startDateHorizontalSearch ? startDateHorizontalSearch : startDateVerticalSearch;\n    }\n  }, {\n    key: \"findAllDayGroupCellStartDate\",\n    value: function findAllDayGroupCellStartDate(groupIndex, startDate) {\n      var groupStartDate = this.getGroupStartDate(groupIndex);\n      return groupStartDate > startDate ? groupStartDate : startDate;\n    }\n  }, {\n    key: \"findCellPositionInMap\",\n    value: function findCellPositionInMap(cellInfo) {\n      var _this = this;\n\n      var groupIndex = cellInfo.groupIndex,\n          startDate = cellInfo.startDate,\n          isAllDay = cellInfo.isAllDay,\n          index = cellInfo.index;\n      var startTime = isAllDay ? dateUtils.trimTime(startDate).getTime() : startDate.getTime();\n\n      var isStartDateInCell = function isStartDateInCell(cellData) {\n        if (!isDateAndTimeView(_this._viewOptions.viewType)) {\n          return dateUtils.sameDate(startDate, cellData.startDate);\n        }\n\n        var cellStartTime = cellData.startDate.getTime();\n        var cellEndTime = cellData.endDate.getTime();\n        return isAllDay ? cellData.allDay && startTime >= cellStartTime && startTime <= cellEndTime : startTime >= cellStartTime && startTime < cellEndTime;\n      };\n\n      var _this$groupedDataMap = this.groupedDataMap,\n          allDayPanelGroupedMap = _this$groupedDataMap.allDayPanelGroupedMap,\n          dateTableGroupedMap = _this$groupedDataMap.dateTableGroupedMap;\n      var rows = isAllDay && !this._viewOptions.isVerticalGrouping ? [allDayPanelGroupedMap[groupIndex]] || [] : dateTableGroupedMap[groupIndex] || [];\n\n      for (var rowIndex = 0; rowIndex < rows.length; ++rowIndex) {\n        var row = rows[rowIndex];\n\n        for (var columnIndex = 0; columnIndex < row.length; ++columnIndex) {\n          var cell = row[columnIndex];\n          var _cell = cell,\n              cellData = _cell.cellData;\n\n          if (this._isSameGroupIndexAndIndex(cellData, groupIndex, index)) {\n            if (isStartDateInCell(cellData)) {\n              return cell.position;\n            }\n          }\n        }\n      }\n\n      return;\n    }\n  }, {\n    key: \"_isSameGroupIndexAndIndex\",\n    value: function _isSameGroupIndexAndIndex(cellData, groupIndex, index) {\n      return cellData.groupIndex === groupIndex && (void 0 === index || cellData.index === index);\n    }\n  }, {\n    key: \"getCellsGroup\",\n    value: function getCellsGroup(groupIndex) {\n      var dateTableGroupedMap = this.groupedDataMap.dateTableGroupedMap;\n      var groupData = dateTableGroupedMap[groupIndex];\n\n      if (groupData) {\n        var cellData = groupData[0][0].cellData;\n        return cellData.groups;\n      }\n    }\n  }, {\n    key: \"getCompletedGroupsInfo\",\n    value: function getCompletedGroupsInfo() {\n      var _this2 = this;\n\n      var dateTableGroupedMap = this.groupedDataMap.dateTableGroupedMap;\n      return dateTableGroupedMap.map(function (groupData) {\n        var firstCell = groupData[0][0];\n        var _firstCell$cellData = firstCell.cellData,\n            allDay = _firstCell$cellData.allDay,\n            groupIndex = _firstCell$cellData.groupIndex;\n        return {\n          allDay: allDay,\n          groupIndex: groupIndex,\n          startDate: _this2.getGroupStartDate(groupIndex),\n          endDate: _this2.getGroupEndDate(groupIndex)\n        };\n      }).filter(function (_ref) {\n        var startDate = _ref.startDate;\n        return !!startDate;\n      });\n    }\n  }, {\n    key: \"getGroupIndices\",\n    value: function getGroupIndices() {\n      return this.getCompletedGroupsInfo().map(function (_ref2) {\n        var groupIndex = _ref2.groupIndex;\n        return groupIndex;\n      });\n    }\n  }, {\n    key: \"getGroupFromDateTableGroupMap\",\n    value: function getGroupFromDateTableGroupMap(groupIndex) {\n      var dateTableGroupedMap = this.groupedDataMap.dateTableGroupedMap;\n      return dateTableGroupedMap[groupIndex];\n    }\n  }, {\n    key: \"getFirstGroupRow\",\n    value: function getFirstGroupRow(groupIndex) {\n      var groupedData = this.getGroupFromDateTableGroupMap(groupIndex);\n\n      if (groupedData) {\n        var cellData = groupedData[0][0].cellData;\n        return !cellData.allDay ? groupedData[0] : groupedData[1];\n      }\n    }\n  }, {\n    key: \"getLastGroupRow\",\n    value: function getLastGroupRow(groupIndex) {\n      var dateTableGroupedMap = this.groupedDataMap.dateTableGroupedMap;\n      var groupedData = dateTableGroupedMap[groupIndex];\n\n      if (groupedData) {\n        var lastRowIndex = groupedData.length - 1;\n        return groupedData[lastRowIndex];\n      }\n    }\n  }, {\n    key: \"getLastGroupCellPosition\",\n    value: function getLastGroupCellPosition(groupIndex) {\n      var groupRow = this.getLastGroupRow(groupIndex);\n      return null === groupRow || void 0 === groupRow ? void 0 : groupRow[(null === groupRow || void 0 === groupRow ? void 0 : groupRow.length) - 1].position;\n    }\n  }, {\n    key: \"getRowCountInGroup\",\n    value: function getRowCountInGroup(groupIndex) {\n      var groupRow = this.getLastGroupRow(groupIndex);\n      var cellAmount = groupRow.length;\n      var lastCellData = groupRow[cellAmount - 1].cellData;\n      var lastCellIndex = lastCellData.index;\n      return (lastCellIndex + 1) / groupRow.length;\n    }\n  }]);\n\n  return GroupedDataMapProvider;\n}();","map":null,"metadata":{},"sourceType":"module"}