{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/scroll_view/ui.scrollable.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { getHeight, getOuterHeight, getWidth, getOuterWidth } from \"../../core/utils/size\";\nimport $ from \"../../core/renderer\";\nimport eventsEngine from \"../../events/core/events_engine\";\nimport { nativeScrolling } from \"../../core/utils/support\";\nimport browser from \"../../core/utils/browser\";\nimport { ensureDefined } from \"../../core/utils/common\";\nimport { isPlainObject, isDefined } from \"../../core/utils/type\";\nimport { extend } from \"../../core/utils/extend\";\nimport { getPublicElement } from \"../../core/element\";\nimport { hasWindow } from \"../../core/utils/window\";\nimport devices from \"../../core/devices\";\nimport registerComponent from \"../../core/component_registrator\";\nimport DOMComponent from \"../../core/dom_component\";\nimport { addNamespace } from \"../../events/utils/index\";\nimport scrollEvents from \"../../events/gesture/emitter.gesture.scroll\";\nimport { SimulatedStrategy } from \"./ui.scrollable.simulated\";\nimport NativeStrategy from \"./ui.scrollable.native\";\nimport { deviceDependentOptions } from \"./ui.scrollable.device\";\nimport { when } from \"../../core/utils/deferred\";\nimport { getElementLocationInternal } from \"../../renovation/ui/scroll_view/utils/get_element_location_internal\";\nvar SCROLLABLE = \"dxScrollable\";\nvar SCROLLABLE_STRATEGY = \"dxScrollableStrategy\";\nvar SCROLLABLE_CLASS = \"dx-scrollable\";\nvar SCROLLABLE_DISABLED_CLASS = \"dx-scrollable-disabled\";\nvar SCROLLABLE_CONTAINER_CLASS = \"dx-scrollable-container\";\nvar SCROLLABLE_WRAPPER_CLASS = \"dx-scrollable-wrapper\";\nvar SCROLLABLE_CONTENT_CLASS = \"dx-scrollable-content\";\nvar VERTICAL = \"vertical\";\nvar HORIZONTAL = \"horizontal\";\nvar BOTH = \"both\";\nvar Scrollable = DOMComponent.inherit({\n  _getDefaultOptions: function _getDefaultOptions() {\n    return extend(this.callBase(), {\n      disabled: false,\n      onScroll: null,\n      direction: VERTICAL,\n      showScrollbar: \"onScroll\",\n      useNative: true,\n      bounceEnabled: true,\n      scrollByContent: true,\n      scrollByThumb: false,\n      onUpdated: null,\n      onStart: null,\n      onEnd: null,\n      onBounce: null,\n      useSimulatedScrollbar: false,\n      useKeyboard: true,\n      inertiaEnabled: true,\n      updateManually: false\n    });\n  },\n  _defaultOptionsRules: function _defaultOptionsRules() {\n    return this.callBase().concat(deviceDependentOptions(), [{\n      device: function device() {\n        return nativeScrolling && \"android\" === devices.real().platform && !browser.mozilla;\n      },\n      options: {\n        useSimulatedScrollbar: true\n      }\n    }]);\n  },\n  _initOptions: function _initOptions(options) {\n    this.callBase(options);\n\n    if (!(\"useSimulatedScrollbar\" in options)) {\n      this._setUseSimulatedScrollbar();\n    }\n  },\n  _setUseSimulatedScrollbar: function _setUseSimulatedScrollbar() {\n    if (!this.initialOption(\"useSimulatedScrollbar\")) {\n      this.option(\"useSimulatedScrollbar\", !this.option(\"useNative\"));\n    }\n  },\n  _init: function _init() {\n    this.callBase();\n\n    this._initScrollableMarkup();\n\n    this._locked = false;\n  },\n  _visibilityChanged: function _visibilityChanged(visible) {\n    if (visible) {\n      this.update();\n\n      this._updateRtlPosition();\n\n      this._savedScrollOffset && this.scrollTo(this._savedScrollOffset);\n      delete this._savedScrollOffset;\n    } else {\n      this._savedScrollOffset = this.scrollOffset();\n    }\n  },\n  _initScrollableMarkup: function _initScrollableMarkup() {\n    var $element = this.$element().addClass(SCROLLABLE_CLASS);\n    var $container = this._$container = $(\"<div>\").addClass(SCROLLABLE_CONTAINER_CLASS);\n    var $wrapper = this._$wrapper = $(\"<div>\").addClass(SCROLLABLE_WRAPPER_CLASS);\n    var $content = this._$content = $(\"<div>\").addClass(SCROLLABLE_CONTENT_CLASS);\n    $content.append($element.contents()).appendTo($container);\n    $container.appendTo($wrapper);\n    $wrapper.appendTo($element);\n  },\n  _dimensionChanged: function _dimensionChanged() {\n    this.update();\n\n    this._updateRtlPosition();\n  },\n  _initMarkup: function _initMarkup() {\n    this.callBase();\n\n    this._renderDirection();\n  },\n  _render: function _render() {\n    this._renderStrategy();\n\n    this._attachEventHandlers();\n\n    this._renderDisabledState();\n\n    this._createActions();\n\n    this.update();\n    this.callBase();\n\n    this._updateRtlPosition(true);\n  },\n  _updateRtlPosition: function _updateRtlPosition(needInitializeRtlConfig) {\n    this._strategy.updateRtlPosition(needInitializeRtlConfig);\n  },\n  _getMaxOffset: function _getMaxOffset() {\n    var _$$get = $(this.container()).get(0),\n        scrollWidth = _$$get.scrollWidth,\n        clientWidth = _$$get.clientWidth,\n        scrollHeight = _$$get.scrollHeight,\n        clientHeight = _$$get.clientHeight;\n\n    return {\n      left: scrollWidth - clientWidth,\n      top: scrollHeight - clientHeight\n    };\n  },\n  _attachEventHandlers: function _attachEventHandlers() {\n    var strategy = this._strategy;\n    var initEventData = {\n      getDirection: strategy.getDirection.bind(strategy),\n      validate: this._validate.bind(this),\n      isNative: this.option(\"useNative\"),\n      scrollTarget: this._$container\n    };\n    eventsEngine.off(this._$wrapper, \".\" + SCROLLABLE);\n    eventsEngine.on(this._$wrapper, addNamespace(scrollEvents.init, SCROLLABLE), initEventData, this._initHandler.bind(this));\n    eventsEngine.on(this._$wrapper, addNamespace(scrollEvents.start, SCROLLABLE), strategy.handleStart.bind(strategy));\n    eventsEngine.on(this._$wrapper, addNamespace(scrollEvents.move, SCROLLABLE), strategy.handleMove.bind(strategy));\n    eventsEngine.on(this._$wrapper, addNamespace(scrollEvents.end, SCROLLABLE), strategy.handleEnd.bind(strategy));\n    eventsEngine.on(this._$wrapper, addNamespace(scrollEvents.cancel, SCROLLABLE), strategy.handleCancel.bind(strategy));\n    eventsEngine.on(this._$wrapper, addNamespace(scrollEvents.stop, SCROLLABLE), strategy.handleStop.bind(strategy));\n    eventsEngine.off(this._$container, \".\" + SCROLLABLE);\n    eventsEngine.on(this._$container, addNamespace(\"scroll\", SCROLLABLE), strategy.handleScroll.bind(strategy));\n  },\n  _validate: function _validate(e) {\n    if (this._isLocked()) {\n      return false;\n    }\n\n    this._updateIfNeed();\n\n    return this._moveIsAllowed(e);\n  },\n  _moveIsAllowed: function _moveIsAllowed(e) {\n    return this._strategy.validate(e);\n  },\n  handleMove: function handleMove(e) {\n    this._strategy.handleMove(e);\n  },\n  _prepareDirections: function _prepareDirections(value) {\n    this._strategy._prepareDirections(value);\n  },\n  _initHandler: function _initHandler() {\n    var strategy = this._strategy;\n    strategy.handleInit.apply(strategy, arguments);\n  },\n  _renderDisabledState: function _renderDisabledState() {\n    this.$element().toggleClass(SCROLLABLE_DISABLED_CLASS, this.option(\"disabled\"));\n\n    if (this.option(\"disabled\")) {\n      this._lock();\n    } else {\n      this._unlock();\n    }\n  },\n  _renderDirection: function _renderDirection() {\n    this.$element().removeClass(\"dx-scrollable-\" + HORIZONTAL).removeClass(\"dx-scrollable-\" + VERTICAL).removeClass(\"dx-scrollable-\" + BOTH).addClass(\"dx-scrollable-\" + this.option(\"direction\"));\n  },\n  _renderStrategy: function _renderStrategy() {\n    this._createStrategy();\n\n    this._strategy.render();\n\n    this.$element().data(SCROLLABLE_STRATEGY, this._strategy);\n  },\n  _createStrategy: function _createStrategy() {\n    this._strategy = this.option(\"useNative\") ? new NativeStrategy(this) : new SimulatedStrategy(this);\n  },\n  _createActions: function _createActions() {\n    this._strategy && this._strategy.createActions();\n  },\n  _clean: function _clean() {\n    this._strategy && this._strategy.dispose();\n  },\n  _optionChanged: function _optionChanged(args) {\n    switch (args.name) {\n      case \"onStart\":\n      case \"onEnd\":\n      case \"onUpdated\":\n      case \"onScroll\":\n      case \"onBounce\":\n        this._createActions();\n\n        break;\n\n      case \"direction\":\n        this._resetInactiveDirection();\n\n        this._invalidate();\n\n        break;\n\n      case \"useNative\":\n        this._setUseSimulatedScrollbar();\n\n        this._invalidate();\n\n        break;\n\n      case \"inertiaEnabled\":\n      case \"scrollByThumb\":\n      case \"bounceEnabled\":\n      case \"useKeyboard\":\n      case \"showScrollbar\":\n      case \"useSimulatedScrollbar\":\n        this._invalidate();\n\n        break;\n\n      case \"disabled\":\n        this._renderDisabledState();\n\n        this._strategy && this._strategy.disabledChanged();\n        break;\n\n      case \"updateManually\":\n      case \"scrollByContent\":\n        break;\n\n      case \"width\":\n        this.callBase(args);\n\n        this._updateRtlPosition();\n\n        break;\n\n      default:\n        this.callBase(args);\n    }\n  },\n  _resetInactiveDirection: function _resetInactiveDirection() {\n    var inactiveProp = this._getInactiveProp();\n\n    if (!inactiveProp || !hasWindow()) {\n      return;\n    }\n\n    var scrollOffset = this.scrollOffset();\n    scrollOffset[inactiveProp] = 0;\n    this.scrollTo(scrollOffset);\n  },\n  _getInactiveProp: function _getInactiveProp() {\n    var direction = this.option(\"direction\");\n\n    if (direction === VERTICAL) {\n      return \"left\";\n    }\n\n    if (direction === HORIZONTAL) {\n      return \"top\";\n    }\n  },\n  _location: function _location() {\n    return this._strategy.location();\n  },\n  _normalizeLocation: function _normalizeLocation(location) {\n    if (isPlainObject(location)) {\n      var left = ensureDefined(location.left, location.x);\n      var top = ensureDefined(location.top, location.y);\n      return {\n        left: isDefined(left) ? -left : void 0,\n        top: isDefined(top) ? -top : void 0\n      };\n    } else {\n      var direction = this.option(\"direction\");\n      return {\n        left: direction !== VERTICAL ? -location : void 0,\n        top: direction !== HORIZONTAL ? -location : void 0\n      };\n    }\n  },\n  _isLocked: function _isLocked() {\n    return this._locked;\n  },\n  _lock: function _lock() {\n    this._locked = true;\n  },\n  _unlock: function _unlock() {\n    if (!this.option(\"disabled\")) {\n      this._locked = false;\n    }\n  },\n  _isDirection: function _isDirection(direction) {\n    var current = this.option(\"direction\");\n\n    if (direction === VERTICAL) {\n      return current !== HORIZONTAL;\n    }\n\n    if (direction === HORIZONTAL) {\n      return current !== VERTICAL;\n    }\n\n    return current === direction;\n  },\n  _updateAllowedDirection: function _updateAllowedDirection() {\n    var allowedDirections = this._strategy._allowedDirections();\n\n    if (this._isDirection(BOTH) && allowedDirections.vertical && allowedDirections.horizontal) {\n      this._allowedDirectionValue = BOTH;\n    } else if (this._isDirection(HORIZONTAL) && allowedDirections.horizontal) {\n      this._allowedDirectionValue = HORIZONTAL;\n    } else if (this._isDirection(VERTICAL) && allowedDirections.vertical) {\n      this._allowedDirectionValue = VERTICAL;\n    } else {\n      this._allowedDirectionValue = null;\n    }\n  },\n  _allowedDirection: function _allowedDirection() {\n    return this._allowedDirectionValue;\n  },\n  $content: function $content() {\n    return this._$content;\n  },\n  content: function content() {\n    return getPublicElement(this._$content);\n  },\n  container: function container() {\n    return getPublicElement(this._$container);\n  },\n  scrollOffset: function scrollOffset() {\n    return this._strategy._getScrollOffset();\n  },\n  _isRtlNativeStrategy: function _isRtlNativeStrategy() {\n    var _this$option = this.option(),\n        useNative = _this$option.useNative,\n        rtlEnabled = _this$option.rtlEnabled;\n\n    return useNative && rtlEnabled;\n  },\n  scrollTop: function scrollTop() {\n    return this.scrollOffset().top;\n  },\n  scrollLeft: function scrollLeft() {\n    return this.scrollOffset().left;\n  },\n  clientHeight: function clientHeight() {\n    return getHeight(this._$container);\n  },\n  scrollHeight: function scrollHeight() {\n    return getOuterHeight(this.$content());\n  },\n  clientWidth: function clientWidth() {\n    return getWidth(this._$container);\n  },\n  scrollWidth: function scrollWidth() {\n    return getOuterWidth(this.$content());\n  },\n  update: function update() {\n    if (!this._strategy) {\n      return;\n    }\n\n    return when(this._strategy.update()).done(function () {\n      this._updateAllowedDirection();\n    }.bind(this));\n  },\n  scrollBy: function scrollBy(distance) {\n    distance = this._normalizeLocation(distance);\n\n    if (!distance.top && !distance.left) {\n      return;\n    }\n\n    this._updateIfNeed();\n\n    this._strategy.scrollBy(distance);\n  },\n  scrollTo: function scrollTo(targetLocation) {\n    targetLocation = this._normalizeLocation(targetLocation);\n\n    this._updateIfNeed();\n\n    var location = this._location();\n\n    if (!this.option(\"useNative\")) {\n      targetLocation = this._strategy._applyScaleRatio(targetLocation);\n      location = this._strategy._applyScaleRatio(location);\n    }\n\n    if (this._isRtlNativeStrategy()) {\n      location.left = location.left - this._getMaxOffset().left;\n    }\n\n    var distance = this._normalizeLocation({\n      left: location.left - ensureDefined(targetLocation.left, location.left),\n      top: location.top - ensureDefined(targetLocation.top, location.top)\n    });\n\n    if (!distance.top && !distance.left) {\n      return;\n    }\n\n    this._strategy.scrollBy(distance);\n  },\n  scrollToElement: function scrollToElement(element, offset) {\n    var $element = $(element);\n    var elementInsideContent = this.$content().find(element).length;\n    var elementIsInsideContent = $element.parents(\".\" + SCROLLABLE_CLASS).length - $element.parents(\".\" + SCROLLABLE_CONTENT_CLASS).length === 0;\n\n    if (!elementInsideContent || !elementIsInsideContent) {\n      return;\n    }\n\n    var scrollPosition = {\n      top: 0,\n      left: 0\n    };\n    var direction = this.option(\"direction\");\n\n    if (direction !== VERTICAL) {\n      scrollPosition.left = this.getScrollElementPosition($element, HORIZONTAL, offset);\n    }\n\n    if (direction !== HORIZONTAL) {\n      scrollPosition.top = this.getScrollElementPosition($element, VERTICAL, offset);\n    }\n\n    this.scrollTo(scrollPosition);\n  },\n  getScrollElementPosition: function getScrollElementPosition($element, direction, offset) {\n    var scrollOffset = this.scrollOffset();\n    return getElementLocationInternal($element.get(0), direction, $(this.container()).get(0), scrollOffset, offset);\n  },\n  _updateIfNeed: function _updateIfNeed() {\n    if (!this.option(\"updateManually\")) {\n      this.update();\n    }\n  },\n  _useTemplates: function _useTemplates() {\n    return false;\n  },\n  isRenovated: function isRenovated() {\n    return !!Scrollable.IS_RENOVATED_WIDGET;\n  }\n});\nregisterComponent(SCROLLABLE, Scrollable);\nexport default Scrollable;","map":null,"metadata":{},"sourceType":"module"}