{"ast":null,"code":"/**\r\n * DevExtreme (esm/viz/core/utils.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { noop } from \"../../core/utils/common\";\nimport { isDefined, isNumeric, isExponential, isFunction, isString } from \"../../core/utils/type\";\nimport { extend } from \"../../core/utils/extend\";\nimport { each } from \"../../core/utils/iterator\";\nimport { adjust, sign } from \"../../core/utils/math\";\nimport dateUtils from \"../../core/utils/date\";\nimport Color from \"../../color\";\nvar PI = Math.PI,\n    LN10 = Math.LN10,\n    abs = Math.abs,\n    log = Math.log,\n    floor = Math.floor,\n    ceil = Math.ceil,\n    pow = Math.pow,\n    sqrt = Math.sqrt,\n    atan2 = Math.atan2;\nvar _min = Math.min;\nvar _max = Math.max;\nvar _cos = Math.cos;\nvar _sin = Math.sin;\nvar _round = Math.round;\nvar dateToMilliseconds = dateUtils.dateToMilliseconds;\nvar MAX_PIXEL_COUNT = 1e10;\nvar PI_DIV_180 = PI / 180;\nvar _isNaN = isNaN;\nvar _Number = Number;\nvar _NaN = NaN;\nexport var PANE_PADDING = 10;\nexport var getLog = function getLog(value, base) {\n  if (!value) {\n    return _NaN;\n  }\n\n  return log(value) / log(base);\n};\nexport var getAdjustedLog10 = function getAdjustedLog10(value) {\n  return adjust(getLog(value, 10));\n};\nexport var raiseTo = function raiseTo(power, base) {\n  return pow(base, power);\n};\nexport var normalizeAngle = function normalizeAngle(angle) {\n  return (angle % 360 + 360) % 360;\n};\nexport var convertAngleToRendererSpace = function convertAngleToRendererSpace(angle) {\n  return 90 - angle;\n};\nexport var degreesToRadians = function degreesToRadians(value) {\n  return PI * value / 180;\n};\nexport var getCosAndSin = function getCosAndSin(angle) {\n  var angleInRadians = degreesToRadians(angle);\n  return {\n    cos: _cos(angleInRadians),\n    sin: _sin(angleInRadians)\n  };\n};\nvar DECIMAL_ORDER_THRESHOLD = 1e-14;\nexport var getDistance = function getDistance(x1, y1, x2, y2) {\n  var diffX = x2 - x1;\n  var diffY = y2 - y1;\n  return sqrt(diffY * diffY + diffX * diffX);\n};\nexport var getDecimalOrder = function getDecimalOrder(number) {\n  var n = abs(number);\n  var cn;\n\n  if (!_isNaN(n)) {\n    if (n > 0) {\n      n = log(n) / LN10;\n      cn = ceil(n);\n      return cn - n < DECIMAL_ORDER_THRESHOLD ? cn : floor(n);\n    }\n\n    return 0;\n  }\n\n  return _NaN;\n};\nexport var getAppropriateFormat = function getAppropriateFormat(start, end, count) {\n  var order = _max(getDecimalOrder(start), getDecimalOrder(end));\n\n  var precision = -getDecimalOrder(abs(end - start) / count);\n  var format;\n\n  if (!_isNaN(order) && !_isNaN(precision)) {\n    if (abs(order) <= 4) {\n      format = \"fixedPoint\";\n      precision < 0 && (precision = 0);\n      precision > 4 && (precision = 4);\n    } else {\n      format = \"exponential\";\n      precision += order - 1;\n      precision > 3 && (precision = 3);\n    }\n\n    return {\n      type: format,\n      precision: precision\n    };\n  }\n\n  return null;\n};\nexport var roundValue = function roundValue(value, precision) {\n  if (precision > 20) {\n    precision = 20;\n  }\n\n  if (isNumeric(value)) {\n    if (isExponential(value)) {\n      return _Number(value.toExponential(precision));\n    } else {\n      return _Number(value.toFixed(precision));\n    }\n  }\n};\nexport var getPower = function getPower(value) {\n  return value.toExponential().split(\"e\")[1];\n};\nexport function map(array, callback) {\n  var i = 0;\n  var len = array.length;\n  var result = [];\n  var value;\n\n  while (i < len) {\n    value = callback(array[i], i);\n\n    if (null !== value) {\n      result.push(value);\n    }\n\n    i++;\n  }\n\n  return result;\n}\n\nfunction selectByKeys(object, keys) {\n  return map(keys, function (key) {\n    return object[key] ? object[key] : null;\n  });\n}\n\nfunction decreaseFields(object, keys, eachDecrease, decrease) {\n  var dec = decrease;\n  each(keys, function (_, key) {\n    if (object[key]) {\n      object[key] -= eachDecrease;\n      dec -= eachDecrease;\n    }\n  });\n  return dec;\n}\n\nexport function normalizeEnum(value) {\n  return String(value).toLowerCase();\n}\nexport function setCanvasValues(canvas) {\n  if (canvas) {\n    canvas.originalTop = canvas.top;\n    canvas.originalBottom = canvas.bottom;\n    canvas.originalLeft = canvas.left;\n    canvas.originalRight = canvas.right;\n  }\n\n  return canvas;\n}\n\nfunction normalizeBBoxField(value) {\n  return -MAX_PIXEL_COUNT < value && value < +MAX_PIXEL_COUNT ? value : 0;\n}\n\nexport function normalizeBBox(bBox) {\n  var xl = normalizeBBoxField(floor(bBox.x));\n  var yt = normalizeBBoxField(floor(bBox.y));\n  var xr = normalizeBBoxField(ceil(bBox.width + bBox.x));\n  var yb = normalizeBBoxField(ceil(bBox.height + bBox.y));\n  var result = {\n    x: xl,\n    y: yt,\n    width: xr - xl,\n    height: yb - yt\n  };\n  result.isEmpty = !result.x && !result.y && !result.width && !result.height;\n  return result;\n}\nexport function rotateBBox(bBox, center, angle) {\n  var cos = _Number(_cos(angle * PI_DIV_180).toFixed(3));\n\n  var sin = _Number(_sin(angle * PI_DIV_180).toFixed(3));\n\n  var w2 = bBox.width / 2;\n  var h2 = bBox.height / 2;\n  var centerX = bBox.x + w2;\n  var centerY = bBox.y + h2;\n  var w2_ = abs(w2 * cos) + abs(h2 * sin);\n  var h2_ = abs(w2 * sin) + abs(h2 * cos);\n  var centerX_ = center[0] + (centerX - center[0]) * cos + (centerY - center[1]) * sin;\n  var centerY_ = center[1] - (centerX - center[0]) * sin + (centerY - center[1]) * cos;\n  return normalizeBBox({\n    x: centerX_ - w2_,\n    y: centerY_ - h2_,\n    width: 2 * w2_,\n    height: 2 * h2_\n  });\n}\nexport var decreaseGaps = function decreaseGaps(object, keys, decrease) {\n  var arrayGaps;\n\n  do {\n    arrayGaps = selectByKeys(object, keys);\n    arrayGaps.push(ceil(decrease / arrayGaps.length));\n    decrease = decreaseFields(object, keys, _min.apply(null, arrayGaps), decrease);\n  } while (decrease > 0 && arrayGaps.length > 1);\n\n  return decrease;\n};\nexport var parseScalar = function parseScalar(value, defaultValue) {\n  return void 0 !== value ? value : defaultValue;\n};\nexport var enumParser = function enumParser(values) {\n  var stored = {};\n  var i;\n  var ii;\n\n  for (i = 0, ii = values.length; i < ii; ++i) {\n    stored[normalizeEnum(values[i])] = 1;\n  }\n\n  return function (value, defaultValue) {\n    var _value = normalizeEnum(value);\n\n    return stored[_value] ? _value : defaultValue;\n  };\n};\nexport var patchFontOptions = function patchFontOptions(options) {\n  var fontOptions = {};\n  each(options || {}, function (key, value) {\n    if (/^(cursor)$/i.test(key)) {} else if (\"opacity\" === key) {\n      value = null;\n    } else if (\"color\" === key) {\n      key = \"fill\";\n\n      if (\"opacity\" in options) {\n        var color = new Color(value);\n        value = \"rgba(\".concat(color.r, \",\").concat(color.g, \",\").concat(color.b, \",\").concat(options.opacity, \")\");\n      }\n    } else {\n      key = \"font-\" + key;\n    }\n\n    fontOptions[key] = value;\n  });\n  return fontOptions;\n};\nexport function convertPolarToXY(centerCoords, startAngle, angle, radius) {\n  var normalizedRadius = radius > 0 ? radius : 0;\n  angle = isDefined(angle) ? angle + startAngle - 90 : 0;\n  var cosSin = getCosAndSin(angle);\n  return {\n    x: _round(centerCoords.x + normalizedRadius * cosSin.cos),\n    y: _round(centerCoords.y + normalizedRadius * cosSin.sin)\n  };\n}\nexport var convertXYToPolar = function convertXYToPolar(centerCoords, x, y) {\n  var radius = getDistance(centerCoords.x, centerCoords.y, x, y);\n  var angle = atan2(y - centerCoords.y, x - centerCoords.x);\n  return {\n    phi: _round(normalizeAngle(180 * angle / PI)),\n    r: _round(radius)\n  };\n};\nexport var processSeriesTemplate = function processSeriesTemplate(seriesTemplate, items) {\n  var customizeSeries = isFunction(seriesTemplate.customizeSeries) ? seriesTemplate.customizeSeries : noop;\n  var nameField = seriesTemplate.nameField;\n  var generatedSeries = {};\n  var seriesOrder = [];\n  var series;\n  var i = 0;\n  var length;\n  var data;\n  items = items || [];\n\n  for (length = items.length; i < length; i++) {\n    data = items[i];\n\n    if (nameField in data) {\n      series = generatedSeries[data[nameField]];\n\n      if (!series) {\n        series = generatedSeries[data[nameField]] = {\n          name: data[nameField],\n          nameFieldValue: data[nameField]\n        };\n        seriesOrder.push(series.name);\n      }\n    }\n  }\n\n  return map(seriesOrder, function (orderedName) {\n    var group = generatedSeries[orderedName];\n    return extend(group, customizeSeries.call(null, group.name));\n  });\n};\nexport var getCategoriesInfo = function getCategoriesInfo(categories, startValue, endValue) {\n  if (0 === categories.length) {\n    return {\n      categories: []\n    };\n  }\n\n  startValue = isDefined(startValue) ? startValue : categories[0];\n  endValue = isDefined(endValue) ? endValue : categories[categories.length - 1];\n  var categoriesValue = map(categories, function (category) {\n    return null === category || void 0 === category ? void 0 : category.valueOf();\n  });\n  var indexStartValue = categoriesValue.indexOf(startValue.valueOf());\n  var indexEndValue = categoriesValue.indexOf(endValue.valueOf());\n  var swapBuf;\n  var inverted = false;\n  indexStartValue < 0 && (indexStartValue = 0);\n  indexEndValue < 0 && (indexEndValue = categories.length - 1);\n\n  if (indexEndValue < indexStartValue) {\n    swapBuf = indexEndValue;\n    indexEndValue = indexStartValue;\n    indexStartValue = swapBuf;\n    inverted = true;\n  }\n\n  var visibleCategories = categories.slice(indexStartValue, indexEndValue + 1);\n  var lastIdx = visibleCategories.length - 1;\n  return {\n    categories: visibleCategories,\n    start: visibleCategories[inverted ? lastIdx : 0],\n    end: visibleCategories[inverted ? 0 : lastIdx],\n    inverted: inverted\n  };\n};\nexport function isRelativeHeightPane(pane) {\n  return !(pane.unit % 2);\n}\nexport function normalizePanesHeight(panes) {\n  panes.forEach(function (pane) {\n    var height = pane.height;\n    var unit = 0;\n    var parsedHeight = parseFloat(height) || void 0;\n\n    if (isString(height) && height.indexOf(\"px\") > -1 || isNumeric(height) && height > 1) {\n      parsedHeight = _round(parsedHeight);\n      unit = 1;\n    }\n\n    if (!unit && parsedHeight) {\n      if (isString(height) && height.indexOf(\"%\") > -1) {\n        parsedHeight /= 100;\n        unit = 2;\n      } else if (parsedHeight < 0) {\n        parsedHeight = parsedHeight < -1 ? 1 : abs(parsedHeight);\n      }\n    }\n\n    pane.height = parsedHeight;\n    pane.unit = unit;\n  });\n  var relativeHeightPanes = panes.filter(isRelativeHeightPane);\n  var weightSum = relativeHeightPanes.reduce(function (prev, next) {\n    return prev + (next.height || 0);\n  }, 0);\n  var weightHeightCount = relativeHeightPanes.length;\n  var emptyHeightPanes = relativeHeightPanes.filter(function (pane) {\n    return !pane.height;\n  });\n  var emptyHeightCount = emptyHeightPanes.length;\n\n  if (weightSum < 1 && emptyHeightCount) {\n    emptyHeightPanes.forEach(function (pane) {\n      return pane.height = (1 - weightSum) / emptyHeightCount;\n    });\n  } else if (weightSum > 1 || weightSum < 1 && !emptyHeightCount || 1 === weightSum && emptyHeightCount) {\n    if (emptyHeightCount) {\n      var weightForEmpty = weightSum / weightHeightCount;\n      var emptyWeightSum = emptyHeightCount * weightForEmpty;\n      relativeHeightPanes.filter(function (pane) {\n        return pane.height;\n      }).forEach(function (pane) {\n        return pane.height *= (weightSum - emptyWeightSum) / weightSum;\n      });\n      emptyHeightPanes.forEach(function (pane) {\n        return pane.height = weightForEmpty;\n      });\n    }\n\n    relativeHeightPanes.forEach(function (pane) {\n      return pane.height *= 1 / weightSum;\n    });\n  }\n}\nexport function updatePanesCanvases(panes, canvas, rotated) {\n  var distributedSpace = 0;\n  var padding = PANE_PADDING;\n  var paneSpace = rotated ? canvas.width - canvas.left - canvas.right : canvas.height - canvas.top - canvas.bottom;\n  var totalCustomSpace = panes.reduce(function (prev, cur) {\n    return prev + (!isRelativeHeightPane(cur) ? cur.height : 0);\n  }, 0);\n  var usefulSpace = paneSpace - padding * (panes.length - 1) - totalCustomSpace;\n  var startName = rotated ? \"left\" : \"top\";\n  var endName = rotated ? \"right\" : \"bottom\";\n  panes.forEach(function (pane) {\n    var calcLength = !isRelativeHeightPane(pane) ? pane.height : _round(pane.height * usefulSpace);\n    pane.canvas = pane.canvas || {};\n    extend(pane.canvas, canvas);\n    pane.canvas[startName] = canvas[startName] + distributedSpace;\n    pane.canvas[endName] = canvas[endName] + (paneSpace - calcLength - distributedSpace);\n    distributedSpace = distributedSpace + calcLength + padding;\n    setCanvasValues(pane.canvas);\n  });\n}\nexport var unique = function unique(array) {\n  var values = {};\n  return map(array, function (item) {\n    var result = !values[item] ? item : null;\n    values[item] = true;\n    return result;\n  });\n};\nexport var getVerticallyShiftedAngularCoords = function getVerticallyShiftedAngularCoords(bBox, dy, center) {\n  var isPositive = bBox.x + bBox.width / 2 >= center.x;\n  var horizontalOffset1 = (isPositive ? bBox.x : bBox.x + bBox.width) - center.x;\n  var verticalOffset1 = bBox.y - center.y;\n  var verticalOffset2 = verticalOffset1 + dy;\n\n  var horizontalOffset2 = _round(sqrt(horizontalOffset1 * horizontalOffset1 + verticalOffset1 * verticalOffset1 - verticalOffset2 * verticalOffset2));\n\n  var dx = (isPositive ? +horizontalOffset2 : -horizontalOffset2) || horizontalOffset1;\n  return {\n    x: center.x + (isPositive ? dx : dx - bBox.width),\n    y: bBox.y + dy\n  };\n};\nexport function mergeMarginOptions(opt1, opt2) {\n  return {\n    checkInterval: opt1.checkInterval || opt2.checkInterval,\n    size: _max(opt1.size || 0, opt2.size || 0),\n    percentStick: opt1.percentStick || opt2.percentStick,\n    sizePointNormalState: _max(opt1.sizePointNormalState || 0, opt2.sizePointNormalState || 0)\n  };\n}\nexport function getVizRangeObject(value) {\n  if (Array.isArray(value)) {\n    return {\n      startValue: value[0],\n      endValue: value[1]\n    };\n  } else {\n    return value || {};\n  }\n}\nexport function convertVisualRangeObject(visualRange, convertToVisualRange) {\n  if (convertToVisualRange) {\n    return visualRange;\n  }\n\n  return [visualRange.startValue, visualRange.endValue];\n}\nexport function getAddFunction(range, correctZeroLevel) {\n  if (\"datetime\" === range.dataType) {\n    return function (rangeValue, marginValue) {\n      var sign = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;\n      return new Date(rangeValue.getTime() + sign * marginValue);\n    };\n  }\n\n  if (\"logarithmic\" === range.axisType) {\n    return function (rangeValue, marginValue) {\n      var sign = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;\n      var log = getLogExt(rangeValue, range.base) + sign * marginValue;\n      return raiseToExt(log, range.base);\n    };\n  }\n\n  return function (rangeValue, marginValue) {\n    var sign = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;\n    var newValue = rangeValue + sign * marginValue;\n    return correctZeroLevel && newValue * rangeValue <= 0 ? 0 : newValue;\n  };\n}\nexport function adjustVisualRange(options, visualRange, wholeRange, dataRange) {\n  var minDefined = isDefined(visualRange.startValue);\n  var maxDefined = isDefined(visualRange.endValue);\n  var nonDiscrete = \"discrete\" !== options.axisType;\n  dataRange = dataRange || wholeRange;\n  var add = getAddFunction(options, false);\n  var min = minDefined ? visualRange.startValue : dataRange.min;\n  var max = maxDefined ? visualRange.endValue : dataRange.max;\n  var rangeLength = visualRange.length;\n  var categories = dataRange.categories;\n\n  if (nonDiscrete && !isDefined(min) && !isDefined(max)) {\n    return {\n      startValue: min,\n      endValue: max\n    };\n  }\n\n  if (isDefined(rangeLength)) {\n    if (nonDiscrete) {\n      if (\"datetime\" === options.dataType && !isNumeric(rangeLength)) {\n        rangeLength = dateToMilliseconds(rangeLength);\n      }\n\n      if (maxDefined && !minDefined || !maxDefined && !minDefined) {\n        isDefined(wholeRange.max) && (max = max > wholeRange.max ? wholeRange.max : max);\n        min = add(max, rangeLength, -1);\n      } else if (minDefined && !maxDefined) {\n        isDefined(wholeRange.min) && (min = min < wholeRange.min ? wholeRange.min : min);\n        max = add(min, rangeLength);\n      }\n    } else {\n      rangeLength = parseInt(rangeLength);\n\n      if (!isNaN(rangeLength) && isFinite(rangeLength)) {\n        rangeLength--;\n\n        if (!maxDefined && !minDefined) {\n          max = categories[categories.length - 1];\n          min = categories[categories.length - 1 - rangeLength];\n        } else if (minDefined && !maxDefined) {\n          var categoriesInfo = getCategoriesInfo(categories, min, void 0);\n          max = categoriesInfo.categories[rangeLength];\n        } else if (!minDefined && maxDefined) {\n          var _categoriesInfo = getCategoriesInfo(categories, void 0, max);\n\n          min = _categoriesInfo.categories[_categoriesInfo.categories.length - 1 - rangeLength];\n        }\n      }\n    }\n  }\n\n  if (nonDiscrete) {\n    if (isDefined(wholeRange.max) && max > wholeRange.max) {\n      max = wholeRange.max;\n    }\n\n    if (isDefined(wholeRange.min) && min < wholeRange.min) {\n      min = wholeRange.min;\n    }\n  }\n\n  return {\n    startValue: min,\n    endValue: max\n  };\n}\nexport function getLogExt(value, base) {\n  var allowNegatives = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : false;\n  var linearThreshold = arguments.length > 3 ? arguments[3] : void 0;\n\n  if (!allowNegatives) {\n    return getLog(value, base);\n  }\n\n  if (0 === value) {\n    return 0;\n  }\n\n  var transformValue = getLog(abs(value), base) - (linearThreshold - 1);\n\n  if (transformValue < 0) {\n    return 0;\n  }\n\n  return adjust(sign(value) * transformValue, Number(pow(base, linearThreshold - 1).toFixed(abs(linearThreshold))));\n}\nexport function raiseToExt(value, base) {\n  var allowNegatives = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : false;\n  var linearThreshold = arguments.length > 3 ? arguments[3] : void 0;\n\n  if (!allowNegatives) {\n    return raiseTo(value, base);\n  }\n\n  if (0 === value) {\n    return 0;\n  }\n\n  var transformValue = raiseTo(abs(value) + (linearThreshold - 1), base);\n\n  if (transformValue < 0) {\n    return 0;\n  }\n\n  return adjust(sign(value) * transformValue, Number(pow(base, linearThreshold).toFixed(abs(linearThreshold))));\n}\nexport function rangesAreEqual(range, rangeFromOptions) {\n  if (Array.isArray(rangeFromOptions)) {\n    return range.length === rangeFromOptions.length && range.every(function (item, i) {\n      return valueOf(item) === valueOf(rangeFromOptions[i]);\n    });\n  } else {\n    return valueOf(range.startValue) === valueOf(rangeFromOptions.startValue) && valueOf(range.endValue) === valueOf(rangeFromOptions.endValue);\n  }\n}\nexport function valueOf(value) {\n  return value && value.valueOf();\n}\nexport function pointInCanvas(canvas, x, y) {\n  return x >= canvas.left && x <= canvas.right && y >= canvas.top && y <= canvas.bottom;\n}","map":null,"metadata":{},"sourceType":"module"}