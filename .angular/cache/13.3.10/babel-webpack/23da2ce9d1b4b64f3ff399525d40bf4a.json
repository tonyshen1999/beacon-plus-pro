{"ast":null,"code":"import _defineProperty from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\n\n/**\r\n * DevExtreme (esm/ui/sortable.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { getHeight, getOuterHeight, getOuterWidth, getWidth } from \"../core/utils/size\";\nimport $ from \"../core/renderer\";\nimport eventsEngine from \"../events/core/events_engine\";\nimport registerComponent from \"../core/component_registrator\";\nimport { extend } from \"../core/utils/extend\";\nimport Draggable from \"./draggable\";\nimport { getPublicElement } from \"../core/element\";\nimport { getWindow } from \"../core/utils/window\";\nimport { getBoundingRect } from \"../core/utils/position\";\nimport { resetPosition } from \"../animation/translator\";\nimport fx from \"../animation/fx\";\nimport { Deferred } from \"../core/utils/deferred\";\nvar window = getWindow();\nvar SORTABLE = \"dxSortable\";\nvar PLACEHOLDER_CLASS = \"placeholder\";\nvar CLONE_CLASS = \"clone\";\n\nvar isElementVisible = function isElementVisible(itemElement) {\n  return $(itemElement).is(\":visible\");\n};\n\nvar animate = function animate(element, config) {\n  var _config$to, _config$to2;\n\n  if (!element) {\n    return;\n  }\n\n  var left = (null === (_config$to = config.to) || void 0 === _config$to ? void 0 : _config$to.left) || 0;\n  var top = (null === (_config$to2 = config.to) || void 0 === _config$to2 ? void 0 : _config$to2.top) || 0;\n  element.style.transform = \"translate(\".concat(left, \"px,\").concat(top, \"px)\");\n  element.style.transition = fx.off ? \"\" : \"transform \".concat(config.duration, \"ms \").concat(config.easing);\n};\n\nvar stopAnimation = function stopAnimation(element) {\n  if (!element) {\n    return;\n  }\n\n  element.style.transform = \"\";\n  element.style.transition = \"\";\n};\n\nfunction getScrollableBoundary($scrollable) {\n  var offset = $scrollable.offset();\n  var style = $scrollable[0].style;\n  var paddingLeft = parseFloat(style.paddingLeft) || 0;\n  var paddingRight = parseFloat(style.paddingRight) || 0;\n  var paddingTop = parseFloat(style.paddingTop) || 0;\n  var width = $scrollable[0].clientWidth - (paddingLeft + paddingRight);\n  var height = getHeight($scrollable);\n  var left = offset.left + paddingLeft;\n  var top = offset.top + paddingTop;\n  return {\n    left: left,\n    right: left + width,\n    top: top,\n    bottom: top + height\n  };\n}\n\nvar Sortable = Draggable.inherit({\n  _init: function _init() {\n    this.callBase();\n    this._sourceScrollHandler = this._handleSourceScroll.bind(this);\n    this._sourceScrollableInfo = null;\n  },\n  _getDefaultOptions: function _getDefaultOptions() {\n    return extend(this.callBase(), {\n      clone: true,\n      filter: \"> *\",\n      itemOrientation: \"vertical\",\n      dropFeedbackMode: \"push\",\n      allowDropInsideItem: false,\n      allowReordering: true,\n      moveItemOnDrop: false,\n      onDragChange: null,\n      onAdd: null,\n      onRemove: null,\n      onReorder: null,\n      onPlaceholderPrepared: null,\n      animation: {\n        type: \"slide\",\n        duration: 300,\n        easing: \"ease\"\n      },\n      fromIndex: null,\n      toIndex: null,\n      dropInsideItem: false,\n      itemPoints: null,\n      fromIndexOffset: 0,\n      offset: 0,\n      autoUpdate: false,\n      draggableElementSize: 0\n    });\n  },\n  reset: function reset() {\n    this.option({\n      dropInsideItem: false,\n      toIndex: null,\n      fromIndex: null,\n      itemPoints: null,\n      fromIndexOffset: 0,\n      draggableElementSize: 0\n    });\n\n    if (this._$placeholderElement) {\n      this._$placeholderElement.remove();\n    }\n\n    this._$placeholderElement = null;\n\n    if (!this._isIndicateMode() && this._$modifiedItem) {\n      this._$modifiedItem.css(\"marginBottom\", this._modifiedItemMargin);\n\n      this._$modifiedItem = null;\n    }\n  },\n  _getPrevVisibleItem: function _getPrevVisibleItem(items, index) {\n    return items.slice(0, index).reverse().filter(isElementVisible)[0];\n  },\n  _dragStartHandler: function _dragStartHandler(e) {\n    this.callBase.apply(this, arguments);\n\n    if (true === e.cancel) {\n      return;\n    }\n\n    var $sourceElement = this._getSourceElement();\n\n    this._updateItemPoints();\n\n    this._subscribeToSourceScroll(e);\n\n    this.option(\"fromIndex\", this._getElementIndex($sourceElement));\n    this.option(\"fromIndexOffset\", this.option(\"offset\"));\n  },\n  _subscribeToSourceScroll: function _subscribeToSourceScroll(e) {\n    var $scrollable = this._getScrollable($(e.target));\n\n    if ($scrollable) {\n      this._sourceScrollableInfo = {\n        element: $scrollable,\n        scrollLeft: $scrollable.scrollLeft(),\n        scrollTop: $scrollable.scrollTop()\n      };\n      eventsEngine.on($scrollable, \"scroll\", this._sourceScrollHandler);\n    }\n  },\n  _unsubscribeFromSourceScroll: function _unsubscribeFromSourceScroll() {\n    if (this._sourceScrollableInfo) {\n      eventsEngine.off(this._sourceScrollableInfo.element, \"scroll\", this._sourceScrollHandler);\n      this._sourceScrollableInfo = null;\n    }\n  },\n  _handleSourceScroll: function _handleSourceScroll(e) {\n    var _this = this;\n\n    var sourceScrollableInfo = this._sourceScrollableInfo;\n\n    if (sourceScrollableInfo) {\n      [\"scrollLeft\", \"scrollTop\"].forEach(function (scrollProp) {\n        if (e.target[scrollProp] !== sourceScrollableInfo[scrollProp]) {\n          var scrollBy = e.target[scrollProp] - sourceScrollableInfo[scrollProp];\n\n          _this._correctItemPoints(scrollBy);\n\n          _this._movePlaceholder();\n\n          sourceScrollableInfo[scrollProp] = e.target[scrollProp];\n        }\n      });\n    }\n  },\n  _dragEnterHandler: function _dragEnterHandler(e) {\n    this.callBase.apply(this, arguments);\n\n    this._subscribeToSourceScroll(e);\n\n    if (this === this._getSourceDraggable()) {\n      return;\n    }\n\n    this._updateItemPoints();\n\n    this.option(\"fromIndex\", -1);\n\n    if (!this._isIndicateMode()) {\n      var itemPoints = this.option(\"itemPoints\");\n      var lastItemPoint = itemPoints[itemPoints.length - 1];\n\n      if (lastItemPoint) {\n        var $element = this.$element();\n\n        var $sourceElement = this._getSourceElement();\n\n        var isVertical = this._isVerticalOrientation();\n\n        var sourceElementSize = isVertical ? getOuterHeight($sourceElement, true) : getOuterWidth($sourceElement, true);\n        var scrollSize = $element.get(0)[isVertical ? \"scrollHeight\" : \"scrollWidth\"];\n        var scrollPosition = $element.get(0)[isVertical ? \"scrollTop\" : \"scrollLeft\"];\n        var positionProp = isVertical ? \"top\" : \"left\";\n        var lastPointPosition = lastItemPoint[positionProp];\n        var elementPosition = $element.offset()[positionProp];\n        var freeSize = elementPosition + scrollSize - scrollPosition - lastPointPosition;\n\n        if (freeSize < sourceElementSize) {\n          if (isVertical) {\n            var items = this._getItems();\n\n            var $lastItem = $(this._getPrevVisibleItem(items));\n            this._$modifiedItem = $lastItem;\n            this._modifiedItemMargin = $lastItem.get(0).style.marginBottom;\n            $lastItem.css(\"marginBottom\", sourceElementSize - freeSize);\n            var $sortable = $lastItem.closest(\".dx-sortable\");\n            var sortable = $sortable.data(\"dxScrollable\") || $sortable.data(\"dxScrollView\");\n            sortable && sortable.update();\n          }\n        }\n      }\n    }\n  },\n  _dragLeaveHandler: function _dragLeaveHandler() {\n    this.callBase.apply(this, arguments);\n\n    this._unsubscribeFromSourceScroll();\n  },\n  dragEnter: function dragEnter() {\n    if (this !== this._getTargetDraggable()) {\n      this.option(\"toIndex\", -1);\n    }\n  },\n  dragLeave: function dragLeave() {\n    if (this !== this._getTargetDraggable()) {\n      this.option(\"toIndex\", this.option(\"fromIndex\"));\n    }\n  },\n  _allowDrop: function _allowDrop(event) {\n    var targetDraggable = this._getTargetDraggable();\n\n    var $targetDraggable = targetDraggable.$element();\n\n    var $scrollable = this._getScrollable($targetDraggable);\n\n    if ($scrollable) {\n      var _getScrollableBoundar = getScrollableBoundary($scrollable),\n          left = _getScrollableBoundar.left,\n          right = _getScrollableBoundar.right,\n          top = _getScrollableBoundar.top,\n          bottom = _getScrollableBoundar.bottom;\n\n      var toIndex = this.option(\"toIndex\");\n      var itemPoints = this.option(\"itemPoints\");\n      var itemPoint = null === itemPoints || void 0 === itemPoints ? void 0 : itemPoints.filter(function (item) {\n        return item.index === toIndex;\n      })[0];\n\n      if (itemPoint && void 0 !== itemPoint.top) {\n        var isVertical = this._isVerticalOrientation();\n\n        if (isVertical) {\n          return top <= itemPoint.top && itemPoint.top <= bottom;\n        } else {\n          return left <= itemPoint.left && itemPoint.left <= right;\n        }\n      }\n    }\n\n    return true;\n  },\n  dragEnd: function dragEnd(sourceEvent) {\n    this._unsubscribeFromSourceScroll();\n\n    var $sourceElement = this._getSourceElement();\n\n    var sourceDraggable = this._getSourceDraggable();\n\n    var isSourceDraggable = sourceDraggable.NAME !== this.NAME;\n    var toIndex = this.option(\"toIndex\");\n    var event = sourceEvent.event;\n\n    var allowDrop = this._allowDrop(event);\n\n    if (null !== toIndex && toIndex >= 0 && allowDrop) {\n      var cancelAdd;\n      var cancelRemove;\n\n      if (sourceDraggable !== this) {\n        cancelAdd = this._fireAddEvent(event);\n\n        if (!cancelAdd) {\n          cancelRemove = this._fireRemoveEvent(event);\n        }\n      }\n\n      if (isSourceDraggable) {\n        resetPosition($sourceElement);\n      }\n\n      if (this.option(\"moveItemOnDrop\")) {\n        !cancelAdd && this._moveItem($sourceElement, toIndex, cancelRemove);\n      }\n\n      if (sourceDraggable === this) {\n        return this._fireReorderEvent(event);\n      }\n    }\n\n    return new Deferred().resolve();\n  },\n  dragMove: function dragMove(e) {\n    var itemPoints = this.option(\"itemPoints\");\n\n    if (!itemPoints) {\n      return;\n    }\n\n    var isVertical = this._isVerticalOrientation();\n\n    var axisName = isVertical ? \"top\" : \"left\";\n    var cursorPosition = isVertical ? e.pageY : e.pageX;\n    var rtlEnabled = this.option(\"rtlEnabled\");\n    var itemPoint;\n\n    for (var i = itemPoints.length - 1; i >= 0; i--) {\n      var centerPosition = itemPoints[i + 1] && (itemPoints[i][axisName] + itemPoints[i + 1][axisName]) / 2;\n\n      if ((!isVertical && rtlEnabled ? cursorPosition > centerPosition : centerPosition > cursorPosition) || void 0 === centerPosition) {\n        itemPoint = itemPoints[i];\n      } else {\n        break;\n      }\n    }\n\n    if (itemPoint) {\n      this._updatePlaceholderPosition(e, itemPoint);\n\n      if (this._verticalScrollHelper.isScrolling() && this._isIndicateMode()) {\n        this._movePlaceholder();\n      }\n    }\n  },\n  _isIndicateMode: function _isIndicateMode() {\n    return \"indicate\" === this.option(\"dropFeedbackMode\") || this.option(\"allowDropInsideItem\");\n  },\n  _createPlaceholder: function _createPlaceholder() {\n    var $placeholderContainer;\n\n    if (this._isIndicateMode()) {\n      $placeholderContainer = $(\"<div>\").addClass(this._addWidgetPrefix(PLACEHOLDER_CLASS)).insertBefore(this._getSourceDraggable()._$dragElement);\n    }\n\n    this._$placeholderElement = $placeholderContainer;\n    return $placeholderContainer;\n  },\n  _getItems: function _getItems() {\n    var itemsSelector = this._getItemsSelector();\n\n    return this._$content().find(itemsSelector).not(\".\" + this._addWidgetPrefix(PLACEHOLDER_CLASS)).not(\".\" + this._addWidgetPrefix(CLONE_CLASS)).toArray();\n  },\n  _allowReordering: function _allowReordering() {\n    var sourceDraggable = this._getSourceDraggable();\n\n    var targetDraggable = this._getTargetDraggable();\n\n    return sourceDraggable !== targetDraggable || this.option(\"allowReordering\");\n  },\n  _isValidPoint: function _isValidPoint(visibleIndex, draggableVisibleIndex, dropInsideItem) {\n    var allowDropInsideItem = this.option(\"allowDropInsideItem\");\n\n    var allowReordering = dropInsideItem || this._allowReordering();\n\n    if (!allowReordering && (0 !== visibleIndex || !allowDropInsideItem)) {\n      return false;\n    }\n\n    if (!this._isIndicateMode()) {\n      return true;\n    }\n\n    return -1 === draggableVisibleIndex || visibleIndex !== draggableVisibleIndex && (dropInsideItem || visibleIndex !== draggableVisibleIndex + 1);\n  },\n  _getItemPoints: function _getItemPoints() {\n    var result = [];\n    var $item;\n    var offset;\n    var itemWidth;\n    var rtlEnabled = this.option(\"rtlEnabled\");\n\n    var isVertical = this._isVerticalOrientation();\n\n    var itemElements = this._getItems();\n\n    var visibleItemElements = itemElements.filter(isElementVisible);\n    var visibleItemCount = visibleItemElements.length;\n\n    var $draggableItem = this._getDraggableElement();\n\n    var draggableVisibleIndex = visibleItemElements.indexOf($draggableItem.get(0));\n\n    if (visibleItemCount) {\n      for (var i = 0; i <= visibleItemCount; i++) {\n        var needCorrectLeftPosition = !isVertical && rtlEnabled ^ i === visibleItemCount;\n        var needCorrectTopPosition = isVertical && i === visibleItemCount;\n\n        if (i < visibleItemCount) {\n          $item = $(visibleItemElements[i]);\n          offset = $item.offset();\n          itemWidth = getOuterWidth($item);\n        }\n\n        result.push({\n          dropInsideItem: false,\n          left: offset.left + (needCorrectLeftPosition ? itemWidth : 0),\n          top: offset.top + (needCorrectTopPosition ? result[i - 1].height : 0),\n          index: i === visibleItemCount ? itemElements.length : itemElements.indexOf($item.get(0)),\n          $item: $item,\n          width: getOuterWidth($item),\n          height: getOuterHeight($item),\n          isValid: this._isValidPoint(i, draggableVisibleIndex)\n        });\n      }\n\n      if (this.option(\"allowDropInsideItem\")) {\n        var points = result;\n        result = [];\n\n        for (var _i = 0; _i < points.length; _i++) {\n          result.push(points[_i]);\n\n          if (points[_i + 1]) {\n            result.push(extend({}, points[_i], {\n              dropInsideItem: true,\n              top: Math.floor((points[_i].top + points[_i + 1].top) / 2),\n              left: Math.floor((points[_i].left + points[_i + 1].left) / 2),\n              isValid: this._isValidPoint(_i, draggableVisibleIndex, true)\n            }));\n          }\n        }\n      }\n    } else {\n      result.push({\n        dropInsideItem: false,\n        index: 0,\n        isValid: true\n      });\n    }\n\n    return result;\n  },\n  _updateItemPoints: function _updateItemPoints(forceUpdate) {\n    if (forceUpdate || this.option(\"autoUpdate\") || !this.option(\"itemPoints\")) {\n      this.option(\"itemPoints\", this._getItemPoints());\n    }\n  },\n  _correctItemPoints: function _correctItemPoints(scrollBy) {\n    var itemPoints = this.option(\"itemPoints\");\n\n    if (scrollBy && itemPoints && !this.option(\"autoUpdate\")) {\n      var isVertical = this._isVerticalOrientation();\n\n      var positionPropName = isVertical ? \"top\" : \"left\";\n      itemPoints.forEach(function (itemPoint) {\n        itemPoint[positionPropName] -= scrollBy;\n      });\n    }\n  },\n  _getElementIndex: function _getElementIndex($itemElement) {\n    return this._getItems().indexOf($itemElement.get(0));\n  },\n  _getDragTemplateArgs: function _getDragTemplateArgs($element) {\n    var args = this.callBase.apply(this, arguments);\n    args.model.fromIndex = this._getElementIndex($element);\n    return args;\n  },\n  _togglePlaceholder: function _togglePlaceholder(value) {\n    this._$placeholderElement && this._$placeholderElement.toggle(value);\n  },\n  _isVerticalOrientation: function _isVerticalOrientation() {\n    return \"vertical\" === this.option(\"itemOrientation\");\n  },\n  _normalizeToIndex: function _normalizeToIndex(toIndex, dropInsideItem) {\n    var isAnotherDraggable = this._getSourceDraggable() !== this._getTargetDraggable();\n\n    var fromIndex = this.option(\"fromIndex\");\n\n    if (null === toIndex) {\n      return fromIndex;\n    }\n\n    return Math.max(isAnotherDraggable || fromIndex >= toIndex || dropInsideItem ? toIndex : toIndex - 1, 0);\n  },\n  _updatePlaceholderPosition: function _updatePlaceholderPosition(e, itemPoint) {\n    var sourceDraggable = this._getSourceDraggable();\n\n    var toIndex = this._normalizeToIndex(itemPoint.index, itemPoint.dropInsideItem);\n\n    var eventArgs = extend(this._getEventArgs(e), {\n      toIndex: toIndex,\n      dropInsideItem: itemPoint.dropInsideItem\n    });\n    itemPoint.isValid && this._getAction(\"onDragChange\")(eventArgs);\n\n    if (eventArgs.cancel || !itemPoint.isValid) {\n      if (!itemPoint.isValid) {\n        this.option({\n          dropInsideItem: false,\n          toIndex: null\n        });\n      }\n\n      return;\n    }\n\n    this.option({\n      dropInsideItem: itemPoint.dropInsideItem,\n      toIndex: itemPoint.index\n    });\n\n    this._getAction(\"onPlaceholderPrepared\")(extend(this._getEventArgs(e), {\n      placeholderElement: getPublicElement(this._$placeholderElement),\n      dragElement: getPublicElement(sourceDraggable._$dragElement)\n    }));\n\n    this._updateItemPoints();\n  },\n  _makeWidthCorrection: function _makeWidthCorrection($item, width) {\n    this._$scrollable = this._getScrollable($item);\n\n    if (this._$scrollable && getWidth(this._$scrollable) < width) {\n      var scrollableWidth = getWidth(this._$scrollable);\n\n      var offsetLeft = $item.offset().left - this._$scrollable.offset().left;\n\n      var offsetRight = scrollableWidth - getOuterWidth($item) - offsetLeft;\n\n      if (offsetLeft > 0) {\n        width = scrollableWidth - offsetLeft;\n      } else if (offsetRight > 0) {\n        width = scrollableWidth - offsetRight;\n      } else {\n        width = scrollableWidth;\n      }\n    }\n\n    return width;\n  },\n  _updatePlaceholderSizes: function _updatePlaceholderSizes($placeholderElement, itemElement) {\n    var dropInsideItem = this.option(\"dropInsideItem\");\n    var $item = $(itemElement);\n\n    var isVertical = this._isVerticalOrientation();\n\n    var width = \"\";\n    var height = \"\";\n    $placeholderElement.toggleClass(this._addWidgetPrefix(\"placeholder-inside\"), dropInsideItem);\n\n    if (isVertical || dropInsideItem) {\n      width = getOuterWidth($item);\n    }\n\n    if (!isVertical || dropInsideItem) {\n      height = getOuterHeight($item);\n    }\n\n    width = this._makeWidthCorrection($item, width);\n    $placeholderElement.css({\n      width: width,\n      height: height\n    });\n  },\n  _moveItem: function _moveItem($itemElement, index, cancelRemove) {\n    var $prevTargetItemElement;\n\n    var $itemElements = this._getItems();\n\n    var $targetItemElement = $itemElements[index];\n\n    var sourceDraggable = this._getSourceDraggable();\n\n    if (cancelRemove) {\n      $itemElement = $itemElement.clone();\n\n      sourceDraggable._toggleDragSourceClass(false, $itemElement);\n    }\n\n    if (!$targetItemElement) {\n      $prevTargetItemElement = $itemElements[index - 1];\n    }\n\n    this._moveItemCore($itemElement, $targetItemElement, $prevTargetItemElement);\n  },\n  _moveItemCore: function _moveItemCore($targetItem, item, prevItem) {\n    if (!item && !prevItem) {\n      $targetItem.appendTo(this.$element());\n    } else if (prevItem) {\n      $targetItem.insertAfter($(prevItem));\n    } else {\n      $targetItem.insertBefore($(item));\n    }\n  },\n  _getDragStartArgs: function _getDragStartArgs(e, $itemElement) {\n    return extend(this.callBase.apply(this, arguments), {\n      fromIndex: this._getElementIndex($itemElement)\n    });\n  },\n  _getEventArgs: function _getEventArgs(e) {\n    var sourceDraggable = this._getSourceDraggable();\n\n    var targetDraggable = this._getTargetDraggable();\n\n    var dropInsideItem = targetDraggable.option(\"dropInsideItem\");\n    return extend(this.callBase.apply(this, arguments), {\n      fromIndex: sourceDraggable.option(\"fromIndex\"),\n      toIndex: this._normalizeToIndex(targetDraggable.option(\"toIndex\"), dropInsideItem),\n      dropInsideItem: dropInsideItem\n    });\n  },\n  _optionChanged: function _optionChanged(args) {\n    var _this2 = this;\n\n    var name = args.name;\n\n    switch (name) {\n      case \"onDragChange\":\n      case \"onPlaceholderPrepared\":\n      case \"onAdd\":\n      case \"onRemove\":\n      case \"onReorder\":\n        this[\"_\" + name + \"Action\"] = this._createActionByOption(name);\n        break;\n\n      case \"itemOrientation\":\n      case \"allowDropInsideItem\":\n      case \"moveItemOnDrop\":\n      case \"dropFeedbackMode\":\n      case \"itemPoints\":\n      case \"animation\":\n      case \"allowReordering\":\n      case \"fromIndexOffset\":\n      case \"offset\":\n      case \"draggableElementSize\":\n      case \"autoUpdate\":\n        break;\n\n      case \"fromIndex\":\n        [false, true].forEach(function (isDragSource) {\n          var fromIndex = isDragSource ? args.value : args.previousValue;\n\n          if (null !== fromIndex) {\n            var $fromElement = $(_this2._getItems()[fromIndex]);\n\n            _this2._toggleDragSourceClass(isDragSource, $fromElement);\n          }\n        });\n        break;\n\n      case \"dropInsideItem\":\n        this._optionChangedDropInsideItem(args);\n\n        break;\n\n      case \"toIndex\":\n        this._optionChangedToIndex(args);\n\n        break;\n\n      default:\n        this.callBase(args);\n    }\n  },\n  _optionChangedDropInsideItem: function _optionChangedDropInsideItem() {\n    if (this._isIndicateMode() && this._$placeholderElement) {\n      this._movePlaceholder();\n    }\n  },\n  _isPositionVisible: function _isPositionVisible(position) {\n    var $element = this.$element();\n    var scrollContainer;\n\n    if (\"hidden\" !== $element.css(\"overflow\")) {\n      scrollContainer = $element.get(0);\n    } else {\n      $element.parents().each(function () {\n        if (\"visible\" !== $(this).css(\"overflow\")) {\n          scrollContainer = this;\n          return false;\n        }\n      });\n    }\n\n    if (scrollContainer) {\n      var clientRect = getBoundingRect(scrollContainer);\n\n      var isVerticalOrientation = this._isVerticalOrientation();\n\n      var start = isVerticalOrientation ? \"top\" : \"left\";\n      var end = isVerticalOrientation ? \"bottom\" : \"right\";\n      var pageOffset = isVerticalOrientation ? window.pageYOffset : window.pageXOffset;\n\n      if (position[start] < clientRect[start] + pageOffset || position[start] > clientRect[end] + pageOffset) {\n        return false;\n      }\n    }\n\n    return true;\n  },\n  _optionChangedToIndex: function _optionChangedToIndex(args) {\n    var toIndex = args.value;\n\n    if (this._isIndicateMode()) {\n      var showPlaceholder = null !== toIndex && toIndex >= 0;\n\n      this._togglePlaceholder(showPlaceholder);\n\n      if (showPlaceholder) {\n        this._movePlaceholder();\n      }\n    } else {\n      this._moveItems(args.previousValue, args.value, args.fullUpdate);\n    }\n  },\n  update: function update() {\n    if (null === this.option(\"fromIndex\") && null === this.option(\"toIndex\")) {\n      return;\n    }\n\n    this._updateItemPoints(true);\n\n    this._updateDragSourceClass();\n\n    var toIndex = this.option(\"toIndex\");\n\n    this._optionChangedToIndex({\n      value: toIndex,\n      fullUpdate: true\n    });\n  },\n  _updateDragSourceClass: function _updateDragSourceClass() {\n    var fromIndex = this._getActualFromIndex();\n\n    var $fromElement = $(this._getItems()[fromIndex]);\n\n    if ($fromElement.length) {\n      this._$sourceElement = $fromElement;\n\n      this._toggleDragSourceClass(true, $fromElement);\n    }\n  },\n  _makeLeftCorrection: function _makeLeftCorrection(left, leftMargin) {\n    var $scrollable = this._$scrollable;\n\n    if ($scrollable && this._isVerticalOrientation() && $scrollable.scrollLeft() > leftMargin) {\n      left += $scrollable.scrollLeft() - leftMargin;\n    }\n\n    return left;\n  },\n  _movePlaceholder: function _movePlaceholder() {\n    var $placeholderElement = this._$placeholderElement || this._createPlaceholder();\n\n    if (!$placeholderElement) {\n      return;\n    }\n\n    var items = this._getItems();\n\n    var toIndex = this.option(\"toIndex\");\n\n    var isVerticalOrientation = this._isVerticalOrientation();\n\n    var rtlEnabled = this.option(\"rtlEnabled\");\n    var dropInsideItem = this.option(\"dropInsideItem\");\n    var position = null;\n    var leftMargin = 0;\n    var itemElement = items[toIndex];\n\n    if (itemElement) {\n      var $itemElement = $(itemElement);\n      position = $itemElement.offset();\n      leftMargin = parseFloat($itemElement.css(\"marginLeft\"));\n\n      if (!isVerticalOrientation && rtlEnabled && !dropInsideItem) {\n        position.left += getOuterWidth($itemElement, true);\n      }\n    } else {\n      var prevVisibleItemElement = itemElement = this._getPrevVisibleItem(items, toIndex);\n\n      if (prevVisibleItemElement) {\n        position = $(prevVisibleItemElement).offset();\n\n        if (isVerticalOrientation) {\n          position.top += getOuterHeight(prevVisibleItemElement, true);\n        } else if (!rtlEnabled) {\n          position.left += getOuterWidth(prevVisibleItemElement, true);\n        }\n      }\n    }\n\n    this._updatePlaceholderSizes($placeholderElement, itemElement);\n\n    if (position && !this._isPositionVisible(position)) {\n      position = null;\n    }\n\n    if (position) {\n      position.left = this._makeLeftCorrection(position.left, leftMargin);\n\n      this._move(position, $placeholderElement);\n    }\n\n    $placeholderElement.toggle(!!position);\n  },\n  _getPositions: function _getPositions(items, elementSize, fromIndex, toIndex) {\n    var positions = [];\n\n    for (var i = 0; i < items.length; i++) {\n      var position = 0;\n\n      if (null === toIndex || null === fromIndex) {\n        positions.push(position);\n        continue;\n      }\n\n      if (-1 === fromIndex) {\n        if (i >= toIndex) {\n          position = elementSize;\n        }\n      } else if (-1 === toIndex) {\n        if (i > fromIndex) {\n          position = -elementSize;\n        }\n      } else if (fromIndex < toIndex) {\n        if (i > fromIndex && i < toIndex) {\n          position = -elementSize;\n        }\n      } else if (fromIndex > toIndex) {\n        if (i >= toIndex && i < fromIndex) {\n          position = elementSize;\n        }\n      }\n\n      positions.push(position);\n    }\n\n    return positions;\n  },\n  _getDraggableElementSize: function _getDraggableElementSize(isVerticalOrientation) {\n    var $draggableItem = this._getDraggableElement();\n\n    var size = this.option(\"draggableElementSize\");\n\n    if (!size) {\n      size = isVerticalOrientation ? (getOuterHeight($draggableItem) + getOuterHeight($draggableItem, true)) / 2 : (getOuterWidth($draggableItem) + getOuterWidth($draggableItem, true)) / 2;\n\n      if (!this.option(\"autoUpdate\")) {\n        this.option(\"draggableElementSize\", size);\n      }\n    }\n\n    return size;\n  },\n  _getActualFromIndex: function _getActualFromIndex() {\n    var _this$option = this.option(),\n        fromIndex = _this$option.fromIndex,\n        fromIndexOffset = _this$option.fromIndexOffset,\n        offset = _this$option.offset;\n\n    return null == fromIndex ? null : fromIndex + fromIndexOffset - offset;\n  },\n  _moveItems: function _moveItems(prevToIndex, toIndex, fullUpdate) {\n    var fromIndex = this._getActualFromIndex();\n\n    var isVerticalOrientation = this._isVerticalOrientation();\n\n    var positionPropName = isVerticalOrientation ? \"top\" : \"left\";\n\n    var elementSize = this._getDraggableElementSize(isVerticalOrientation);\n\n    var items = this._getItems();\n\n    var prevPositions = this._getPositions(items, elementSize, fromIndex, prevToIndex);\n\n    var positions = this._getPositions(items, elementSize, fromIndex, toIndex);\n\n    var animationConfig = this.option(\"animation\");\n    var rtlEnabled = this.option(\"rtlEnabled\");\n\n    for (var i = 0; i < items.length; i++) {\n      var itemElement = items[i];\n      var prevPosition = prevPositions[i];\n      var position = positions[i];\n\n      if (null === toIndex || null === fromIndex) {\n        stopAnimation(itemElement);\n      } else if (prevPosition !== position || fullUpdate && position) {\n        animate(itemElement, extend({}, animationConfig, {\n          to: _defineProperty({}, positionPropName, !isVerticalOrientation && rtlEnabled ? -position : position)\n        }));\n      }\n    }\n  },\n  _toggleDragSourceClass: function _toggleDragSourceClass(value, $element) {\n    var $sourceElement = $element || this._$sourceElement;\n    this.callBase.apply(this, arguments);\n\n    if (!this._isIndicateMode()) {\n      $sourceElement && $sourceElement.toggleClass(this._addWidgetPrefix(\"source-hidden\"), value);\n    }\n  },\n  _dispose: function _dispose() {\n    this.reset();\n    this.callBase();\n  },\n  _fireAddEvent: function _fireAddEvent(sourceEvent) {\n    var args = this._getEventArgs(sourceEvent);\n\n    this._getAction(\"onAdd\")(args);\n\n    return args.cancel;\n  },\n  _fireRemoveEvent: function _fireRemoveEvent(sourceEvent) {\n    var sourceDraggable = this._getSourceDraggable();\n\n    var args = this._getEventArgs(sourceEvent);\n\n    sourceDraggable._getAction(\"onRemove\")(args);\n\n    return args.cancel;\n  },\n  _fireReorderEvent: function _fireReorderEvent(sourceEvent) {\n    var args = this._getEventArgs(sourceEvent);\n\n    this._getAction(\"onReorder\")(args);\n\n    return args.promise || new Deferred().resolve();\n  }\n});\nregisterComponent(SORTABLE, Sortable);\nexport default Sortable;","map":null,"metadata":{},"sourceType":"module"}