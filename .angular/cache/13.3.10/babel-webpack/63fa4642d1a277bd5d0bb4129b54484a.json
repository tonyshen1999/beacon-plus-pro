{"ast":null,"code":"/**\r\n * DevExtreme (esm/viz/translators/translator2d.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { extend } from \"../../core/utils/extend\";\nimport { each } from \"../../core/utils/iterator\";\nimport { Range } from \"./range\";\nimport categoryTranslator from \"./category_translator\";\nimport intervalTranslator from \"./interval_translator\";\nimport datetimeTranslator from \"./datetime_translator\";\nimport logarithmicTranslator from \"./logarithmic_translator\";\nimport { getLogExt as getLog, getPower, raiseToExt, getCategoriesInfo } from \"../core/utils\";\nimport { isDefined, isDate } from \"../../core/utils/type\";\nimport { adjust } from \"../../core/utils/math\";\nimport dateUtils from \"../../core/utils/date\";\nvar _abs = Math.abs;\nvar CANVAS_PROP = [\"width\", \"height\", \"left\", \"top\", \"bottom\", \"right\"];\nvar dummyTranslator = {\n  to: function to(value) {\n    var coord = this._canvasOptions.startPoint + (this._options.conversionValue ? value : Math.round(value));\n    return coord > this._canvasOptions.endPoint ? this._canvasOptions.endPoint : coord;\n  },\n  from: function from(value) {\n    return value - this._canvasOptions.startPoint;\n  }\n};\n\nvar validateCanvas = function validateCanvas(canvas) {\n  each(CANVAS_PROP, function (_, prop) {\n    canvas[prop] = parseInt(canvas[prop]) || 0;\n  });\n  return canvas;\n};\n\nvar makeCategoriesToPoints = function makeCategoriesToPoints(categories) {\n  var categoriesToPoints = {};\n  categories.forEach(function (item, i) {\n    categoriesToPoints[item.valueOf()] = i;\n  });\n  return categoriesToPoints;\n};\n\nvar validateBusinessRange = function validateBusinessRange(businessRange) {\n  if (!(businessRange instanceof Range)) {\n    businessRange = new Range(businessRange);\n  }\n\n  function validate(valueSelector, baseValueSelector) {\n    if (!isDefined(businessRange[valueSelector]) && isDefined(businessRange[baseValueSelector])) {\n      businessRange[valueSelector] = businessRange[baseValueSelector];\n    }\n  }\n\n  validate(\"minVisible\", \"min\");\n  validate(\"maxVisible\", \"max\");\n  return businessRange;\n};\n\nfunction prepareBreaks(breaks, range) {\n  var transform = \"logarithmic\" === range.axisType ? function (value) {\n    return getLog(value, range.base);\n  } : function (value) {\n    return value;\n  };\n  var array = [];\n  var br;\n  var transformFrom;\n  var transformTo;\n  var i;\n  var length = breaks.length;\n  var sum = 0;\n\n  for (i = 0; i < length; i++) {\n    br = breaks[i];\n    transformFrom = transform(br.from);\n    transformTo = transform(br.to);\n    sum += transformTo - transformFrom;\n    array.push({\n      trFrom: transformFrom,\n      trTo: transformTo,\n      from: br.from,\n      to: br.to,\n      length: sum,\n      cumulativeWidth: br.cumulativeWidth\n    });\n  }\n\n  return array;\n}\n\nfunction getCanvasBounds(range) {\n  var min = range.min;\n  var max = range.max;\n  var minVisible = range.minVisible;\n  var maxVisible = range.maxVisible;\n  var isLogarithmic = \"logarithmic\" === range.axisType;\n\n  if (isLogarithmic) {\n    maxVisible = getLog(maxVisible, range.base, range.allowNegatives, range.linearThreshold);\n    minVisible = getLog(minVisible, range.base, range.allowNegatives, range.linearThreshold);\n    min = getLog(min, range.base, range.allowNegatives, range.linearThreshold);\n    max = getLog(max, range.base, range.allowNegatives, range.linearThreshold);\n  }\n\n  return {\n    base: range.base,\n    rangeMin: min,\n    rangeMax: max,\n    rangeMinVisible: minVisible,\n    rangeMaxVisible: maxVisible\n  };\n}\n\nfunction getCheckingMethodsAboutBreaks(inverted) {\n  return {\n    isStartSide: !inverted ? function (pos, breaks, start, end) {\n      return pos < breaks[0][start];\n    } : function (pos, breaks, start, end) {\n      return pos <= breaks[breaks.length - 1][end];\n    },\n    isEndSide: !inverted ? function (pos, breaks, start, end) {\n      return pos >= breaks[breaks.length - 1][end];\n    } : function (pos, breaks, start, end) {\n      return pos > breaks[0][start];\n    },\n    isInBreak: !inverted ? function (pos, br, start, end) {\n      return pos >= br[start] && pos < br[end];\n    } : function (pos, br, start, end) {\n      return pos > br[end] && pos <= br[start];\n    },\n    isBetweenBreaks: !inverted ? function (pos, br, prevBreak, start, end) {\n      return pos < br[start] && pos >= prevBreak[end];\n    } : function (pos, br, prevBreak, start, end) {\n      return pos >= br[end] && pos < prevBreak[start];\n    },\n    getLength: !inverted ? function (br) {\n      return br.length;\n    } : function (br, lastBreak) {\n      return lastBreak.length - br.length;\n    },\n    getBreaksSize: !inverted ? function (br) {\n      return br.cumulativeWidth;\n    } : function (br, lastBreak) {\n      return lastBreak.cumulativeWidth - br.cumulativeWidth;\n    }\n  };\n}\n\nvar _Translator2d = function _Translator2d(businessRange, canvas, options) {\n  this.update(businessRange, canvas, options);\n};\n\n_Translator2d.prototype = {\n  constructor: _Translator2d,\n  reinit: function reinit() {\n    var that = this;\n    var options = that._options;\n    var range = that._businessRange;\n    var categories = range.categories || [];\n    var script = {};\n\n    var canvasOptions = that._prepareCanvasOptions();\n\n    var visibleCategories = getCategoriesInfo(categories, range.minVisible, range.maxVisible).categories;\n    var categoriesLength = visibleCategories.length;\n\n    if (range.isEmpty()) {\n      script = dummyTranslator;\n    } else {\n      switch (range.axisType) {\n        case \"logarithmic\":\n          script = logarithmicTranslator;\n          break;\n\n        case \"semidiscrete\":\n          script = intervalTranslator;\n          canvasOptions.ratioOfCanvasRange = canvasOptions.canvasLength / (dateUtils.addInterval(canvasOptions.rangeMaxVisible, options.interval) - canvasOptions.rangeMinVisible);\n          break;\n\n        case \"discrete\":\n          script = categoryTranslator;\n          that._categories = categories;\n          canvasOptions.interval = that._getDiscreteInterval(options.addSpiderCategory ? categoriesLength + 1 : categoriesLength, canvasOptions);\n          that._categoriesToPoints = makeCategoriesToPoints(categories);\n\n          if (categoriesLength) {\n            canvasOptions.startPointIndex = that._categoriesToPoints[visibleCategories[0].valueOf()];\n            that.visibleCategories = visibleCategories;\n          }\n\n          break;\n\n        default:\n          if (\"datetime\" === range.dataType) {\n            script = datetimeTranslator;\n          }\n\n      }\n    }\n\n    (that._oldMethods || []).forEach(function (methodName) {\n      delete that[methodName];\n    });\n    that._oldMethods = Object.keys(script);\n    extend(that, script);\n    that._conversionValue = options.conversionValue ? function (value) {\n      return value;\n    } : function (value) {\n      return Math.round(value);\n    };\n    that.sc = {};\n    that._checkingMethodsAboutBreaks = [getCheckingMethodsAboutBreaks(false), getCheckingMethodsAboutBreaks(that.isInverted())];\n\n    that._translateBreaks();\n\n    that._calculateSpecialValues();\n  },\n  _translateBreaks: function _translateBreaks() {\n    var breaks = this._breaks;\n    var size = this._options.breaksSize;\n    var i;\n    var b;\n    var end;\n    var length;\n\n    if (void 0 === breaks) {\n      return;\n    }\n\n    for (i = 0, length = breaks.length; i < length; i++) {\n      b = breaks[i];\n      end = this.translate(b.to);\n      b.end = end;\n      b.start = !b.gapSize ? !this.isInverted() ? end - size : end + size : end;\n    }\n  },\n  _checkValueAboutBreaks: function _checkValueAboutBreaks(breaks, pos, start, end, methods) {\n    var i;\n    var length;\n    var prop = {\n      length: 0,\n      breaksSize: void 0,\n      inBreak: false\n    };\n    var br;\n    var prevBreak;\n    var lastBreak = breaks[breaks.length - 1];\n\n    if (methods.isStartSide(pos, breaks, start, end)) {\n      return prop;\n    } else if (methods.isEndSide(pos, breaks, start, end)) {\n      return {\n        length: lastBreak.length,\n        breaksSize: lastBreak.cumulativeWidth,\n        inBreak: false\n      };\n    }\n\n    for (i = 0, length = breaks.length; i < length; i++) {\n      br = breaks[i];\n      prevBreak = breaks[i - 1];\n\n      if (methods.isInBreak(pos, br, start, end)) {\n        prop.inBreak = true;\n        prop.break = br;\n        break;\n      }\n\n      if (prevBreak && methods.isBetweenBreaks(pos, br, prevBreak, start, end)) {\n        prop = {\n          length: methods.getLength(prevBreak, lastBreak),\n          breaksSize: methods.getBreaksSize(prevBreak, lastBreak),\n          inBreak: false\n        };\n        break;\n      }\n    }\n\n    return prop;\n  },\n  isInverted: function isInverted() {\n    return !(this._options.isHorizontal ^ this._businessRange.invert);\n  },\n  _getDiscreteInterval: function _getDiscreteInterval(categoriesLength, canvasOptions) {\n    var correctedCategoriesCount = categoriesLength - (this._options.stick ? 1 : 0);\n    return correctedCategoriesCount > 0 ? canvasOptions.canvasLength / correctedCategoriesCount : canvasOptions.canvasLength;\n  },\n  _prepareCanvasOptions: function _prepareCanvasOptions() {\n    var businessRange = this._businessRange;\n    var canvasOptions = this._canvasOptions = getCanvasBounds(businessRange);\n    var canvas = this._canvas;\n    var breaks = this._breaks;\n    var length;\n    canvasOptions.startPadding = canvas.startPadding || 0;\n    canvasOptions.endPadding = canvas.endPadding || 0;\n\n    if (this._options.isHorizontal) {\n      canvasOptions.startPoint = canvas.left + canvasOptions.startPadding;\n      length = canvas.width;\n      canvasOptions.endPoint = canvas.width - canvas.right - canvasOptions.endPadding;\n      canvasOptions.invert = businessRange.invert;\n    } else {\n      canvasOptions.startPoint = canvas.top + canvasOptions.startPadding;\n      length = canvas.height;\n      canvasOptions.endPoint = canvas.height - canvas.bottom - canvasOptions.endPadding;\n      canvasOptions.invert = !businessRange.invert;\n    }\n\n    this.canvasLength = canvasOptions.canvasLength = canvasOptions.endPoint - canvasOptions.startPoint;\n    canvasOptions.rangeDoubleError = Math.pow(10, getPower(canvasOptions.rangeMax - canvasOptions.rangeMin) - getPower(length) - 2);\n    canvasOptions.ratioOfCanvasRange = canvasOptions.canvasLength / (canvasOptions.rangeMaxVisible - canvasOptions.rangeMinVisible);\n\n    if (void 0 !== breaks) {\n      canvasOptions.ratioOfCanvasRange = (canvasOptions.canvasLength - breaks[breaks.length - 1].cumulativeWidth) / (canvasOptions.rangeMaxVisible - canvasOptions.rangeMinVisible - breaks[breaks.length - 1].length);\n    }\n\n    return canvasOptions;\n  },\n  updateCanvas: function updateCanvas(canvas) {\n    this._canvas = validateCanvas(canvas);\n    this.reinit();\n  },\n  updateBusinessRange: function updateBusinessRange(businessRange) {\n    var breaks = businessRange.breaks || [];\n    this._userBreaks = businessRange.userBreaks || [];\n    this._businessRange = validateBusinessRange(businessRange);\n    this._breaks = breaks.length ? prepareBreaks(breaks, this._businessRange) : void 0;\n    this.reinit();\n  },\n  update: function update(businessRange, canvas, options) {\n    this._options = extend(this._options || {}, options);\n    this._canvas = validateCanvas(canvas);\n    this.updateBusinessRange(businessRange);\n  },\n  getBusinessRange: function getBusinessRange() {\n    return this._businessRange;\n  },\n  getEventScale: function getEventScale(zoomEvent) {\n    return zoomEvent.deltaScale || 1;\n  },\n  getCanvasVisibleArea: function getCanvasVisibleArea() {\n    return {\n      min: this._canvasOptions.startPoint,\n      max: this._canvasOptions.endPoint\n    };\n  },\n  _calculateSpecialValues: function _calculateSpecialValues() {\n    var canvasOptions = this._canvasOptions;\n    var startPoint = canvasOptions.startPoint - canvasOptions.startPadding;\n    var endPoint = canvasOptions.endPoint + canvasOptions.endPadding;\n    var range = this._businessRange;\n    var minVisible = range.minVisible;\n    var maxVisible = range.maxVisible;\n    var canvas_position_center_middle = startPoint + canvasOptions.canvasLength / 2;\n    var canvas_position_default;\n\n    if (minVisible < 0 && maxVisible > 0 && minVisible !== maxVisible) {\n      canvas_position_default = this.translate(0, 1);\n    }\n\n    if (!isDefined(canvas_position_default)) {\n      var invert = range.invert ^ (minVisible < 0 && maxVisible <= 0);\n\n      if (this._options.isHorizontal) {\n        canvas_position_default = invert ? endPoint : startPoint;\n      } else {\n        canvas_position_default = invert ? startPoint : endPoint;\n      }\n    }\n\n    this.sc = {\n      canvas_position_default: canvas_position_default,\n      canvas_position_left: startPoint,\n      canvas_position_top: startPoint,\n      canvas_position_center: canvas_position_center_middle,\n      canvas_position_middle: canvas_position_center_middle,\n      canvas_position_right: endPoint,\n      canvas_position_bottom: endPoint,\n      canvas_position_start: canvasOptions.invert ? endPoint : startPoint,\n      canvas_position_end: canvasOptions.invert ? startPoint : endPoint\n    };\n  },\n  translateSpecialCase: function translateSpecialCase(value) {\n    return this.sc[value];\n  },\n  _calculateProjection: function _calculateProjection(distance) {\n    var canvasOptions = this._canvasOptions;\n    return canvasOptions.invert ? canvasOptions.endPoint - distance : canvasOptions.startPoint + distance;\n  },\n  _calculateUnProjection: function _calculateUnProjection(distance) {\n    var canvasOptions = this._canvasOptions;\n    \"datetime\" === this._businessRange.dataType && (distance = Math.round(distance));\n    return canvasOptions.invert ? canvasOptions.rangeMaxVisible.valueOf() - distance : canvasOptions.rangeMinVisible.valueOf() + distance;\n  },\n  getMinBarSize: function getMinBarSize(minBarSize) {\n    var visibleArea = this.getCanvasVisibleArea();\n    var minValue = this.from(visibleArea.min + minBarSize);\n    return _abs(this.from(visibleArea.min) - (!isDefined(minValue) ? this.from(visibleArea.max) : minValue));\n  },\n  checkMinBarSize: function checkMinBarSize(value, minShownValue, stackValue) {\n    return _abs(value) < minShownValue ? value >= 0 ? minShownValue : -minShownValue : value;\n  },\n  translate: function translate(bp, direction) {\n    var specialValue = this.translateSpecialCase(bp);\n\n    if (isDefined(specialValue)) {\n      return Math.round(specialValue);\n    }\n\n    if (isNaN(bp)) {\n      return null;\n    }\n\n    return this.to(bp, direction);\n  },\n  getInterval: function getInterval(interval) {\n    var _interval;\n\n    var canvasOptions = this._canvasOptions;\n    interval = null !== (_interval = interval) && void 0 !== _interval ? _interval : this._businessRange.interval;\n\n    if (interval) {\n      return Math.round(canvasOptions.ratioOfCanvasRange * interval);\n    }\n\n    return Math.round(canvasOptions.endPoint - canvasOptions.startPoint);\n  },\n  zoom: function zoom(translate, scale, wholeRange) {\n    var canvasOptions = this._canvasOptions;\n\n    if (canvasOptions.rangeMinVisible.valueOf() === canvasOptions.rangeMaxVisible.valueOf() && 0 !== translate) {\n      return this.zoomZeroLengthRange(translate, scale);\n    }\n\n    var startPoint = canvasOptions.startPoint;\n    var endPoint = canvasOptions.endPoint;\n    var isInverted = this.isInverted();\n    var newStart = (startPoint + translate) / scale;\n    var newEnd = (endPoint + translate) / scale;\n    wholeRange = wholeRange || {};\n    var minPoint = this.to(isInverted ? wholeRange.endValue : wholeRange.startValue);\n    var maxPoint = this.to(isInverted ? wholeRange.startValue : wholeRange.endValue);\n    var min;\n    var max;\n\n    if (minPoint > newStart) {\n      newEnd -= newStart - minPoint;\n      newStart = minPoint;\n      min = isInverted ? wholeRange.endValue : wholeRange.startValue;\n    }\n\n    if (maxPoint < newEnd) {\n      newStart -= newEnd - maxPoint;\n      newEnd = maxPoint;\n      max = isInverted ? wholeRange.startValue : wholeRange.endValue;\n    }\n\n    if (maxPoint - minPoint < newEnd - newStart) {\n      newStart = minPoint;\n      newEnd = maxPoint;\n    }\n\n    translate = (endPoint - startPoint) * newStart / (newEnd - newStart) - startPoint;\n    scale = (startPoint + translate) / newStart || 1;\n    min = isDefined(min) ? min : adjust(this.from(newStart, 1));\n    max = isDefined(max) ? max : adjust(this.from(newEnd, -1));\n\n    if (scale <= 1) {\n      min = this._correctValueAboutBreaks(min, 1 === scale ? translate : -1);\n      max = this._correctValueAboutBreaks(max, 1 === scale ? translate : 1);\n    }\n\n    if (min > max) {\n      min = min > wholeRange.endValue ? wholeRange.endValue : min;\n      max = max < wholeRange.startValue ? wholeRange.startValue : max;\n    } else {\n      min = min < wholeRange.startValue ? wholeRange.startValue : min;\n      max = max > wholeRange.endValue ? wholeRange.endValue : max;\n    }\n\n    return {\n      min: min,\n      max: max,\n      translate: adjust(translate),\n      scale: adjust(scale)\n    };\n  },\n  _correctValueAboutBreaks: function _correctValueAboutBreaks(value, direction) {\n    var br = this._userBreaks.filter(function (br) {\n      return value >= br.from && value <= br.to;\n    });\n\n    if (br.length) {\n      return direction > 0 ? br[0].to : br[0].from;\n    } else {\n      return value;\n    }\n  },\n  zoomZeroLengthRange: function zoomZeroLengthRange(translate, scale) {\n    var canvasOptions = this._canvasOptions;\n    var min = canvasOptions.rangeMin;\n    var max = canvasOptions.rangeMax;\n    var correction = (max.valueOf() !== min.valueOf() ? max.valueOf() - min.valueOf() : _abs(canvasOptions.rangeMinVisible.valueOf() - min.valueOf())) / canvasOptions.canvasLength;\n    var isDateTime = isDate(max) || isDate(min);\n    var isLogarithmic = \"logarithmic\" === this._businessRange.axisType;\n    var newMin = canvasOptions.rangeMinVisible.valueOf() - correction;\n    var newMax = canvasOptions.rangeMaxVisible.valueOf() + correction;\n    newMin = isLogarithmic ? adjust(raiseToExt(newMin, canvasOptions.base)) : isDateTime ? new Date(newMin) : newMin;\n    newMax = isLogarithmic ? adjust(raiseToExt(newMax, canvasOptions.base)) : isDateTime ? new Date(newMax) : newMax;\n    return {\n      min: newMin,\n      max: newMax,\n      translate: translate,\n      scale: scale\n    };\n  },\n  getMinScale: function getMinScale(zoom) {\n    var _this$_businessRange = this._businessRange,\n        dataType = _this$_businessRange.dataType,\n        interval = _this$_businessRange.interval;\n\n    if (\"datetime\" === dataType && 1 === interval) {\n      return this.getDateTimeMinScale(zoom);\n    }\n\n    return zoom ? 1.1 : .9;\n  },\n  getDateTimeMinScale: function getDateTimeMinScale(zoom) {\n    var canvasOptions = this._canvasOptions;\n    var length = canvasOptions.canvasLength / canvasOptions.ratioOfCanvasRange;\n    length += (parseInt(.1 * length) || 1) * (zoom ? -2 : 2);\n    return canvasOptions.canvasLength / (Math.max(length, 1) * canvasOptions.ratioOfCanvasRange);\n  },\n  getScale: function getScale(val1, val2) {\n    var canvasOptions = this._canvasOptions;\n\n    if (canvasOptions.rangeMax === canvasOptions.rangeMin) {\n      return 1;\n    }\n\n    val1 = isDefined(val1) ? this.fromValue(val1) : canvasOptions.rangeMin;\n    val2 = isDefined(val2) ? this.fromValue(val2) : canvasOptions.rangeMax;\n    return (canvasOptions.rangeMax - canvasOptions.rangeMin) / Math.abs(val1 - val2);\n  },\n  isValid: function isValid(value) {\n    var co = this._canvasOptions;\n    value = this.fromValue(value);\n    return null !== value && !isNaN(value) && value.valueOf() + co.rangeDoubleError >= co.rangeMin && value.valueOf() - co.rangeDoubleError <= co.rangeMax;\n  },\n  getCorrectValue: function getCorrectValue(value, direction) {\n    var breaks = this._breaks;\n    var prop;\n    value = this.fromValue(value);\n\n    if (this._breaks) {\n      prop = this._checkValueAboutBreaks(breaks, value, \"trFrom\", \"trTo\", this._checkingMethodsAboutBreaks[0]);\n\n      if (true === prop.inBreak) {\n        return this.toValue(direction > 0 ? prop.break.trTo : prop.break.trFrom);\n      }\n    }\n\n    return this.toValue(value);\n  },\n  to: function to(bp, direction) {\n    var range = this.getBusinessRange();\n\n    if (isDefined(range.maxVisible) && isDefined(range.minVisible) && range.maxVisible.valueOf() === range.minVisible.valueOf()) {\n      if (!isDefined(bp) || range.maxVisible.valueOf() !== bp.valueOf()) {\n        return null;\n      }\n\n      return this.translateSpecialCase(0 === bp && this._options.shiftZeroValue ? \"canvas_position_default\" : \"canvas_position_middle\");\n    }\n\n    bp = this.fromValue(bp);\n    var canvasOptions = this._canvasOptions;\n    var breaks = this._breaks;\n    var prop = {\n      length: 0\n    };\n    var commonBreakSize = 0;\n\n    if (void 0 !== breaks) {\n      prop = this._checkValueAboutBreaks(breaks, bp, \"trFrom\", \"trTo\", this._checkingMethodsAboutBreaks[0]);\n      commonBreakSize = isDefined(prop.breaksSize) ? prop.breaksSize : 0;\n    }\n\n    if (true === prop.inBreak) {\n      if (direction > 0) {\n        return prop.break.start;\n      } else if (direction < 0) {\n        return prop.break.end;\n      } else {\n        return null;\n      }\n    }\n\n    return this._conversionValue(this._calculateProjection((bp - canvasOptions.rangeMinVisible - prop.length) * canvasOptions.ratioOfCanvasRange + commonBreakSize));\n  },\n  from: function from(pos, direction) {\n    var breaks = this._breaks;\n    var prop = {\n      length: 0\n    };\n    var canvasOptions = this._canvasOptions;\n    var startPoint = canvasOptions.startPoint;\n    var commonBreakSize = 0;\n\n    if (void 0 !== breaks) {\n      prop = this._checkValueAboutBreaks(breaks, pos, \"start\", \"end\", this._checkingMethodsAboutBreaks[1]);\n      commonBreakSize = isDefined(prop.breaksSize) ? prop.breaksSize : 0;\n    }\n\n    if (true === prop.inBreak) {\n      if (direction > 0) {\n        return this.toValue(prop.break.trTo);\n      } else if (direction < 0) {\n        return this.toValue(prop.break.trFrom);\n      } else {\n        return null;\n      }\n    }\n\n    return this.toValue(this._calculateUnProjection((pos - startPoint - commonBreakSize) / canvasOptions.ratioOfCanvasRange + prop.length));\n  },\n  isValueProlonged: false,\n  getRange: function getRange() {\n    return [this.toValue(this._canvasOptions.rangeMin), this.toValue(this._canvasOptions.rangeMax)];\n  },\n  getScreenRange: function getScreenRange() {\n    return [this._canvasOptions.startPoint, this._canvasOptions.endPoint];\n  },\n  add: function add(value, diff, dir) {\n    return this._add(value, diff, (this._businessRange.invert ? -1 : 1) * dir);\n  },\n  _add: function _add(value, diff, coeff) {\n    return this.toValue(this.fromValue(value) + diff * coeff);\n  },\n  fromValue: function fromValue(value) {\n    return null !== value ? Number(value) : null;\n  },\n  toValue: function toValue(value) {\n    return null !== value ? Number(value) : null;\n  },\n  ratioOfCanvasRange: function ratioOfCanvasRange() {\n    return this._canvasOptions.ratioOfCanvasRange;\n  },\n  convert: function convert(value) {\n    return value;\n  },\n  getRangeByMinZoomValue: function getRangeByMinZoomValue(minZoom, visualRange) {\n    if (visualRange.minVisible + minZoom <= this._businessRange.max) {\n      return [visualRange.minVisible, visualRange.minVisible + minZoom];\n    } else {\n      return [visualRange.maxVisible - minZoom, visualRange.maxVisible];\n    }\n  }\n};\nexport { _Translator2d as Translator2D };","map":null,"metadata":{},"sourceType":"module"}