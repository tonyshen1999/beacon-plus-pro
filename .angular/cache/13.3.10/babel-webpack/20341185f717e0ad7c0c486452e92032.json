{"ast":null,"code":"/**\r\n * DevExtreme (esm/viz/gauges/linear_gauge.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { each as _each } from \"../../core/utils/iterator\";\nvar _max = Math.max;\nvar _min = Math.min;\nvar _round = Math.round;\nimport registerComponent from \"../../core/component_registrator\";\nimport { extend } from \"../../core/utils/extend\";\nimport { clone } from \"../../core/utils/object\";\nimport { BaseGauge } from \"./base_gauge\";\nimport { dxGauge, createIndicatorCreator } from \"./common\";\nimport { normalizeEnum as _normalizeEnum } from \"../core/utils\";\nimport * as linearIndicators from \"./linear_indicators\";\nimport LinearRangeContainer from \"./linear_range_container\";\nvar dxLinearGauge = dxGauge.inherit({\n  _rootClass: \"dxg-linear-gauge\",\n  _factoryMethods: {\n    rangeContainer: \"createLinearRangeContainer\",\n    indicator: \"createLinearIndicator\"\n  },\n  _gridSpacingFactor: 25,\n  _scaleTypes: {\n    type: \"xyAxes\",\n    drawingType: \"linear\"\n  },\n  _getTicksOrientation: function _getTicksOrientation(scaleOptions) {\n    return scaleOptions.isHorizontal ? scaleOptions.verticalOrientation : scaleOptions.horizontalOrientation;\n  },\n  _getThemeManagerOptions: function _getThemeManagerOptions() {\n    var options = this.callBase.apply(this, arguments);\n    options.subTheme = \"_linear\";\n    return options;\n  },\n  _getInvertedState: function _getInvertedState() {\n    return !this._area.vertical && this.option(\"rtlEnabled\");\n  },\n  _prepareScaleSettings: function _prepareScaleSettings() {\n    var scaleOptions = this.callBase();\n    scaleOptions.inverted = this._getInvertedState();\n    return scaleOptions;\n  },\n  _updateScaleTickIndent: function _updateScaleTickIndent(scaleOptions) {\n    var indentFromTick = scaleOptions.label.indentFromTick;\n    var length = scaleOptions.tick.length;\n\n    var textParams = this._scale.measureLabels(extend({}, this._canvas));\n\n    var verticalTextCorrection = scaleOptions.isHorizontal ? textParams.height + textParams.y : 0;\n    var isIndentPositive = indentFromTick > 0;\n    var orientation;\n    var textCorrection;\n    var tickCorrection;\n\n    if (scaleOptions.isHorizontal) {\n      orientation = isIndentPositive ? {\n        center: .5,\n        top: 0,\n        bottom: 1\n      } : {\n        center: .5,\n        top: 1,\n        bottom: 0\n      };\n      tickCorrection = length * orientation[scaleOptions.verticalOrientation];\n      textCorrection = textParams.y;\n    } else {\n      orientation = isIndentPositive ? {\n        center: .5,\n        left: 0,\n        right: 1\n      } : {\n        center: .5,\n        left: 1,\n        right: 0\n      };\n      tickCorrection = length * orientation[scaleOptions.horizontalOrientation];\n      textCorrection = -textParams.width;\n    }\n\n    scaleOptions.label.indentFromAxis = -indentFromTick + (isIndentPositive ? -tickCorrection + textCorrection : tickCorrection - verticalTextCorrection);\n\n    this._scale.updateOptions(scaleOptions);\n  },\n  _shiftScale: function _shiftScale(layout, scaleOptions) {\n    var canvas = extend({}, this._canvas);\n    var isHorizontal = scaleOptions.isHorizontal;\n    var scale = this._scale;\n    canvas[isHorizontal ? \"left\" : \"top\"] = this._area[isHorizontal ? \"startCoord\" : \"endCoord\"];\n    canvas[isHorizontal ? \"right\" : \"bottom\"] = canvas[isHorizontal ? \"width\" : \"height\"] - this._area[isHorizontal ? \"endCoord\" : \"startCoord\"];\n    scale.draw(canvas);\n    scale.shift({\n      left: -layout.x,\n      top: -layout.y\n    });\n  },\n  _setupCodomain: function _setupCodomain() {\n    var geometry = this.option(\"geometry\") || {};\n\n    var vertical = \"vertical\" === _normalizeEnum(geometry.orientation);\n\n    this._area = {\n      vertical: vertical,\n      x: 0,\n      y: 0,\n      startCoord: -100,\n      endCoord: 100\n    };\n    this._rangeContainer.vertical = vertical;\n\n    this._translator.setInverted(this._getInvertedState());\n\n    this._translator.setCodomain(-100, 100);\n  },\n  _getScaleLayoutValue: function _getScaleLayoutValue() {\n    return this._area[this._area.vertical ? \"x\" : \"y\"];\n  },\n  _getTicksCoefficients: function _getTicksCoefficients(options) {\n    var coefs = {\n      inner: 0,\n      outer: 1\n    };\n\n    if (this._area.vertical) {\n      if (\"left\" === options.horizontalOrientation) {\n        coefs.inner = 1;\n        coefs.outer = 0;\n      } else if (\"center\" === options.horizontalOrientation) {\n        coefs.inner = coefs.outer = .5;\n      }\n    } else if (\"top\" === options.verticalOrientation) {\n      coefs.inner = 1;\n      coefs.outer = 0;\n    } else if (\"center\" === options.verticalOrientation) {\n      coefs.inner = coefs.outer = .5;\n    }\n\n    return coefs;\n  },\n  _correctScaleIndents: function _correctScaleIndents(result, indentFromTick, textParams) {\n    var vertical = this._area.vertical;\n\n    if (indentFromTick >= 0) {\n      result.max += indentFromTick + textParams[vertical ? \"width\" : \"height\"];\n    } else {\n      result.min -= -indentFromTick + textParams[vertical ? \"width\" : \"height\"];\n    }\n\n    result.indent = textParams[vertical ? \"height\" : \"width\"] / 2;\n  },\n  _measureMainElements: function _measureMainElements(elements, scaleMeasurement) {\n    var x = this._area.x;\n    var y = this._area.y;\n    var minBound = 1e3;\n    var maxBound = 0;\n    var indent = 0;\n    var scale = this._scale;\n\n    _each(elements.concat(scale), function (_, element) {\n      var bounds = element.measure ? element.measure({\n        x: x + element.getOffset(),\n        y: y + element.getOffset()\n      }) : scaleMeasurement;\n      void 0 !== bounds.max && (maxBound = _max(maxBound, bounds.max));\n      void 0 !== bounds.min && (minBound = _min(minBound, bounds.min));\n      bounds.indent > 0 && (indent = _max(indent, bounds.indent));\n    });\n\n    return {\n      minBound: minBound,\n      maxBound: maxBound,\n      indent: indent\n    };\n  },\n  _applyMainLayout: function _applyMainLayout(elements, scaleMeasurement) {\n    var measurements = this._measureMainElements(elements, scaleMeasurement);\n\n    var area = this._area;\n    var rect;\n    var offset;\n\n    if (area.vertical) {\n      rect = selectRectBySizes(this._innerRect, {\n        width: measurements.maxBound - measurements.minBound\n      });\n      offset = (rect.left + rect.right) / 2 - (measurements.minBound + measurements.maxBound) / 2;\n      area.startCoord = rect.bottom - measurements.indent;\n      area.endCoord = rect.top + measurements.indent;\n      area.x = _round(area.x + offset);\n    } else {\n      rect = selectRectBySizes(this._innerRect, {\n        height: measurements.maxBound - measurements.minBound\n      });\n      offset = (rect.top + rect.bottom) / 2 - (measurements.minBound + measurements.maxBound) / 2;\n      area.startCoord = rect.left + measurements.indent;\n      area.endCoord = rect.right - measurements.indent;\n      area.y = _round(area.y + offset);\n    }\n\n    this._translator.setCodomain(area.startCoord, area.endCoord);\n\n    this._innerRect = rect;\n  },\n  _getElementLayout: function _getElementLayout(offset) {\n    return {\n      x: _round(this._area.x + offset),\n      y: _round(this._area.y + offset)\n    };\n  },\n  _getApproximateScreenRange: function _getApproximateScreenRange() {\n    var area = this._area;\n    var s = area.vertical ? this._canvas.height : this._canvas.width;\n    s > area.totalSize && (s = area.totalSize);\n    s *= .8;\n    return s;\n  },\n  _getDefaultSize: function _getDefaultSize() {\n    var geometry = this.option(\"geometry\") || {};\n\n    if (\"vertical\" === geometry.orientation) {\n      return {\n        width: 100,\n        height: 300\n      };\n    } else {\n      return {\n        width: 300,\n        height: 100\n      };\n    }\n  },\n  _factory: clone(BaseGauge.prototype._factory)\n});\n\nfunction selectRectBySizes(srcRect, sizes, margins) {\n  var rect = extend({}, srcRect);\n  var step;\n  margins = margins || {};\n\n  if (sizes) {\n    rect.left += margins.left || 0;\n    rect.right -= margins.right || 0;\n    rect.top += margins.top || 0;\n    rect.bottom -= margins.bottom || 0;\n\n    if (sizes.width > 0) {\n      step = (rect.right - rect.left - sizes.width) / 2;\n\n      if (step > 0) {\n        rect.left += step;\n        rect.right -= step;\n      }\n    }\n\n    if (sizes.height > 0) {\n      step = (rect.bottom - rect.top - sizes.height) / 2;\n\n      if (step > 0) {\n        rect.top += step;\n        rect.bottom -= step;\n      }\n    }\n  }\n\n  return rect;\n}\n\nvar indicators = dxLinearGauge.prototype._factory.indicators = {};\ndxLinearGauge.prototype._factory.createIndicator = createIndicatorCreator(indicators);\nindicators._default = linearIndicators._default;\nindicators.rectangle = linearIndicators.rectangle;\nindicators.rhombus = linearIndicators.rhombus;\nindicators.circle = linearIndicators.circle;\nindicators.trianglemarker = linearIndicators.trianglemarker;\nindicators.textcloud = linearIndicators.textcloud;\nindicators.rangebar = linearIndicators.rangebar;\ndxLinearGauge.prototype._factory.RangeContainer = LinearRangeContainer;\nregisterComponent(\"dxLinearGauge\", dxLinearGauge);\nexport default dxLinearGauge;","map":null,"metadata":{},"sourceType":"module"}