{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/data_grid/ui.data_grid.grouping.expanded.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { toComparable } from \"../../core/utils/data\";\nimport { keysEqual } from \"../../data/utils\";\nimport { each } from \"../../core/utils/iterator\";\nimport { extend } from \"../../core/utils/extend\";\nimport storeHelper from \"../../data/store_helper\";\nimport dataGridCore from \"./ui.data_grid.core\";\nimport { GroupingHelper as GroupingHelperCore, createOffsetFilter } from \"./ui.data_grid.grouping.core\";\nimport { createGroupFilter } from \"./ui.data_grid.utils\";\nimport dataQuery from \"../../data/query\";\nimport { when, Deferred } from \"../../core/utils/deferred\";\n\nvar loadTotalCount = function loadTotalCount(dataSource, options) {\n  var d = new Deferred();\n  var loadOptions = extend({\n    skip: 0,\n    take: 1,\n    requireTotalCount: true\n  }, options);\n  dataSource.load(loadOptions).done(function (data, extra) {\n    d.resolve(extra && extra.totalCount);\n  }).fail(d.reject.bind(d));\n  return d;\n};\n\nexport var GroupingHelper = GroupingHelperCore.inherit(function () {\n  var foreachCollapsedGroups = function foreachCollapsedGroups(that, callback, updateOffsets) {\n    return that.foreachGroups(function (groupInfo) {\n      if (!groupInfo.isExpanded) {\n        return callback(groupInfo);\n      }\n    }, false, false, updateOffsets, true);\n  };\n\n  var correctSkipLoadOption = function correctSkipLoadOption(that, skip) {\n    var skipCorrection = 0;\n    var resultSkip = skip || 0;\n\n    if (skip) {\n      foreachCollapsedGroups(that, function (groupInfo) {\n        if (groupInfo.offset - skipCorrection >= skip) {\n          return false;\n        }\n\n        skipCorrection += groupInfo.count - 1;\n      });\n      resultSkip += skipCorrection;\n    }\n\n    return resultSkip;\n  };\n\n  var pathEquals = function pathEquals(path1, path2) {\n    if (path1.length !== path2.length) {\n      return false;\n    }\n\n    for (var i = 0; i < path1.length; i++) {\n      if (!keysEqual(null, path1[i], path2[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  var updateGroupOffsets = function updateGroupOffsets(that, items, path, offset, additionalGroupInfo) {\n    if (!items) {\n      return;\n    }\n\n    for (var i = 0; i < items.length; i++) {\n      var item = items[i];\n\n      if (\"key\" in item && void 0 !== item.items) {\n        path.push(item.key);\n\n        if (additionalGroupInfo && pathEquals(additionalGroupInfo.path, path) && !item.isContinuation) {\n          additionalGroupInfo.offset = offset;\n        }\n\n        var groupInfo = that.findGroupInfo(path);\n\n        if (groupInfo && !item.isContinuation) {\n          groupInfo.offset = offset;\n        }\n\n        if (groupInfo && !groupInfo.isExpanded) {\n          offset += groupInfo.count;\n        } else {\n          offset = updateGroupOffsets(that, item.items, path, offset, additionalGroupInfo);\n        }\n\n        path.pop();\n      } else {\n        offset++;\n      }\n    }\n\n    return offset;\n  };\n\n  var getGroupCount = function getGroupCount(item, groupCount) {\n    var count = item.count || item.items.length;\n\n    if (!item.count && groupCount > 1) {\n      count = 0;\n\n      for (var i = 0; i < item.items.length; i++) {\n        count += getGroupCount(item.items[i], groupCount - 1);\n      }\n    }\n\n    return count;\n  };\n\n  return {\n    handleDataLoading: function handleDataLoading(options) {\n      var storeLoadOptions = options.storeLoadOptions;\n      var collapsedGroups = [];\n      var collapsedItemsCount = 0;\n      var skipFirstItem = false;\n      var take;\n      var group = options.loadOptions.group;\n      var skipCorrection = 0;\n      !function (storeLoadOptions, loadOptions) {\n        if (loadOptions.group) {\n          var groups = dataGridCore.normalizeSortingInfo(loadOptions.group);\n          var sorts = dataGridCore.normalizeSortingInfo(storeLoadOptions.sort);\n          storeLoadOptions.sort = storeHelper.arrangeSortingInfo(groups, sorts);\n          delete loadOptions.group;\n        }\n      }(storeLoadOptions, options.loadOptions);\n      options.group = options.group || group;\n\n      if (options.isCustomLoading) {\n        return;\n      }\n\n      var loadOptions = extend({}, storeLoadOptions);\n      loadOptions.skip = correctSkipLoadOption(this, storeLoadOptions.skip);\n\n      if (loadOptions.skip && loadOptions.take && group) {\n        loadOptions.skip--;\n        loadOptions.take++;\n        skipFirstItem = true;\n      }\n\n      if (loadOptions.take && group) {\n        take = loadOptions.take;\n        loadOptions.take++;\n      }\n\n      foreachCollapsedGroups(this, function (groupInfo) {\n        if (groupInfo.offset >= loadOptions.skip + loadOptions.take + skipCorrection) {\n          return false;\n        } else if (groupInfo.offset >= loadOptions.skip + skipCorrection && groupInfo.count) {\n          skipCorrection += groupInfo.count - 1;\n          collapsedGroups.push(groupInfo);\n          collapsedItemsCount += groupInfo.count;\n        }\n      });\n      each(collapsedGroups, function () {\n        loadOptions.filter = function (path, storeLoadOptions, group) {\n          var groups = dataGridCore.normalizeSortingInfo(group || storeLoadOptions.group);\n          var filter = [];\n\n          for (var i = 0; i < path.length; i++) {\n            var filterElement = [];\n\n            for (var j = 0; j <= i; j++) {\n              filterElement.push([groups[j].selector, i === j ? \"<>\" : \"=\", path[j]]);\n            }\n\n            filter.push(dataGridCore.combineFilters(filterElement));\n          }\n\n          filter = dataGridCore.combineFilters(filter, \"or\");\n          return dataGridCore.combineFilters([filter, storeLoadOptions.filter]);\n        }(this.path, loadOptions, group);\n      });\n      options.storeLoadOptions = loadOptions;\n      options.collapsedGroups = collapsedGroups;\n      options.collapsedItemsCount = collapsedItemsCount;\n      options.skip = loadOptions.skip || 0;\n      options.skipFirstItem = skipFirstItem;\n      options.take = take;\n    },\n    handleDataLoaded: function handleDataLoaded(options, callBase) {\n      var collapsedGroups = options.collapsedGroups;\n      var groups = dataGridCore.normalizeSortingInfo(options.group);\n      var groupCount = groups.length;\n\n      function appendCollapsedPath(data, path, groups, collapsedGroup, offset) {\n        if (!data || !path.length || !groups.length) {\n          return;\n        }\n\n        var keyValue;\n        var i;\n        var pathValue = toComparable(path[0], true);\n\n        for (i = 0; i < data.length; i++) {\n          keyValue = toComparable(data[i].key, true);\n\n          if (offset >= collapsedGroup.offset || pathValue === keyValue) {\n            break;\n          } else {\n            offset += getGroupCount(data[i], groups.length);\n          }\n        }\n\n        if (!data.length || pathValue !== keyValue) {\n          data.splice(i, 0, {\n            key: path[0],\n            items: [],\n            count: 1 === path.length ? collapsedGroup.count : void 0\n          });\n        }\n\n        appendCollapsedPath(data[i].items, path.slice(1), groups.slice(1), collapsedGroup, offset);\n      }\n\n      if (options.collapsedItemsCount && options.extra && options.extra.totalCount >= 0) {\n        options.extra.totalCount += options.collapsedItemsCount;\n      }\n\n      callBase(options);\n\n      if (groupCount) {\n        var data = options.data;\n        var query = dataQuery(data);\n        storeHelper.multiLevelGroup(query, groups).enumerate().done(function (groupedData) {\n          data = groupedData;\n        });\n\n        if (collapsedGroups) {\n          for (var pathIndex = 0; pathIndex < collapsedGroups.length; pathIndex++) {\n            appendCollapsedPath(data, collapsedGroups[pathIndex].path, groups, collapsedGroups[pathIndex], options.skip);\n          }\n        }\n\n        if (!options.isCustomLoading) {\n          !function processGroupItems(that, items, path, offset, skipFirstItem, take) {\n            var removeLastItemsCount = 0;\n            var needRemoveFirstItem = false;\n\n            for (var i = 0; i < items.length; i++) {\n              var item = items[i];\n\n              if (void 0 !== item.items) {\n                path.push(item.key);\n                var groupInfo = that.findGroupInfo(path);\n\n                if (groupInfo && !groupInfo.isExpanded) {\n                  item.collapsedItems = item.items;\n                  item.items = null;\n                  offset += groupInfo.count;\n                  take--;\n\n                  if (take < 0) {\n                    removeLastItemsCount++;\n                  }\n\n                  if (skipFirstItem) {\n                    needRemoveFirstItem = true;\n                  }\n                } else if (item.items) {\n                  var offsetInfo = processGroupItems(that, item.items, path, offset, skipFirstItem, take);\n\n                  if (skipFirstItem) {\n                    if (offsetInfo.offset - offset > 1) {\n                      item.isContinuation = true;\n                    } else {\n                      needRemoveFirstItem = true;\n                    }\n                  }\n\n                  offset = offsetInfo.offset;\n                  take = offsetInfo.take;\n\n                  if (take < 0) {\n                    if (item.items.length) {\n                      item.isContinuationOnNextPage = true;\n                    } else {\n                      removeLastItemsCount++;\n                    }\n                  }\n                }\n\n                path.pop();\n              } else {\n                if (skipFirstItem) {\n                  needRemoveFirstItem = true;\n                }\n\n                offset++;\n                take--;\n\n                if (take < 0) {\n                  removeLastItemsCount++;\n                }\n              }\n\n              skipFirstItem = false;\n            }\n\n            if (needRemoveFirstItem) {\n              items.splice(0, 1);\n            }\n\n            if (removeLastItemsCount) {\n              items.splice(-removeLastItemsCount, removeLastItemsCount);\n            }\n\n            return {\n              offset: offset,\n              take: take\n            };\n          }(this, data, [], options.skip, options.skipFirstItem, options.take);\n        }\n\n        options.data = data;\n      }\n    },\n    isGroupItemCountable: function isGroupItemCountable(item) {\n      return null === item.items;\n    },\n    updateTotalItemsCount: function updateTotalItemsCount() {\n      var itemsCountCorrection = 0;\n      foreachCollapsedGroups(this, function (groupInfo) {\n        if (groupInfo.count) {\n          itemsCountCorrection -= groupInfo.count - 1;\n        }\n      });\n      this.callBase(itemsCountCorrection);\n    },\n    changeRowExpand: function changeRowExpand(path) {\n      var that = this;\n      var dataSource = that._dataSource;\n      var beginPageIndex = dataSource.beginPageIndex ? dataSource.beginPageIndex() : dataSource.pageIndex();\n      var dataSourceItems = dataSource.items();\n      var offset = correctSkipLoadOption(that, beginPageIndex * dataSource.pageSize());\n      var groupInfo = that.findGroupInfo(path);\n      var groupCountQuery;\n\n      if (groupInfo && !groupInfo.isExpanded) {\n        groupCountQuery = new Deferred().resolve(groupInfo.count);\n      } else {\n        groupCountQuery = loadTotalCount(dataSource, {\n          filter: createGroupFilter(path, {\n            filter: dataSource.filter(),\n            group: dataSource.group()\n          })\n        });\n      }\n\n      return when(groupCountQuery).done(function (count) {\n        count = parseInt(count.length ? count[0] : count);\n\n        if (groupInfo) {\n          updateGroupOffsets(that, dataSourceItems, [], offset);\n          groupInfo.isExpanded = !groupInfo.isExpanded;\n          groupInfo.count = count;\n        } else {\n          groupInfo = {\n            offset: -1,\n            count: count,\n            path: path,\n            isExpanded: false\n          };\n          updateGroupOffsets(that, dataSourceItems, [], offset, groupInfo);\n\n          if (groupInfo.offset >= 0) {\n            that.addGroupInfo(groupInfo);\n          }\n        }\n\n        that.updateTotalItemsCount();\n      }).fail(function () {\n        dataSource._eventsStrategy.fireEvent(\"loadError\", arguments);\n      });\n    },\n    allowCollapseAll: function allowCollapseAll() {\n      return false;\n    },\n    refresh: function refresh(options, operationTypes) {\n      var that = this;\n      var storeLoadOptions = options.storeLoadOptions;\n      var dataSource = that._dataSource;\n      this.callBase.apply(this, arguments);\n\n      if (operationTypes.reload) {\n        return foreachCollapsedGroups(that, function (groupInfo) {\n          var groupCountQuery = loadTotalCount(dataSource, {\n            filter: createGroupFilter(groupInfo.path, storeLoadOptions)\n          });\n          var groupOffsetQuery = loadTotalCount(dataSource, {\n            filter: createOffsetFilter(groupInfo.path, storeLoadOptions)\n          });\n          return when(groupOffsetQuery, groupCountQuery).done(function (offset, count) {\n            offset = parseInt(offset.length ? offset[0] : offset);\n            count = parseInt(count.length ? count[0] : count);\n            groupInfo.offset = offset;\n\n            if (groupInfo.count !== count) {\n              groupInfo.count = count;\n              that.updateTotalItemsCount();\n            }\n          });\n        }, true);\n      }\n    }\n  };\n}());","map":null,"metadata":{},"sourceType":"module"}