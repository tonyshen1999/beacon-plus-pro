{"ast":null,"code":"import _toConsumableArray from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n\n/**\r\n * DevExtreme (esm/ui/scheduler/workspaces/view_model/view_data_generator.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport dateUtils from \"../../../../core/utils/date\";\nimport { HORIZONTAL_GROUP_ORIENTATION } from \"../../constants\";\nimport { getAllGroups, getGroupCount } from \"../../resources/utils\";\nimport { calculateCellIndex, calculateDayDuration, isHorizontalView, getStartViewDateWithoutDST, getDisplayedRowCount, getTotalCellCountByCompleteData, getTotalRowCountByCompleteData, getDisplayedCellCount } from \"../../../../renovation/ui/scheduler/view_model/to_test/views/utils/base\";\nvar HOUR_MS = dateUtils.dateToMilliseconds(\"hour\");\nvar DAY_MS = dateUtils.dateToMilliseconds(\"day\");\nexport var ViewDataGenerator = /*#__PURE__*/function () {\n  function ViewDataGenerator() {\n    _classCallCheck(this, ViewDataGenerator);\n  }\n\n  _createClass(ViewDataGenerator, [{\n    key: \"daysInInterval\",\n    get: function get() {\n      return 1;\n    }\n  }, {\n    key: \"isWorkView\",\n    get: function get() {\n      return false;\n    }\n  }, {\n    key: \"tableAllDay\",\n    get: function get() {\n      return false;\n    }\n  }, {\n    key: \"isSkippedDate\",\n    value: function isSkippedDate() {\n      return false;\n    }\n  }, {\n    key: \"getStartViewDate\",\n    value: function getStartViewDate(options) {\n      return this._calculateStartViewDate(options);\n    }\n  }, {\n    key: \"getCompleteViewDataMap\",\n    value: function getCompleteViewDataMap(options) {\n      var _viewDataMap;\n\n      var groups = options.groups,\n          isGroupedByDate = options.isGroupedByDate,\n          isHorizontalGrouping = options.isHorizontalGrouping,\n          isVerticalGrouping = options.isVerticalGrouping,\n          intervalCount = options.intervalCount,\n          currentDate = options.currentDate,\n          viewType = options.viewType,\n          startDayHour = options.startDayHour,\n          endDayHour = options.endDayHour,\n          hoursInterval = options.hoursInterval;\n\n      this._setVisibilityDates(options);\n\n      this.setHiddenInterval(startDayHour, endDayHour, hoursInterval);\n      var groupsList = getAllGroups(groups);\n      var cellCountInGroupRow = this.getCellCount({\n        intervalCount: intervalCount,\n        currentDate: currentDate,\n        viewType: viewType,\n        startDayHour: startDayHour,\n        endDayHour: endDayHour,\n        hoursInterval: hoursInterval\n      });\n      var rowCountInGroup = this.getRowCount({\n        intervalCount: intervalCount,\n        currentDate: currentDate,\n        viewType: viewType,\n        hoursInterval: hoursInterval,\n        startDayHour: startDayHour,\n        endDayHour: endDayHour\n      });\n      var viewDataMap = [];\n\n      var allDayPanelData = this._generateAllDayPanelData(options, rowCountInGroup, cellCountInGroupRow);\n\n      var viewCellsData = this._generateViewCellsData(options, rowCountInGroup, cellCountInGroupRow);\n\n      allDayPanelData && viewDataMap.push(allDayPanelData);\n\n      (_viewDataMap = viewDataMap).push.apply(_viewDataMap, _toConsumableArray(viewCellsData));\n\n      if (isHorizontalGrouping && !isGroupedByDate) {\n        viewDataMap = this._transformViewDataMapForHorizontalGrouping(viewDataMap, groupsList);\n      }\n\n      if (isVerticalGrouping) {\n        viewDataMap = this._transformViewDataMapForVerticalGrouping(viewDataMap, groupsList);\n      }\n\n      if (isGroupedByDate) {\n        viewDataMap = this._transformViewDataMapForGroupingByDate(viewDataMap, groupsList);\n      }\n\n      var completeViewDataMap = this._addKeysToCells(viewDataMap);\n\n      return completeViewDataMap;\n    }\n  }, {\n    key: \"_transformViewDataMapForHorizontalGrouping\",\n    value: function _transformViewDataMapForHorizontalGrouping(viewDataMap, groupsList) {\n      var result = viewDataMap.map(function (row) {\n        return row.slice();\n      });\n      groupsList.slice(1).forEach(function (groups, index) {\n        var groupIndex = index + 1;\n        viewDataMap.forEach(function (row, rowIndex) {\n          var _result$rowIndex;\n\n          var nextGroupRow = row.map(function (cellData) {\n            return _extends({}, cellData, {\n              groups: groups,\n              groupIndex: groupIndex\n            });\n          });\n\n          (_result$rowIndex = result[rowIndex]).push.apply(_result$rowIndex, _toConsumableArray(nextGroupRow));\n        });\n      });\n      return result;\n    }\n  }, {\n    key: \"_transformViewDataMapForVerticalGrouping\",\n    value: function _transformViewDataMapForVerticalGrouping(viewDataMap, groupsList) {\n      var result = viewDataMap.map(function (row) {\n        return row.slice();\n      });\n      groupsList.slice(1).forEach(function (groups, index) {\n        var groupIndex = index + 1;\n        var nextGroupMap = viewDataMap.map(function (cellsRow) {\n          var nextRow = cellsRow.map(function (cellData) {\n            return _extends({}, cellData, {\n              groupIndex: groupIndex,\n              groups: groups\n            });\n          });\n          return nextRow;\n        });\n        result.push.apply(result, _toConsumableArray(nextGroupMap));\n      });\n      return result;\n    }\n  }, {\n    key: \"_transformViewDataMapForGroupingByDate\",\n    value: function _transformViewDataMapForGroupingByDate(viewDataMap, groupsList) {\n      var correctedGroupList = groupsList.slice(1);\n      var correctedGroupCount = correctedGroupList.length;\n      var result = viewDataMap.map(function (cellsRow) {\n        var groupedByDateCellsRow = cellsRow.reduce(function (currentRow, cell) {\n          var rowWithCurrentCell = [].concat(_toConsumableArray(currentRow), [_extends({}, cell, {\n            isFirstGroupCell: true,\n            isLastGroupCell: 0 === correctedGroupCount\n          })], _toConsumableArray(correctedGroupList.map(function (groups, index) {\n            return _extends({}, cell, {\n              groups: groups,\n              groupIndex: index + 1,\n              isFirstGroupCell: false,\n              isLastGroupCell: index === correctedGroupCount - 1\n            });\n          })));\n          return rowWithCurrentCell;\n        }, []);\n        return groupedByDateCellsRow;\n      });\n      return result;\n    }\n  }, {\n    key: \"_addKeysToCells\",\n    value: function _addKeysToCells(viewDataMap) {\n      var totalColumnCount = viewDataMap[0].length;\n\n      var _viewDataMap$reduce = viewDataMap.reduce(function (_ref, row, rowIndex) {\n        var allDayPanelsCount = _ref.allDayPanelsCount,\n            currentViewDataMap = _ref.currentViewDataMap;\n        var isAllDay = row[0].allDay;\n        var keyBase = (rowIndex - allDayPanelsCount) * totalColumnCount;\n        var currentAllDayPanelsCount = isAllDay ? allDayPanelsCount + 1 : allDayPanelsCount;\n        currentViewDataMap[rowIndex].forEach(function (cell, columnIndex) {\n          cell.key = keyBase + columnIndex;\n        });\n        return {\n          allDayPanelsCount: currentAllDayPanelsCount,\n          currentViewDataMap: currentViewDataMap\n        };\n      }, {\n        allDayPanelsCount: 0,\n        currentViewDataMap: viewDataMap\n      }),\n          result = _viewDataMap$reduce.currentViewDataMap;\n\n      return result;\n    }\n  }, {\n    key: \"generateViewDataMap\",\n    value: function generateViewDataMap(completeViewDataMap, options) {\n      var rowCount = options.rowCount,\n          startCellIndex = options.startCellIndex,\n          startRowIndex = options.startRowIndex,\n          cellCount = options.cellCount,\n          isVerticalGrouping = options.isVerticalGrouping,\n          isAllDayPanelVisible = options.isAllDayPanelVisible;\n\n      var sliceCells = function sliceCells(row, rowIndex, startIndex, count) {\n        var sliceToIndex = void 0 !== count ? startIndex + count : void 0;\n        return row.slice(startIndex, sliceToIndex).map(function (cellData, columnIndex) {\n          return {\n            cellData: cellData,\n            position: {\n              rowIndex: rowIndex,\n              columnIndex: columnIndex\n            }\n          };\n        });\n      };\n\n      var correctedStartRowIndex = startRowIndex;\n      var allDayPanelMap = [];\n\n      if (this._isStandaloneAllDayPanel(isVerticalGrouping, isAllDayPanelVisible)) {\n        correctedStartRowIndex++;\n        allDayPanelMap = sliceCells(completeViewDataMap[0], 0, startCellIndex, cellCount);\n      }\n\n      var displayedRowCount = getDisplayedRowCount(rowCount, completeViewDataMap);\n      var dateTableMap = completeViewDataMap.slice(correctedStartRowIndex, correctedStartRowIndex + displayedRowCount).map(function (row, rowIndex) {\n        return sliceCells(row, rowIndex, startCellIndex, cellCount);\n      });\n      return {\n        allDayPanelMap: allDayPanelMap,\n        dateTableMap: dateTableMap\n      };\n    }\n  }, {\n    key: \"_isStandaloneAllDayPanel\",\n    value: function _isStandaloneAllDayPanel(isVerticalGrouping, isAllDayPanelVisible) {\n      return !isVerticalGrouping && isAllDayPanelVisible;\n    }\n  }, {\n    key: \"getViewDataFromMap\",\n    value: function getViewDataFromMap(completeViewDataMap, viewDataMap, options) {\n      var topVirtualRowHeight = options.topVirtualRowHeight,\n          bottomVirtualRowHeight = options.bottomVirtualRowHeight,\n          leftVirtualCellWidth = options.leftVirtualCellWidth,\n          rightVirtualCellWidth = options.rightVirtualCellWidth,\n          cellCount = options.cellCount,\n          rowCount = options.rowCount,\n          startRowIndex = options.startRowIndex,\n          startCellIndex = options.startCellIndex,\n          isProvideVirtualCellsWidth = options.isProvideVirtualCellsWidth,\n          isGroupedAllDayPanel = options.isGroupedAllDayPanel,\n          isVerticalGrouping = options.isVerticalGrouping,\n          isAllDayPanelVisible = options.isAllDayPanelVisible;\n      var allDayPanelMap = viewDataMap.allDayPanelMap,\n          dateTableMap = viewDataMap.dateTableMap;\n\n      var _dateTableMap$reduce = dateTableMap.reduce(function (_ref2, cellsRow) {\n        var previousGroupIndex = _ref2.previousGroupIndex,\n            previousGroupedData = _ref2.previousGroupedData;\n        var cellDataRow = cellsRow.map(function (_ref3) {\n          var cellData = _ref3.cellData;\n          return cellData;\n        });\n        var firstCell = cellDataRow[0];\n        var isAllDayRow = firstCell.allDay;\n        var currentGroupIndex = firstCell.groupIndex;\n\n        if (currentGroupIndex !== previousGroupIndex) {\n          previousGroupedData.push({\n            dateTable: [],\n            isGroupedAllDayPanel: isGroupedAllDayPanel,\n            groupIndex: currentGroupIndex\n          });\n        }\n\n        if (isAllDayRow) {\n          previousGroupedData[previousGroupedData.length - 1].allDayPanel = cellDataRow;\n        } else {\n          previousGroupedData[previousGroupedData.length - 1].dateTable.push(cellDataRow);\n        }\n\n        return {\n          previousGroupedData: previousGroupedData,\n          previousGroupIndex: currentGroupIndex\n        };\n      }, {\n        previousGroupIndex: -1,\n        previousGroupedData: []\n      }),\n          groupedData = _dateTableMap$reduce.previousGroupedData;\n\n      if (this._isStandaloneAllDayPanel(isVerticalGrouping, isAllDayPanelVisible)) {\n        groupedData[0].allDayPanel = allDayPanelMap.map(function (_ref4) {\n          var cellData = _ref4.cellData;\n          return cellData;\n        });\n      }\n\n      var totalCellCount = getTotalCellCountByCompleteData(completeViewDataMap);\n      var totalRowCount = getTotalRowCountByCompleteData(completeViewDataMap);\n      var displayedCellCount = getDisplayedCellCount(cellCount, completeViewDataMap);\n      var displayedRowCount = getDisplayedRowCount(rowCount, completeViewDataMap);\n      return {\n        groupedData: groupedData,\n        topVirtualRowHeight: topVirtualRowHeight,\n        bottomVirtualRowHeight: bottomVirtualRowHeight,\n        leftVirtualCellWidth: isProvideVirtualCellsWidth ? leftVirtualCellWidth : void 0,\n        rightVirtualCellWidth: isProvideVirtualCellsWidth ? rightVirtualCellWidth : void 0,\n        isGroupedAllDayPanel: isGroupedAllDayPanel,\n        leftVirtualCellCount: startCellIndex,\n        rightVirtualCellCount: void 0 === cellCount ? 0 : totalCellCount - startCellIndex - displayedCellCount,\n        topVirtualRowCount: startRowIndex,\n        bottomVirtualRowCount: totalRowCount - startRowIndex - displayedRowCount\n      };\n    }\n  }, {\n    key: \"_generateViewCellsData\",\n    value: function _generateViewCellsData(options, rowCount, cellCountInGroupRow) {\n      var viewCellsData = [];\n\n      for (var rowIndex = 0; rowIndex < rowCount; rowIndex += 1) {\n        viewCellsData.push(this._generateCellsRow(options, false, rowIndex, rowCount, cellCountInGroupRow));\n      }\n\n      return viewCellsData;\n    }\n  }, {\n    key: \"_generateAllDayPanelData\",\n    value: function _generateAllDayPanelData(options, rowCount, columnCount) {\n      if (!options.isAllDayPanelVisible) {\n        return null;\n      }\n\n      return this._generateCellsRow(options, true, 0, rowCount, columnCount);\n    }\n  }, {\n    key: \"_generateCellsRow\",\n    value: function _generateCellsRow(options, allDay, rowIndex, rowCount, columnCount) {\n      var cellsRow = [];\n\n      for (var columnIndex = 0; columnIndex < columnCount; ++columnIndex) {\n        var cellDataValue = this.getCellData(rowIndex, columnIndex, options, allDay);\n        cellDataValue.index = rowIndex * columnCount + columnIndex;\n        cellDataValue.isFirstGroupCell = this._isFirstGroupCell(rowIndex, columnIndex, options, rowCount, columnCount);\n        cellDataValue.isLastGroupCell = this._isLastGroupCell(rowIndex, columnIndex, options, rowCount, columnCount);\n        cellsRow.push(cellDataValue);\n      }\n\n      return cellsRow;\n    }\n  }, {\n    key: \"getCellData\",\n    value: function getCellData(rowIndex, columnIndex, options, allDay) {\n      return allDay ? this.prepareAllDayCellData(options, rowIndex, columnIndex) : this.prepareCellData(options, rowIndex, columnIndex);\n    }\n  }, {\n    key: \"prepareCellData\",\n    value: function prepareCellData(options, rowIndex, columnIndex) {\n      var groups = options.groups,\n          startDayHour = options.startDayHour,\n          endDayHour = options.endDayHour,\n          interval = options.interval,\n          hoursInterval = options.hoursInterval;\n      var groupsList = getAllGroups(groups);\n      var startDate = this.getDateByCellIndices(options, rowIndex, columnIndex, this.getCellCountInDay(startDayHour, endDayHour, hoursInterval));\n      var endDate = this.calculateEndDate(startDate, interval, endDayHour);\n      var data = {\n        startDate: startDate,\n        endDate: endDate,\n        allDay: this.tableAllDay,\n        groupIndex: 0\n      };\n\n      if (groupsList.length > 0) {\n        data.groups = groupsList[0];\n      }\n\n      return data;\n    }\n  }, {\n    key: \"prepareAllDayCellData\",\n    value: function prepareAllDayCellData(options, rowIndex, columnIndex) {\n      var data = this.prepareCellData(options, rowIndex, columnIndex);\n      var startDate = dateUtils.trimTime(data.startDate);\n      return _extends({}, data, {\n        startDate: startDate,\n        endDate: startDate,\n        allDay: true\n      });\n    }\n  }, {\n    key: \"getDateByCellIndices\",\n    value: function getDateByCellIndices(options, rowIndex, columnIndex, cellCountInDay) {\n      var startViewDate = options.startViewDate;\n      var startDayHour = options.startDayHour,\n          interval = options.interval,\n          firstDayOfWeek = options.firstDayOfWeek,\n          intervalCount = options.intervalCount;\n      var isStartViewDateDuringDST = startViewDate.getHours() !== Math.floor(startDayHour);\n\n      if (isStartViewDateDuringDST) {\n        var dateWithCorrectHours = getStartViewDateWithoutDST(startViewDate, startDayHour);\n        startViewDate = new Date(dateWithCorrectHours - dateUtils.dateToMilliseconds(\"day\"));\n      }\n\n      var columnCountBase = this.getCellCount(options);\n      var rowCountBase = this.getRowCount(options);\n\n      var cellIndex = this._calculateCellIndex(rowIndex, columnIndex, rowCountBase, columnCountBase);\n\n      var millisecondsOffset = this.getMillisecondsOffset(cellIndex, interval, cellCountInDay);\n      var offsetByCount = this.isWorkView ? this.getTimeOffsetByColumnIndex(columnIndex, this.getFirstDayOfWeek(firstDayOfWeek), columnCountBase, intervalCount) : 0;\n      var startViewDateTime = startViewDate.getTime();\n      var currentDate = new Date(startViewDateTime + millisecondsOffset + offsetByCount);\n      var timeZoneDifference = isStartViewDateDuringDST ? 0 : dateUtils.getTimezonesDifference(startViewDate, currentDate);\n      currentDate.setTime(currentDate.getTime() + timeZoneDifference);\n      return currentDate;\n    }\n  }, {\n    key: \"getMillisecondsOffset\",\n    value: function getMillisecondsOffset(cellIndex, interval, cellCountInDay) {\n      var dayIndex = Math.floor(cellIndex / cellCountInDay);\n      var realHiddenInterval = dayIndex * this.hiddenInterval;\n      return interval * cellIndex + realHiddenInterval;\n    }\n  }, {\n    key: \"getTimeOffsetByColumnIndex\",\n    value: function getTimeOffsetByColumnIndex(columnIndex, firstDayOfWeek, columnCount, intervalCount) {\n      var firstDayOfWeekDiff = Math.max(0, firstDayOfWeek - 1);\n      var columnsInWeek = columnCount / intervalCount;\n      var weekendCount = Math.floor((columnIndex + firstDayOfWeekDiff) / columnsInWeek);\n      return DAY_MS * weekendCount * 2;\n    }\n  }, {\n    key: \"calculateEndDate\",\n    value: function calculateEndDate(startDate, interval, endDayHour) {\n      var result = new Date(startDate);\n      result.setMilliseconds(result.getMilliseconds() + Math.round(interval));\n      return result;\n    }\n  }, {\n    key: \"_calculateCellIndex\",\n    value: function _calculateCellIndex(rowIndex, columnIndex, rowCount, columnCount) {\n      return calculateCellIndex(rowIndex, columnIndex, rowCount);\n    }\n  }, {\n    key: \"generateGroupedDataMap\",\n    value: function generateGroupedDataMap(viewDataMap) {\n      var allDayPanelMap = viewDataMap.allDayPanelMap,\n          dateTableMap = viewDataMap.dateTableMap;\n\n      var _dateTableMap$reduce2 = dateTableMap.reduce(function (previousOptions, cellsRow) {\n        var previousGroupedDataMap = previousOptions.previousGroupedDataMap,\n            previousRowIndex = previousOptions.previousRowIndex,\n            previousGroupIndex = previousOptions.previousGroupIndex;\n        var currentGroupIndex = cellsRow[0].cellData.groupIndex;\n        var currentRowIndex = currentGroupIndex === previousGroupIndex ? previousRowIndex + 1 : 0;\n        cellsRow.forEach(function (cell) {\n          var groupIndex = cell.cellData.groupIndex;\n\n          if (!previousGroupedDataMap[groupIndex]) {\n            previousGroupedDataMap[groupIndex] = [];\n          }\n\n          if (!previousGroupedDataMap[groupIndex][currentRowIndex]) {\n            previousGroupedDataMap[groupIndex][currentRowIndex] = [];\n          }\n\n          previousGroupedDataMap[groupIndex][currentRowIndex].push(cell);\n        });\n        return {\n          previousGroupedDataMap: previousGroupedDataMap,\n          previousRowIndex: currentRowIndex,\n          previousGroupIndex: currentGroupIndex\n        };\n      }, {\n        previousGroupedDataMap: [],\n        previousRowIndex: -1,\n        previousGroupIndex: -1\n      }),\n          dateTableGroupedMap = _dateTableMap$reduce2.previousGroupedDataMap;\n\n      var allDayPanelGroupedMap = [];\n      null === allDayPanelMap || void 0 === allDayPanelMap ? void 0 : allDayPanelMap.forEach(function (cell) {\n        var groupIndex = cell.cellData.groupIndex;\n\n        if (!allDayPanelGroupedMap[groupIndex]) {\n          allDayPanelGroupedMap[groupIndex] = [];\n        }\n\n        allDayPanelGroupedMap[groupIndex].push(cell);\n      });\n      return {\n        allDayPanelGroupedMap: allDayPanelGroupedMap,\n        dateTableGroupedMap: dateTableGroupedMap\n      };\n    }\n  }, {\n    key: \"_isFirstGroupCell\",\n    value: function _isFirstGroupCell(rowIndex, columnIndex, options, rowCount, columnCount) {\n      var groupOrientation = options.groupOrientation,\n          groups = options.groups,\n          isGroupedByDate = options.isGroupedByDate;\n      var groupCount = getGroupCount(groups);\n\n      if (isGroupedByDate) {\n        return columnIndex % groupCount === 0;\n      }\n\n      if (groupOrientation === HORIZONTAL_GROUP_ORIENTATION) {\n        return columnIndex % columnCount === 0;\n      }\n\n      return rowIndex % rowCount === 0;\n    }\n  }, {\n    key: \"_isLastGroupCell\",\n    value: function _isLastGroupCell(rowIndex, columnIndex, options, rowCount, columnCount) {\n      var groupOrientation = options.groupOrientation,\n          groups = options.groups,\n          isGroupedByDate = options.isGroupedByDate;\n      var groupCount = getGroupCount(groups);\n\n      if (isGroupedByDate) {\n        return (columnIndex + 1) % groupCount === 0;\n      }\n\n      if (groupOrientation === HORIZONTAL_GROUP_ORIENTATION) {\n        return (columnIndex + 1) % columnCount === 0;\n      }\n\n      return (rowIndex + 1) % rowCount === 0;\n    }\n  }, {\n    key: \"markSelectedAndFocusedCells\",\n    value: function markSelectedAndFocusedCells(viewDataMap, renderOptions) {\n      var _this = this;\n\n      var selectedCells = renderOptions.selectedCells,\n          focusedCell = renderOptions.focusedCell;\n\n      if (!selectedCells && !focusedCell) {\n        return viewDataMap;\n      }\n\n      var allDayPanelMap = viewDataMap.allDayPanelMap,\n          dateTableMap = viewDataMap.dateTableMap;\n      var nextDateTableMap = dateTableMap.map(function (row) {\n        return _this._markSelectedAndFocusedCellsInRow(row, selectedCells, focusedCell);\n      });\n\n      var nextAllDayMap = this._markSelectedAndFocusedCellsInRow(allDayPanelMap, selectedCells, focusedCell);\n\n      return {\n        allDayPanelMap: nextAllDayMap,\n        dateTableMap: nextDateTableMap\n      };\n    }\n  }, {\n    key: \"_markSelectedAndFocusedCellsInRow\",\n    value: function _markSelectedAndFocusedCellsInRow(dataRow, selectedCells, focusedCell) {\n      return dataRow.map(function (cell) {\n        var _cell$cellData = cell.cellData,\n            index = _cell$cellData.index,\n            groupIndex = _cell$cellData.groupIndex,\n            allDay = _cell$cellData.allDay,\n            startDate = _cell$cellData.startDate;\n        var indexInSelectedCells = selectedCells.findIndex(function (_ref5) {\n          var selectedCellIndex = _ref5.index,\n              selectedCellGroupIndex = _ref5.groupIndex,\n              selectedCellAllDay = _ref5.allDay,\n              selectedCellStartDate = _ref5.startDate;\n          return groupIndex === selectedCellGroupIndex && (index === selectedCellIndex || void 0 === selectedCellIndex && startDate.getTime() === selectedCellStartDate.getTime()) && !!allDay === !!selectedCellAllDay;\n        });\n        var isFocused = !!focusedCell && index === focusedCell.cellData.index && groupIndex === focusedCell.cellData.groupIndex && allDay === focusedCell.cellData.allDay;\n\n        if (!isFocused && -1 === indexInSelectedCells) {\n          return cell;\n        }\n\n        return _extends({}, cell, {\n          cellData: _extends({}, cell.cellData, {\n            isSelected: indexInSelectedCells > -1,\n            isFocused: isFocused\n          })\n        });\n      });\n    }\n  }, {\n    key: \"getInterval\",\n    value: function getInterval(hoursInterval) {\n      if (void 0 === this._interval) {\n        this._interval = hoursInterval * HOUR_MS;\n      }\n\n      return this._interval;\n    }\n  }, {\n    key: \"_getIntervalDuration\",\n    value: function _getIntervalDuration(intervalCount) {\n      return dateUtils.dateToMilliseconds(\"day\") * intervalCount;\n    }\n  }, {\n    key: \"_setVisibilityDates\",\n    value: function _setVisibilityDates() {}\n  }, {\n    key: \"getCellCountInDay\",\n    value: function getCellCountInDay(startDayHour, endDayHour, hoursInterval) {\n      var result = calculateDayDuration(startDayHour, endDayHour) / hoursInterval;\n      return Math.ceil(result);\n    }\n  }, {\n    key: \"getCellCount\",\n    value: function getCellCount(options) {\n      var intervalCount = options.intervalCount,\n          viewType = options.viewType,\n          startDayHour = options.startDayHour,\n          endDayHour = options.endDayHour,\n          hoursInterval = options.hoursInterval;\n      var cellCountInDay = this.getCellCountInDay(startDayHour, endDayHour, hoursInterval);\n      var columnCountInDay = isHorizontalView(viewType) ? cellCountInDay : 1;\n      return this.daysInInterval * intervalCount * columnCountInDay;\n    }\n  }, {\n    key: \"getRowCount\",\n    value: function getRowCount(options) {\n      var viewType = options.viewType,\n          startDayHour = options.startDayHour,\n          endDayHour = options.endDayHour,\n          hoursInterval = options.hoursInterval;\n      var cellCountInDay = this.getCellCountInDay(startDayHour, endDayHour, hoursInterval);\n      var rowCountInDay = !isHorizontalView(viewType) ? cellCountInDay : 1;\n      return rowCountInDay;\n    }\n  }, {\n    key: \"setHiddenInterval\",\n    value: function setHiddenInterval(startDayHour, endDayHour, hoursInterval) {\n      this.hiddenInterval = DAY_MS - this.getVisibleDayDuration(startDayHour, endDayHour, hoursInterval);\n    }\n  }, {\n    key: \"getVisibleDayDuration\",\n    value: function getVisibleDayDuration(startDayHour, endDayHour, hoursInterval) {\n      var cellCountInDay = this.getCellCountInDay(startDayHour, endDayHour, hoursInterval);\n      return hoursInterval * cellCountInDay * HOUR_MS;\n    }\n  }, {\n    key: \"getFirstDayOfWeek\",\n    value: function getFirstDayOfWeek(firstDayOfWeekOption) {\n      return firstDayOfWeekOption;\n    }\n  }]);\n\n  return ViewDataGenerator;\n}();","map":null,"metadata":{},"sourceType":"module"}