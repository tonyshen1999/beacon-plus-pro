{"ast":null,"code":"import _classCallCheck from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n\n/**\r\n * DevExtreme (esm/ui/scheduler/workspaces/view_model/view_data_provider.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nvar _excluded = [\"groups\", \"groupOrientation\", \"groupByDate\", \"isAllDayPanelVisible\"];\nimport dateUtils from \"../../../../core/utils/date\";\nimport { getGroupPanelData as _getGroupPanelData } from \"../../../../renovation/ui/scheduler/view_model/group_panel/utils\";\nimport { isGroupingByDate, isHorizontalGroupingApplied, isVerticalGroupingApplied } from \"../../../../renovation/ui/scheduler/workspaces/utils\";\nimport { calculateIsGroupedAllDayPanel } from \"../../../../renovation/ui/scheduler/view_model/to_test/views/utils/base\";\nimport { DateHeaderDataGenerator } from \"./date_header_data_generator\";\nimport { GroupedDataMapProvider } from \"./grouped_data_map_provider\";\nimport { TimePanelDataGenerator } from \"./time_panel_data_generator\";\nimport { getViewDataGeneratorByViewType } from \"./utils\";\nimport timeZoneUtils from \"../../utils.timeZone\";\n\nvar ViewDataProvider = /*#__PURE__*/function () {\n  function ViewDataProvider(viewType) {\n    _classCallCheck(this, ViewDataProvider);\n\n    this.viewDataGenerator = getViewDataGeneratorByViewType(viewType);\n    this.viewData = {};\n    this.completeViewDataMap = [];\n    this.completeDateHeaderMap = [];\n    this.viewDataMap = {};\n    this._groupedDataMapProvider = null;\n  }\n\n  _createClass(ViewDataProvider, [{\n    key: \"groupedDataMap\",\n    get: function get() {\n      return this._groupedDataMapProvider.groupedDataMap;\n    }\n  }, {\n    key: \"hiddenInterval\",\n    get: function get() {\n      return this.viewDataGenerator.hiddenInterval;\n    }\n  }, {\n    key: \"isSkippedDate\",\n    value: function isSkippedDate(date) {\n      return this.viewDataGenerator.isSkippedDate(date);\n    }\n  }, {\n    key: \"update\",\n    value: function update(options, isGenerateNewViewData) {\n      this.viewDataGenerator = getViewDataGeneratorByViewType(options.viewType);\n      var viewDataGenerator = this.viewDataGenerator;\n      var dateHeaderDataGenerator = new DateHeaderDataGenerator(viewDataGenerator);\n      var timePanelDataGenerator = new TimePanelDataGenerator(viewDataGenerator);\n\n      var renderOptions = this._transformRenderOptions(options);\n\n      renderOptions.interval = this.viewDataGenerator.getInterval(renderOptions.hoursInterval);\n      this._options = renderOptions;\n\n      if (isGenerateNewViewData) {\n        this.completeViewDataMap = viewDataGenerator.getCompleteViewDataMap(renderOptions);\n        this.completeDateHeaderMap = dateHeaderDataGenerator.getCompleteDateHeaderMap(renderOptions, this.completeViewDataMap);\n\n        if (renderOptions.isGenerateTimePanelData) {\n          this.completeTimePanelMap = timePanelDataGenerator.getCompleteTimePanelMap(renderOptions, this.completeViewDataMap);\n        }\n      }\n\n      this.viewDataMap = viewDataGenerator.generateViewDataMap(this.completeViewDataMap, renderOptions);\n      this.updateViewData(renderOptions);\n      this._groupedDataMapProvider = new GroupedDataMapProvider(this.viewDataGenerator, this.viewDataMap, this.completeViewDataMap, {\n        isVerticalGrouping: renderOptions.isVerticalGrouping,\n        viewType: renderOptions.viewType\n      });\n      this.dateHeaderData = dateHeaderDataGenerator.generateDateHeaderData(this.completeDateHeaderMap, this.completeViewDataMap, renderOptions);\n\n      if (renderOptions.isGenerateTimePanelData) {\n        this.timePanelData = timePanelDataGenerator.generateTimePanelData(this.completeTimePanelMap, renderOptions);\n      }\n    }\n  }, {\n    key: \"createGroupedDataMapProvider\",\n    value: function createGroupedDataMapProvider() {\n      this._groupedDataMapProvider = new GroupedDataMapProvider(this.viewDataGenerator, this.viewDataMap, this.completeViewDataMap, {\n        isVerticalGrouping: this._options.isVerticalGrouping,\n        viewType: this._options.viewType\n      });\n    }\n  }, {\n    key: \"updateViewData\",\n    value: function updateViewData(options) {\n      var renderOptions = this._transformRenderOptions(options);\n\n      this.viewDataMapWithSelection = this.viewDataGenerator.markSelectedAndFocusedCells(this.viewDataMap, renderOptions);\n      this.viewData = this.viewDataGenerator.getViewDataFromMap(this.completeViewDataMap, this.viewDataMapWithSelection, renderOptions);\n    }\n  }, {\n    key: \"_transformRenderOptions\",\n    value: function _transformRenderOptions(renderOptions) {\n      var groups = renderOptions.groups,\n          groupOrientation = renderOptions.groupOrientation,\n          groupByDate = renderOptions.groupByDate,\n          isAllDayPanelVisible = renderOptions.isAllDayPanelVisible,\n          restOptions = _objectWithoutPropertiesLoose(renderOptions, _excluded);\n\n      return _extends({}, restOptions, {\n        startViewDate: this.viewDataGenerator._calculateStartViewDate(renderOptions),\n        isVerticalGrouping: isVerticalGroupingApplied(groups, groupOrientation),\n        isHorizontalGrouping: isHorizontalGroupingApplied(groups, groupOrientation),\n        isGroupedByDate: isGroupingByDate(groups, groupOrientation, groupByDate),\n        isGroupedAllDayPanel: calculateIsGroupedAllDayPanel(groups, groupOrientation, isAllDayPanelVisible),\n        groups: groups,\n        groupOrientation: groupOrientation,\n        isAllDayPanelVisible: isAllDayPanelVisible\n      });\n    }\n  }, {\n    key: \"getGroupPanelData\",\n    value: function getGroupPanelData(options) {\n      var renderOptions = this._transformRenderOptions(options);\n\n      if (renderOptions.groups.length > 0) {\n        var cellCount = this.getCellCount(renderOptions);\n        return _getGroupPanelData(renderOptions.groups, cellCount, renderOptions.isGroupedByDate, renderOptions.isGroupedByDate ? 1 : cellCount);\n      }\n\n      return;\n    }\n  }, {\n    key: \"getGroupStartDate\",\n    value: function getGroupStartDate(groupIndex) {\n      return this._groupedDataMapProvider.getGroupStartDate(groupIndex);\n    }\n  }, {\n    key: \"getGroupEndDate\",\n    value: function getGroupEndDate(groupIndex) {\n      return this._groupedDataMapProvider.getGroupEndDate(groupIndex);\n    }\n  }, {\n    key: \"findGroupCellStartDate\",\n    value: function findGroupCellStartDate(groupIndex, startDate, endDate, isAllDay, isFindByDate) {\n      return this._groupedDataMapProvider.findGroupCellStartDate(groupIndex, startDate, endDate, isAllDay, isFindByDate);\n    }\n  }, {\n    key: \"findAllDayGroupCellStartDate\",\n    value: function findAllDayGroupCellStartDate(groupIndex, startDate) {\n      return this._groupedDataMapProvider.findAllDayGroupCellStartDate(groupIndex, startDate);\n    }\n  }, {\n    key: \"findCellPositionInMap\",\n    value: function findCellPositionInMap(cellInfo) {\n      return this._groupedDataMapProvider.findCellPositionInMap(cellInfo);\n    }\n  }, {\n    key: \"hasAllDayPanel\",\n    value: function hasAllDayPanel() {\n      var viewData = this.viewDataMap.viewData;\n      var allDayPanel = viewData.groupedData[0].allDayPanel;\n      return !viewData.isGroupedAllDayPanel && (null === allDayPanel || void 0 === allDayPanel ? void 0 : allDayPanel.length) > 0;\n    }\n  }, {\n    key: \"getCellsGroup\",\n    value: function getCellsGroup(groupIndex) {\n      return this._groupedDataMapProvider.getCellsGroup(groupIndex);\n    }\n  }, {\n    key: \"getCompletedGroupsInfo\",\n    value: function getCompletedGroupsInfo() {\n      return this._groupedDataMapProvider.getCompletedGroupsInfo();\n    }\n  }, {\n    key: \"getGroupIndices\",\n    value: function getGroupIndices() {\n      return this._groupedDataMapProvider.getGroupIndices();\n    }\n  }, {\n    key: \"getLastGroupCellPosition\",\n    value: function getLastGroupCellPosition(groupIndex) {\n      return this._groupedDataMapProvider.getLastGroupCellPosition(groupIndex);\n    }\n  }, {\n    key: \"getRowCountInGroup\",\n    value: function getRowCountInGroup(groupIndex) {\n      return this._groupedDataMapProvider.getRowCountInGroup(groupIndex);\n    }\n  }, {\n    key: \"getCellData\",\n    value: function getCellData(rowIndex, columnIndex, isAllDay, rtlEnabled) {\n      var row = isAllDay && !this._options.isVerticalGrouping ? this.viewDataMap.allDayPanelMap : this.viewDataMap.dateTableMap[rowIndex];\n      var actualColumnIndex = !rtlEnabled ? columnIndex : row.length - 1 - columnIndex;\n      var cellData = row[actualColumnIndex].cellData;\n      return cellData;\n    }\n  }, {\n    key: \"getCellsByGroupIndexAndAllDay\",\n    value: function getCellsByGroupIndexAndAllDay(groupIndex, allDay) {\n      var rowsPerGroup = this._getRowCountWithAllDayRows();\n\n      var isShowAllDayPanel = this._options.isAllDayPanelVisible;\n      var firstRowInGroup = this._options.isVerticalGrouping ? groupIndex * rowsPerGroup : 0;\n      var lastRowInGroup = this._options.isVerticalGrouping ? (groupIndex + 1) * rowsPerGroup - 1 : rowsPerGroup;\n      var correctedFirstRow = isShowAllDayPanel && !allDay ? firstRowInGroup + 1 : firstRowInGroup;\n      var correctedLastRow = allDay ? correctedFirstRow : lastRowInGroup;\n      return this.completeViewDataMap.slice(correctedFirstRow, correctedLastRow + 1).map(function (row) {\n        return row.filter(function (_ref) {\n          var currentGroupIndex = _ref.groupIndex;\n          return groupIndex === currentGroupIndex;\n        });\n      });\n    }\n  }, {\n    key: \"getGroupData\",\n    value: function getGroupData(groupIndex) {\n      var groupedData = this.viewData.groupedData;\n\n      if (this._options.isVerticalGrouping) {\n        return groupedData.filter(function (item) {\n          return item.groupIndex === groupIndex;\n        })[0];\n      }\n\n      var filterCells = function filterCells(row) {\n        return null === row || void 0 === row ? void 0 : row.filter(function (cell) {\n          return cell.groupIndex === groupIndex;\n        });\n      };\n\n      var _groupedData$ = groupedData[0],\n          allDayPanel = _groupedData$.allDayPanel,\n          dateTable = _groupedData$.dateTable;\n      var filteredDateTable = [];\n      dateTable.forEach(function (row) {\n        filteredDateTable.push(filterCells(row));\n      });\n      return {\n        allDayPanel: filterCells(allDayPanel),\n        dateTable: filteredDateTable\n      };\n    }\n  }, {\n    key: \"getCellCountWithGroup\",\n    value: function getCellCountWithGroup(groupIndex) {\n      var rowIndex = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;\n      var dateTableGroupedMap = this.groupedDataMap.dateTableGroupedMap;\n      return dateTableGroupedMap.filter(function (_, index) {\n        return index <= groupIndex;\n      }).reduce(function (previous, row) {\n        return previous + row[rowIndex].length;\n      }, 0);\n    }\n  }, {\n    key: \"getAllDayPanel\",\n    value: function getAllDayPanel(groupIndex) {\n      var groupData = this.getGroupData(groupIndex);\n      return null === groupData || void 0 === groupData ? void 0 : groupData.allDayPanel;\n    }\n  }, {\n    key: \"isGroupIntersectDateInterval\",\n    value: function isGroupIntersectDateInterval(groupIndex, startDate, endDate) {\n      var groupStartDate = this.getGroupStartDate(groupIndex);\n      var groupEndDate = this.getGroupEndDate(groupIndex);\n      return startDate < groupEndDate && endDate > groupStartDate;\n    }\n  }, {\n    key: \"findGlobalCellPosition\",\n    value: function findGlobalCellPosition(date) {\n      var groupIndex = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;\n      var allDay = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : false;\n      var completeViewDataMap = this.completeViewDataMap;\n      var showAllDayPanel = this._options.isAllDayPanelVisible;\n\n      for (var rowIndex = 0; rowIndex < completeViewDataMap.length; rowIndex += 1) {\n        var currentRow = completeViewDataMap[rowIndex];\n\n        for (var columnIndex = 0; columnIndex < currentRow.length; columnIndex += 1) {\n          var cellData = currentRow[columnIndex];\n          var _cellData = cellData,\n              currentStartDate = _cellData.startDate,\n              currentEndDate = _cellData.endDate,\n              currentGroupIndex = _cellData.groupIndex,\n              currentAllDay = _cellData.allDay;\n\n          if (groupIndex === currentGroupIndex && allDay === !!currentAllDay && this._compareDatesAndAllDay(date, currentStartDate, currentEndDate, allDay)) {\n            return {\n              position: {\n                columnIndex: columnIndex,\n                rowIndex: showAllDayPanel && !this._options.isVerticalGrouping ? rowIndex - 1 : rowIndex\n              },\n              cellData: cellData\n            };\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_compareDatesAndAllDay\",\n    value: function _compareDatesAndAllDay(date, cellStartDate, cellEndDate, allDay) {\n      var time = date.getTime();\n      var trimmedTime = dateUtils.trimTime(date).getTime();\n      var cellStartTime = cellStartDate.getTime();\n      var cellEndTime = cellEndDate.getTime();\n      return !allDay && time >= cellStartTime && time < cellEndTime || allDay && trimmedTime === cellStartTime;\n    }\n  }, {\n    key: \"getSkippedDaysCount\",\n    value: function getSkippedDaysCount(groupIndex, startDate, endDate, daysCount) {\n      var dateTableGroupedMap = this._groupedDataMapProvider.groupedDataMap.dateTableGroupedMap;\n      var groupedData = dateTableGroupedMap[groupIndex];\n      var includedDays = 0;\n\n      for (var rowIndex = 0; rowIndex < groupedData.length; rowIndex += 1) {\n        for (var columnIndex = 0; columnIndex < groupedData[rowIndex].length; columnIndex += 1) {\n          var cell = groupedData[rowIndex][columnIndex].cellData;\n\n          if (startDate.getTime() < cell.endDate.getTime() && endDate.getTime() > cell.startDate.getTime()) {\n            includedDays += 1;\n          }\n        }\n      }\n\n      var lastCell = groupedData[groupedData.length - 1][groupedData[0].length - 1].cellData;\n      var lastCellStart = dateUtils.trimTime(lastCell.startDate);\n      var daysAfterView = Math.floor((endDate.getTime() - lastCellStart.getTime()) / dateUtils.dateToMilliseconds(\"day\"));\n      var deltaDays = daysAfterView > 0 ? daysAfterView : 0;\n      return daysCount - includedDays - deltaDays;\n    }\n  }, {\n    key: \"getColumnsCount\",\n    value: function getColumnsCount() {\n      var dateTableMap = this.viewDataMap.dateTableMap;\n      return dateTableMap ? dateTableMap[0].length : 0;\n    }\n  }, {\n    key: \"getViewEdgeIndices\",\n    value: function getViewEdgeIndices(isAllDayPanel) {\n      if (isAllDayPanel) {\n        return {\n          firstColumnIndex: 0,\n          lastColumnIndex: this.viewDataMap.allDayPanelMap.length - 1,\n          firstRowIndex: 0,\n          lastRowIndex: 0\n        };\n      }\n\n      return {\n        firstColumnIndex: 0,\n        lastColumnIndex: this.viewDataMap.dateTableMap[0].length - 1,\n        firstRowIndex: 0,\n        lastRowIndex: this.viewDataMap.dateTableMap.length - 1\n      };\n    }\n  }, {\n    key: \"getGroupEdgeIndices\",\n    value: function getGroupEdgeIndices(groupIndex, isAllDay) {\n      var groupedDataMap = this.groupedDataMap.dateTableGroupedMap[groupIndex];\n      var cellsCount = groupedDataMap[0].length;\n      var rowsCount = groupedDataMap.length;\n      var firstColumnIndex = groupedDataMap[0][0].position.columnIndex;\n      var lastColumnIndex = groupedDataMap[0][cellsCount - 1].position.columnIndex;\n\n      if (isAllDay) {\n        return {\n          firstColumnIndex: firstColumnIndex,\n          lastColumnIndex: lastColumnIndex,\n          firstRowIndex: 0,\n          lastRowIndex: 0\n        };\n      }\n\n      return {\n        firstColumnIndex: firstColumnIndex,\n        lastColumnIndex: lastColumnIndex,\n        firstRowIndex: groupedDataMap[0][0].position.rowIndex,\n        lastRowIndex: groupedDataMap[rowsCount - 1][0].position.rowIndex\n      };\n    }\n  }, {\n    key: \"isSameCell\",\n    value: function isSameCell(firstCellData, secondCellData) {\n      var firstStartDate = firstCellData.startDate,\n          firstGroupIndex = firstCellData.groupIndex,\n          firstAllDay = firstCellData.allDay,\n          firstIndex = firstCellData.index;\n      var secondStartDate = secondCellData.startDate,\n          secondGroupIndex = secondCellData.groupIndex,\n          secondAllDay = secondCellData.allDay,\n          secondIndex = secondCellData.index;\n      return firstStartDate.getTime() === secondStartDate.getTime() && firstGroupIndex === secondGroupIndex && firstAllDay === secondAllDay && firstIndex === secondIndex;\n    }\n  }, {\n    key: \"getLastViewDate\",\n    value: function getLastViewDate() {\n      var completeViewDataMap = this.completeViewDataMap;\n      var rowsCount = completeViewDataMap.length - 1;\n      return completeViewDataMap[rowsCount][completeViewDataMap[rowsCount].length - 1].endDate;\n    }\n  }, {\n    key: \"getStartViewDate\",\n    value: function getStartViewDate() {\n      return this._options.startViewDate;\n    }\n  }, {\n    key: \"getIntervalDuration\",\n    value: function getIntervalDuration(intervalCount) {\n      return this.viewDataGenerator._getIntervalDuration(intervalCount);\n    }\n  }, {\n    key: \"getLastCellEndDate\",\n    value: function getLastCellEndDate() {\n      return new Date(this.getLastViewDate().getTime() - dateUtils.dateToMilliseconds(\"minute\"));\n    }\n  }, {\n    key: \"getLastViewDateByEndDayHour\",\n    value: function getLastViewDateByEndDayHour(endDayHour) {\n      var lastCellEndDate = this.getLastCellEndDate();\n      var endTime = dateUtils.dateTimeFromDecimal(endDayHour);\n      var endDateOfLastViewCell = new Date(lastCellEndDate.setHours(endTime.hours, endTime.minutes));\n      return this._adjustEndDateByDaylightDiff(lastCellEndDate, endDateOfLastViewCell);\n    }\n  }, {\n    key: \"_adjustEndDateByDaylightDiff\",\n    value: function _adjustEndDateByDaylightDiff(startDate, endDate) {\n      var daylightDiff = timeZoneUtils.getDaylightOffsetInMs(startDate, endDate);\n      var endDateOfLastViewCell = new Date(endDate.getTime() - daylightDiff);\n      return new Date(endDateOfLastViewCell.getTime() - dateUtils.dateToMilliseconds(\"minute\"));\n    }\n  }, {\n    key: \"getCellCountInDay\",\n    value: function getCellCountInDay(startDayHour, endDayHour, hoursInterval) {\n      return this.viewDataGenerator.getCellCountInDay(startDayHour, endDayHour, hoursInterval);\n    }\n  }, {\n    key: \"getCellCount\",\n    value: function getCellCount(options) {\n      return this.viewDataGenerator.getCellCount(options);\n    }\n  }, {\n    key: \"getRowCount\",\n    value: function getRowCount(options) {\n      return this.viewDataGenerator.getRowCount(options);\n    }\n  }, {\n    key: \"getVisibleDayDuration\",\n    value: function getVisibleDayDuration(startDayHour, endDayHour, hoursInterval) {\n      return this.viewDataGenerator.getVisibleDayDuration(startDayHour, endDayHour, hoursInterval);\n    }\n  }, {\n    key: \"_getRowCountWithAllDayRows\",\n    value: function _getRowCountWithAllDayRows() {\n      var allDayRowCount = this._options.isAllDayPanelVisible ? 1 : 0;\n      return this.getRowCount(this._options) + allDayRowCount;\n    }\n  }, {\n    key: \"getFirstDayOfWeek\",\n    value: function getFirstDayOfWeek(firstDayOfWeekOption) {\n      return this.viewDataGenerator.getFirstDayOfWeek(firstDayOfWeekOption);\n    }\n  }, {\n    key: \"setViewOptions\",\n    value: function setViewOptions(options) {\n      this._options = this._transformRenderOptions(options);\n    }\n  }, {\n    key: \"getViewOptions\",\n    value: function getViewOptions() {\n      return this._options;\n    }\n  }, {\n    key: \"getViewPortGroupCount\",\n    value: function getViewPortGroupCount() {\n      var dateTableGroupedMap = this.groupedDataMap.dateTableGroupedMap;\n      return (null === dateTableGroupedMap || void 0 === dateTableGroupedMap ? void 0 : dateTableGroupedMap.length) || 0;\n    }\n  }]);\n\n  return ViewDataProvider;\n}();\n\nexport { ViewDataProvider as default };","map":null,"metadata":{},"sourceType":"module"}