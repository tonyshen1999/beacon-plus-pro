{"ast":null,"code":"import _defineProperty from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\n\n/**\r\n * DevExtreme (esm/ui/pivot_grid/ui.pivot_grid.data_controller.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport Callbacks from \"../../core/utils/callbacks\";\nimport { when, Deferred } from \"../../core/utils/deferred\";\nimport { extend } from \"../../core/utils/extend\";\nimport { inArray } from \"../../core/utils/array\";\nimport { map, each } from \"../../core/utils/iterator\";\nimport Class from \"../../core/class\";\nimport { format } from \"../../core/utils/string\";\nimport { deferUpdate } from \"../../core/utils/common\";\nimport { isDefined, isString } from \"../../core/utils/type\";\nimport { VirtualScrollController } from \"../grid_core/ui.grid_core.virtual_scrolling_core\";\nimport { foreachColumnInfo, createColumnsInfo } from \"../grid_core/ui.grid_core.virtual_columns_core\";\nimport { StateStoringController } from \"../grid_core/ui.grid_core.state_storing_core\";\nimport PivotGridDataSource from \"./data_source\";\nimport { findField, foreachTree, foreachTreeAsync, createPath, formatValue } from \"./ui.pivot_grid.utils\";\nvar math = Math;\nvar GRAND_TOTAL_TYPE = \"GT\";\nvar TOTAL_TYPE = \"T\";\nvar DATA_TYPE = \"D\";\nvar NOT_AVAILABLE = \"#N/A\";\nvar CHANGING_DURATION_IF_PAGINATE = 300;\n\nvar proxyMethod = function proxyMethod(instance, methodName, defaultResult) {\n  if (!instance[methodName]) {\n    instance[methodName] = function () {\n      var dataSource = this._dataSource;\n      return dataSource ? dataSource[methodName].apply(dataSource, arguments) : defaultResult;\n    };\n  }\n};\n\nexport var DataController = Class.inherit(function () {\n  function formatCellValue(value, dataField, errorText) {\n    return value === NOT_AVAILABLE ? errorText : formatValue(value, dataField);\n  }\n\n  var createHeaderInfo = function () {\n    var addInfoItem = function addInfoItem(info, options) {\n      var breadth = options.lastIndex - options.index || 1;\n\n      var itemInfo = function (headerItem, breadth, isHorizontal, isTree) {\n        var infoItem = {\n          type: headerItem.type,\n          text: headerItem.text\n        };\n\n        if (headerItem.path) {\n          infoItem.path = headerItem.path;\n        }\n\n        if (headerItem.width) {\n          infoItem.width = headerItem.width;\n        }\n\n        if (isDefined(headerItem.wordWrapEnabled)) {\n          infoItem.wordWrapEnabled = headerItem.wordWrapEnabled;\n        }\n\n        if (headerItem.isLast) {\n          infoItem.isLast = true;\n        }\n\n        if (headerItem.sorted) {\n          infoItem.sorted = true;\n        }\n\n        if (headerItem.isMetric) {\n          infoItem.dataIndex = headerItem.dataIndex;\n        }\n\n        if (isDefined(headerItem.expanded)) {\n          infoItem.expanded = headerItem.expanded;\n        }\n\n        if (breadth > 1) {\n          infoItem[isHorizontal ? \"colspan\" : \"rowspan\"] = breadth;\n        }\n\n        if (headerItem.depthSize && headerItem.depthSize > 1) {\n          infoItem[isHorizontal ? \"rowspan\" : \"colspan\"] = headerItem.depthSize;\n        }\n\n        if (headerItem.index >= 0) {\n          infoItem.dataSourceIndex = headerItem.index;\n        }\n\n        if (isTree && headerItem.children && headerItem.children.length && !headerItem.children[0].isMetric) {\n          infoItem.width = null;\n          infoItem.isWhiteSpace = true;\n        }\n\n        return infoItem;\n      }(options.headerItem, breadth, options.isHorizontal, options.isTree);\n\n      !function (info, infoItem, itemIndex, depthIndex, isHorizontal) {\n        var index = isHorizontal ? depthIndex : itemIndex;\n\n        while (!info[index]) {\n          info.push([]);\n        }\n\n        if (isHorizontal) {\n          info[index].push(infoItem);\n        } else {\n          info[index].unshift(infoItem);\n        }\n      }(info, itemInfo, options.index, options.depth, options.isHorizontal);\n\n      if (!options.headerItem.children || 0 === options.headerItem.children.length) {\n        return options.lastIndex + 1;\n      }\n\n      return options.lastIndex;\n    };\n\n    var getViewHeaderItems = function getViewHeaderItems(headerItems, headerDescriptions, cellDescriptions, depthSize, options) {\n      var cellDescriptionsCount = cellDescriptions.length;\n\n      var viewHeaderItems = function (headerItems, headerDescriptions) {\n        var headerDescriptionsCount = headerDescriptions && headerDescriptions.length || 0;\n        var childrenStack = [];\n        var d = new Deferred();\n        var headerItem;\n        when(foreachTreeAsync(headerItems, function (items, index) {\n          var item = items[0];\n          var path = createPath(items);\n          headerItem = createHeaderItem(childrenStack, path.length, index);\n          headerItem.type = DATA_TYPE;\n          headerItem.value = item.value;\n          headerItem.path = path;\n          headerItem.text = item.text;\n          headerItem.index = item.index;\n          headerItem.displayText = item.displayText;\n          headerItem.key = item.key;\n          headerItem.isEmpty = item.isEmpty;\n\n          if (path.length < headerDescriptionsCount && (!item.children || 0 !== item.children.length)) {\n            headerItem.expanded = !!item.children;\n          }\n        })).done(function () {\n          d.resolve(createHeaderItem(childrenStack, 0, 0).children || []);\n        });\n        return d;\n      }(headerItems, headerDescriptions);\n\n      var dataFields = options.dataFields;\n      var d = new Deferred();\n      when(viewHeaderItems).done(function (viewHeaderItems) {\n        options.notifyProgress(.5);\n\n        if (options.showGrandTotals) {\n          viewHeaderItems[!options.showTotalsPrior ? \"push\" : \"unshift\"]({\n            type: GRAND_TOTAL_TYPE,\n            isEmpty: options.isEmptyGrandTotal\n          });\n        }\n\n        var hideTotals = false === options.showTotals || dataFields.length > 0 && dataFields.length === options.hiddenTotals.length;\n        var hideData = dataFields.length > 0 && options.hiddenValues.length === dataFields.length;\n\n        if (hideData && hideTotals) {\n          depthSize = 1;\n        }\n\n        if (!hideTotals || \"tree\" === options.layout) {\n          !function (headerItems, headerDescriptions, showTotalsPrior, isTree) {\n            showTotalsPrior = showTotalsPrior || isTree;\n            foreachTree(headerItems, function (items, index) {\n              var item = items[0];\n              var parentChildren = (items[1] ? items[1].children : headerItems) || [];\n              var dataField = headerDescriptions[items.length - 1];\n\n              if (item.type === DATA_TYPE && item.expanded && (false !== dataField.showTotals || isTree)) {\n                -1 !== index && parentChildren.splice(showTotalsPrior ? index : index + 1, 0, extend({}, item, {\n                  children: null,\n                  type: TOTAL_TYPE,\n                  expanded: showTotalsPrior ? true : null,\n                  isAdditionalTotal: true\n                }));\n\n                if (showTotalsPrior) {\n                  item.expanded = null;\n                }\n              }\n            });\n          }(viewHeaderItems, headerDescriptions, options.showTotalsPrior, \"tree\" === options.layout);\n        }\n\n        when(foreachTreeAsync(viewHeaderItems, function (items) {\n          var item = items[0];\n\n          if (!item.children || 0 === item.children.length) {\n            item.depthSize = depthSize - items.length + 1;\n          }\n        })).done(function () {\n          if (cellDescriptionsCount > 1) {\n            !function (headerItems, cellDescriptions, options) {\n              foreachTree(headerItems, function (items) {\n                var item = items[0];\n                var i;\n\n                if (!item.children || 0 === item.children.length) {\n                  item.children = [];\n\n                  for (i = 0; i < cellDescriptions.length; i++) {\n                    var isGrandTotal = item.type === GRAND_TOTAL_TYPE;\n                    var isTotal = item.type === TOTAL_TYPE;\n                    var isValue = item.type === DATA_TYPE;\n                    var columnIsHidden = false === cellDescriptions[i].visible || isGrandTotal && -1 !== inArray(i, options.hiddenGrandTotals) || isTotal && -1 !== inArray(i, options.hiddenTotals) || isValue && -1 !== inArray(i, options.hiddenValues);\n\n                    if (columnIsHidden) {\n                      continue;\n                    }\n\n                    item.children.push({\n                      caption: cellDescriptions[i].caption,\n                      path: item.path,\n                      type: item.type,\n                      value: i,\n                      index: item.index,\n                      dataIndex: i,\n                      isMetric: true,\n                      isEmpty: item.isEmpty && item.isEmpty[i]\n                    });\n                  }\n                }\n              });\n            }(viewHeaderItems, cellDescriptions, options);\n          }\n\n          !options.showEmpty && function (headerItems) {\n            foreachTree([{\n              children: headerItems\n            }], function (items, index) {\n              var item = items[0];\n              var parentChildren = (items[1] ? items[1].children : headerItems) || [];\n              var isEmpty = item.isEmpty;\n\n              if (isEmpty && isEmpty.length) {\n                isEmpty = item.isEmpty.filter(function (isEmpty) {\n                  return isEmpty;\n                }).length === isEmpty.length;\n              }\n\n              if (item && !item.children && isEmpty) {\n                parentChildren.splice(index, 1);\n                !function removeEmptyParent(items, index) {\n                  var parent = items[index + 1];\n\n                  if (!items[index].children.length && parent && parent.children) {\n                    parent.children.splice(inArray(items[index], parent.children), 1);\n                    removeEmptyParent(items, index + 1);\n                  }\n                }(items, 1);\n              }\n            });\n          }(viewHeaderItems);\n          options.notifyProgress(.75);\n          when(foreachTreeAsync(viewHeaderItems, function (items) {\n            var item = items[0];\n            var isMetric = item.isMetric;\n            var field = headerDescriptions[items.length - 1] || {};\n\n            if (item.type === DATA_TYPE && !isMetric) {\n              item.width = field.width;\n            }\n\n            if (true === hideData && item.type === DATA_TYPE) {\n              var parentChildren = (items[1] ? items[1].children : viewHeaderItems) || [];\n              parentChildren.splice(inArray(item, parentChildren), 1);\n              return;\n            }\n\n            if (isMetric) {\n              item.wordWrapEnabled = cellDescriptions[item.dataIndex].wordWrapEnabled;\n            } else {\n              item.wordWrapEnabled = field.wordWrapEnabled;\n            }\n\n            item.isLast = !item.children || !item.children.length;\n\n            if (item.isLast) {\n              each(options.sortBySummaryPaths, function (index, sortBySummaryPath) {\n                if (!isDefined(item.dataIndex)) {\n                  sortBySummaryPath = sortBySummaryPath.slice(0);\n                  sortBySummaryPath.pop();\n                }\n\n                if (function (items, sortBySummaryPath) {\n                  var path;\n                  var item = items[0];\n                  var stringValuesUsed = isString(sortBySummaryPath[0]);\n                  var headerItem = item.dataIndex >= 0 ? items[1] : item;\n\n                  if (stringValuesUsed && -1 !== sortBySummaryPath[0].indexOf(\"&[\") && headerItem.key || !headerItem.key) {\n                    path = createPath(items);\n                  } else {\n                    path = map(items, function (item) {\n                      return item.dataIndex >= 0 ? item.value : item.text;\n                    }).reverse();\n                  }\n\n                  if (item.type === GRAND_TOTAL_TYPE) {\n                    path = path.slice(1);\n                  }\n\n                  return path.join(\"/\") === sortBySummaryPath.join(\"/\");\n                }(items, sortBySummaryPath)) {\n                  item.sorted = true;\n                  return false;\n                }\n              });\n            }\n\n            item.text = function (item, description, options) {\n              var text = item.text;\n\n              if (isDefined(item.displayText)) {\n                text = item.displayText;\n              } else if (isDefined(item.caption)) {\n                text = item.caption;\n              } else if (item.type === GRAND_TOTAL_TYPE) {\n                text = options.texts.grandTotal;\n              }\n\n              if (item.isAdditionalTotal) {\n                text = format(options.texts.total || \"\", text);\n              }\n\n              return text;\n            }(item, 0, options);\n          })).done(function () {\n            if (!viewHeaderItems.length) {\n              viewHeaderItems.push({});\n            }\n\n            options.notifyProgress(1);\n            d.resolve(viewHeaderItems);\n          });\n        });\n      });\n      return d;\n    };\n\n    function createHeaderItem(childrenStack, depth, index) {\n      var parent = childrenStack[depth] = childrenStack[depth] || [];\n      var node = parent[index] = {};\n\n      if (childrenStack[depth + 1]) {\n        node.children = childrenStack[depth + 1];\n\n        for (var i = depth + 1; i < childrenStack.length; i++) {\n          childrenStack[i] = void 0;\n        }\n\n        childrenStack.length = depth + 1;\n      }\n\n      return node;\n    }\n\n    return function (headerItems, headerDescriptions, cellDescriptions, isHorizontal, options) {\n      var info = [];\n\n      var depthSize = function (headerItems) {\n        var depth = 0;\n        foreachTree(headerItems, function (items) {\n          depth = math.max(depth, items.length);\n        });\n        return depth;\n      }(headerItems) || 1;\n\n      var d = new Deferred();\n      getViewHeaderItems(headerItems, headerDescriptions, cellDescriptions, depthSize, options).done(function (viewHeaderItems) {\n        !function (info, viewHeaderItems, depthSize, isHorizontal, isTree) {\n          var lastIndex = 0;\n          var index;\n          var depth;\n          var indexesByDepth = [0];\n          foreachTree(viewHeaderItems, function (items) {\n            var headerItem = items[0];\n            depth = headerItem.isMetric ? depthSize : items.length - 1;\n\n            while (indexesByDepth.length - 1 < depth) {\n              indexesByDepth.push(indexesByDepth[indexesByDepth.length - 1]);\n            }\n\n            index = indexesByDepth[depth] || 0;\n            lastIndex = addInfoItem(info, {\n              headerItem: headerItem,\n              index: index,\n              lastIndex: lastIndex,\n              depth: depth,\n              isHorizontal: isHorizontal,\n              isTree: isTree\n            });\n            indexesByDepth.length = depth;\n            indexesByDepth.push(lastIndex);\n          });\n        }(info, viewHeaderItems, depthSize, isHorizontal, \"tree\" === options.layout);\n        options.notifyProgress(1);\n        d.resolve(info);\n      });\n      return d;\n    };\n  }();\n\n  function createSortPaths(headerFields, dataFields) {\n    var sortBySummaryPaths = [];\n    each(headerFields, function (index, headerField) {\n      var fieldIndex = findField(dataFields, headerField.sortBySummaryField);\n\n      if (fieldIndex >= 0) {\n        sortBySummaryPaths.push((headerField.sortBySummaryPath || []).concat([fieldIndex]));\n      }\n    });\n    return sortBySummaryPaths;\n  }\n\n  function foreachRowInfo(rowsInfo, callback) {\n    var columnOffset = 0;\n    var columnOffsetResetIndexes = [];\n\n    for (var i = 0; i < rowsInfo.length; i++) {\n      for (var j = 0; j < rowsInfo[i].length; j++) {\n        var rowSpanOffset = (rowsInfo[i][j].rowspan || 1) - 1;\n        var visibleIndex = i + rowSpanOffset;\n\n        if (columnOffsetResetIndexes[i]) {\n          columnOffset -= columnOffsetResetIndexes[i];\n          columnOffsetResetIndexes[i] = 0;\n        }\n\n        if (false === callback(rowsInfo[i][j], visibleIndex, i, j, columnOffset)) {\n          break;\n        }\n\n        columnOffsetResetIndexes[i + (rowsInfo[i][j].rowspan || 1)] = (columnOffsetResetIndexes[i + (rowsInfo[i][j].rowspan || 1)] || 0) + 1;\n        columnOffset++;\n      }\n    }\n  }\n\n  function getHeaderIndexedItems(headerItems, options) {\n    var visibleIndex = 0;\n    var indexedItems = [];\n    foreachTree(headerItems, function (items) {\n      var headerItem = items[0];\n      var path = createPath(items);\n\n      if (headerItem.children && false === options.showTotals) {\n        return;\n      }\n\n      var indexedItem = extend(true, {}, headerItem, {\n        visibleIndex: visibleIndex++,\n        path: path\n      });\n\n      if (isDefined(indexedItem.index)) {\n        indexedItems[indexedItem.index] = indexedItem;\n      } else {\n        indexedItems.push(indexedItem);\n      }\n    });\n    return indexedItems;\n  }\n\n  function createScrollController(dataController, component, dataAdapter) {\n    return new VirtualScrollController(component, extend({\n      hasKnownLastPage: function hasKnownLastPage() {\n        return true;\n      },\n      pageCount: function pageCount() {\n        return math.ceil(this.totalItemsCount() / this.pageSize());\n      },\n      updateLoading: function updateLoading() {},\n      itemsCount: function itemsCount() {\n        if (this.pageIndex() < this.pageCount() - 1) {\n          return this.pageSize();\n        } else {\n          return this.totalItemsCount() % this.pageSize();\n        }\n      },\n      items: function items() {\n        return [];\n      },\n      viewportItems: function viewportItems() {\n        return [];\n      },\n      onChanged: function onChanged() {},\n      isLoading: function isLoading() {\n        return dataController.isLoading();\n      },\n      changingDuration: function changingDuration() {\n        var dataSource = dataController._dataSource;\n\n        if (dataSource.paginate()) {\n          return CHANGING_DURATION_IF_PAGINATE;\n        }\n\n        return dataController._changingDuration || 0;\n      }\n    }, dataAdapter));\n  }\n\n  var members = {\n    ctor: function ctor(options) {\n      var that = this;\n\n      var virtualScrollControllerChanged = that._fireChanged.bind(that);\n\n      options = that._options = options || {};\n      that.dataSourceChanged = Callbacks();\n      that._dataSource = that._createDataSource(options);\n\n      if (options.component && \"virtual\" === options.component.option(\"scrolling.mode\")) {\n        that._rowsScrollController = createScrollController(that, options.component, {\n          totalItemsCount: function totalItemsCount() {\n            return that.totalRowCount();\n          },\n          pageIndex: function pageIndex(index) {\n            return that.rowPageIndex(index);\n          },\n          pageSize: function pageSize() {\n            return that.rowPageSize();\n          },\n          load: function load() {\n            if (that._rowsScrollController.pageIndex() >= this.pageCount()) {\n              that._rowsScrollController.pageIndex(this.pageCount() - 1);\n            }\n\n            return that._rowsScrollController.handleDataChanged(function () {\n              if (that._dataSource.paginate()) {\n                that._dataSource.load();\n              } else {\n                virtualScrollControllerChanged.apply(this, arguments);\n              }\n            });\n          }\n        });\n        that._columnsScrollController = createScrollController(that, options.component, {\n          totalItemsCount: function totalItemsCount() {\n            return that.totalColumnCount();\n          },\n          pageIndex: function pageIndex(index) {\n            return that.columnPageIndex(index);\n          },\n          pageSize: function pageSize() {\n            return that.columnPageSize();\n          },\n          load: function load() {\n            if (that._columnsScrollController.pageIndex() >= this.pageCount()) {\n              that._columnsScrollController.pageIndex(this.pageCount() - 1);\n            }\n\n            return that._columnsScrollController.handleDataChanged(function () {\n              if (that._dataSource.paginate()) {\n                that._dataSource.load();\n              } else {\n                virtualScrollControllerChanged.apply(this, arguments);\n              }\n            });\n          }\n        });\n      }\n\n      that._stateStoringController = new StateStoringController(options.component).init();\n      that._columnsInfo = [];\n      that._rowsInfo = [];\n      that._cellsInfo = [];\n      that.expandValueChanging = Callbacks();\n      that.loadingChanged = Callbacks();\n      that.progressChanged = Callbacks();\n      that.scrollChanged = Callbacks();\n      that.load();\n\n      that._update();\n\n      that.changed = Callbacks();\n    },\n    _fireChanged: function _fireChanged() {\n      var startChanging = new Date();\n      this.changed && !this._lockChanged && this.changed.fire();\n      this._changingDuration = new Date() - startChanging;\n    },\n    _correctSkipsTakes: function _correctSkipsTakes(rowIndex, rowSkip, rowSpan, levels, skips, takes) {\n      var endIndex = rowSpan ? rowIndex + rowSpan - 1 : rowIndex;\n      skips[levels.length] = skips[levels.length] || 0;\n      takes[levels.length] = takes[levels.length] || 0;\n\n      if (endIndex < rowSkip) {\n        skips[levels.length]++;\n      } else {\n        takes[levels.length]++;\n      }\n    },\n    _calculatePagingForRowExpandedPaths: function _calculatePagingForRowExpandedPaths(options, skips, takes, rowExpandedSkips, rowExpandedTakes) {\n      var rows = this._rowsInfo;\n      var rowCount = Math.min(options.rowSkip + options.rowTake, rows.length);\n      var rowExpandedPaths = options.rowExpandedPaths;\n      var levels = [];\n      var expandedPathIndexes = {};\n      var i;\n      var j;\n      var path;\n      rowExpandedPaths.forEach(function (path, index) {\n        expandedPathIndexes[path] = index;\n      });\n\n      for (i = 0; i < rowCount; i++) {\n        takes.length = skips.length = levels.length + 1;\n\n        for (j = 0; j < rows[i].length; j++) {\n          var cell = rows[i][j];\n\n          if (\"D\" === cell.type) {\n            this._correctSkipsTakes(i, options.rowSkip, cell.rowspan, levels, skips, takes);\n\n            path = cell.path || path;\n            var expandIndex = path && path.length > 1 ? expandedPathIndexes[path.slice(0, -1)] : -1;\n\n            if (expandIndex >= 0) {\n              rowExpandedSkips[expandIndex] = skips[levels.length] || 0;\n              rowExpandedTakes[expandIndex] = takes[levels.length] || 0;\n            }\n\n            if (cell.rowspan) {\n              levels.push(cell.rowspan);\n            }\n          }\n        }\n\n        levels = levels.map(function (level) {\n          return level - 1;\n        }).filter(function (level) {\n          return level > 0;\n        });\n      }\n    },\n    _calculatePagingForColumnExpandedPaths: function _calculatePagingForColumnExpandedPaths(options, skips, takes, expandedSkips, expandedTakes) {\n      var skipByPath = {};\n      var takeByPath = {};\n      foreachColumnInfo(this._columnsInfo, function (columnInfo, columnIndex) {\n        if (\"D\" === columnInfo.type && columnInfo.path && void 0 === columnInfo.dataIndex) {\n          var colspan = columnInfo.colspan || 1;\n          var path = columnInfo.path.slice(0, -1).toString();\n          skipByPath[path] = skipByPath[path] || 0;\n          takeByPath[path] = takeByPath[path] || 0;\n\n          if (columnIndex + colspan <= options.columnSkip) {\n            skipByPath[path]++;\n          } else if (columnIndex < options.columnSkip + options.columnTake) {\n            takeByPath[path]++;\n          }\n        }\n      });\n      skips[0] = skipByPath[[]];\n      takes[0] = takeByPath[[]];\n      options.columnExpandedPaths.forEach(function (path, index) {\n        var skip = skipByPath[path];\n        var take = takeByPath[path];\n\n        if (void 0 !== skip) {\n          expandedSkips[index] = skip;\n        }\n\n        if (void 0 !== take) {\n          expandedTakes[index] = take;\n        }\n      });\n    },\n    _processPagingForExpandedPaths: function _processPagingForExpandedPaths(options, area, storeLoadOptions, reload) {\n      var expandedPaths = options[area + \"ExpandedPaths\"];\n      var expandedSkips = expandedPaths.map(function () {\n        return 0;\n      });\n      var expandedTakes = expandedPaths.map(function () {\n        return reload ? options.pageSize : 0;\n      });\n      var skips = [];\n      var takes = [];\n\n      if (!reload) {\n        if (\"row\" === area) {\n          this._calculatePagingForRowExpandedPaths(options, skips, takes, expandedSkips, expandedTakes);\n        } else {\n          this._calculatePagingForColumnExpandedPaths(options, skips, takes, expandedSkips, expandedTakes);\n        }\n      }\n\n      this._savePagingForExpandedPaths(options, area, storeLoadOptions, skips[0], takes[0], expandedSkips, expandedTakes);\n    },\n    _savePagingForExpandedPaths: function _savePagingForExpandedPaths(options, area, storeLoadOptions, skip, take, expandedSkips, expandedTakes) {\n      var expandedPaths = options[area + \"ExpandedPaths\"];\n      options[area + \"ExpandedPaths\"] = [];\n      options[area + \"Skip\"] = void 0 !== skip ? skip : options[area + \"Skip\"];\n      options[area + \"Take\"] = void 0 !== take ? take : options[area + \"Take\"];\n\n      for (var i = 0; i < expandedPaths.length; i++) {\n        if (expandedTakes[i]) {\n          var _extend;\n\n          var isOppositeArea = options.area && options.area !== area;\n          storeLoadOptions.push(extend({\n            area: area,\n            headerName: area + \"s\"\n          }, options, (_extend = {}, _defineProperty(_extend, area + \"Skip\", expandedSkips[i]), _defineProperty(_extend, area + \"Take\", expandedTakes[i]), _defineProperty(_extend, isOppositeArea ? \"oppositePath\" : \"path\", expandedPaths[i]), _extend)));\n        }\n      }\n    },\n    _handleCustomizeStoreLoadOptions: function _handleCustomizeStoreLoadOptions(storeLoadOptions, reload) {\n      var _this = this;\n\n      var options = storeLoadOptions[0];\n      var rowsScrollController = this._rowsScrollController;\n\n      if (this._dataSource.paginate() && rowsScrollController) {\n        var rowPageSize = rowsScrollController.pageSize();\n\n        if (\"rows\" === options.headerName) {\n          options.rowSkip = 0;\n          options.rowTake = rowPageSize;\n          options.rowExpandedPaths = [];\n        } else {\n          options.rowSkip = rowsScrollController.beginPageIndex() * rowPageSize;\n          options.rowTake = (rowsScrollController.endPageIndex() - rowsScrollController.beginPageIndex() + 1) * rowPageSize;\n\n          this._processPagingForExpandedPaths(options, \"row\", storeLoadOptions, reload);\n        }\n      }\n\n      var columnsScrollController = this._columnsScrollController;\n\n      if (this._dataSource.paginate() && columnsScrollController) {\n        var columnPageSize = columnsScrollController.pageSize();\n        storeLoadOptions.forEach(function (options, index) {\n          if (\"columns\" === options.headerName) {\n            options.columnSkip = 0;\n            options.columnTake = columnPageSize;\n            options.columnExpandedPaths = [];\n          } else {\n            options.columnSkip = columnsScrollController.beginPageIndex() * columnPageSize;\n            options.columnTake = (columnsScrollController.endPageIndex() - columnsScrollController.beginPageIndex() + 1) * columnPageSize;\n\n            _this._processPagingForExpandedPaths(options, \"column\", storeLoadOptions, reload);\n          }\n        });\n      }\n    },\n    load: function load() {\n      var that = this;\n      var stateStoringController = this._stateStoringController;\n\n      if (stateStoringController.isEnabled() && !stateStoringController.isLoaded()) {\n        stateStoringController.load().always(function (state) {\n          if (state) {\n            that._dataSource.state(state);\n          } else {\n            that._dataSource.load();\n          }\n        });\n      } else {\n        that._dataSource.load();\n      }\n    },\n    calculateVirtualContentParams: function calculateVirtualContentParams(contentParams) {\n      var rowsScrollController = this._rowsScrollController;\n      var columnsScrollController = this._columnsScrollController;\n\n      if (rowsScrollController && columnsScrollController) {\n        rowsScrollController.viewportItemSize(contentParams.virtualRowHeight);\n        rowsScrollController.viewportSize(contentParams.viewportHeight / rowsScrollController.viewportItemSize());\n        rowsScrollController.setContentItemSizes(contentParams.itemHeights);\n        columnsScrollController.viewportItemSize(contentParams.virtualColumnWidth);\n        columnsScrollController.viewportSize(contentParams.viewportWidth / columnsScrollController.viewportItemSize());\n        columnsScrollController.setContentItemSizes(contentParams.itemWidths);\n        deferUpdate(function () {\n          columnsScrollController.loadIfNeed();\n          rowsScrollController.loadIfNeed();\n        });\n        this.scrollChanged.fire({\n          left: columnsScrollController.getViewportPosition(),\n          top: rowsScrollController.getViewportPosition()\n        });\n        return {\n          contentTop: rowsScrollController.getContentOffset(),\n          contentLeft: columnsScrollController.getContentOffset(),\n          width: columnsScrollController.getVirtualContentSize(),\n          height: rowsScrollController.getVirtualContentSize()\n        };\n      }\n    },\n    setViewportPosition: function setViewportPosition(left, top) {\n      this._rowsScrollController.setViewportPosition(top || 0);\n\n      this._columnsScrollController.setViewportPosition(left || 0);\n    },\n    subscribeToWindowScrollEvents: function subscribeToWindowScrollEvents($element) {\n      this._rowsScrollController && this._rowsScrollController.subscribeToWindowScrollEvents($element);\n    },\n    updateWindowScrollPosition: function updateWindowScrollPosition(position) {\n      this._rowsScrollController && this._rowsScrollController.scrollTo(position);\n    },\n    updateViewOptions: function updateViewOptions(options) {\n      extend(this._options, options);\n\n      this._update();\n    },\n    _handleExpandValueChanging: function _handleExpandValueChanging(e) {\n      this.expandValueChanging.fire(e);\n    },\n    _handleLoadingChanged: function _handleLoadingChanged(isLoading) {\n      this.loadingChanged.fire(isLoading);\n    },\n    _handleProgressChanged: function _handleProgressChanged(progress) {\n      this.progressChanged.fire(progress);\n    },\n    _handleFieldsPrepared: function _handleFieldsPrepared(e) {\n      this._options.onFieldsPrepared && this._options.onFieldsPrepared(e);\n    },\n    _createDataSource: function _createDataSource(options) {\n      var that = this;\n      var dataSourceOptions = options.dataSource;\n      var dataSource;\n      that._isSharedDataSource = dataSourceOptions instanceof PivotGridDataSource;\n\n      if (that._isSharedDataSource) {\n        dataSource = dataSourceOptions;\n      } else {\n        dataSource = new PivotGridDataSource(dataSourceOptions);\n      }\n\n      that._expandValueChangingHandler = that._handleExpandValueChanging.bind(that);\n      that._loadingChangedHandler = that._handleLoadingChanged.bind(that);\n      that._fieldsPreparedHandler = that._handleFieldsPrepared.bind(that);\n      that._customizeStoreLoadOptionsHandler = that._handleCustomizeStoreLoadOptions.bind(that);\n\n      that._changedHandler = function () {\n        that._update();\n\n        that.dataSourceChanged.fire();\n      };\n\n      that._progressChangedHandler = function (progress) {\n        that._handleProgressChanged(.8 * progress);\n      };\n\n      dataSource.on(\"changed\", that._changedHandler);\n      dataSource.on(\"expandValueChanging\", that._expandValueChangingHandler);\n      dataSource.on(\"loadingChanged\", that._loadingChangedHandler);\n      dataSource.on(\"progressChanged\", that._progressChangedHandler);\n      dataSource.on(\"fieldsPrepared\", that._fieldsPreparedHandler);\n      dataSource.on(\"customizeStoreLoadOptions\", that._customizeStoreLoadOptionsHandler);\n      return dataSource;\n    },\n    getDataSource: function getDataSource() {\n      return this._dataSource;\n    },\n    isLoading: function isLoading() {\n      return this._dataSource.isLoading();\n    },\n    beginLoading: function beginLoading() {\n      this._dataSource.beginLoading();\n    },\n    endLoading: function endLoading() {\n      this._dataSource.endLoading();\n    },\n    _update: function _update() {\n      var that = this;\n      var dataSource = that._dataSource;\n      var options = that._options;\n      var columnFields = dataSource.getAreaFields(\"column\");\n      var rowFields = dataSource.getAreaFields(\"row\");\n      var dataFields = dataSource.getAreaFields(\"data\");\n      var dataFieldsForRows = \"row\" === options.dataFieldArea ? dataFields : [];\n      var dataFieldsForColumns = \"row\" !== options.dataFieldArea ? dataFields : [];\n      var data = dataSource.getData();\n\n      var hiddenTotals = function (dataFields) {\n        var result = [];\n        each(dataFields, function (index, field) {\n          if (false === field.showTotals) {\n            result.push(index);\n          }\n        });\n        return result;\n      }(dataFields);\n\n      var hiddenValues = function (dataFields) {\n        var result = [];\n        dataFields.forEach(function (field, index) {\n          if (void 0 === field.showValues && false === field.showTotals || false === field.showValues) {\n            result.push(index);\n          }\n        });\n        return result;\n      }(dataFields);\n\n      var hiddenGrandTotals = function (dataFields, columnFields) {\n        var result = [];\n        each(dataFields, function (index, field) {\n          if (false === field.showGrandTotals) {\n            result.push(index);\n          }\n        });\n\n        if (0 === columnFields.length && result.length === dataFields.length) {\n          result = [];\n        }\n\n        return result;\n      }(dataFields, columnFields);\n\n      var grandTotalsAreHiddenForNotAllDataFields = dataFields.length > 0 ? hiddenGrandTotals.length !== dataFields.length : true;\n      var rowOptions = {\n        isEmptyGrandTotal: data.isEmptyGrandTotalRow,\n        texts: options.texts || {},\n        hiddenTotals: hiddenTotals,\n        hiddenValues: hiddenValues,\n        hiddenGrandTotals: [],\n        showTotals: options.showRowTotals,\n        showGrandTotals: false !== options.showRowGrandTotals && grandTotalsAreHiddenForNotAllDataFields,\n        sortBySummaryPaths: createSortPaths(columnFields, dataFields),\n        showTotalsPrior: \"rows\" === options.showTotalsPrior || \"both\" === options.showTotalsPrior,\n        showEmpty: !options.hideEmptySummaryCells,\n        layout: options.rowHeaderLayout,\n        fields: rowFields,\n        dataFields: dataFields,\n        progress: 0\n      };\n      var columnOptions = {\n        isEmptyGrandTotal: data.isEmptyGrandTotalColumn,\n        texts: options.texts || {},\n        hiddenTotals: hiddenTotals,\n        hiddenValues: hiddenValues,\n        hiddenGrandTotals: hiddenGrandTotals,\n        showTotals: options.showColumnTotals,\n        showTotalsPrior: \"columns\" === options.showTotalsPrior || \"both\" === options.showTotalsPrior,\n        showGrandTotals: false !== options.showColumnGrandTotals && grandTotalsAreHiddenForNotAllDataFields,\n        sortBySummaryPaths: createSortPaths(rowFields, dataFields),\n        showEmpty: !options.hideEmptySummaryCells,\n        fields: columnFields,\n        dataFields: dataFields,\n        progress: 0\n      };\n\n      var notifyProgress = function notifyProgress(progress) {\n        this.progress = progress;\n\n        that._handleProgressChanged(.8 + .1 * rowOptions.progress + .1 * columnOptions.progress);\n      };\n\n      rowOptions.notifyProgress = notifyProgress;\n      columnOptions.notifyProgress = notifyProgress;\n\n      if (!isDefined(data.grandTotalRowIndex)) {\n        data.grandTotalRowIndex = getHeaderIndexedItems(data.rows, rowOptions).length;\n      }\n\n      if (!isDefined(data.grandTotalColumnIndex)) {\n        data.grandTotalColumnIndex = getHeaderIndexedItems(data.columns, columnOptions).length;\n      }\n\n      dataSource._changeLoadingCount(1);\n\n      when(createHeaderInfo(data.columns, columnFields, dataFieldsForColumns, true, columnOptions), createHeaderInfo(data.rows, rowFields, dataFieldsForRows, false, rowOptions)).always(function () {\n        dataSource._changeLoadingCount(-1);\n      }).done(function (columnsInfo, rowsInfo) {\n        that._columnsInfo = columnsInfo;\n        that._rowsInfo = rowsInfo;\n\n        if (that._rowsScrollController && that._columnsScrollController && that.changed && !that._dataSource.paginate()) {\n          that._rowsScrollController.reset(true);\n\n          that._columnsScrollController.reset(true);\n\n          that._lockChanged = true;\n\n          that._rowsScrollController.load();\n\n          that._columnsScrollController.load();\n\n          that._lockChanged = false;\n        }\n      }).done(function () {\n        that._fireChanged();\n\n        if (that._stateStoringController.isEnabled() && !that._dataSource.isLoading()) {\n          that._stateStoringController.state(that._dataSource.state());\n\n          that._stateStoringController.save();\n        }\n      });\n    },\n    getRowsInfo: function getRowsInfo(getAllData) {\n      var rowsInfo = this._rowsInfo;\n      var scrollController = this._rowsScrollController;\n      var rowspan;\n\n      if (scrollController && !getAllData) {\n        var startIndex = scrollController.beginPageIndex() * this.rowPageSize();\n        var endIndex = scrollController.endPageIndex() * this.rowPageSize() + this.rowPageSize();\n        var newRowsInfo = [];\n        var maxDepth = 1;\n        foreachRowInfo(rowsInfo, function (rowInfo, visibleIndex, rowIndex, _, columnIndex) {\n          var isVisible = visibleIndex >= startIndex && rowIndex < endIndex;\n          var index = rowIndex < startIndex ? 0 : rowIndex - startIndex;\n          var cell = rowInfo;\n\n          if (isVisible) {\n            newRowsInfo[index] = newRowsInfo[index] || [];\n            rowspan = rowIndex < startIndex ? rowInfo.rowspan - (startIndex - rowIndex) || 1 : rowInfo.rowspan;\n\n            if (startIndex + index + rowspan > endIndex) {\n              rowspan = endIndex - (index + startIndex) || 1;\n            }\n\n            if (rowspan !== rowInfo.rowspan) {\n              cell = extend({}, cell, {\n                rowspan: rowspan\n              });\n            }\n\n            newRowsInfo[index].push(cell);\n            maxDepth = math.max(maxDepth, columnIndex + 1);\n          } else if (void 0 > endIndex) {\n            return false;\n          }\n        });\n        foreachRowInfo(newRowsInfo, function (rowInfo, visibleIndex, rowIndex, columnIndex, realColumnIndex) {\n          var colspan = rowInfo.colspan || 1;\n\n          if (realColumnIndex + colspan > maxDepth) {\n            newRowsInfo[rowIndex][columnIndex] = extend({}, rowInfo, {\n              colspan: maxDepth - realColumnIndex || 1\n            });\n          }\n        });\n        return newRowsInfo;\n      }\n\n      return rowsInfo;\n    },\n    getColumnsInfo: function getColumnsInfo(getAllData) {\n      var info = this._columnsInfo;\n      var scrollController = this._columnsScrollController;\n\n      if (scrollController && !getAllData) {\n        var startIndex = scrollController.beginPageIndex() * this.columnPageSize();\n        var endIndex = scrollController.endPageIndex() * this.columnPageSize() + this.columnPageSize();\n        info = createColumnsInfo(info, startIndex, endIndex);\n      }\n\n      return info;\n    },\n    totalRowCount: function totalRowCount() {\n      return this._rowsInfo.length;\n    },\n    rowPageIndex: function rowPageIndex(index) {\n      if (void 0 !== index) {\n        this._rowPageIndex = index;\n      }\n\n      return this._rowPageIndex || 0;\n    },\n    totalColumnCount: function totalColumnCount() {\n      var count = 0;\n\n      if (this._columnsInfo && this._columnsInfo.length) {\n        for (var i = 0; i < this._columnsInfo[0].length; i++) {\n          count += this._columnsInfo[0][i].colspan || 1;\n        }\n      }\n\n      return count;\n    },\n    rowPageSize: function rowPageSize(size) {\n      if (void 0 !== size) {\n        this._rowPageSize = size;\n      }\n\n      return this._rowPageSize || 20;\n    },\n    columnPageSize: function columnPageSize(size) {\n      if (void 0 !== size) {\n        this._columnPageSize = size;\n      }\n\n      return this._columnPageSize || 20;\n    },\n    columnPageIndex: function columnPageIndex(index) {\n      if (void 0 !== index) {\n        this._columnPageIndex = index;\n      }\n\n      return this._columnPageIndex || 0;\n    },\n    getCellsInfo: function getCellsInfo(getAllData) {\n      var rowsInfo = this.getRowsInfo(getAllData);\n      var columnsInfo = this.getColumnsInfo(getAllData);\n\n      var data = this._dataSource.getData();\n\n      var texts = this._options.texts || {};\n      return function (rowsInfo, columnsInfo, data, dataFields, dataFieldArea, errorText) {\n        var info = [];\n        var dataFieldAreaInRows = \"row\" === dataFieldArea;\n        var dataSourceCells = data.values;\n        dataSourceCells.length && foreachRowInfo(rowsInfo, function (rowInfo, rowIndex) {\n          var row = info[rowIndex] = [];\n          var dataRow = dataSourceCells[rowInfo.dataSourceIndex >= 0 ? rowInfo.dataSourceIndex : data.grandTotalRowIndex] || [];\n          rowInfo.isLast && foreachColumnInfo(columnsInfo, function (columnInfo, columnIndex) {\n            var dataIndex = (dataFieldAreaInRows ? rowInfo.dataIndex : columnInfo.dataIndex) || 0;\n            var dataField = dataFields[dataIndex];\n\n            if (columnInfo.isLast && dataField && false !== dataField.visible) {\n              var cell = dataRow[columnInfo.dataSourceIndex >= 0 ? columnInfo.dataSourceIndex : data.grandTotalColumnIndex];\n\n              if (!Array.isArray(cell)) {\n                cell = [cell];\n              }\n\n              var cellValue = cell[dataIndex];\n              row[columnIndex] = {\n                text: formatCellValue(cellValue, dataField, errorText),\n                value: cellValue,\n                format: dataField.format,\n                dataType: dataField.dataType,\n                columnType: columnInfo.type,\n                rowType: rowInfo.type,\n                rowPath: rowInfo.path || [],\n                columnPath: columnInfo.path || [],\n                dataIndex: dataIndex\n              };\n\n              if (dataField.width) {\n                row[columnIndex].width = dataField.width;\n              }\n            }\n          });\n        });\n        return info;\n      }(rowsInfo, columnsInfo, data, this._dataSource.getAreaFields(\"data\"), this._options.dataFieldArea, texts.dataNotAvailable);\n    },\n    dispose: function dispose() {\n      if (this._isSharedDataSource) {\n        this._dataSource.off(\"changed\", this._changedHandler);\n\n        this._dataSource.off(\"expandValueChanging\", this._expandValueChangingHandler);\n\n        this._dataSource.off(\"loadingChanged\", this._loadingChangedHandler);\n\n        this._dataSource.off(\"progressChanged\", this._progressChangedHandler);\n\n        this._dataSource.off(\"fieldsPrepared\", this._fieldsPreparedHandler);\n\n        this._dataSource.off(\"customizeStoreLoadOptions\", this._customizeStoreLoadOptionsHandler);\n      } else {\n        this._dataSource.dispose();\n      }\n\n      this._columnsScrollController && this._columnsScrollController.dispose();\n      this._rowsScrollController && this._rowsScrollController.dispose();\n\n      this._stateStoringController.dispose();\n\n      this.expandValueChanging.empty();\n      this.changed.empty();\n      this.loadingChanged.empty();\n      this.progressChanged.empty();\n      this.scrollChanged.empty();\n      this.dataSourceChanged.empty();\n    }\n  };\n  proxyMethod(members, \"applyPartialDataSource\");\n  proxyMethod(members, \"collapseHeaderItem\");\n  proxyMethod(members, \"expandHeaderItem\");\n  proxyMethod(members, \"getData\");\n  proxyMethod(members, \"isEmpty\");\n  return members;\n}());","map":null,"metadata":{},"sourceType":"module"}