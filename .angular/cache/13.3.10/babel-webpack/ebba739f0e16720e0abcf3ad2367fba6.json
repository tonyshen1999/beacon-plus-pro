{"ast":null,"code":"/**\r\n * DevExtreme (esm/viz/series/points/bar_point.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { extend } from \"../../../core/utils/extend\";\nvar _extend = extend;\nvar _math = Math;\nvar _floor = _math.floor;\nvar _abs = _math.abs;\nimport symbolPoint from \"./symbol_point\";\nvar CANVAS_POSITION_DEFAULT = \"canvas_position_default\";\nvar DEFAULT_BAR_TRACKER_SIZE = 9;\nvar CORRECTING_BAR_TRACKER_VALUE = 4;\nvar RIGHT = \"right\";\nvar LEFT = \"left\";\nvar TOP = \"top\";\nvar BOTTOM = \"bottom\";\n\nfunction getLabelOrientation(point) {\n  var initialValue = point.initialValue;\n\n  var invert = point._getValTranslator().getBusinessRange().invert;\n\n  var isDiscreteValue = \"discrete\" === point.series.valueAxisType;\n  var isFullStacked = point.series.isFullStackedSeries();\n  var notAxisInverted = !isDiscreteValue && (initialValue >= 0 && !invert || initialValue < 0 && invert) || isDiscreteValue && !invert || isFullStacked;\n  return notAxisInverted ? TOP : BOTTOM;\n}\n\nexport default _extend({}, symbolPoint, {\n  correctCoordinates: function correctCoordinates(correctOptions) {\n    var correction = _floor(correctOptions.offset - correctOptions.width / 2);\n\n    if (this._options.rotated) {\n      this.height = correctOptions.width;\n      this.yCorrection = correction;\n      this.xCorrection = null;\n    } else {\n      this.width = correctOptions.width;\n      this.xCorrection = correction;\n      this.yCorrection = null;\n    }\n  },\n  _getGraphicBBox: function _getGraphicBBox(location) {\n    var bBox = {\n      x: this.x,\n      y: this.y,\n      width: this.width,\n      height: this.height\n    };\n\n    if (location) {\n      var isTop = \"top\" === location;\n\n      if (!this._options.rotated) {\n        bBox.y = isTop ? bBox.y : bBox.y + bBox.height;\n        bBox.height = 0;\n      } else {\n        bBox.x = isTop ? bBox.x + bBox.width : bBox.x;\n        bBox.width = 0;\n      }\n    }\n\n    return bBox;\n  },\n  _getLabelConnector: function _getLabelConnector(location) {\n    return this._getGraphicBBox(location);\n  },\n  _getLabelPosition: function _getLabelPosition() {\n    var position = getLabelOrientation(this);\n\n    if (this._options.rotated) {\n      position = position === TOP ? RIGHT : LEFT;\n    }\n\n    return position;\n  },\n  _getLabelCoords: function _getLabelCoords(label) {\n    var coords;\n\n    if (0 === this.initialValue && this.series.isFullStackedSeries()) {\n      if (!this._options.rotated) {\n        coords = this._getLabelCoordOfPosition(label, TOP);\n      } else {\n        coords = this._getLabelCoordOfPosition(label, RIGHT);\n      }\n    } else if (\"inside\" === label.getLayoutOptions().position) {\n      coords = this._getLabelCoordOfPosition(label, \"inside\");\n    } else {\n      coords = symbolPoint._getLabelCoords.call(this, label);\n    }\n\n    return coords;\n  },\n  _drawLabel: function _drawLabel() {\n    this._label.pointPosition = \"inside\" !== this._label.getLayoutOptions().position && getLabelOrientation(this);\n\n    symbolPoint._drawLabel.call(this);\n  },\n  hideInsideLabel: function hideInsideLabel(label, coord) {\n    var graphicBBox = this._getGraphicBBox();\n\n    var labelBBox = label.getBoundingRect();\n\n    if (this._options.resolveLabelsOverlapping) {\n      if ((coord.y <= graphicBBox.y && coord.y + labelBBox.height >= graphicBBox.y + graphicBBox.height || coord.x <= graphicBBox.x && coord.x + labelBBox.width >= graphicBBox.x + graphicBBox.width) && !(coord.y > graphicBBox.y + graphicBBox.height || coord.y + labelBBox.height < graphicBBox.y || coord.x > graphicBBox.x + graphicBBox.width || coord.x + labelBBox.width < graphicBBox.x)) {\n        label.draw(false);\n        return true;\n      }\n    }\n\n    return false;\n  },\n  _showForZeroValues: function _showForZeroValues() {\n    return this._options.label.showForZeroValues || this.initialValue;\n  },\n  _drawMarker: function _drawMarker(renderer, group, animationEnabled) {\n    var style = this._getStyle();\n\n    var r = this._options.cornerRadius;\n    var rotated = this._options.rotated;\n\n    var _this$getMarkerCoords = this.getMarkerCoords(),\n        x = _this$getMarkerCoords.x,\n        y = _this$getMarkerCoords.y,\n        width = _this$getMarkerCoords.width,\n        height = _this$getMarkerCoords.height;\n\n    if (animationEnabled) {\n      if (rotated) {\n        width = 0;\n        x = this.defaultX;\n      } else {\n        height = 0;\n        y = this.defaultY;\n      }\n    }\n\n    this.graphic = renderer.rect(x, y, width, height).attr({\n      rx: r,\n      ry: r\n    }).smartAttr(style).data({\n      \"chart-data-point\": this\n    }).append(group);\n  },\n  _getSettingsForTracker: function _getSettingsForTracker() {\n    var y = this.y;\n    var height = this.height;\n    var x = this.x;\n    var width = this.width;\n\n    if (this._options.rotated) {\n      if (1 === width) {\n        width = DEFAULT_BAR_TRACKER_SIZE;\n        x -= CORRECTING_BAR_TRACKER_VALUE;\n      }\n    } else if (1 === height) {\n      height = DEFAULT_BAR_TRACKER_SIZE;\n      y -= CORRECTING_BAR_TRACKER_VALUE;\n    }\n\n    return {\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    };\n  },\n  getGraphicSettings: function getGraphicSettings() {\n    var graphic = this.graphic;\n    return {\n      x: graphic.attr(\"x\"),\n      y: graphic.attr(\"y\"),\n      height: graphic.attr(\"height\"),\n      width: graphic.attr(\"width\")\n    };\n  },\n  _getEdgeTooltipParams: function _getEdgeTooltipParams() {\n    var isPositive = this.value >= 0;\n    var xCoord;\n    var yCoord;\n\n    var invertedBusinessRange = this._getValTranslator().getBusinessRange().invert;\n\n    var x = this.x,\n        y = this.y,\n        width = this.width,\n        height = this.height;\n\n    if (this._options.rotated) {\n      yCoord = y + height / 2;\n\n      if (invertedBusinessRange) {\n        xCoord = isPositive ? x : x + width;\n      } else {\n        xCoord = isPositive ? x + width : x;\n      }\n    } else {\n      xCoord = x + width / 2;\n\n      if (invertedBusinessRange) {\n        yCoord = isPositive ? y + height : y;\n      } else {\n        yCoord = isPositive ? y : y + height;\n      }\n    }\n\n    return {\n      x: xCoord,\n      y: yCoord,\n      offset: 0\n    };\n  },\n  getTooltipParams: function getTooltipParams(location) {\n    if (\"edge\" === location) {\n      return this._getEdgeTooltipParams();\n    }\n\n    var center = this.getCenterCoord();\n    center.offset = 0;\n    return center;\n  },\n  getCenterCoord: function getCenterCoord() {\n    var width = this.width,\n        height = this.height,\n        x = this.x,\n        y = this.y;\n    return {\n      x: x + width / 2,\n      y: y + height / 2\n    };\n  },\n  _truncateCoord: function _truncateCoord(coord, bounds) {\n    if (null === coord) {\n      return coord;\n    }\n\n    if (coord < bounds[0]) {\n      return bounds[0];\n    }\n\n    if (coord > bounds[1]) {\n      return bounds[1];\n    }\n\n    return coord;\n  },\n  _getErrorBarBaseEdgeLength: function _getErrorBarBaseEdgeLength() {\n    return this._options.rotated ? this.height : this.width;\n  },\n  _translateErrorBars: function _translateErrorBars(argVisibleArea) {\n    symbolPoint._translateErrorBars.call(this);\n\n    if (this._errorBarPos < argVisibleArea[0] || this._errorBarPos > argVisibleArea[1]) {\n      this._errorBarPos = void 0;\n    }\n  },\n  _translate: function _translate() {\n    var rotated = this._options.rotated;\n    var valAxis = rotated ? \"x\" : \"y\";\n    var argAxis = rotated ? \"y\" : \"x\";\n    var valIntervalName = rotated ? \"width\" : \"height\";\n    var argIntervalName = rotated ? \"height\" : \"width\";\n\n    var argTranslator = this._getArgTranslator();\n\n    var valTranslator = this._getValTranslator();\n\n    var argVisibleArea = this.series.getArgumentAxis().getVisibleArea();\n    var valVisibleArea = this.series.getValueAxis().getVisibleArea();\n    var arg = argTranslator.translate(this.argument);\n    var val = valTranslator.translate(this.value, 1);\n    var minVal = valTranslator.translate(this.minValue);\n    this[argAxis] = arg = null === arg ? arg : arg + (this[argAxis + \"Correction\"] || 0);\n    this[\"v\" + valAxis] = val;\n    this[\"v\" + argAxis] = arg + this[argIntervalName] / 2;\n    val = this._truncateCoord(val, valVisibleArea);\n    minVal = this._truncateCoord(minVal, valVisibleArea);\n    this[valIntervalName] = _abs(val - minVal);\n    val = val < minVal ? val : minVal;\n\n    this._calculateVisibility(rotated ? val : arg, rotated ? arg : val, this.width, this.height);\n\n    this[valAxis] = null === val ? val : val + (this[valAxis + \"Correction\"] || 0);\n    this[\"min\" + valAxis.toUpperCase()] = null === minVal ? minVal : minVal + (this[valAxis + \"Correction\"] || 0);\n    this[\"default\" + valAxis.toUpperCase()] = valTranslator.translate(CANVAS_POSITION_DEFAULT);\n\n    this._translateErrorBars(argVisibleArea);\n\n    if (this.inVisibleArea && null !== this[argAxis]) {\n      if (this[argAxis] < argVisibleArea[0]) {\n        this[argIntervalName] = this[argIntervalName] - (argVisibleArea[0] - this[argAxis]);\n        this[argAxis] = argVisibleArea[0];\n      }\n\n      if (this[argAxis] + this[argIntervalName] > argVisibleArea[1]) {\n        this[argIntervalName] = argVisibleArea[1] - this[argAxis];\n      }\n    }\n  },\n  _updateMarker: function _updateMarker(animationEnabled, style) {\n    this.graphic.smartAttr(_extend({}, style, !animationEnabled ? this.getMarkerCoords() : {}));\n  },\n  getMarkerCoords: function getMarkerCoords() {\n    var x = this.x;\n    var y = this.y;\n    var width = this.width;\n    var height = this.height;\n    var argAxis = this.series.getArgumentAxis();\n    var rotated = this._options.rotated;\n\n    if (argAxis.getAxisPosition) {\n      var axisOptions = argAxis.getOptions();\n      var edgeOffset = Math.round(axisOptions.width / 2);\n      var argAxisPosition = argAxis.getAxisPosition();\n\n      if (axisOptions.visible) {\n        if (!rotated) {\n          height -= this.minY === this.defaultY && this.minY === argAxisPosition - argAxis.getAxisShift() ? edgeOffset : 0;\n          height < 0 && (height = 0);\n        } else {\n          var isStartFromAxis = this.minX === this.defaultX && this.minX === argAxisPosition - argAxis.getAxisShift();\n          x += isStartFromAxis ? edgeOffset : 0;\n          width -= isStartFromAxis ? edgeOffset : 0;\n          width < 0 && (width = 0);\n        }\n      }\n    }\n\n    return {\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    };\n  },\n  coordsIn: function coordsIn(x, y) {\n    return x >= this.x && x <= this.x + this.width && y >= this.y && y <= this.y + this.height;\n  }\n});","map":null,"metadata":{},"sourceType":"module"}