{"ast":null,"code":"/**\r\n * DevExtreme (esm/animation/transition_executor/transition_executor.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport $ from \"../../core/renderer\";\nimport Class from \"../../core/class\";\nimport { extend } from \"../../core/utils/extend\";\nimport { executeAsync } from \"../../core/utils/common\";\nimport { isFunction, isPlainObject } from \"../../core/utils/type\";\nimport { map } from \"../../core/utils/iterator\";\nimport fx from \"../fx\";\nimport { presets } from \"../presets/presets\";\nimport { when, Deferred } from \"../../core/utils/deferred\";\nvar directionPostfixes = {\n  forward: \" dx-forward\",\n  backward: \" dx-backward\",\n  none: \" dx-no-direction\",\n  undefined: \" dx-no-direction\"\n};\nvar DX_ANIMATING_CLASS = \"dx-animating\";\nexport var TransitionExecutor = Class.inherit({\n  ctor: function ctor() {\n    this._accumulatedDelays = {\n      enter: 0,\n      leave: 0\n    };\n    this._animations = [];\n    this.reset();\n  },\n  _createAnimations: function _createAnimations($elements, initialConfig, configModifier, type) {\n    var that = this;\n    var result = [];\n    configModifier = configModifier || {};\n\n    var animationConfig = this._prepareElementAnimationConfig(initialConfig, configModifier, type);\n\n    if (animationConfig) {\n      $elements.each(function () {\n        var animation = that._createAnimation($(this), animationConfig, configModifier);\n\n        if (animation) {\n          animation.element.addClass(DX_ANIMATING_CLASS);\n          animation.setup();\n          result.push(animation);\n        }\n      });\n    }\n\n    return result;\n  },\n  _prepareElementAnimationConfig: function _prepareElementAnimationConfig(config, configModifier, type) {\n    var result;\n\n    if (\"string\" === typeof config) {\n      var presetName = config;\n      config = presets.getPreset(presetName);\n    }\n\n    if (!config) {\n      result = void 0;\n    } else if (isFunction(config[type])) {\n      result = config[type];\n    } else {\n      result = extend({\n        skipElementInitialStyles: true,\n        cleanupWhen: this._completePromise\n      }, config, configModifier);\n\n      if (!result.type || \"css\" === result.type) {\n        var cssClass = \"dx-\" + type;\n        var extraCssClasses = (result.extraCssClasses ? \" \" + result.extraCssClasses : \"\") + directionPostfixes[result.direction];\n        result.type = \"css\";\n        result.from = (result.from || cssClass) + extraCssClasses;\n        result.to = result.to || cssClass + \"-active\";\n      }\n\n      result.staggerDelay = result.staggerDelay || 0;\n      result.delay = result.delay || 0;\n\n      if (result.staggerDelay) {\n        result.delay += this._accumulatedDelays[type];\n        this._accumulatedDelays[type] += result.staggerDelay;\n      }\n    }\n\n    return result;\n  },\n  _createAnimation: function _createAnimation($element, animationConfig, configModifier) {\n    var result;\n\n    if (isPlainObject(animationConfig)) {\n      result = fx.createAnimation($element, animationConfig);\n    } else if (isFunction(animationConfig)) {\n      result = animationConfig($element, configModifier);\n    }\n\n    return result;\n  },\n  _startAnimations: function _startAnimations() {\n    var animations = this._animations;\n\n    for (var i = 0; i < animations.length; i++) {\n      animations[i].start();\n    }\n  },\n  _stopAnimations: function _stopAnimations(jumpToEnd) {\n    var animations = this._animations;\n\n    for (var i = 0; i < animations.length; i++) {\n      animations[i].stop(jumpToEnd);\n    }\n  },\n  _clearAnimations: function _clearAnimations() {\n    var animations = this._animations;\n\n    for (var i = 0; i < animations.length; i++) {\n      animations[i].element.removeClass(DX_ANIMATING_CLASS);\n    }\n\n    this._animations.length = 0;\n  },\n  reset: function reset() {\n    this._accumulatedDelays.enter = 0;\n    this._accumulatedDelays.leave = 0;\n\n    this._clearAnimations();\n\n    this._completeDeferred = new Deferred();\n    this._completePromise = this._completeDeferred.promise();\n  },\n  enter: function enter($elements, animationConfig, configModifier) {\n    var animations = this._createAnimations($elements, animationConfig, configModifier, \"enter\");\n\n    this._animations.push.apply(this._animations, animations);\n  },\n  leave: function leave($elements, animationConfig, configModifier) {\n    var animations = this._createAnimations($elements, animationConfig, configModifier, \"leave\");\n\n    this._animations.push.apply(this._animations, animations);\n  },\n  start: function start() {\n    var that = this;\n    var result;\n\n    if (!this._animations.length) {\n      that.reset();\n      result = new Deferred().resolve().promise();\n    } else {\n      var animationDeferreds = map(this._animations, function (animation) {\n        var result = new Deferred();\n        animation.deferred.always(function () {\n          result.resolve();\n        });\n        return result.promise();\n      });\n      result = when.apply($, animationDeferreds).always(function () {\n        that._completeDeferred.resolve();\n\n        that.reset();\n      });\n      executeAsync(function () {\n        that._startAnimations();\n      });\n    }\n\n    return result;\n  },\n  stop: function stop(jumpToEnd) {\n    this._stopAnimations(jumpToEnd);\n  }\n});","map":null,"metadata":{},"sourceType":"module"}