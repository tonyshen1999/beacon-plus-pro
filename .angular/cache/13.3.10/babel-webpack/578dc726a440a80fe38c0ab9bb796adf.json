{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/pivot_grid/data_source.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { normalizeDataSourceOptions } from \"../../data/data_source/utils\";\nimport Store from \"../../data/abstract_store\";\nimport { executeAsync } from \"../../core/utils/common\";\nimport { isFunction, isNumeric, isDefined, isString, isPlainObject } from \"../../core/utils/type\";\nimport { extend } from \"../../core/utils/extend\";\nimport { inArray, normalizeIndexes } from \"../../core/utils/array\";\nimport { each } from \"../../core/utils/iterator\";\nimport { when, Deferred } from \"../../core/utils/deferred\";\nimport Class from \"../../core/class\";\nimport { EventsStrategy } from \"../../core/events_strategy\";\nimport { titleize } from \"../../core/utils/inflector\";\nimport { LocalStore } from \"./local_store\";\nimport RemoteStore from \"./remote_store\";\nimport { sort } from \"./data_source.utils\";\nimport { XmlaStore } from \"./xmla_store/xmla_store\";\nimport { applyDisplaySummaryMode, createMockSummaryCell, applyRunningTotal } from \"./ui.pivot_grid.summary_display_modes\";\nimport { foreachTree, foreachTreeAsync, findField, formatValue, createPath, setFieldProperty, getFieldsDataType } from \"./ui.pivot_grid.utils\";\nvar DESCRIPTION_NAME_BY_AREA = {\n  row: \"rows\",\n  column: \"columns\",\n  data: \"values\",\n  filter: \"filters\"\n};\nvar STATE_PROPERTIES = [\"area\", \"areaIndex\", \"sortOrder\", \"filterType\", \"filterValues\", \"sortBy\", \"sortBySummaryField\", \"sortBySummaryPath\", \"expanded\", \"summaryType\", \"summaryDisplayMode\"];\nvar CALCULATED_PROPERTIES = [\"format\", \"selector\", \"customizeText\", \"caption\"];\nvar ALL_CALCULATED_PROPERTIES = CALCULATED_PROPERTIES.concat([\"allowSorting\", \"allowSortingBySummary\", \"allowFiltering\", \"allowExpandAll\"]);\n\nfunction createCaption(field) {\n  var caption = field.dataField || field.groupName || \"\";\n  var summaryType = (field.summaryType || \"\").toLowerCase();\n\n  if (isString(field.groupInterval)) {\n    caption += \"_\" + field.groupInterval;\n  }\n\n  if (summaryType && \"custom\" !== summaryType) {\n    summaryType = summaryType.replace(/^./, summaryType[0].toUpperCase());\n\n    if (caption.length) {\n      summaryType = \" (\" + summaryType + \")\";\n    }\n  } else {\n    summaryType = \"\";\n  }\n\n  return titleize(caption) + summaryType;\n}\n\nfunction resetFieldState(field, properties) {\n  var initialProperties = field._initProperties || {};\n  each(properties, function (_, prop) {\n    if (Object.prototype.hasOwnProperty.call(initialProperties, prop)) {\n      field[prop] = initialProperties[prop];\n    }\n  });\n}\n\nfunction updateCalculatedFieldProperties(field, calculatedProperties) {\n  resetFieldState(field, calculatedProperties);\n\n  if (!isDefined(field.caption)) {\n    setFieldProperty(field, \"caption\", createCaption(field));\n  }\n}\n\nfunction areExpressionsUsed(dataFields) {\n  return dataFields.some(function (field) {\n    return field.summaryDisplayMode || field.calculateSummaryValue;\n  });\n}\n\nfunction isRunningTotalUsed(dataFields) {\n  return dataFields.some(function (field) {\n    return !!field.runningTotal;\n  });\n}\n\nfunction isDataExists(data) {\n  return data.rows.length || data.columns.length || data.values.length;\n}\n\nexport default Class.inherit(function () {\n  var findHeaderItem = function findHeaderItem(headerItems, path) {\n    if (headerItems._cacheByPath) {\n      return headerItems._cacheByPath[path.join(\".\")] || null;\n    }\n  };\n\n  var getHeaderItemsLastIndex = function getHeaderItemsLastIndex(headerItems, grandTotalIndex) {\n    var i;\n    var lastIndex = -1;\n    var headerItem;\n\n    if (headerItems) {\n      for (i = 0; i < headerItems.length; i++) {\n        headerItem = headerItems[i];\n\n        if (void 0 !== headerItem.index) {\n          lastIndex = Math.max(lastIndex, headerItem.index);\n        }\n\n        if (headerItem.children) {\n          lastIndex = Math.max(lastIndex, getHeaderItemsLastIndex(headerItem.children));\n        } else if (headerItem.collapsedChildren) {\n          lastIndex = Math.max(lastIndex, getHeaderItemsLastIndex(headerItem.collapsedChildren));\n        }\n      }\n    }\n\n    if (isDefined(grandTotalIndex)) {\n      lastIndex = Math.max(lastIndex, grandTotalIndex);\n    }\n\n    return lastIndex;\n  };\n\n  var updateHeaderItemChildren = function updateHeaderItemChildren(headerItems, headerItem, children, grandTotalIndex) {\n    var applyingHeaderItemsCount = getHeaderItemsLastIndex(children) + 1;\n    var emptyIndex = getHeaderItemsLastIndex(headerItems, grandTotalIndex) + 1;\n    var index;\n    var applyingItemIndexesToCurrent = [];\n    var needIndexUpdate = false;\n    var d = new Deferred();\n\n    if (headerItem.children && headerItem.children.length === children.length) {\n      for (var i = 0; i < children.length; i++) {\n        var child = children[i];\n\n        if (void 0 !== child.index) {\n          if (void 0 === headerItem.children[i].index) {\n            child.index = applyingItemIndexesToCurrent[child.index] = emptyIndex++;\n            headerItem.children[i] = child;\n          } else {\n            applyingItemIndexesToCurrent[child.index] = headerItem.children[i].index;\n          }\n        }\n      }\n    } else {\n      needIndexUpdate = true;\n\n      for (index = 0; index < applyingHeaderItemsCount; index++) {\n        applyingItemIndexesToCurrent[index] = emptyIndex++;\n      }\n\n      headerItem.children = children;\n    }\n\n    when(foreachTreeAsync(headerItem.children, function (items) {\n      if (needIndexUpdate) {\n        items[0].index = applyingItemIndexesToCurrent[items[0].index];\n      }\n    })).done(function () {\n      d.resolve(applyingItemIndexesToCurrent);\n    });\n    return d;\n  };\n\n  var updateHeaderItems = function updateHeaderItems(headerItems, newHeaderItems, grandTotalIndex) {\n    var d = new Deferred();\n    var emptyIndex = grandTotalIndex >= 0 && getHeaderItemsLastIndex(headerItems, grandTotalIndex) + 1;\n    var applyingItemIndexesToCurrent = [];\n    when(foreachTreeAsync(headerItems, function (items) {\n      delete items[0].collapsedChildren;\n    })).done(function () {\n      when(foreachTreeAsync(newHeaderItems, function (newItems, index) {\n        var newItem = newItems[0];\n\n        if (newItem.index >= 0) {\n          var headerItem = findHeaderItem(headerItems, createPath(newItems));\n\n          if (headerItem && headerItem.index >= 0) {\n            applyingItemIndexesToCurrent[newItem.index] = headerItem.index;\n          } else if (emptyIndex) {\n            var path = createPath(newItems.slice(1));\n            headerItem = findHeaderItem(headerItems, path);\n            var parentItems = path.length ? headerItem && headerItem.children : headerItems;\n\n            if (parentItems) {\n              parentItems[index] = newItem;\n              newItem.index = applyingItemIndexesToCurrent[newItem.index] = emptyIndex++;\n            }\n          }\n        }\n      })).done(function () {\n        d.resolve(applyingItemIndexesToCurrent);\n      });\n    });\n    return d;\n  };\n\n  var updateDataSourceCells = function updateDataSourceCells(dataSource, newDataSourceCells, newRowItemIndexesToCurrent, newColumnItemIndexesToCurrent) {\n    var newRowIndex;\n    var newColumnIndex;\n    var newRowCells;\n    var newCell;\n    var rowIndex;\n    var columnIndex;\n    var dataSourceCells = dataSource.values;\n\n    if (newDataSourceCells) {\n      for (newRowIndex = 0; newRowIndex <= newDataSourceCells.length; newRowIndex++) {\n        newRowCells = newDataSourceCells[newRowIndex];\n        rowIndex = newRowItemIndexesToCurrent[newRowIndex];\n\n        if (!isDefined(rowIndex)) {\n          rowIndex = dataSource.grandTotalRowIndex;\n        }\n\n        if (newRowCells && isDefined(rowIndex)) {\n          if (!dataSourceCells[rowIndex]) {\n            dataSourceCells[rowIndex] = [];\n          }\n\n          for (newColumnIndex = 0; newColumnIndex <= newRowCells.length; newColumnIndex++) {\n            newCell = newRowCells[newColumnIndex];\n            columnIndex = newColumnItemIndexesToCurrent[newColumnIndex];\n\n            if (!isDefined(columnIndex)) {\n              columnIndex = dataSource.grandTotalColumnIndex;\n            }\n\n            if (isDefined(newCell) && isDefined(columnIndex)) {\n              dataSourceCells[rowIndex][columnIndex] = newCell;\n            }\n          }\n        }\n      }\n    }\n  };\n\n  function createLocalOrRemoteStore(dataSourceOptions, notifyProgress) {\n    var StoreConstructor = dataSourceOptions.remoteOperations || dataSourceOptions.paginate ? RemoteStore : LocalStore;\n    return new StoreConstructor(extend(normalizeDataSourceOptions(dataSourceOptions), {\n      onChanged: null,\n      onLoadingChanged: null,\n      onProgressChanged: notifyProgress\n    }));\n  }\n\n  function getExpandedPaths(dataSource, loadOptions, dimensionName, prevLoadOptions) {\n    var result = [];\n    var fields = loadOptions && loadOptions[dimensionName] || [];\n    var prevFields = prevLoadOptions && prevLoadOptions[dimensionName] || [];\n    foreachTree(dataSource[dimensionName], function (items) {\n      var item = items[0];\n      var path = createPath(items);\n\n      if (item.children && fields[path.length - 1] && !fields[path.length - 1].expanded) {\n        if (path.length < fields.length && (!prevLoadOptions || function (fields, prevFields, count) {\n          for (var i = 0; i < count; i++) {\n            if (!fields[i] || !prevFields[i] || fields[i].index !== prevFields[i].index) {\n              return false;\n            }\n          }\n\n          return true;\n        }(fields, prevFields, path.length))) {\n          result.push(path.slice());\n        }\n      }\n    }, true);\n    return result;\n  }\n\n  function setFieldProperties(field, srcField, skipInitPropertySave, properties) {\n    if (srcField) {\n      each(properties, function (_, name) {\n        if (skipInitPropertySave) {\n          field[name] = srcField[name];\n        } else {\n          if ((\"summaryType\" === name || \"summaryDisplayMode\" === name) && void 0 === srcField[name]) {\n            return;\n          }\n\n          setFieldProperty(field, name, srcField[name]);\n        }\n      });\n    } else {\n      resetFieldState(field, properties);\n    }\n\n    return field;\n  }\n\n  function getFieldsState(fields, properties) {\n    var result = [];\n    each(fields, function (_, field) {\n      result.push(setFieldProperties({\n        dataField: field.dataField,\n        name: field.name\n      }, field, true, properties));\n    });\n    return result;\n  }\n\n  function getFieldStateId(field) {\n    if (field.name) {\n      return field.name;\n    }\n\n    return field.dataField + \"\";\n  }\n\n  function getFieldsById(fields, id) {\n    var result = [];\n    each(fields || [], function (_, field) {\n      if (getFieldStateId(field) === id) {\n        result.push(field);\n      }\n    });\n    return result;\n  }\n\n  function setFieldsState(stateFields, fields) {\n    stateFields = stateFields || [];\n    var fieldsById = {};\n    var id;\n    each(fields, function (_, field) {\n      id = getFieldStateId(field);\n\n      if (!fieldsById[id]) {\n        fieldsById[id] = getFieldsById(fields, getFieldStateId(field));\n      }\n    });\n    each(fieldsById, function (id, fields) {\n      !function (stateFields, fields) {\n        stateFields = stateFields || [];\n        each(fields, function (index, field) {\n          setFieldProperties(field, stateFields[index], false, STATE_PROPERTIES);\n          updateCalculatedFieldProperties(field, CALCULATED_PROPERTIES);\n        });\n        return fields;\n      }(getFieldsById(stateFields, id), fields);\n    });\n    return fields;\n  }\n\n  function sortFieldsByAreaIndex(fields) {\n    fields.sort(function (field1, field2) {\n      return field1.areaIndex - field2.areaIndex || field1.groupIndex - field2.groupIndex;\n    });\n  }\n\n  function getFieldId(field, retrieveFieldsOptionValue) {\n    var groupName = field.groupName || \"\";\n    return (field.dataField || groupName) + (field.groupInterval ? groupName + field.groupInterval : \"NOGROUP\") + (retrieveFieldsOptionValue ? \"\" : groupName);\n  }\n\n  function mergeFields(fields, storeFields, retrieveFieldsOptionValue) {\n    var result = [];\n    var fieldsDictionary = {};\n    var removedFields = {};\n    var dataTypes = getFieldsDataType(fields);\n\n    if (storeFields) {\n      each(storeFields, function (_, field) {\n        fieldsDictionary[getFieldId(field, retrieveFieldsOptionValue)] = field;\n      });\n      each(fields, function (_, field) {\n        var fieldKey = getFieldId(field, retrieveFieldsOptionValue);\n        var storeField = fieldsDictionary[fieldKey] || removedFields[fieldKey];\n        var mergedField;\n\n        if (storeField) {\n          if (storeField._initProperties) {\n            resetFieldState(storeField, ALL_CALCULATED_PROPERTIES);\n          }\n\n          mergedField = extend({}, storeField, field, {\n            _initProperties: null\n          });\n        } else {\n          fieldsDictionary[fieldKey] = mergedField = field;\n        }\n\n        extend(mergedField, {\n          dataType: dataTypes[field.dataField]\n        });\n        delete fieldsDictionary[fieldKey];\n        removedFields[fieldKey] = storeField;\n        result.push(mergedField);\n      });\n\n      if (retrieveFieldsOptionValue) {\n        each(fieldsDictionary, function (_, field) {\n          result.push(field);\n        });\n      }\n    } else {\n      result = fields;\n    }\n\n    result.push.apply(result, []);\n    !function (fields) {\n      fields.forEach(function (field) {\n        if (field.groupName && field.groupInterval && void 0 === field.groupIndex) {\n          var maxGroupIndex = fields.filter(function (f) {\n            return f.groupName === field.groupName && isNumeric(f.groupIndex);\n          }).map(function (f) {\n            return f.groupIndex;\n          }).reduce(function (prev, current) {\n            return Math.max(prev, current);\n          }, -1);\n          field.groupIndex = maxGroupIndex + 1;\n        }\n      });\n    }(result);\n    return result;\n  }\n\n  function getFields(that) {\n    var result = new Deferred();\n    var store = that._store;\n    var storeFields = store && store.getFields(that._fields);\n    var mergedFields;\n    when(storeFields).done(function (storeFields) {\n      that._storeFields = storeFields;\n      mergedFields = mergeFields(that._fields, storeFields, that._retrieveFields);\n      result.resolve(mergedFields);\n    }).fail(result.reject);\n    return result;\n  }\n\n  function formatHeaderItems(data, loadOptions, headerName) {\n    return foreachTreeAsync(data[headerName], function (items) {\n      var item = items[0];\n      item.text = item.text || formatValue(item.value, loadOptions[headerName][createPath(items).length - 1]);\n    });\n  }\n\n  function formatHeaders(loadOptions, data) {\n    return when(formatHeaderItems(data, loadOptions, \"columns\"), formatHeaderItems(data, loadOptions, \"rows\"));\n  }\n\n  function updateCache(headerItems) {\n    var d = new Deferred();\n    var cacheByPath = {};\n    when(foreachTreeAsync(headerItems, function (items) {\n      var path = createPath(items).join(\".\");\n      cacheByPath[path] = items[0];\n    })).done(d.resolve);\n    headerItems._cacheByPath = cacheByPath;\n    return d;\n  }\n\n  function _getAreaFields(fields, area) {\n    var areaFields = [];\n    each(fields, function () {\n      if (function (field, area) {\n        var canAddFieldInArea = \"data\" === area || false !== field.visible;\n        return field.area === area && !isDefined(field.groupIndex) && canAddFieldInArea;\n      }(this, area)) {\n        areaFields.push(this);\n      }\n    });\n    return areaFields;\n  }\n\n  return {\n    ctor: function ctor(options) {\n      options = options || {};\n      this._eventsStrategy = new EventsStrategy(this);\n      var that = this;\n\n      var store = function (dataSourceOptions, notifyProgress) {\n        var store;\n        var storeOptions;\n\n        if (isPlainObject(dataSourceOptions) && dataSourceOptions.load) {\n          store = createLocalOrRemoteStore(dataSourceOptions, notifyProgress);\n        } else {\n          if (dataSourceOptions && !dataSourceOptions.store) {\n            dataSourceOptions = {\n              store: dataSourceOptions\n            };\n          }\n\n          storeOptions = dataSourceOptions.store;\n\n          if (\"xmla\" === storeOptions.type) {\n            store = new XmlaStore(storeOptions);\n          } else if (isPlainObject(storeOptions) && storeOptions.type || storeOptions instanceof Store || Array.isArray(storeOptions)) {\n            store = createLocalOrRemoteStore(dataSourceOptions, notifyProgress);\n          } else if (storeOptions instanceof Class) {\n            store = storeOptions;\n          }\n        }\n\n        return store;\n      }(options, function (progress) {\n        that._eventsStrategy.fireEvent(\"progressChanged\", [progress]);\n      });\n\n      that._store = store;\n      that._paginate = !!options.paginate;\n      that._pageSize = options.pageSize || 40;\n      that._data = {\n        rows: [],\n        columns: [],\n        values: []\n      };\n      that._loadingCount = 0;\n      that._isFieldsModified = false;\n      each([\"changed\", \"loadError\", \"loadingChanged\", \"progressChanged\", \"fieldsPrepared\", \"expandValueChanging\"], function (_, eventName) {\n        var optionName = \"on\" + eventName[0].toUpperCase() + eventName.slice(1);\n\n        if (Object.prototype.hasOwnProperty.call(options, optionName)) {\n          this.on(eventName, options[optionName]);\n        }\n      }.bind(this));\n      that._retrieveFields = isDefined(options.retrieveFields) ? options.retrieveFields : true;\n      that._fields = options.fields || [];\n      that._descriptions = options.descriptions ? extend(that._createDescriptions(), options.descriptions) : void 0;\n\n      if (!store) {\n        extend(true, that._data, options.store || options);\n      }\n    },\n    getData: function getData() {\n      return this._data;\n    },\n    getAreaFields: function getAreaFields(area, collectGroups) {\n      var areaFields = [];\n      var descriptions;\n\n      if (collectGroups || \"data\" === area) {\n        areaFields = _getAreaFields(this._fields, area);\n        sortFieldsByAreaIndex(areaFields);\n      } else {\n        descriptions = this._descriptions || {};\n        areaFields = descriptions[DESCRIPTION_NAME_BY_AREA[area]] || [];\n      }\n\n      return areaFields;\n    },\n    fields: function fields(_fields) {\n      if (_fields) {\n        this._fields = mergeFields(_fields, this._storeFields, this._retrieveFields);\n\n        this._fieldsPrepared(this._fields);\n      }\n\n      return this._fields;\n    },\n    field: function field(id, options) {\n      var fields = this._fields;\n      var field = fields && fields[isNumeric(id) ? id : findField(fields, id)];\n      var levels;\n\n      if (field && options) {\n        each(options, function (optionName, optionValue) {\n          var isInitialization = inArray(optionName, STATE_PROPERTIES) < 0;\n          setFieldProperty(field, optionName, optionValue, isInitialization);\n\n          if (\"sortOrder\" === optionName) {\n            levels = field.levels || [];\n\n            for (var i = 0; i < levels.length; i++) {\n              levels[i][optionName] = optionValue;\n            }\n          }\n        });\n        updateCalculatedFieldProperties(field, CALCULATED_PROPERTIES);\n        this._descriptions = this._createDescriptions(field);\n        this._isFieldsModified = true;\n\n        this._eventsStrategy.fireEvent(\"fieldChanged\", [field]);\n      }\n\n      return field;\n    },\n    getFieldValues: function getFieldValues(index, applyFilters, options) {\n      var that = this;\n      var field = this._fields && this._fields[index];\n      var store = this.store();\n      var loadFields = [];\n      var loadOptions = {\n        columns: loadFields,\n        rows: [],\n        values: this.getAreaFields(\"data\"),\n        filters: applyFilters ? this._fields.filter(function (f) {\n          return f !== field && f.area && f.filterValues && f.filterValues.length;\n        }) : [],\n        skipValues: true\n      };\n      var searchValue;\n      var d = new Deferred();\n\n      if (options) {\n        searchValue = options.searchValue;\n        loadOptions.columnSkip = options.skip;\n        loadOptions.columnTake = options.take;\n      }\n\n      if (field && store) {\n        each(field.levels || [field], function () {\n          loadFields.push(extend({}, this, {\n            expanded: true,\n            filterValues: null,\n            sortOrder: \"asc\",\n            sortBySummaryField: null,\n            searchValue: searchValue\n          }));\n        });\n        store.load(loadOptions).done(function (data) {\n          if (loadOptions.columnSkip) {\n            data.columns = data.columns.slice(loadOptions.columnSkip);\n          }\n\n          if (loadOptions.columnTake) {\n            data.columns = data.columns.slice(0, loadOptions.columnTake);\n          }\n\n          formatHeaders(loadOptions, data);\n\n          if (!loadOptions.columnTake) {\n            that._sort(loadOptions, data);\n          }\n\n          d.resolve(data.columns);\n        }).fail(d);\n      } else {\n        d.reject();\n      }\n\n      return d;\n    },\n    reload: function reload() {\n      return this.load({\n        reload: true\n      });\n    },\n    filter: function filter() {\n      var store = this._store;\n      return store.filter.apply(store, arguments);\n    },\n    load: function load(options) {\n      var that = this;\n      var d = new Deferred();\n      options = options || {};\n      that.beginLoading();\n      d.fail(function (e) {\n        that._eventsStrategy.fireEvent(\"loadError\", [e]);\n      }).always(function () {\n        that.endLoading();\n      });\n\n      function loadTask() {\n        that._delayedLoadTask = void 0;\n\n        if (!that._descriptions) {\n          when(getFields(that)).done(function (fields) {\n            that._fieldsPrepared(fields);\n\n            that._loadCore(options, d);\n          }).fail(d.reject).fail(that._loadErrorHandler);\n        } else {\n          that._loadCore(options, d);\n        }\n      }\n\n      if (that.store()) {\n        that._delayedLoadTask = executeAsync(loadTask);\n      } else {\n        loadTask();\n      }\n\n      return d;\n    },\n    createDrillDownDataSource: function createDrillDownDataSource(params) {\n      return this._store.createDrillDownDataSource(this._descriptions, params);\n    },\n    _createDescriptions: function _createDescriptions(currentField) {\n      var fields = this.fields();\n      var descriptions = {\n        rows: [],\n        columns: [],\n        values: [],\n        filters: []\n      };\n      each([\"row\", \"column\", \"data\", \"filter\"], function (_, areaName) {\n        normalizeIndexes(_getAreaFields(fields, areaName), \"areaIndex\", currentField);\n      });\n      each(fields || [], function (_, field) {\n        var descriptionName = DESCRIPTION_NAME_BY_AREA[field.area];\n        var dimension = descriptions[descriptionName];\n        var groupName = field.groupName;\n\n        if (groupName && !isNumeric(field.groupIndex)) {\n          field.levels = function (fields, groupingField) {\n            return fields.filter(function (field) {\n              return field.groupName === groupingField.groupName && isNumeric(field.groupIndex) && false !== field.visible;\n            }).map(function (field) {\n              return extend(field, {\n                areaIndex: groupingField.areaIndex,\n                area: groupingField.area,\n                expanded: isDefined(field.expanded) ? field.expanded : groupingField.expanded,\n                dataField: field.dataField || groupingField.dataField,\n                dataType: field.dataType || groupingField.dataType,\n                sortBy: field.sortBy || groupingField.sortBy,\n                sortOrder: field.sortOrder || groupingField.sortOrder,\n                sortBySummaryField: field.sortBySummaryField || groupingField.sortBySummaryField,\n                sortBySummaryPath: field.sortBySummaryPath || groupingField.sortBySummaryPath,\n                visible: field.visible || groupingField.visible,\n                showTotals: isDefined(field.showTotals) ? field.showTotals : groupingField.showTotals,\n                showGrandTotals: isDefined(field.showGrandTotals) ? field.showGrandTotals : groupingField.showGrandTotals\n              });\n            }).sort(function (a, b) {\n              return a.groupIndex - b.groupIndex;\n            });\n          }(fields, field);\n        }\n\n        if (!dimension || groupName && isNumeric(field.groupIndex) || false === field.visible && \"data\" !== field.area && \"filter\" !== field.area) {\n          return;\n        }\n\n        if (field.levels && dimension !== descriptions.filters && dimension !== descriptions.values) {\n          dimension.push.apply(dimension, field.levels);\n\n          if (field.filterValues && field.filterValues.length) {\n            descriptions.filters.push(field);\n          }\n        } else {\n          dimension.push(field);\n        }\n      });\n      each(descriptions, function (_, fields) {\n        sortFieldsByAreaIndex(fields);\n      });\n      var indices = {};\n      each(descriptions.values, function (_, field) {\n        var expression = field.calculateSummaryValue;\n\n        if (isFunction(expression)) {\n          var summaryCell = createMockSummaryCell(descriptions, fields, indices);\n          expression(summaryCell);\n        }\n      });\n      return descriptions;\n    },\n    _fieldsPrepared: function _fieldsPrepared(fields) {\n      this._fields = fields;\n      each(fields, function (index, field) {\n        field.index = index;\n        updateCalculatedFieldProperties(field, ALL_CALCULATED_PROPERTIES);\n      });\n      var currentFieldState = getFieldsState(fields, [\"caption\"]);\n\n      this._eventsStrategy.fireEvent(\"fieldsPrepared\", [fields]);\n\n      for (var i = 0; i < fields.length; i++) {\n        if (fields[i].caption !== currentFieldState[i].caption) {\n          setFieldProperty(fields[i], \"caption\", fields[i].caption, true);\n        }\n      }\n\n      this._descriptions = this._createDescriptions();\n    },\n    isLoading: function isLoading() {\n      return this._loadingCount > 0;\n    },\n    state: function state(_state, skipLoading) {\n      var that = this;\n\n      if (arguments.length) {\n        _state = extend({\n          rowExpandedPaths: [],\n          columnExpandedPaths: []\n        }, _state);\n\n        if (!that._descriptions) {\n          that.beginLoading();\n          when(getFields(that)).done(function (fields) {\n            that._fields = setFieldsState(_state.fields, fields);\n\n            that._fieldsPrepared(fields);\n\n            !skipLoading && that.load(_state);\n          }).always(function () {\n            that.endLoading();\n          });\n        } else {\n          that._fields = setFieldsState(_state.fields, that._fields);\n          that._descriptions = that._createDescriptions();\n          !skipLoading && that.load(_state);\n        }\n      } else {\n        return {\n          fields: getFieldsState(that._fields, STATE_PROPERTIES),\n          columnExpandedPaths: getExpandedPaths(that._data, that._descriptions, \"columns\", that._lastLoadOptions),\n          rowExpandedPaths: getExpandedPaths(that._data, that._descriptions, \"rows\", that._lastLoadOptions)\n        };\n      }\n    },\n    beginLoading: function beginLoading() {\n      this._changeLoadingCount(1);\n    },\n    endLoading: function endLoading() {\n      this._changeLoadingCount(-1);\n    },\n    _changeLoadingCount: function _changeLoadingCount(increment) {\n      var oldLoading = this.isLoading();\n      this._loadingCount += increment;\n      var newLoading = this.isLoading();\n\n      if (oldLoading ^ newLoading) {\n        this._eventsStrategy.fireEvent(\"loadingChanged\", [newLoading]);\n      }\n    },\n    _hasPagingValues: function _hasPagingValues(options, area, oppositeIndex) {\n      var takeField = area + \"Take\";\n      var skipField = area + \"Skip\";\n      var values = this._data.values;\n      var items = this._data[area + \"s\"];\n      var oppositeArea = \"row\" === area ? \"column\" : \"row\";\n      var indices = [];\n\n      if (options.path && options.area === area) {\n        var headerItem = findHeaderItem(items, options.path);\n        items = headerItem && headerItem.children;\n\n        if (!items) {\n          return false;\n        }\n      }\n\n      if (options.oppositePath && options.area === oppositeArea) {\n        var _headerItem = findHeaderItem(items, options.oppositePath);\n\n        items = _headerItem && _headerItem.children;\n\n        if (!items) {\n          return false;\n        }\n      }\n\n      for (var i = options[skipField]; i < options[skipField] + options[takeField]; i++) {\n        if (items[i]) {\n          indices.push(items[i].index);\n        }\n      }\n\n      return indices.every(function (index) {\n        if (void 0 !== index) {\n          if (\"row\" === area) {\n            return (values[index] || [])[oppositeIndex];\n          } else {\n            return (values[oppositeIndex] || [])[index];\n          }\n        }\n      });\n    },\n    _processPagingCacheByArea: function _processPagingCacheByArea(options, pageSize, area) {\n      var takeField = area + \"Take\";\n      var skipField = area + \"Skip\";\n      var items = this._data[area + \"s\"];\n      var oppositeArea = \"row\" === area ? \"column\" : \"row\";\n      var item;\n\n      if (options[takeField]) {\n        if (options.path && options.area === area) {\n          var headerItem = findHeaderItem(items, options.path);\n          items = headerItem && headerItem.children || [];\n        }\n\n        if (options.oppositePath && options.area === oppositeArea) {\n          var _headerItem2 = findHeaderItem(items, options.oppositePath);\n\n          items = _headerItem2 && _headerItem2.children || [];\n        }\n\n        do {\n          item = items[options[skipField]];\n\n          if (item && void 0 !== item.index) {\n            if (this._hasPagingValues(options, oppositeArea, item.index)) {\n              options[skipField]++;\n              options[takeField]--;\n            } else {\n              break;\n            }\n          }\n        } while (item && void 0 !== item.index && options[takeField]);\n\n        if (options[takeField]) {\n          var start = Math.floor(options[skipField] / pageSize) * pageSize;\n          var end = Math.ceil((options[skipField] + options[takeField]) / pageSize) * pageSize;\n          options[skipField] = start;\n          options[takeField] = end - start;\n        }\n      }\n    },\n    _processPagingCache: function _processPagingCache(storeLoadOptions) {\n      var pageSize = this._pageSize;\n\n      if (pageSize < 0) {\n        return;\n      }\n\n      for (var i = 0; i < storeLoadOptions.length; i++) {\n        this._processPagingCacheByArea(storeLoadOptions[i], pageSize, \"row\");\n\n        this._processPagingCacheByArea(storeLoadOptions[i], pageSize, \"column\");\n      }\n    },\n    _loadCore: function _loadCore(options, deferred) {\n      var that = this;\n      var store = this._store;\n      var descriptions = this._descriptions;\n\n      var reload = options.reload || this.paginate() && that._isFieldsModified;\n\n      var paginate = this.paginate();\n      var headerName = DESCRIPTION_NAME_BY_AREA[options.area];\n      options = options || {};\n\n      if (store) {\n        extend(options, descriptions);\n        options.columnExpandedPaths = options.columnExpandedPaths || getExpandedPaths(this._data, options, \"columns\", that._lastLoadOptions);\n        options.rowExpandedPaths = options.rowExpandedPaths || getExpandedPaths(this._data, options, \"rows\", that._lastLoadOptions);\n\n        if (paginate) {\n          options.pageSize = this._pageSize;\n        }\n\n        if (headerName) {\n          options.headerName = headerName;\n        }\n\n        that.beginLoading();\n        deferred.always(function () {\n          that.endLoading();\n        });\n        var storeLoadOptions = [options];\n\n        that._eventsStrategy.fireEvent(\"customizeStoreLoadOptions\", [storeLoadOptions, reload]);\n\n        if (!reload) {\n          that._processPagingCache(storeLoadOptions);\n        }\n\n        storeLoadOptions = storeLoadOptions.filter(function (options) {\n          return !(options.rows.length && 0 === options.rowTake) && !(options.columns.length && 0 === options.columnTake);\n        });\n\n        if (!storeLoadOptions.length) {\n          that._update(deferred);\n\n          return;\n        }\n\n        var results = storeLoadOptions.map(function (options) {\n          return store.load(options);\n        });\n        when.apply(null, results).done(function () {\n          var results = arguments;\n\n          for (var i = 0; i < results.length; i++) {\n            var _options = storeLoadOptions[i];\n            var data = results[i];\n            var isLast = i === results.length - 1;\n\n            if (_options.path) {\n              that.applyPartialDataSource(_options.area, _options.path, data, isLast ? deferred : false, _options.oppositePath);\n            } else if (paginate && !reload && isDataExists(that._data)) {\n              that.mergePartialDataSource(data, isLast ? deferred : false);\n            } else {\n              extend(that._data, data);\n              that._lastLoadOptions = _options;\n\n              that._update(isLast ? deferred : false);\n            }\n          }\n        }).fail(deferred.reject);\n      } else {\n        that._update(deferred);\n      }\n    },\n    _sort: function _sort(descriptions, data, getAscOrder) {\n      var store = this._store;\n\n      if (store && !this._paginate) {\n        sort(descriptions, data, getAscOrder);\n      }\n    },\n    paginate: function paginate() {\n      return this._paginate && this._store && this._store.supportPaging();\n    },\n    isEmpty: function isEmpty() {\n      var dataFields = this.getAreaFields(\"data\").filter(function (f) {\n        return false !== f.visible;\n      });\n      var data = this.getData();\n      return !dataFields.length || !data.values.length;\n    },\n    _update: function _update(deferred) {\n      var that = this;\n      var descriptions = that._descriptions;\n      var loadedData = that._data;\n      var dataFields = descriptions.values;\n      var expressionsUsed = areExpressionsUsed(dataFields);\n      when(formatHeaders(descriptions, loadedData), updateCache(loadedData.rows), updateCache(loadedData.columns)).done(function () {\n        if (expressionsUsed) {\n          that._sort(descriptions, loadedData, expressionsUsed);\n\n          !that.isEmpty() && applyDisplaySummaryMode(descriptions, loadedData);\n        }\n\n        that._sort(descriptions, loadedData);\n\n        !that.isEmpty() && isRunningTotalUsed(dataFields) && applyRunningTotal(descriptions, loadedData);\n        that._data = loadedData;\n        false !== deferred && when(deferred).done(function () {\n          that._isFieldsModified = false;\n\n          that._eventsStrategy.fireEvent(\"changed\");\n\n          if (isDefined(that._data.grandTotalRowIndex)) {\n            loadedData.grandTotalRowIndex = that._data.grandTotalRowIndex;\n          }\n\n          if (isDefined(that._data.grandTotalColumnIndex)) {\n            loadedData.grandTotalColumnIndex = that._data.grandTotalColumnIndex;\n          }\n        });\n        deferred && deferred.resolve(that._data);\n      });\n      return deferred;\n    },\n    store: function store() {\n      return this._store;\n    },\n    collapseHeaderItem: function collapseHeaderItem(area, path) {\n      var headerItems = \"column\" === area ? this._data.columns : this._data.rows;\n      var headerItem = findHeaderItem(headerItems, path);\n      var field = this.getAreaFields(area)[path.length - 1];\n\n      if (headerItem && headerItem.children) {\n        this._eventsStrategy.fireEvent(\"expandValueChanging\", [{\n          area: area,\n          path: path,\n          expanded: false\n        }]);\n\n        if (field) {\n          field.expanded = false;\n        }\n\n        headerItem.collapsedChildren = headerItem.children;\n        delete headerItem.children;\n\n        this._update();\n\n        if (this.paginate()) {\n          this.load();\n        }\n\n        return true;\n      }\n\n      return false;\n    },\n    collapseAll: function collapseAll(id) {\n      var _this = this;\n\n      var dataChanged = false;\n      var field = this.field(id) || {};\n      var areaOffsets = [inArray(field, this.getAreaFields(field.area))];\n      field.expanded = false;\n\n      if (field && field.levels) {\n        areaOffsets = [];\n        field.levels.forEach(function (f) {\n          areaOffsets.push(inArray(f, _this.getAreaFields(field.area)));\n          f.expanded = false;\n        });\n      }\n\n      foreachTree(this._data[field.area + \"s\"], function (items) {\n        var item = items[0];\n        var path = createPath(items);\n\n        if (item && item.children && -1 !== areaOffsets.indexOf(path.length - 1)) {\n          item.collapsedChildren = item.children;\n          delete item.children;\n          dataChanged = true;\n        }\n      }, true);\n      dataChanged && this._update();\n    },\n    expandAll: function expandAll(id) {\n      var field = this.field(id);\n\n      if (field && field.area) {\n        field.expanded = true;\n\n        if (field && field.levels) {\n          field.levels.forEach(function (f) {\n            f.expanded = true;\n          });\n        }\n\n        this.load();\n      }\n    },\n    expandHeaderItem: function expandHeaderItem(area, path) {\n      var headerItems = \"column\" === area ? this._data.columns : this._data.rows;\n      var headerItem = findHeaderItem(headerItems, path);\n\n      if (headerItem && !headerItem.children) {\n        var hasCache = !!headerItem.collapsedChildren;\n        var options = {\n          area: area,\n          path: path,\n          expanded: true,\n          needExpandData: !hasCache\n        };\n\n        this._eventsStrategy.fireEvent(\"expandValueChanging\", [options]);\n\n        if (hasCache) {\n          headerItem.children = headerItem.collapsedChildren;\n          delete headerItem.collapsedChildren;\n\n          this._update();\n        } else if (this.store()) {\n          this.load(options);\n        }\n\n        return hasCache;\n      }\n\n      return false;\n    },\n    mergePartialDataSource: function mergePartialDataSource(dataSource, deferred) {\n      var that = this;\n      var loadedData = that._data;\n      var newRowItemIndexesToCurrent;\n      var newColumnItemIndexesToCurrent;\n\n      if (dataSource && dataSource.values) {\n        dataSource.rows = dataSource.rows || [];\n        dataSource.columns = dataSource.columns || [];\n        newRowItemIndexesToCurrent = updateHeaderItems(loadedData.rows, dataSource.rows, loadedData.grandTotalColumnIndex);\n        newColumnItemIndexesToCurrent = updateHeaderItems(loadedData.columns, dataSource.columns, loadedData.grandTotalColumnIndex);\n        when(newRowItemIndexesToCurrent, newColumnItemIndexesToCurrent).done(function (newRowItemIndexesToCurrent, newColumnItemIndexesToCurrent) {\n          if (newRowItemIndexesToCurrent.length || newColumnItemIndexesToCurrent.length) {\n            updateDataSourceCells(loadedData, dataSource.values, newRowItemIndexesToCurrent, newColumnItemIndexesToCurrent);\n          }\n\n          that._update(deferred);\n        });\n      }\n    },\n    applyPartialDataSource: function applyPartialDataSource(area, path, dataSource, deferred, oppositePath) {\n      var that = this;\n      var loadedData = that._data;\n      var headerItems = \"column\" === area ? loadedData.columns : loadedData.rows;\n      var headerItem;\n      var oppositeHeaderItems = \"column\" === area ? loadedData.rows : loadedData.columns;\n      var oppositeHeaderItem;\n      var newRowItemIndexesToCurrent;\n      var newColumnItemIndexesToCurrent;\n\n      if (dataSource && dataSource.values) {\n        dataSource.rows = dataSource.rows || [];\n        dataSource.columns = dataSource.columns || [];\n        headerItem = findHeaderItem(headerItems, path);\n        oppositeHeaderItem = oppositePath && findHeaderItem(oppositeHeaderItems, oppositePath);\n\n        if (headerItem) {\n          if (\"column\" === area) {\n            newColumnItemIndexesToCurrent = updateHeaderItemChildren(headerItems, headerItem, dataSource.columns, loadedData.grandTotalColumnIndex);\n\n            if (oppositeHeaderItem) {\n              newRowItemIndexesToCurrent = updateHeaderItemChildren(oppositeHeaderItems, oppositeHeaderItem, dataSource.rows, loadedData.grandTotalRowIndex);\n            } else {\n              newRowItemIndexesToCurrent = updateHeaderItems(loadedData.rows, dataSource.rows, loadedData.grandTotalRowIndex);\n            }\n          } else {\n            newRowItemIndexesToCurrent = updateHeaderItemChildren(headerItems, headerItem, dataSource.rows, loadedData.grandTotalRowIndex);\n\n            if (oppositeHeaderItem) {\n              newColumnItemIndexesToCurrent = updateHeaderItemChildren(oppositeHeaderItems, oppositeHeaderItem, dataSource.columns, loadedData.grandTotalColumnIndex);\n            } else {\n              newColumnItemIndexesToCurrent = updateHeaderItems(loadedData.columns, dataSource.columns, loadedData.grandTotalColumnIndex);\n            }\n          }\n\n          when(newRowItemIndexesToCurrent, newColumnItemIndexesToCurrent).done(function (newRowItemIndexesToCurrent, newColumnItemIndexesToCurrent) {\n            if (\"row\" === area && newRowItemIndexesToCurrent.length || \"column\" === area && newColumnItemIndexesToCurrent.length) {\n              updateDataSourceCells(loadedData, dataSource.values, newRowItemIndexesToCurrent, newColumnItemIndexesToCurrent);\n            }\n\n            that._update(deferred);\n          });\n        }\n      }\n    },\n    on: function on(eventName, eventHandler) {\n      this._eventsStrategy.on(eventName, eventHandler);\n\n      return this;\n    },\n    off: function off(eventName, eventHandler) {\n      this._eventsStrategy.off(eventName, eventHandler);\n\n      return this;\n    },\n    dispose: function dispose() {\n      var delayedLoadTask = this._delayedLoadTask;\n\n      this._eventsStrategy.dispose();\n\n      if (delayedLoadTask) {\n        delayedLoadTask.abort();\n      }\n\n      this._isDisposed = true;\n    },\n    isDisposed: function isDisposed() {\n      return !!this._isDisposed;\n    }\n  };\n}());","map":null,"metadata":{},"sourceType":"module"}