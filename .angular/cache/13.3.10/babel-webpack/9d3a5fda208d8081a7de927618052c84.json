{"ast":null,"code":"/**\r\n * DevExtreme (esm/viz/core/series_family.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { isNumeric, isDefined } from \"../../core/utils/type\";\nimport { extend } from \"../../core/utils/extend\";\nimport { each as _each } from \"../../core/utils/iterator\";\nimport { sign } from \"../../core/utils/math\";\nimport { noop as _noop } from \"../../core/utils/common\";\nimport { map as _map, normalizeEnum as _normalizeEnum } from \"./utils\";\nimport dateUtils from \"../../core/utils/date\";\nvar round = Math.round,\n    abs = Math.abs,\n    pow = Math.pow,\n    sqrt = Math.sqrt;\nvar _min = Math.min;\nvar DEFAULT_BAR_GROUP_PADDING = .3;\n\nfunction validateBarPadding(barPadding) {\n  return barPadding < 0 || barPadding > 1 ? void 0 : barPadding;\n}\n\nfunction validateBarGroupPadding(barGroupPadding) {\n  return barGroupPadding < 0 || barGroupPadding > 1 ? DEFAULT_BAR_GROUP_PADDING : barGroupPadding;\n}\n\nfunction isStackExist(series, arg) {\n  return series.some(function (s) {\n    return !s.getOptions().ignoreEmptyPoints || s.getPointsByArg(arg, true).some(function (point) {\n      return point.hasValue();\n    });\n  });\n}\n\nfunction correctStackCoordinates(series, currentStacks, arg, stack, parameters, barsArea, seriesStackIndexCallback) {\n  series.forEach(function (series) {\n    var stackIndex = seriesStackIndexCallback(currentStacks.indexOf(stack), currentStacks.length);\n    var points = series.getPointsByArg(arg, true);\n    var barPadding = validateBarPadding(series.getOptions().barPadding);\n    var barWidth = series.getOptions().barWidth;\n    var offset = getOffset(stackIndex, parameters);\n    var width = parameters.width;\n    var extraParameters;\n\n    if (-1 === stackIndex) {\n      return;\n    }\n\n    if (isDefined(barPadding) || isDefined(barWidth)) {\n      extraParameters = calculateParams(barsArea, currentStacks.length, 1 - barPadding, barWidth);\n      width = extraParameters.width;\n\n      if (!series.getBarOverlapGroup()) {\n        offset = getOffset(stackIndex, extraParameters);\n      }\n    }\n\n    correctPointCoordinates(points, width, offset);\n  });\n}\n\nfunction getStackName(series) {\n  return series.getStackName() || series.getBarOverlapGroup();\n}\n\nfunction adjustBarSeriesDimensionsCore(series, options, seriesStackIndexCallback) {\n  var _series$, _series$2;\n\n  var commonStacks = [];\n  var allArguments = [];\n  var seriesInStacks = {};\n  var barGroupWidth = options.barGroupWidth;\n  var argumentAxis = null === (_series$ = series[0]) || void 0 === _series$ ? void 0 : _series$.getArgumentAxis();\n  var interval;\n\n  if (null !== (_series$2 = series[0]) && void 0 !== _series$2 && _series$2.useAggregation()) {\n    var _series$3;\n\n    var isDateArgAxis = \"datetime\" === (null === (_series$3 = series[0]) || void 0 === _series$3 ? void 0 : _series$3.argumentType);\n    var tickInterval = argumentAxis.getTickInterval();\n    var aggregationInterval = argumentAxis.getAggregationInterval();\n    tickInterval = isDateArgAxis ? dateUtils.dateToMilliseconds(tickInterval) : tickInterval;\n    aggregationInterval = isDateArgAxis ? dateUtils.dateToMilliseconds(aggregationInterval) : aggregationInterval;\n    interval = aggregationInterval < tickInterval ? aggregationInterval : tickInterval;\n  }\n\n  interval = null === argumentAxis || void 0 === argumentAxis ? void 0 : argumentAxis.getTranslator().getInterval(interval);\n  var barsArea = barGroupWidth ? interval > barGroupWidth ? barGroupWidth : interval : interval * (1 - validateBarGroupPadding(options.barGroupPadding));\n  series.forEach(function (s, i) {\n    var stackName = getStackName(s) || i.toString();\n    var argument;\n\n    for (argument in s.pointsByArgument) {\n      if (-1 === allArguments.indexOf(argument.valueOf())) {\n        allArguments.push(argument.valueOf());\n      }\n    }\n\n    if (-1 === commonStacks.indexOf(stackName)) {\n      commonStacks.push(stackName);\n      seriesInStacks[stackName] = [];\n    }\n\n    seriesInStacks[stackName].push(s);\n  });\n  allArguments.forEach(function (arg) {\n    var currentStacks = commonStacks.reduce(function (stacks, stack) {\n      if (isStackExist(seriesInStacks[stack], arg)) {\n        stacks.push(stack);\n      }\n\n      return stacks;\n    }, []);\n    var parameters = calculateParams(barsArea, currentStacks.length);\n    commonStacks.forEach(function (stack) {\n      correctStackCoordinates(seriesInStacks[stack], currentStacks, arg, stack, parameters, barsArea, seriesStackIndexCallback);\n    });\n  });\n}\n\nfunction calculateParams(barsArea, count, percentWidth, fixedBarWidth) {\n  var spacing;\n  var width;\n\n  if (fixedBarWidth) {\n    width = _min(fixedBarWidth, barsArea / count);\n    spacing = count > 1 ? round((barsArea - round(width) * count) / (count - 1)) : 0;\n  } else if (isDefined(percentWidth)) {\n    width = barsArea * percentWidth / count;\n    spacing = count > 1 ? round((barsArea - barsArea * percentWidth) / (count - 1)) : 0;\n  } else {\n    spacing = round(barsArea / count * .2);\n    width = (barsArea - spacing * (count - 1)) / count;\n  }\n\n  return {\n    width: width > 1 ? round(width) : 1,\n    spacing: spacing,\n    middleIndex: count / 2,\n    rawWidth: width\n  };\n}\n\nfunction getOffset(stackIndex, parameters) {\n  var width = parameters.rawWidth < 1 ? parameters.rawWidth : parameters.width;\n  return (stackIndex - parameters.middleIndex + .5) * width - (parameters.middleIndex - stackIndex - .5) * parameters.spacing;\n}\n\nfunction correctPointCoordinates(points, width, offset) {\n  _each(points, function (_, point) {\n    point.correctCoordinates({\n      width: width,\n      offset: offset\n    });\n  });\n}\n\nfunction getValueType(value) {\n  return value >= 0 ? \"positive\" : \"negative\";\n}\n\nfunction getVisibleSeries(that) {\n  return that.series.filter(function (s) {\n    return s.isVisible();\n  });\n}\n\nfunction getAbsStackSumByArg(stackKeepers, stackName, argument) {\n  var positiveStackValue = (stackKeepers.positive[stackName] || {})[argument] || 0;\n  var negativeStackValue = -(stackKeepers.negative[stackName] || {})[argument] || 0;\n  return positiveStackValue + negativeStackValue;\n}\n\nfunction getStackSumByArg(stackKeepers, stackName, argument) {\n  var positiveStackValue = (stackKeepers.positive[stackName] || {})[argument] || 0;\n  var negativeStackValue = (stackKeepers.negative[stackName] || {})[argument] || 0;\n  return positiveStackValue + negativeStackValue;\n}\n\nfunction getSeriesStackIndexCallback(inverted) {\n  if (!inverted) {\n    return function (index) {\n      return index;\n    };\n  } else {\n    return function (index, stackCount) {\n      return stackCount - index - 1;\n    };\n  }\n}\n\nfunction isInverted(series) {\n  return series[0] && series[0].getArgumentAxis().getTranslator().isInverted();\n}\n\nfunction adjustBarSeriesDimensions() {\n  var series = getVisibleSeries(this);\n  adjustBarSeriesDimensionsCore(series, this._options, getSeriesStackIndexCallback(isInverted(series)));\n}\n\nfunction getFirstValueSign(series) {\n  var points = series.getPoints();\n  var value;\n\n  for (var i = 0; i < points.length; i++) {\n    var point = points[i];\n    value = point.initialValue && point.initialValue.valueOf();\n\n    if (abs(value) > 0) {\n      break;\n    }\n  }\n\n  return sign(value);\n}\n\nfunction adjustStackedSeriesValues() {\n  var negativesAsZeroes = this._options.negativesAsZeroes;\n  var series = getVisibleSeries(this);\n  var stackKeepers = {\n    positive: {},\n    negative: {}\n  };\n  var holesStack = {\n    left: {},\n    right: {}\n  };\n  var lastSeriesInPositiveStack = {};\n  var lastSeriesInNegativeStack = {};\n  series.forEach(function (singleSeries) {\n    var stackName = getStackName(singleSeries);\n    var hole = false;\n    var stack = getFirstValueSign(singleSeries) < 0 ? lastSeriesInNegativeStack : lastSeriesInPositiveStack;\n    singleSeries._prevSeries = stack[stackName];\n    stack[stackName] = singleSeries;\n    singleSeries.holes = extend(true, {}, holesStack);\n    singleSeries.getPoints().forEach(function (point, index, points) {\n      var value = point.initialValue && point.initialValue.valueOf();\n      var argument = point.argument.valueOf();\n      var stacks = value >= 0 ? stackKeepers.positive : stackKeepers.negative;\n      var isNotBarSeries = \"bar\" !== singleSeries.type;\n\n      if (negativesAsZeroes && value < 0) {\n        stacks = stackKeepers.positive;\n        value = 0;\n        point.resetValue();\n      }\n\n      stacks[stackName] = stacks[stackName] || {};\n      var currentStack = stacks[stackName];\n\n      if (currentStack[argument]) {\n        if (isNotBarSeries) {\n          point.correctValue(currentStack[argument]);\n        }\n\n        currentStack[argument] += value;\n      } else {\n        currentStack[argument] = value;\n\n        if (isNotBarSeries) {\n          point.resetCorrection();\n        }\n      }\n\n      if (!point.hasValue()) {\n        var prevPoint = points[index - 1];\n\n        if (!hole && prevPoint && prevPoint.hasValue()) {\n          argument = prevPoint.argument.valueOf();\n          prevPoint._skipSetRightHole = true;\n          holesStack.right[argument] = (holesStack.right[argument] || 0) + (prevPoint.value.valueOf() - (isFinite(prevPoint.minValue) ? prevPoint.minValue.valueOf() : 0));\n        }\n\n        hole = true;\n      } else if (hole) {\n        hole = false;\n        holesStack.left[argument] = (holesStack.left[argument] || 0) + (point.value.valueOf() - (isFinite(point.minValue) ? point.minValue.valueOf() : 0));\n        point._skipSetLeftHole = true;\n      }\n    });\n  });\n  series.forEach(function (singleSeries) {\n    var holes = singleSeries.holes;\n    singleSeries.getPoints().forEach(function (point) {\n      var argument = point.argument.valueOf();\n      point.resetHoles();\n      !point._skipSetLeftHole && point.setHole(holes.left[argument] || holesStack.left[argument] && 0, \"left\");\n      !point._skipSetRightHole && point.setHole(holes.right[argument] || holesStack.right[argument] && 0, \"right\");\n      point._skipSetLeftHole = null;\n      point._skipSetRightHole = null;\n    });\n  });\n  this._stackKeepers = stackKeepers;\n  series.forEach(function (singleSeries) {\n    singleSeries.getPoints().forEach(function (point) {\n      var argument = point.argument.valueOf();\n      var stackName = getStackName(singleSeries);\n      var absTotal = getAbsStackSumByArg(stackKeepers, stackName, argument);\n      var total = getStackSumByArg(stackKeepers, stackName, argument);\n      point.setPercentValue(absTotal, total, holesStack.left[argument], holesStack.right[argument]);\n    });\n  });\n}\n\nfunction updateStackedSeriesValues() {\n  var that = this;\n  var series = getVisibleSeries(that);\n  var stack = that._stackKeepers;\n  var stackKeepers = {\n    positive: {},\n    negative: {}\n  };\n\n  _each(series, function (_, singleSeries) {\n    var minBarSize = singleSeries.getOptions().minBarSize;\n    var valueAxisTranslator = singleSeries.getValueAxis().getTranslator();\n    var minShownBusinessValue = minBarSize && valueAxisTranslator.getMinBarSize(minBarSize);\n    var stackName = singleSeries.getStackName();\n\n    _each(singleSeries.getPoints(), function (index, point) {\n      if (!point.hasValue()) {\n        return;\n      }\n\n      var value = point.initialValue && point.initialValue.valueOf();\n      var argument = point.argument.valueOf();\n\n      if (that.fullStacked) {\n        value = value / getAbsStackSumByArg(stack, stackName, argument) || 0;\n      }\n\n      var updateValue = valueAxisTranslator.checkMinBarSize(value, minShownBusinessValue, point.value);\n      var valueType = getValueType(updateValue);\n      var currentStack = stackKeepers[valueType][stackName] = stackKeepers[valueType][stackName] || {};\n\n      if (currentStack[argument]) {\n        point.minValue = currentStack[argument];\n        currentStack[argument] += updateValue;\n      } else {\n        currentStack[argument] = updateValue;\n      }\n\n      point.value = currentStack[argument];\n    });\n  });\n\n  if (that.fullStacked) {\n    updateFullStackedSeriesValues(series, stackKeepers);\n  }\n}\n\nfunction updateFullStackedSeriesValues(series, stackKeepers) {\n  _each(series, function (_, singleSeries) {\n    var stackName = singleSeries.getStackName ? singleSeries.getStackName() : \"default\";\n\n    _each(singleSeries.getPoints(), function (index, point) {\n      var stackSum = getAbsStackSumByArg(stackKeepers, stackName, point.argument.valueOf());\n\n      if (0 !== stackSum) {\n        point.value = point.value / stackSum;\n\n        if (isNumeric(point.minValue)) {\n          point.minValue = point.minValue / stackSum;\n        }\n      }\n    });\n  });\n}\n\nfunction updateBarSeriesValues() {\n  _each(this.series, function (_, singleSeries) {\n    var minBarSize = singleSeries.getOptions().minBarSize;\n    var valueAxisTranslator = singleSeries.getValueAxis().getTranslator();\n    var minShownBusinessValue = minBarSize && valueAxisTranslator.getMinBarSize(minBarSize);\n\n    if (minShownBusinessValue) {\n      _each(singleSeries.getPoints(), function (index, point) {\n        if (point.hasValue()) {\n          point.value = valueAxisTranslator.checkMinBarSize(point.initialValue, minShownBusinessValue);\n        }\n      });\n    }\n  });\n}\n\nfunction adjustCandlestickSeriesDimensions() {\n  var series = getVisibleSeries(this);\n  adjustBarSeriesDimensionsCore(series, {\n    barGroupPadding: .3\n  }, getSeriesStackIndexCallback(isInverted(series)));\n}\n\nfunction adjustBubbleSeriesDimensions() {\n  var series = getVisibleSeries(this);\n\n  if (!series.length) {\n    return;\n  }\n\n  var options = this._options;\n  var visibleAreaX = series[0].getArgumentAxis().getVisibleArea();\n  var visibleAreaY = series[0].getValueAxis().getVisibleArea();\n\n  var min = _min(visibleAreaX[1] - visibleAreaX[0], visibleAreaY[1] - visibleAreaY[0]);\n\n  var minBubbleArea = pow(options.minBubbleSize, 2);\n  var maxBubbleArea = pow(min * options.maxBubbleSize, 2);\n  var equalBubbleSize = (min * options.maxBubbleSize + options.minBubbleSize) / 2;\n  var minPointSize = 1 / 0;\n  var maxPointSize = -1 / 0;\n  var pointSize;\n  var bubbleArea;\n  var sizeProportion;\n\n  _each(series, function (_, seriesItem) {\n    _each(seriesItem.getPoints(), function (_, point) {\n      maxPointSize = maxPointSize > point.size ? maxPointSize : point.size;\n      minPointSize = minPointSize < point.size ? minPointSize : point.size;\n    });\n  });\n\n  var sizeDispersion = maxPointSize - minPointSize;\n  var areaDispersion = abs(maxBubbleArea - minBubbleArea);\n\n  _each(series, function (_, seriesItem) {\n    _each(seriesItem.getPoints(), function (_, point) {\n      if (maxPointSize === minPointSize) {\n        pointSize = round(equalBubbleSize);\n      } else {\n        sizeProportion = abs(point.size - minPointSize) / sizeDispersion;\n        bubbleArea = areaDispersion * sizeProportion + minBubbleArea;\n        pointSize = round(sqrt(bubbleArea));\n      }\n\n      point.correctCoordinates(pointSize);\n    });\n  });\n}\n\nexport function SeriesFamily(options) {\n  this.type = _normalizeEnum(options.type);\n  this.pane = options.pane;\n  this.series = [];\n  this.updateOptions(options);\n\n  switch (this.type) {\n    case \"bar\":\n      this.adjustSeriesDimensions = adjustBarSeriesDimensions;\n      this.updateSeriesValues = updateBarSeriesValues;\n      this.adjustSeriesValues = adjustStackedSeriesValues;\n      break;\n\n    case \"rangebar\":\n      this.adjustSeriesDimensions = adjustBarSeriesDimensions;\n      break;\n\n    case \"fullstackedbar\":\n      this.fullStacked = true;\n      this.adjustSeriesDimensions = adjustBarSeriesDimensions;\n      this.adjustSeriesValues = adjustStackedSeriesValues;\n      this.updateSeriesValues = updateStackedSeriesValues;\n      break;\n\n    case \"stackedbar\":\n      this.adjustSeriesDimensions = adjustBarSeriesDimensions;\n      this.adjustSeriesValues = adjustStackedSeriesValues;\n      this.updateSeriesValues = updateStackedSeriesValues;\n      break;\n\n    case \"fullstackedarea\":\n    case \"fullstackedline\":\n    case \"fullstackedspline\":\n    case \"fullstackedsplinearea\":\n      this.fullStacked = true;\n      this.adjustSeriesValues = adjustStackedSeriesValues;\n      break;\n\n    case \"stackedarea\":\n    case \"stackedsplinearea\":\n    case \"stackedline\":\n    case \"stackedspline\":\n      this.adjustSeriesValues = adjustStackedSeriesValues;\n      break;\n\n    case \"candlestick\":\n    case \"stock\":\n      this.adjustSeriesDimensions = adjustCandlestickSeriesDimensions;\n      break;\n\n    case \"bubble\":\n      this.adjustSeriesDimensions = adjustBubbleSeriesDimensions;\n  }\n}\nSeriesFamily.prototype = {\n  constructor: SeriesFamily,\n  adjustSeriesDimensions: _noop,\n  adjustSeriesValues: _noop,\n  updateSeriesValues: _noop,\n  updateOptions: function updateOptions(options) {\n    this._options = options;\n  },\n  dispose: function dispose() {\n    this.series = null;\n  },\n  add: function add(series) {\n    var type = this.type;\n    this.series = _map(series, function (singleSeries) {\n      return singleSeries.type === type ? singleSeries : null;\n    });\n  }\n};","map":null,"metadata":{},"sourceType":"module"}