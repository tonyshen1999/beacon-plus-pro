{"ast":null,"code":"import _classCallCheck from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n\n/**\r\n * DevExtreme (esm/ui/scheduler/table_creator.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport $ from \"../../core/renderer\";\nimport domAdapter from \"../../core/dom_adapter\";\nimport { data as elementData } from \"../../core/element_data\";\nimport { isFunction } from \"../../core/utils/type\";\nimport { getPublicElement } from \"../../core/element\";\nvar ROW_SELECTOR = \"tr\";\n\nvar SchedulerTableCreator = /*#__PURE__*/function () {\n  function SchedulerTableCreator() {\n    _classCallCheck(this, SchedulerTableCreator);\n\n    this.VERTICAL = \"vertical\";\n    this.HORIZONTAL = \"horizontal\";\n  }\n\n  _createClass(SchedulerTableCreator, [{\n    key: \"insertAllDayRow\",\n    value: function insertAllDayRow(allDayElements, tableBody, index) {\n      if (allDayElements[index]) {\n        var row = allDayElements[index].find(ROW_SELECTOR);\n\n        if (!row.length) {\n          row = $(domAdapter.createElement(ROW_SELECTOR));\n          row.append(allDayElements[index].get(0));\n        }\n\n        tableBody.appendChild(row.get ? row.get(0) : row);\n      }\n    }\n  }, {\n    key: \"makeTable\",\n    value: function makeTable(options) {\n      var tableBody = domAdapter.createElement(\"tbody\");\n      var templateCallbacks = [];\n      var row;\n      var rowCountInGroup = options.groupCount ? options.rowCount / options.groupCount : options.rowCount;\n      var allDayElementIndex = 0;\n      var allDayElements = options.allDayElements;\n      var groupIndex = options.groupIndex;\n      var rowCount = options.rowCount;\n      $(options.container).append(tableBody);\n\n      if (allDayElements) {\n        this.insertAllDayRow(allDayElements, tableBody, 0);\n        allDayElementIndex++;\n      }\n\n      for (var rowIndex = 0; rowIndex < rowCount; rowIndex++) {\n        row = domAdapter.createElement(ROW_SELECTOR);\n        tableBody.appendChild(row);\n        var isLastRowInGroup = (rowIndex + 1) % rowCountInGroup === 0;\n\n        if (options.rowClass) {\n          row.className = options.rowClass;\n        }\n\n        for (var columnIndex = 0; columnIndex < options.cellCount; columnIndex++) {\n          var _options$setAdditiona;\n\n          var td = domAdapter.createElement(\"td\");\n          row.appendChild(td);\n\n          if (options.cellClass) {\n            if (isFunction(options.cellClass)) {\n              td.className = options.cellClass(rowIndex, columnIndex);\n            } else {\n              td.className = options.cellClass;\n            }\n          }\n\n          var cellDataObject = void 0;\n          var dataKey = void 0;\n          var dataValue = void 0;\n\n          if (options.getCellData) {\n            cellDataObject = options.getCellData(td, rowIndex, columnIndex, groupIndex);\n            dataKey = cellDataObject.key;\n            dataValue = cellDataObject.value;\n            dataKey && elementData(td, dataKey, dataValue);\n          }\n\n          null === (_options$setAdditiona = options.setAdditionalClasses) || void 0 === _options$setAdditiona ? void 0 : _options$setAdditiona.call(options, $(td), dataValue);\n\n          if (options.cellTemplate && options.cellTemplate.render) {\n            var additionalTemplateData = options.getTemplateData ? options.getTemplateData(rowIndex) : {};\n            var templateOptions = {\n              model: _extends({\n                text: options.getCellText ? options.getCellText(rowIndex, columnIndex) : \"\",\n                date: options.getCellDate ? options.getCellDate(rowIndex) : void 0\n              }, additionalTemplateData),\n              container: getPublicElement($(td)),\n              index: rowIndex * options.cellCount + columnIndex\n            };\n\n            if (dataValue) {\n              if (dataValue.startDate) {\n                templateOptions.model.startDate = dataValue.startDate;\n              }\n\n              if (dataValue.endDate) {\n                templateOptions.model.endDate = dataValue.endDate;\n              }\n\n              if (dataValue.groups) {\n                templateOptions.model.groups = dataValue.groups;\n              }\n\n              if (dataValue.allDay) {\n                templateOptions.model.allDay = dataValue.allDay;\n              }\n            }\n\n            templateCallbacks.push(options.cellTemplate.render.bind(options.cellTemplate, templateOptions));\n          } else if (options.getCellText) {\n            $(\"<div>\").text(options.getCellText(rowIndex, columnIndex)).addClass(options.getCellTextClass).appendTo($(td));\n          }\n        }\n\n        if (allDayElements && isLastRowInGroup) {\n          this.insertAllDayRow(allDayElements, tableBody, allDayElementIndex);\n          allDayElementIndex++;\n        }\n      }\n\n      return templateCallbacks;\n    }\n  }, {\n    key: \"makeGroupedTable\",\n    value: function makeGroupedTable(type, groups, cssClasses, cellCount, cellTemplate, rowCount, groupByDate) {\n      var rows = [];\n\n      if (type === this.VERTICAL) {\n        rows = this._makeVerticalGroupedRows(groups, cssClasses, cellTemplate, rowCount);\n      } else {\n        rows = this._makeHorizontalGroupedRows(groups, cssClasses, cellCount, cellTemplate, groupByDate);\n      }\n\n      return rows;\n    }\n  }, {\n    key: \"makeGroupedTableFromJSON\",\n    value: function makeGroupedTableFromJSON(type, data, config) {\n      var table;\n      var cellStorage = [];\n      var rowIndex = 0;\n      config = config || {};\n      var cellTag = config.cellTag || \"td\";\n      var childrenField = config.childrenField || \"children\";\n      var titleField = config.titleField || \"title\";\n      var groupTableClass = config.groupTableClass;\n      var groupRowClass = config.groupRowClass;\n      var groupCellClass = config.groupCellClass;\n      var groupCellCustomContent = config.groupCellCustomContent;\n\n      function getChildCount(item) {\n        if (item[childrenField]) {\n          return item[childrenField].length;\n        }\n\n        return 0;\n      }\n\n      function createCell(text, childCount, index, data) {\n        var cell = {\n          element: domAdapter.createElement(cellTag),\n          childCount: childCount\n        };\n\n        if (groupCellClass) {\n          cell.element.className = groupCellClass;\n        }\n\n        var cellText = domAdapter.createTextNode(text);\n\n        if (\"function\" === typeof groupCellCustomContent) {\n          groupCellCustomContent(cell.element, cellText, index, data);\n        } else {\n          cell.element.appendChild(cellText);\n        }\n\n        return cell;\n      }\n\n      !function () {\n        table = domAdapter.createElement(\"table\");\n\n        if (groupTableClass) {\n          table.className = groupTableClass;\n        }\n      }();\n      !function generateCells(data) {\n        for (var i = 0; i < data.length; i++) {\n          var childCount = getChildCount(data[i]);\n          var cell = createCell(data[i][titleField], childCount, i, data[i]);\n\n          if (!cellStorage[rowIndex]) {\n            cellStorage[rowIndex] = [];\n          }\n\n          cellStorage[rowIndex].push(cell);\n\n          if (childCount) {\n            generateCells(data[i][childrenField]);\n          } else {\n            rowIndex++;\n          }\n        }\n      }(data);\n      void cellStorage.forEach(function (cells) {\n        var row = domAdapter.createElement(ROW_SELECTOR);\n\n        if (groupRowClass) {\n          row.className = groupRowClass;\n        }\n\n        var rowspans = [];\n\n        for (var i = cells.length - 1; i >= 0; i--) {\n          var prev = cells[i + 1];\n          var rowspan = cells[i].childCount;\n\n          if (prev && prev.childCount) {\n            rowspan *= prev.childCount;\n          }\n\n          rowspans.push(rowspan);\n        }\n\n        rowspans.reverse();\n        cells.forEach(function (cell, index) {\n          if (rowspans[index]) {\n            cell.element.setAttribute(\"rowSpan\", rowspans[index]);\n          }\n\n          row.appendChild(cell.element);\n        });\n        table.appendChild(row);\n      });\n      return table;\n    }\n  }, {\n    key: \"_makeFlexGroupedRowCells\",\n    value: function _makeFlexGroupedRowCells(group, repeatCount, cssClasses, cellTemplate) {\n      var repeatByDate = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1;\n      var cells = [];\n      var items = group.items;\n      var itemCount = items.length;\n\n      for (var i = 0; i < repeatCount * repeatByDate; i++) {\n        for (var j = 0; j < itemCount; j++) {\n          var $container = $(\"<div>\");\n          var cell = {};\n\n          if (cellTemplate && cellTemplate.render) {\n            var templateOptions = {\n              model: items[j],\n              container: getPublicElement($container),\n              index: i * itemCount + j\n            };\n\n            if (group.data) {\n              templateOptions.model.data = group.data[j];\n            }\n\n            cell.template = cellTemplate.render.bind(cellTemplate, templateOptions);\n          } else {\n            $container.text(items[j].text).attr(\"title\", items[j].text).addClass(\"dx-scheduler-group-header-content\");\n            $container = $(\"<div>\").append($container);\n          }\n\n          var cssClass = isFunction(cssClasses.groupHeaderClass) ? cssClasses.groupHeaderClass(j) : cssClasses.groupHeaderClass;\n          cell.element = $container.addClass(cssClass);\n          cells.push(cell);\n        }\n      }\n\n      return cells;\n    }\n  }, {\n    key: \"_makeVerticalGroupedRows\",\n    value: function _makeVerticalGroupedRows(groups, cssClasses, cellTemplate) {\n      var cellTemplates = [];\n      var repeatCount = 1;\n      var cellsArray = [];\n\n      var cellIterator = function cellIterator(cell) {\n        if (cell.template) {\n          cellTemplates.push(cell.template);\n        }\n      };\n\n      for (var i = 0; i < groups.length; i++) {\n        if (i > 0) {\n          repeatCount = groups[i - 1].items.length * repeatCount;\n        }\n\n        var cells = this._makeFlexGroupedRowCells(groups[i], repeatCount, cssClasses, cellTemplate);\n\n        cells.forEach(cellIterator);\n        cellsArray.push(cells);\n      }\n\n      var rows = [];\n      var groupCount = cellsArray.length;\n\n      for (var _i = 0; _i < groupCount; _i++) {\n        rows.push($(\"<div>\").addClass(cssClasses.groupHeaderRowClass));\n      }\n\n      for (var _i2 = groupCount - 1; _i2 >= 0; _i2--) {\n        var currentColumnLength = cellsArray[_i2].length;\n\n        for (var j = 0; j < currentColumnLength; j++) {\n          rows[_i2].append(cellsArray[_i2][j].element);\n        }\n      }\n\n      return {\n        elements: $(\"<div>\").addClass(\"dx-scheduler-group-flex-container\").append(rows),\n        cellTemplates: cellTemplates\n      };\n    }\n  }, {\n    key: \"_makeHorizontalGroupedRows\",\n    value: function _makeHorizontalGroupedRows(groups, cssClasses, cellCount, cellTemplate, groupByDate) {\n      var repeatCount = 1;\n      var groupCount = groups.length;\n      var rows = [];\n      var cellTemplates = [];\n      var repeatByDate = groupByDate ? cellCount : 1;\n\n      var cellIterator = function cellIterator(cell) {\n        if (cell.template) {\n          cellTemplates.push(cell.template);\n        }\n\n        return cell.element;\n      };\n\n      for (var i = 0; i < groupCount; i++) {\n        if (i > 0) {\n          repeatCount = groups[i - 1].items.length * repeatCount;\n        }\n\n        var cells = this._makeGroupedRowCells(groups[i], repeatCount, cssClasses, cellTemplate, repeatByDate);\n\n        rows.push($(\"<tr>\").addClass(cssClasses.groupRowClass).append(cells.map(cellIterator)));\n      }\n\n      var maxCellCount = rows[groupCount - 1].find(\"th\").length;\n\n      for (var j = 0; j < groupCount; j++) {\n        var $cell = rows[j].find(\"th\");\n        var colspan = maxCellCount / $cell.length;\n\n        if (!groupByDate) {\n          colspan *= cellCount;\n        }\n\n        if (colspan > 1 && 1 === repeatByDate || groupByDate && groupCount > 1) {\n          $cell.attr(\"colSpan\", colspan);\n        }\n      }\n\n      return {\n        elements: rows,\n        cellTemplates: cellTemplates\n      };\n    }\n  }, {\n    key: \"_makeGroupedRowCells\",\n    value: function _makeGroupedRowCells(group, repeatCount, cssClasses, cellTemplate, repeatByDate) {\n      repeatByDate = repeatByDate || 1;\n      repeatCount *= repeatByDate;\n      var cells = [];\n      var items = group.items;\n      var itemCount = items.length;\n\n      for (var i = 0; i < repeatCount; i++) {\n        for (var j = 0; j < itemCount; j++) {\n          var $container = $(\"<div>\");\n          var cell = {};\n\n          if (cellTemplate && cellTemplate.render) {\n            var templateOptions = {\n              model: items[j],\n              container: getPublicElement($container),\n              index: i * itemCount + j\n            };\n\n            if (group.data) {\n              templateOptions.model.data = group.data[j];\n            }\n\n            cell.template = cellTemplate.render.bind(cellTemplate, templateOptions);\n          } else {\n            $container.text(items[j].text);\n            $container = $(\"<div>\").append($container);\n          }\n\n          $container.addClass(cssClasses.groupHeaderContentClass);\n          var cssClass = void 0;\n\n          if (isFunction(cssClasses.groupHeaderClass)) {\n            cssClass = cssClasses.groupHeaderClass(j);\n          } else {\n            cssClass = cssClasses.groupHeaderClass;\n          }\n\n          cell.element = $(\"<th>\").addClass(cssClass).append($container);\n          cells.push(cell);\n        }\n      }\n\n      return cells;\n    }\n  }]);\n\n  return SchedulerTableCreator;\n}();\n\nexport default {\n  tableCreator: new SchedulerTableCreator()\n};","map":null,"metadata":{},"sourceType":"module"}