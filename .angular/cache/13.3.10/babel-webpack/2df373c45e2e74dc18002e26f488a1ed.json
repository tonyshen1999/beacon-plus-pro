{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/grid_core/ui.grid_core.columns_controller.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport $ from \"../../core/renderer\";\nimport Callbacks from \"../../core/utils/callbacks\";\nimport variableWrapper from \"../../core/utils/variable_wrapper\";\nimport { compileGetter, compileSetter } from \"../../core/utils/data\";\nimport { isDefined, isString, isNumeric, isFunction, isObject, isPlainObject, type } from \"../../core/utils/type\";\nimport { each, map } from \"../../core/utils/iterator\";\nimport { getDefaultAlignment } from \"../../core/utils/position\";\nimport { extend } from \"../../core/utils/extend\";\nimport { inArray, normalizeIndexes } from \"../../core/utils/array\";\nimport config from \"../../core/config\";\nimport { orderEach, deepExtendArraySafe } from \"../../core/utils/object\";\nimport errors from \"../widget/ui.errors\";\nimport modules from \"./ui.grid_core.modules\";\nimport gridCoreUtils from \"./ui.grid_core.utils\";\nimport { captionize } from \"../../core/utils/inflector\";\nimport dateSerialization from \"../../core/utils/date_serialization\";\nimport numberLocalization from \"../../localization/number\";\nimport dateLocalization from \"../../localization/date\";\nimport messageLocalization from \"../../localization/message\";\nimport { when, Deferred } from \"../../core/utils/deferred\";\nimport Store from \"../../data/abstract_store\";\nimport { DataSource } from \"../../data/data_source/data_source\";\nimport { normalizeDataSourceOptions } from \"../../data/data_source/utils\";\nimport filterUtils from \"../shared/filtering\";\nvar USER_STATE_FIELD_NAMES_15_1 = [\"filterValues\", \"filterType\", \"fixed\", \"fixedPosition\"];\nvar USER_STATE_FIELD_NAMES = [\"visibleIndex\", \"dataField\", \"name\", \"dataType\", \"width\", \"visible\", \"sortOrder\", \"lastSortOrder\", \"sortIndex\", \"groupIndex\", \"filterValue\", \"selectedFilterOperation\", \"added\"].concat(USER_STATE_FIELD_NAMES_15_1);\nvar IGNORE_COLUMN_OPTION_NAMES = {\n  visibleWidth: true,\n  bestFitWidth: true,\n  bufferedFilterValue: true\n};\nvar COMMAND_EXPAND_CLASS = \"dx-command-expand\";\nvar MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;\nvar GROUP_COMMAND_COLUMN_NAME = \"groupExpand\";\nvar regExp = /columns\\[(\\d+)\\]\\.?/gi;\nvar globalColumnId = 1;\nexport var columnsControllerModule = {\n  defaultOptions: function defaultOptions() {\n    return {\n      commonColumnSettings: {\n        allowFiltering: true,\n        allowHiding: true,\n        allowSorting: true,\n        allowEditing: true,\n        encodeHtml: true,\n        trueText: messageLocalization.format(\"dxDataGrid-trueText\"),\n        falseText: messageLocalization.format(\"dxDataGrid-falseText\")\n      },\n      allowColumnReordering: false,\n      allowColumnResizing: false,\n      columnResizingMode: \"nextColumn\",\n      columnMinWidth: void 0,\n      columnWidth: void 0,\n      adaptColumnWidthByRatio: true,\n      columns: void 0,\n      regenerateColumnsByVisibleItems: false,\n      customizeColumns: null,\n      dateSerializationFormat: void 0\n    };\n  },\n  controllers: {\n    columns: modules.Controller.inherit(function () {\n      var DEFAULT_COLUMN_OPTIONS = {\n        visible: true,\n        showInColumnChooser: true\n      };\n      var DATATYPE_OPERATIONS = {\n        number: [\"=\", \"<>\", \"<\", \">\", \"<=\", \">=\", \"between\"],\n        string: [\"contains\", \"notcontains\", \"startswith\", \"endswith\", \"=\", \"<>\"],\n        date: [\"=\", \"<>\", \"<\", \">\", \"<=\", \">=\", \"between\"],\n        datetime: [\"=\", \"<>\", \"<\", \">\", \"<=\", \">=\", \"between\"]\n      };\n      var COLUMN_INDEX_OPTIONS = {\n        visibleIndex: true,\n        groupIndex: true,\n        grouped: true,\n        sortIndex: true,\n        sortOrder: true\n      };\n\n      var setFilterOperationsAsDefaultValues = function setFilterOperationsAsDefaultValues(column) {\n        column.filterOperations = column.defaultFilterOperations;\n      };\n\n      var createColumn = function createColumn(that, columnOptions, userStateColumnOptions, bandColumn) {\n        var commonColumnOptions = {};\n\n        if (columnOptions) {\n          if (isString(columnOptions)) {\n            columnOptions = {\n              dataField: columnOptions\n            };\n          }\n\n          that.setName(columnOptions);\n          var result = {};\n\n          if (columnOptions.command) {\n            result = deepExtendArraySafe(commonColumnOptions, columnOptions);\n          } else {\n            commonColumnOptions = that.getCommonSettings(columnOptions);\n\n            if (userStateColumnOptions && userStateColumnOptions.name && userStateColumnOptions.dataField) {\n              columnOptions = extend({}, columnOptions, {\n                dataField: userStateColumnOptions.dataField\n              });\n            }\n\n            var calculatedColumnOptions = that._createCalculatedColumnOptions(columnOptions, bandColumn);\n\n            if (!columnOptions.type) {\n              result = {\n                headerId: \"dx-col-\".concat(globalColumnId++)\n              };\n            }\n\n            result = deepExtendArraySafe(result, DEFAULT_COLUMN_OPTIONS);\n            deepExtendArraySafe(result, commonColumnOptions);\n            deepExtendArraySafe(result, calculatedColumnOptions);\n            deepExtendArraySafe(result, columnOptions);\n            deepExtendArraySafe(result, {\n              selector: null\n            });\n          }\n\n          if (columnOptions.filterOperations === columnOptions.defaultFilterOperations) {\n            setFilterOperationsAsDefaultValues(result);\n          }\n\n          return result;\n        }\n      };\n\n      var createColumnsFromOptions = function createColumnsFromOptions(that, columnsOptions, bandColumn) {\n        var result = [];\n\n        if (columnsOptions) {\n          each(columnsOptions, function (index, columnOptions) {\n            var userStateColumnOptions = that._columnsUserState && checkUserStateColumn(columnOptions, that._columnsUserState[index]) && that._columnsUserState[index];\n\n            var column = createColumn(that, columnOptions, userStateColumnOptions, bandColumn);\n\n            if (column) {\n              if (bandColumn) {\n                column.ownerBand = bandColumn;\n              }\n\n              result.push(column);\n\n              if (column.columns) {\n                result = result.concat(createColumnsFromOptions(that, column.columns, column));\n                delete column.columns;\n                column.hasColumns = true;\n              }\n            }\n          });\n        }\n\n        return result;\n      };\n\n      var getParentBandColumns = function getParentBandColumns(columnIndex, columnParentByIndex) {\n        var result = [];\n        var parent = columnParentByIndex[columnIndex];\n\n        while (parent) {\n          result.unshift(parent);\n          columnIndex = parent.index;\n          parent = columnParentByIndex[columnIndex];\n        }\n\n        return result;\n      };\n\n      var _getChildrenByBandColumn = function _getChildrenByBandColumn(columnIndex, columnChildrenByIndex, recursive) {\n        var result = [];\n        var children = columnChildrenByIndex[columnIndex];\n\n        if (children) {\n          for (var i = 0; i < children.length; i++) {\n            var column = children[i];\n\n            if (!isDefined(column.groupIndex) || column.showWhenGrouped) {\n              result.push(column);\n\n              if (recursive && column.isBand) {\n                result = result.concat(_getChildrenByBandColumn(column.index, columnChildrenByIndex, recursive));\n              }\n            }\n          }\n        }\n\n        return result;\n      };\n\n      var getColumnFullPath = function getColumnFullPath(that, column) {\n        var result = [];\n        var columns;\n        var bandColumnsCache = that.getBandColumnsCache();\n\n        var callbackFilter = function callbackFilter(item) {\n          return item.ownerBand === column.ownerBand;\n        };\n\n        if (bandColumnsCache.isPlain) {\n          var columnIndex = that._columns.indexOf(column);\n\n          if (columnIndex >= 0) {\n            result = [\"columns[\".concat(columnIndex, \"]\")];\n          }\n        } else {\n          columns = that._columns.filter(callbackFilter);\n\n          while (columns.length && -1 !== columns.indexOf(column)) {\n            result.unshift(\"columns[\".concat(columns.indexOf(column), \"]\"));\n            column = bandColumnsCache.columnParentByIndex[column.index];\n            columns = column ? that._columns.filter(callbackFilter) : [];\n          }\n        }\n\n        return result.join(\".\");\n      };\n\n      var calculateColspan = function calculateColspan(that, columnID) {\n        var colspan = 0;\n        var columns = that.getChildrenByBandColumn(columnID, true);\n        each(columns, function (_, column) {\n          if (column.isBand) {\n            column.colspan = column.colspan || calculateColspan(that, column.index);\n            colspan += column.colspan || 1;\n          } else {\n            colspan += 1;\n          }\n        });\n        return colspan;\n      };\n\n      var getValueDataType = function getValueDataType(value) {\n        var dataType = type(value);\n\n        if (\"string\" !== dataType && \"boolean\" !== dataType && \"number\" !== dataType && \"date\" !== dataType && \"object\" !== dataType) {\n          dataType = void 0;\n        }\n\n        return dataType;\n      };\n\n      var getSerializationFormat = function getSerializationFormat(dataType, value) {\n        switch (dataType) {\n          case \"date\":\n          case \"datetime\":\n            return dateSerialization.getDateSerializationFormat(value);\n\n          case \"number\":\n            if (isString(value)) {\n              return \"string\";\n            }\n\n            if (isNumeric(value)) {\n              return null;\n            }\n\n        }\n      };\n\n      var updateSerializers = function updateSerializers(options, dataType) {\n        if (!options.deserializeValue) {\n          if (gridCoreUtils.isDateType(dataType)) {\n            options.deserializeValue = function (value) {\n              return dateSerialization.deserializeDate(value);\n            };\n\n            options.serializeValue = function (value) {\n              return isString(value) ? value : dateSerialization.serializeDate(value, this.serializationFormat);\n            };\n          }\n\n          if (\"number\" === dataType) {\n            options.deserializeValue = function (value) {\n              var parsedValue = parseFloat(value);\n              return isNaN(parsedValue) ? value : parsedValue;\n            };\n\n            options.serializeValue = function (value, target) {\n              if (\"filter\" === target) {\n                return value;\n              }\n\n              return isDefined(value) && \"string\" === this.serializationFormat ? value.toString() : value;\n            };\n          }\n        }\n      };\n\n      var customizeTextForBooleanDataType = function customizeTextForBooleanDataType(e) {\n        if (true === e.value) {\n          return this.trueText || \"true\";\n        } else if (false === e.value) {\n          return this.falseText || \"false\";\n        } else {\n          return e.valueText || \"\";\n        }\n      };\n\n      var getCustomizeTextByDataType = function getCustomizeTextByDataType(dataType) {\n        if (\"boolean\" === dataType) {\n          return customizeTextForBooleanDataType;\n        }\n      };\n\n      var updateColumnIndexes = function updateColumnIndexes(that) {\n        each(that._columns, function (index, column) {\n          column.index = index;\n        });\n        each(that._columns, function (index, column) {\n          if (isObject(column.ownerBand)) {\n            column.ownerBand = column.ownerBand.index;\n          }\n        });\n        each(that._commandColumns, function (index, column) {\n          column.index = -(index + 1);\n        });\n      };\n\n      var updateColumnGroupIndexes = function updateColumnGroupIndexes(that, currentColumn) {\n        normalizeIndexes(that._columns, \"groupIndex\", currentColumn, function (column) {\n          var grouped = column.grouped;\n          delete column.grouped;\n          return grouped;\n        });\n      };\n\n      var getColumnIndexByVisibleIndex = function getColumnIndexByVisibleIndex(that, visibleIndex, location) {\n        var rowIndex = isObject(visibleIndex) ? visibleIndex.rowIndex : null;\n        var columns = \"group\" === location ? that.getGroupColumns() : \"columnChooser\" === location ? that.getChooserColumns() : that.getVisibleColumns(rowIndex);\n        var column;\n        visibleIndex = isObject(visibleIndex) ? visibleIndex.columnIndex : visibleIndex;\n        column = columns[visibleIndex];\n\n        if (column && column.type === GROUP_COMMAND_COLUMN_NAME) {\n          column = that._columns.filter(function (col) {\n            return column.type === col.type;\n          })[0] || column;\n        }\n\n        return column && isDefined(column.index) ? column.index : -1;\n      };\n\n      function checkUserStateColumn(column, userStateColumn) {\n        return column && userStateColumn && userStateColumn.name === (column.name || column.dataField) && (userStateColumn.dataField === column.dataField || column.name);\n      }\n\n      var applyUserState = function applyUserState(that) {\n        var columnsUserState = that._columnsUserState;\n        var ignoreColumnOptionNames = that._ignoreColumnOptionNames || [];\n        var columns = that._columns;\n        var columnCountById = {};\n        var resultColumns = [];\n        var allColumnsHaveState = true;\n        var userStateColumnIndexes = [];\n        var column;\n        var userStateColumnIndex;\n        var i;\n\n        function applyFieldsState(column, userStateColumn) {\n          if (!userStateColumn) {\n            return;\n          }\n\n          for (var index = 0; index < USER_STATE_FIELD_NAMES.length; index++) {\n            var fieldName = USER_STATE_FIELD_NAMES[index];\n\n            if (inArray(fieldName, ignoreColumnOptionNames) >= 0) {\n              continue;\n            }\n\n            if (\"dataType\" === fieldName) {\n              column[fieldName] = column[fieldName] || userStateColumn[fieldName];\n            } else if (inArray(fieldName, USER_STATE_FIELD_NAMES_15_1) >= 0) {\n              if (fieldName in userStateColumn) {\n                column[fieldName] = userStateColumn[fieldName];\n              }\n            } else {\n              if (\"selectedFilterOperation\" === fieldName && userStateColumn[fieldName]) {\n                column.defaultSelectedFilterOperation = column[fieldName] || null;\n              }\n\n              column[fieldName] = userStateColumn[fieldName];\n            }\n          }\n        }\n\n        function findUserStateColumn(columnsUserState, column) {\n          var id = column.name || column.dataField;\n          var count = columnCountById[id] || 0;\n\n          for (var j = 0; j < columnsUserState.length; j++) {\n            if (checkUserStateColumn(column, columnsUserState[j])) {\n              if (count) {\n                count--;\n              } else {\n                columnCountById[id] = columnCountById[id] || 0;\n                columnCountById[id]++;\n                return j;\n              }\n            }\n          }\n\n          return -1;\n        }\n\n        if (columnsUserState) {\n          for (i = 0; i < columns.length; i++) {\n            userStateColumnIndex = findUserStateColumn(columnsUserState, columns[i]);\n            allColumnsHaveState = allColumnsHaveState && userStateColumnIndex >= 0;\n            userStateColumnIndexes.push(userStateColumnIndex);\n          }\n\n          for (i = 0; i < columns.length; i++) {\n            column = columns[i];\n            userStateColumnIndex = userStateColumnIndexes[i];\n\n            if (that._hasUserState || allColumnsHaveState) {\n              applyFieldsState(column, columnsUserState[userStateColumnIndex]);\n            }\n\n            if (userStateColumnIndex >= 0 && isDefined(columnsUserState[userStateColumnIndex].initialIndex)) {\n              resultColumns[userStateColumnIndex] = column;\n            } else {\n              resultColumns.push(column);\n            }\n          }\n\n          var hasAddedBands = false;\n\n          for (i = 0; i < columnsUserState.length; i++) {\n            var columnUserState = columnsUserState[i];\n\n            if (columnUserState.added && findUserStateColumn(columns, columnUserState) < 0) {\n              column = createColumn(that, columnUserState.added);\n              applyFieldsState(column, columnUserState);\n              resultColumns.push(column);\n\n              if (columnUserState.added.columns) {\n                hasAddedBands = true;\n              }\n            }\n          }\n\n          if (hasAddedBands) {\n            updateColumnIndexes(that);\n            resultColumns = createColumnsFromOptions(that, resultColumns);\n          }\n\n          assignColumns(that, resultColumns);\n        }\n      };\n\n      var updateIndexes = function updateIndexes(that, column) {\n        updateColumnIndexes(that);\n        updateColumnGroupIndexes(that, column);\n        !function (that, currentColumn) {\n          each(that._columns, function (index, column) {\n            if (isDefined(column.sortIndex) && !isSortOrderValid(column.sortOrder)) {\n              delete column.sortIndex;\n            }\n          });\n          normalizeIndexes(that._columns, \"sortIndex\", currentColumn, function (column) {\n            return !isDefined(column.groupIndex) && isSortOrderValid(column.sortOrder);\n          });\n        }(that, column);\n        resetBandColumnsCache(that);\n        !function (that, currentColumn) {\n          var key;\n          var column;\n          var bandColumns = {};\n          var result = [];\n          var bandColumnsCache = that.getBandColumnsCache();\n\n          var columns = that._columns.filter(function (column) {\n            return !column.command;\n          });\n\n          for (var i = 0; i < columns.length; i++) {\n            column = columns[i];\n            var parentBandColumns = getParentBandColumns(i, bandColumnsCache.columnParentByIndex);\n\n            if (parentBandColumns.length) {\n              var bandColumnIndex = parentBandColumns[parentBandColumns.length - 1].index;\n              bandColumns[bandColumnIndex] = bandColumns[bandColumnIndex] || [];\n              bandColumns[bandColumnIndex].push(column);\n            } else {\n              result.push(column);\n            }\n          }\n\n          for (key in bandColumns) {\n            normalizeIndexes(bandColumns[key], \"visibleIndex\", currentColumn);\n          }\n\n          normalizeIndexes(result, \"visibleIndex\", currentColumn);\n        }(that, column);\n      };\n\n      var resetColumnsCache = function resetColumnsCache(that) {\n        that.resetColumnsCache();\n      };\n\n      function assignColumns(that, columns) {\n        that._columns = columns;\n        resetColumnsCache(that);\n        that.updateColumnDataTypes();\n      }\n\n      var updateColumnChanges = function updateColumnChanges(that, changeType, optionName, columnIndex) {\n        var columnChanges = that._columnChanges || {\n          optionNames: {\n            length: 0\n          },\n          changeTypes: {\n            length: 0\n          },\n          columnIndex: columnIndex\n        };\n        optionName = optionName || \"all\";\n        optionName = optionName.split(\".\")[0];\n        var changeTypes = columnChanges.changeTypes;\n\n        if (changeType && !changeTypes[changeType]) {\n          changeTypes[changeType] = true;\n          changeTypes.length++;\n        }\n\n        var optionNames = columnChanges.optionNames;\n\n        if (optionName && !optionNames[optionName]) {\n          optionNames[optionName] = true;\n          optionNames.length++;\n        }\n\n        if (void 0 === columnIndex || columnIndex !== columnChanges.columnIndex) {\n          delete columnChanges.columnIndex;\n        }\n\n        that._columnChanges = columnChanges;\n        resetColumnsCache(that);\n      };\n\n      var fireColumnsChanged = function fireColumnsChanged(that) {\n        var onColumnsChanging = that.option(\"onColumnsChanging\");\n        var columnChanges = that._columnChanges;\n        var reinitOptionNames = [\"dataField\", \"lookup\", \"dataType\", \"columns\"];\n\n        if (that.isInitialized() && !that._updateLockCount && columnChanges) {\n          if (onColumnsChanging) {\n            that._updateLockCount++;\n            onColumnsChanging(extend({\n              component: that.component\n            }, columnChanges));\n            that._updateLockCount--;\n          }\n\n          that._columnChanges = void 0;\n\n          if (options = columnChanges.optionNames, options && reinitOptionNames.some(function (name) {\n            return options[name];\n          })) {\n            that.reinit();\n          } else {\n            that.columnsChanged.fire(columnChanges);\n          }\n        }\n\n        var options;\n      };\n\n      var updateSortOrderWhenGrouping = function updateSortOrderWhenGrouping(that, column, groupIndex, prevGroupIndex) {\n        var columnWasGrouped = prevGroupIndex >= 0;\n\n        if (groupIndex >= 0) {\n          if (!columnWasGrouped) {\n            column.lastSortOrder = column.sortOrder;\n          }\n        } else {\n          var sortMode = that.option(\"sorting.mode\");\n          var sortOrder = column.lastSortOrder;\n\n          if (\"single\" === sortMode) {\n            var sortedByAnotherColumn = that._columns.some(function (col) {\n              return col !== column && isDefined(col.sortIndex);\n            });\n\n            if (sortedByAnotherColumn) {\n              sortOrder = void 0;\n            }\n          }\n\n          column.sortOrder = sortOrder;\n        }\n      };\n\n      var fireOptionChanged = function fireOptionChanged(that, options) {\n        var value = options.value;\n        var optionName = options.optionName;\n        var prevValue = options.prevValue;\n        var fullOptionName = options.fullOptionName;\n        var fullOptionPath = \"\".concat(fullOptionName, \".\").concat(optionName);\n\n        if (!IGNORE_COLUMN_OPTION_NAMES[optionName] && that._skipProcessingColumnsChange !== fullOptionPath) {\n          that._skipProcessingColumnsChange = fullOptionPath;\n\n          that.component._notifyOptionChanged(fullOptionPath, value, prevValue);\n\n          that._skipProcessingColumnsChange = false;\n        }\n      };\n\n      var columnOptionCore = function columnOptionCore(that, column, optionName, value, notFireEvent) {\n        var optionGetter = compileGetter(optionName);\n        var columnIndex = column.index;\n        var columns;\n        var changeType;\n        var initialColumn;\n\n        if (3 === arguments.length) {\n          return optionGetter(column, {\n            functionsAsIs: true\n          });\n        }\n\n        var prevValue = optionGetter(column, {\n          functionsAsIs: true\n        });\n\n        if (prevValue !== value) {\n          if (\"groupIndex\" === optionName || \"calculateGroupValue\" === optionName) {\n            changeType = \"grouping\";\n            updateSortOrderWhenGrouping(that, column, value, prevValue);\n          } else if (\"sortIndex\" === optionName || \"sortOrder\" === optionName || \"calculateSortValue\" === optionName) {\n            changeType = \"sorting\";\n          } else {\n            changeType = \"columns\";\n          }\n\n          var optionSetter = compileSetter(optionName);\n          optionSetter(column, value, {\n            functionsAsIs: true\n          });\n          var fullOptionName = getColumnFullPath(that, column);\n\n          if (COLUMN_INDEX_OPTIONS[optionName]) {\n            updateIndexes(that, column);\n            value = optionGetter(column);\n          }\n\n          if (\"name\" === optionName || \"allowEditing\" === optionName) {\n            that._checkColumns();\n          }\n\n          fullOptionName && fireOptionChanged(that, {\n            fullOptionName: fullOptionName,\n            optionName: optionName,\n            value: value,\n            prevValue: prevValue\n          });\n\n          if (!isDefined(prevValue) && !isDefined(value) && 0 !== optionName.indexOf(\"buffer\")) {\n            notFireEvent = true;\n          }\n\n          if (!notFireEvent) {\n            if (inArray(optionName, USER_STATE_FIELD_NAMES) < 0 && \"visibleWidth\" !== optionName) {\n              columns = that.option(\"columns\");\n              initialColumn = that.getColumnByPath(fullOptionName, columns);\n\n              if (isString(initialColumn)) {\n                initialColumn = columns[columnIndex] = {\n                  dataField: initialColumn\n                };\n              }\n\n              if (initialColumn && checkUserStateColumn(initialColumn, column)) {\n                optionSetter(initialColumn, value, {\n                  functionsAsIs: true\n                });\n              }\n            }\n\n            updateColumnChanges(that, changeType, optionName, columnIndex);\n          } else {\n            resetColumnsCache(that);\n          }\n        }\n      };\n\n      function isSortOrderValid(sortOrder) {\n        return \"asc\" === sortOrder || \"desc\" === sortOrder;\n      }\n\n      var defaultSetCellValue = function defaultSetCellValue(data, value) {\n        var path = this.dataField.split(\".\");\n        var dotCount = path.length - 1;\n\n        if (this.serializeValue) {\n          value = this.serializeValue(value);\n        }\n\n        for (var i = 0; i < dotCount; i++) {\n          var name = path[i];\n          data = data[name] = data[name] || {};\n        }\n\n        data[path[dotCount]] = value;\n      };\n\n      var isCustomCommandColumn = function isCustomCommandColumn(that, commandColumn) {\n        return !!that._columns.filter(function (column) {\n          return column.type === commandColumn.type;\n        }).length;\n      };\n\n      var getFixedPosition = function getFixedPosition(that, column) {\n        var rtlEnabled = that.option(\"rtlEnabled\");\n\n        if (column.command && !isCustomCommandColumn(that, column) || !column.fixedPosition) {\n          return rtlEnabled ? \"right\" : \"left\";\n        }\n\n        return column.fixedPosition;\n      };\n\n      var processExpandColumns = function processExpandColumns(columns, expandColumns, type, columnIndex) {\n        var customColumnIndex;\n        var rowCount = this.getRowCount();\n        var rowspan = columns[columnIndex] && columns[columnIndex].rowspan;\n        var expandColumnsByType = expandColumns.filter(function (column) {\n          return column.type === type;\n        });\n        columns.forEach(function (column, index) {\n          if (column.type === type) {\n            customColumnIndex = index;\n            rowspan = columns[index + 1] ? columns[index + 1].rowspan : rowCount;\n          }\n        });\n\n        if (rowspan > 1) {\n          expandColumnsByType = map(expandColumnsByType, function (expandColumn) {\n            return extend({}, expandColumn, {\n              rowspan: rowspan\n            });\n          });\n        }\n\n        expandColumnsByType.unshift.apply(expandColumnsByType, isDefined(customColumnIndex) ? [customColumnIndex, 1] : [columnIndex, 0]);\n        columns.splice.apply(columns, expandColumnsByType);\n        return rowspan || 1;\n      };\n\n      var numberToString = function numberToString(number, digitsCount) {\n        var str = number ? number.toString() : \"0\";\n\n        while (str.length < digitsCount) {\n          str = \"0\" + str;\n        }\n\n        return str;\n      };\n\n      var mergeColumns = function mergeColumns(that, columns, commandColumns, needToExtend) {\n        var column;\n        var commandColumnIndex;\n        var result = columns.slice().map(function (column) {\n          return extend({}, column);\n        });\n\n        var isColumnFixing = that._isColumnFixing();\n\n        var defaultCommandColumns = commandColumns.slice().map(function (column) {\n          return extend({\n            fixed: isColumnFixing\n          }, column);\n        });\n\n        var getCommandColumnIndex = function getCommandColumnIndex(column) {\n          return commandColumns.reduce(function (result, commandColumn, index) {\n            var columnType = needToExtend && column.type === GROUP_COMMAND_COLUMN_NAME ? \"expand\" : column.type;\n            return commandColumn.type === columnType || commandColumn.command === column.command ? index : result;\n          }, -1);\n        };\n\n        var callbackFilter = function callbackFilter(commandColumn) {\n          return commandColumn.command !== commandColumns[commandColumnIndex].command;\n        };\n\n        for (var i = 0; i < columns.length; i++) {\n          column = columns[i];\n          commandColumnIndex = column && (column.type || column.command) ? getCommandColumnIndex(column) : -1;\n\n          if (commandColumnIndex >= 0) {\n            if (needToExtend) {\n              result[i] = extend({\n                fixed: isColumnFixing\n              }, commandColumns[commandColumnIndex], column);\n\n              if (column.type !== GROUP_COMMAND_COLUMN_NAME) {\n                defaultCommandColumns = defaultCommandColumns.filter(callbackFilter);\n              }\n            } else {\n              var columnOptions = {\n                visibleIndex: column.visibleIndex,\n                index: column.index,\n                headerId: column.headerId,\n                allowFixing: 0 === column.groupIndex,\n                allowReordering: 0 === column.groupIndex,\n                groupIndex: column.groupIndex\n              };\n              result[i] = extend({}, column, commandColumns[commandColumnIndex], column.type === GROUP_COMMAND_COLUMN_NAME && columnOptions);\n            }\n          }\n        }\n\n        if (columns.length && needToExtend && defaultCommandColumns.length) {\n          result = result.concat(defaultCommandColumns);\n        }\n\n        return result;\n      };\n\n      var isColumnFixed = function isColumnFixed(that, column) {\n        return isDefined(column.fixed) || !column.type ? column.fixed : that._isColumnFixing();\n      };\n\n      var resetBandColumnsCache = function resetBandColumnsCache(that) {\n        that._bandColumnsCache = void 0;\n      };\n\n      var findColumn = function findColumn(columns, identifier) {\n        var identifierOptionName = isString(identifier) && identifier.substr(0, identifier.indexOf(\":\"));\n        var column;\n\n        if (void 0 === identifier) {\n          return;\n        }\n\n        if (identifierOptionName) {\n          identifier = identifier.substr(identifierOptionName.length + 1);\n        }\n\n        if (identifierOptionName) {\n          column = columns.filter(function (column) {\n            return \"\" + column[identifierOptionName] === identifier;\n          })[0];\n        } else {\n          [\"index\", \"name\", \"dataField\", \"caption\"].some(function (optionName) {\n            column = columns.filter(function (column) {\n              return column[optionName] === identifier;\n            })[0];\n            return !!column;\n          });\n        }\n\n        return column;\n      };\n\n      return {\n        _getExpandColumnOptions: function _getExpandColumnOptions() {\n          return {\n            type: \"expand\",\n            command: \"expand\",\n            width: \"auto\",\n            cssClass: COMMAND_EXPAND_CLASS,\n            allowEditing: false,\n            allowGrouping: false,\n            allowSorting: false,\n            allowResizing: false,\n            allowReordering: false,\n            allowHiding: false\n          };\n        },\n        _getFirstItems: function _getFirstItems(dataSource) {\n          var groupsCount;\n          var items = [];\n\n          if (dataSource && dataSource.items().length > 0) {\n            groupsCount = gridCoreUtils.normalizeSortingInfo(dataSource.group()).length;\n\n            items = function getFirstItemsCore(items, groupsCount) {\n              if (!items || !groupsCount) {\n                return items;\n              }\n\n              for (var i = 0; i < items.length; i++) {\n                var childItems = getFirstItemsCore(items[i].items || items[i].collapsedItems, groupsCount - 1);\n\n                if (childItems && childItems.length) {\n                  return childItems;\n                }\n              }\n            }(dataSource.items(), groupsCount) || [];\n          }\n\n          return items;\n        },\n        _endUpdateCore: function _endUpdateCore() {\n          !this._skipProcessingColumnsChange && fireColumnsChanged(this);\n        },\n        init: function init() {\n          var columns = this.option(\"columns\");\n          this._commandColumns = this._commandColumns || [];\n          this._columns = this._columns || [];\n          this._isColumnsFromOptions = !!columns;\n\n          if (this._isColumnsFromOptions) {\n            assignColumns(this, columns ? createColumnsFromOptions(this, columns) : []);\n            applyUserState(this);\n          } else {\n            assignColumns(this, this._columnsUserState ? createColumnsFromOptions(this, this._columnsUserState) : this._columns);\n          }\n\n          !function (that) {\n            var options = that._getExpandColumnOptions();\n\n            that.addCommandColumn(options);\n          }(this);\n\n          if (this._dataSourceApplied) {\n            this.applyDataSource(this._dataSource, true);\n          } else {\n            updateIndexes(this);\n          }\n\n          this._checkColumns();\n        },\n        callbackNames: function callbackNames() {\n          return [\"columnsChanged\"];\n        },\n        getColumnByPath: function getColumnByPath(path, columns) {\n          var column;\n          var columnIndexes = [];\n          path.replace(regExp, function (_, columnIndex) {\n            columnIndexes.push(parseInt(columnIndex));\n            return \"\";\n          });\n\n          if (columnIndexes.length) {\n            if (columns) {\n              column = columnIndexes.reduce(function (column, index) {\n                return column && column.columns && column.columns[index];\n              }, {\n                columns: columns\n              });\n            } else {\n              column = function (that, columnIndexes) {\n                var result;\n                var columns;\n                var bandColumnsCache = that.getBandColumnsCache();\n\n                var callbackFilter = function callbackFilter(column) {\n                  var ownerBand = result ? result.index : void 0;\n                  return column.ownerBand === ownerBand;\n                };\n\n                if (bandColumnsCache.isPlain) {\n                  result = that._columns[columnIndexes[0]];\n                } else {\n                  columns = that._columns.filter(callbackFilter);\n\n                  for (var i = 0; i < columnIndexes.length; i++) {\n                    result = columns[columnIndexes[i]];\n\n                    if (result) {\n                      columns = that._columns.filter(callbackFilter);\n                    }\n                  }\n                }\n\n                return result;\n              }(this, columnIndexes);\n            }\n          }\n\n          return column;\n        },\n        optionChanged: function optionChanged(args) {\n          var needUpdateRequireResize;\n\n          switch (args.name) {\n            case \"adaptColumnWidthByRatio\":\n              args.handled = true;\n              break;\n\n            case \"dataSource\":\n              if (args.value !== args.previousValue && !this.option(\"columns\") && (!Array.isArray(args.value) || !Array.isArray(args.previousValue))) {\n                this._columns = [];\n              }\n\n              break;\n\n            case \"columns\":\n              needUpdateRequireResize = this._skipProcessingColumnsChange;\n              args.handled = true;\n\n              if (!this._skipProcessingColumnsChange) {\n                if (args.name === args.fullName) {\n                  this._columnsUserState = null;\n                  this._ignoreColumnOptionNames = null;\n                  this.init();\n                } else {\n                  this._columnOptionChanged(args);\n\n                  needUpdateRequireResize = true;\n                }\n              }\n\n              if (needUpdateRequireResize) {\n                this._updateRequireResize(args);\n              }\n\n              break;\n\n            case \"commonColumnSettings\":\n            case \"columnAutoWidth\":\n            case \"allowColumnResizing\":\n            case \"allowColumnReordering\":\n            case \"columnFixing\":\n            case \"grouping\":\n            case \"groupPanel\":\n            case \"regenerateColumnsByVisibleItems\":\n            case \"customizeColumns\":\n            case \"columnHidingEnabled\":\n            case \"dateSerializationFormat\":\n            case \"columnResizingMode\":\n            case \"columnMinWidth\":\n            case \"columnWidth\":\n              args.handled = true;\n              var ignoreColumnOptionNames = \"columnWidth\" === args.fullName && [\"width\"];\n              this.reinit(ignoreColumnOptionNames);\n              break;\n\n            case \"rtlEnabled\":\n              this.reinit();\n              break;\n\n            default:\n              this.callBase(args);\n          }\n        },\n        _columnOptionChanged: function _columnOptionChanged(args) {\n          var columnOptionValue = {};\n          var column = this.getColumnByPath(args.fullName);\n          var columnOptionName = args.fullName.replace(regExp, \"\");\n\n          if (column) {\n            if (columnOptionName) {\n              columnOptionValue[columnOptionName] = args.value;\n            } else {\n              columnOptionValue = args.value;\n            }\n\n            this._skipProcessingColumnsChange = args.fullName;\n            this.columnOption(column.index, columnOptionValue);\n            this._skipProcessingColumnsChange = false;\n          }\n        },\n        _updateRequireResize: function _updateRequireResize(args) {\n          var component = this.component;\n\n          if (\"width\" === args.fullName.replace(regExp, \"\") && component._updateLockCount) {\n            component._requireResize = true;\n          }\n        },\n        publicMethods: function publicMethods() {\n          return [\"addColumn\", \"deleteColumn\", \"columnOption\", \"columnCount\", \"clearSorting\", \"clearGrouping\", \"getVisibleColumns\", \"getVisibleColumnIndex\"];\n        },\n        applyDataSource: function applyDataSource(dataSource, forceApplying) {\n          var isDataSourceLoaded = dataSource && dataSource.isLoaded();\n          this._dataSource = dataSource;\n\n          if (!this._dataSourceApplied || 0 === this._dataSourceColumnsCount || forceApplying || this.option(\"regenerateColumnsByVisibleItems\")) {\n            if (isDataSourceLoaded) {\n              if (!this._isColumnsFromOptions) {\n                var columnsFromDataSource = function (that, dataSource) {\n                  var firstItems = that._getFirstItems(dataSource);\n\n                  var fieldName;\n                  var processedFields = {};\n                  var result = [];\n\n                  for (var i = 0; i < firstItems.length; i++) {\n                    if (firstItems[i]) {\n                      for (fieldName in firstItems[i]) {\n                        if (!isFunction(firstItems[i][fieldName]) || variableWrapper.isWrapped(firstItems[i][fieldName])) {\n                          processedFields[fieldName] = true;\n                        }\n                      }\n                    }\n                  }\n\n                  for (fieldName in processedFields) {\n                    if (0 !== fieldName.indexOf(\"__\")) {\n                      var column = createColumn(that, fieldName);\n                      result.push(column);\n                    }\n                  }\n\n                  return result;\n                }(this, dataSource);\n\n                if (columnsFromDataSource.length) {\n                  assignColumns(this, columnsFromDataSource);\n                  this._dataSourceColumnsCount = this._columns.length;\n                  applyUserState(this);\n                }\n              }\n\n              return this.updateColumns(dataSource, forceApplying);\n            } else {\n              this._dataSourceApplied = false;\n            }\n          } else if (isDataSourceLoaded && !this.isAllDataTypesDefined(true) && this.updateColumnDataTypes(dataSource)) {\n            updateColumnChanges(this, \"columns\");\n            fireColumnsChanged(this);\n            return new Deferred().reject().promise();\n          }\n        },\n        reset: function reset() {\n          this._dataSource = null;\n          this._dataSourceApplied = false;\n          this._dataSourceColumnsCount = void 0;\n          this.reinit();\n        },\n        resetColumnsCache: function resetColumnsCache() {\n          this._visibleColumns = void 0;\n          this._fixedColumns = void 0;\n          this._rowCount = void 0;\n          resetBandColumnsCache(this);\n        },\n        reinit: function reinit(ignoreColumnOptionNames) {\n          this._columnsUserState = this.getUserState();\n          this._ignoreColumnOptionNames = ignoreColumnOptionNames || null;\n          this.init();\n\n          if (ignoreColumnOptionNames) {\n            this._ignoreColumnOptionNames = null;\n          }\n        },\n        isInitialized: function isInitialized() {\n          return !!this._columns.length || !!this.option(\"columns\");\n        },\n        isDataSourceApplied: function isDataSourceApplied() {\n          return this._dataSourceApplied;\n        },\n        getCommonSettings: function getCommonSettings(column) {\n          var commonColumnSettings = (!column || !column.type) && this.option(\"commonColumnSettings\") || {};\n          var groupingOptions = this.option(\"grouping\") || {};\n          var groupPanelOptions = this.option(\"groupPanel\") || {};\n          return extend({\n            allowFixing: this.option(\"columnFixing.enabled\"),\n            allowResizing: this.option(\"allowColumnResizing\") || void 0,\n            allowReordering: this.option(\"allowColumnReordering\"),\n            minWidth: this.option(\"columnMinWidth\"),\n            width: this.option(\"columnWidth\"),\n            autoExpandGroup: groupingOptions.autoExpandAll,\n            allowCollapsing: groupingOptions.allowCollapsing,\n            allowGrouping: groupPanelOptions.allowColumnDragging && groupPanelOptions.visible || groupingOptions.contextMenuEnabled\n          }, commonColumnSettings);\n        },\n        isColumnOptionUsed: function isColumnOptionUsed(optionName) {\n          for (var i = 0; i < this._columns.length; i++) {\n            if (this._columns[i][optionName]) {\n              return true;\n            }\n          }\n        },\n        isAllDataTypesDefined: function isAllDataTypesDefined(checkSerializers) {\n          var columns = this._columns;\n\n          if (!columns.length) {\n            return false;\n          }\n\n          for (var i = 0; i < columns.length; i++) {\n            if (!columns[i].dataField && columns[i].calculateCellValue === columns[i].defaultCalculateCellValue) {\n              continue;\n            }\n\n            if (!columns[i].dataType || checkSerializers && columns[i].deserializeValue && void 0 === columns[i].serializationFormat) {\n              return false;\n            }\n          }\n\n          return true;\n        },\n        getColumns: function getColumns() {\n          return this._columns;\n        },\n        isBandColumnsUsed: function isBandColumnsUsed() {\n          return this.getColumns().some(function (column) {\n            return column.isBand;\n          });\n        },\n        getGroupColumns: function getGroupColumns() {\n          var result = [];\n          each(this._columns, function () {\n            if (isDefined(this.groupIndex)) {\n              result[this.groupIndex] = this;\n            }\n          });\n          return result;\n        },\n        getVisibleColumns: function getVisibleColumns(rowIndex) {\n          this._visibleColumns = this._visibleColumns || this._getVisibleColumnsCore();\n          rowIndex = isDefined(rowIndex) ? rowIndex : this._visibleColumns.length - 1;\n          return this._visibleColumns[rowIndex] || [];\n        },\n        getFixedColumns: function getFixedColumns(rowIndex) {\n          this._fixedColumns = this._fixedColumns || this._getFixedColumnsCore();\n          rowIndex = isDefined(rowIndex) ? rowIndex : this._fixedColumns.length - 1;\n          return this._fixedColumns[rowIndex] || [];\n        },\n        getFilteringColumns: function getFilteringColumns() {\n          return this.getColumns().filter(function (item) {\n            return (item.dataField || item.name) && (item.allowFiltering || item.allowHeaderFiltering);\n          }).map(function (item) {\n            var field = extend(true, {}, item);\n\n            if (!isDefined(field.dataField)) {\n              field.dataField = field.name;\n            }\n\n            field.filterOperations = item.filterOperations !== item.defaultFilterOperations ? field.filterOperations : null;\n            return field;\n          });\n        },\n        getColumnIndexOffset: function getColumnIndexOffset() {\n          return 0;\n        },\n        _getFixedColumnsCore: function _getFixedColumnsCore() {\n          var result = [];\n          var rowCount = this.getRowCount();\n\n          var isColumnFixing = this._isColumnFixing();\n\n          var transparentColumn = {\n            command: \"transparent\"\n          };\n          var transparentColspan = 0;\n          var notFixedColumnCount;\n          var transparentColumnIndex;\n          var lastFixedPosition;\n\n          if (isColumnFixing) {\n            for (var i = 0; i <= rowCount; i++) {\n              notFixedColumnCount = 0;\n              lastFixedPosition = null;\n              transparentColumnIndex = null;\n              var visibleColumns = this.getVisibleColumns(i, true);\n\n              for (var j = 0; j < visibleColumns.length; j++) {\n                var prevColumn = visibleColumns[j - 1];\n                var column = visibleColumns[j];\n\n                if (!column.fixed) {\n                  if (0 === i) {\n                    if (column.isBand && column.colspan) {\n                      transparentColspan += column.colspan;\n                    } else {\n                      transparentColspan++;\n                    }\n                  }\n\n                  notFixedColumnCount++;\n\n                  if (!isDefined(transparentColumnIndex)) {\n                    transparentColumnIndex = j;\n                  }\n                } else if (prevColumn && prevColumn.fixed && getFixedPosition(this, prevColumn) !== getFixedPosition(this, column)) {\n                  if (!isDefined(transparentColumnIndex)) {\n                    transparentColumnIndex = j;\n                  }\n                } else {\n                  lastFixedPosition = column.fixedPosition;\n                }\n              }\n\n              if (0 === i && (0 === notFixedColumnCount || notFixedColumnCount >= visibleColumns.length)) {\n                return [];\n              }\n\n              if (!isDefined(transparentColumnIndex)) {\n                transparentColumnIndex = \"right\" === lastFixedPosition ? 0 : visibleColumns.length;\n              }\n\n              result[i] = visibleColumns.slice(0);\n\n              if (!transparentColumn.colspan) {\n                transparentColumn.colspan = transparentColspan;\n              }\n\n              result[i].splice(transparentColumnIndex, notFixedColumnCount, transparentColumn);\n            }\n          }\n\n          return result.map(function (columns) {\n            return columns.map(function (column) {\n              var newColumn = _extends({}, column);\n\n              if (newColumn.headerId) {\n                newColumn.headerId += \"-fixed\";\n              }\n\n              return newColumn;\n            });\n          });\n        },\n        _isColumnFixing: function _isColumnFixing() {\n          var isColumnFixing = this.option(\"columnFixing.enabled\");\n          !isColumnFixing && each(this._columns, function (_, column) {\n            if (column.fixed) {\n              isColumnFixing = true;\n              return false;\n            }\n          });\n          return isColumnFixing;\n        },\n        _getExpandColumnsCore: function _getExpandColumnsCore() {\n          return this.getGroupColumns();\n        },\n        getExpandColumns: function getExpandColumns() {\n          var expandColumns = this._getExpandColumnsCore();\n\n          var expandColumn;\n          var firstGroupColumn = expandColumns.filter(function (column) {\n            return 0 === column.groupIndex;\n          })[0];\n          var isFixedFirstGroupColumn = firstGroupColumn && firstGroupColumn.fixed;\n\n          var isColumnFixing = this._isColumnFixing();\n\n          if (expandColumns.length) {\n            expandColumn = this.columnOption(\"command:expand\");\n          }\n\n          expandColumns = map(expandColumns, function (column) {\n            return extend({}, column, {\n              visibleWidth: null,\n              minWidth: null,\n              cellTemplate: !isDefined(column.groupIndex) ? column.cellTemplate : null,\n              headerCellTemplate: null,\n              fixed: !isDefined(column.groupIndex) || !isFixedFirstGroupColumn ? isColumnFixing : true\n            }, expandColumn, {\n              index: column.index,\n              type: column.type || GROUP_COMMAND_COLUMN_NAME\n            });\n          });\n          return expandColumns;\n        },\n        getBandColumnsCache: function getBandColumnsCache() {\n          if (!this._bandColumnsCache) {\n            var columns = this._columns;\n            var columnChildrenByIndex = {};\n            var columnParentByIndex = {};\n            var isPlain = true;\n            columns.forEach(function (column) {\n              var ownerBand = column.ownerBand;\n              var parentIndex = isObject(ownerBand) ? ownerBand.index : ownerBand;\n              var parent = columns[parentIndex];\n\n              if (column.hasColumns) {\n                isPlain = false;\n              }\n\n              if (column.colspan) {\n                column.colspan = void 0;\n              }\n\n              if (column.rowspan) {\n                column.rowspan = void 0;\n              }\n\n              if (parent) {\n                columnParentByIndex[column.index] = parent;\n              } else {\n                parentIndex = -1;\n              }\n\n              columnChildrenByIndex[parentIndex] = columnChildrenByIndex[parentIndex] || [];\n              columnChildrenByIndex[parentIndex].push(column);\n            });\n            this._bandColumnsCache = {\n              isPlain: isPlain,\n              columnChildrenByIndex: columnChildrenByIndex,\n              columnParentByIndex: columnParentByIndex\n            };\n          }\n\n          return this._bandColumnsCache;\n        },\n        _isColumnVisible: function _isColumnVisible(column) {\n          return column.visible && this.isParentColumnVisible(column.index);\n        },\n        _getVisibleColumnsCore: function _getVisibleColumnsCore() {\n          var that = this;\n          var i;\n          var result = [];\n          var rowspanGroupColumns = 0;\n          var rowspanExpandColumns = 0;\n          var rowCount = that.getRowCount();\n          var positiveIndexedColumns = [];\n          var negativeIndexedColumns = [];\n          var notGroupedColumnsCount = 0;\n          var isFixedToEnd;\n          var rtlEnabled = that.option(\"rtlEnabled\");\n          var bandColumnsCache = that.getBandColumnsCache();\n          var expandColumns = mergeColumns(that, that.getExpandColumns(), that._columns);\n          var columns = mergeColumns(that, that._columns, that._commandColumns, true);\n\n          var columnDigitsCount = function (number) {\n            var i;\n\n            for (i = 0; number > 1; i++) {\n              number /= 10;\n            }\n\n            return i;\n          }(columns.length);\n\n          !function (that, columns, bandColumnsCache) {\n            var rowspan;\n\n            for (var i = 0; i < columns.length; i++) {\n              var column = columns[i];\n\n              if (column.visible || column.command) {\n                if (column.isBand) {\n                  column.colspan = column.colspan || calculateColspan(that, column.index);\n                }\n\n                if (!column.isBand || !column.colspan) {\n                  rowspan = that.getRowCount();\n\n                  if (!column.command && (!isDefined(column.groupIndex) || column.showWhenGrouped)) {\n                    rowspan -= getParentBandColumns(column.index, bandColumnsCache.columnParentByIndex).length;\n                  }\n\n                  if (rowspan > 1) {\n                    column.rowspan = rowspan;\n                  }\n                }\n              }\n            }\n          }(that, columns, bandColumnsCache);\n\n          for (i = 0; i < rowCount; i++) {\n            result[i] = [];\n            negativeIndexedColumns[i] = [{}];\n            positiveIndexedColumns[i] = [{}, {}, {}];\n          }\n\n          each(columns, function () {\n            var visibleIndex = this.visibleIndex;\n            var indexedColumns;\n            var parentBandColumns = getParentBandColumns(this.index, bandColumnsCache.columnParentByIndex);\n\n            var visible = that._isColumnVisible(this);\n\n            if (visible && (!isDefined(this.groupIndex) || this.showWhenGrouped)) {\n              var rowIndex = parentBandColumns.length;\n\n              if (visibleIndex < 0) {\n                visibleIndex = -visibleIndex;\n                indexedColumns = negativeIndexedColumns[rowIndex];\n              } else {\n                this.fixed = parentBandColumns.length ? parentBandColumns[0].fixed : this.fixed;\n                this.fixedPosition = parentBandColumns.length ? parentBandColumns[0].fixedPosition : this.fixedPosition;\n\n                if (this.fixed) {\n                  isFixedToEnd = \"right\" === this.fixedPosition;\n\n                  if (rtlEnabled && (!this.command || isCustomCommandColumn(that, this))) {\n                    isFixedToEnd = !isFixedToEnd;\n                  }\n\n                  if (isFixedToEnd) {\n                    indexedColumns = positiveIndexedColumns[rowIndex][2];\n                  } else {\n                    indexedColumns = positiveIndexedColumns[rowIndex][0];\n                  }\n                } else {\n                  indexedColumns = positiveIndexedColumns[rowIndex][1];\n                }\n              }\n\n              if (parentBandColumns.length) {\n                visibleIndex = numberToString(visibleIndex, columnDigitsCount);\n\n                for (i = parentBandColumns.length - 1; i >= 0; i--) {\n                  visibleIndex = numberToString(parentBandColumns[i].visibleIndex, columnDigitsCount) + visibleIndex;\n                }\n              }\n\n              indexedColumns[visibleIndex] = indexedColumns[visibleIndex] || [];\n              indexedColumns[visibleIndex].push(this);\n              notGroupedColumnsCount++;\n            }\n          });\n          each(result, function (rowIndex) {\n            orderEach(negativeIndexedColumns[rowIndex], function (_, columns) {\n              result[rowIndex].unshift.apply(result[rowIndex], columns);\n            });\n            var firstPositiveIndexColumn = result[rowIndex].length;\n            each(positiveIndexedColumns[rowIndex], function (index, columnsByFixing) {\n              orderEach(columnsByFixing, function (_, columnsByVisibleIndex) {\n                result[rowIndex].push.apply(result[rowIndex], columnsByVisibleIndex);\n              });\n            });\n\n            if (rowspanExpandColumns < rowIndex + 1) {\n              rowspanExpandColumns += processExpandColumns.call(that, result[rowIndex], expandColumns, \"detailExpand\", firstPositiveIndexColumn);\n            }\n\n            if (rowspanGroupColumns < rowIndex + 1) {\n              rowspanGroupColumns += processExpandColumns.call(that, result[rowIndex], expandColumns, GROUP_COMMAND_COLUMN_NAME, firstPositiveIndexColumn);\n            }\n          });\n          result.push(function getDataColumns(columns, rowIndex, bandColumnID) {\n            var result = [];\n            rowIndex = rowIndex || 0;\n            columns[rowIndex] && each(columns[rowIndex], function (_, column) {\n              if (column.ownerBand === bandColumnID || column.type === GROUP_COMMAND_COLUMN_NAME) {\n                if (!column.isBand || !column.colspan) {\n                  if (!column.command || rowIndex < 1) {\n                    result.push(column);\n                  }\n                } else {\n                  result.push.apply(result, getDataColumns(columns, rowIndex + 1, column.index));\n                }\n              }\n            });\n            return result;\n          }(result));\n\n          if (!notGroupedColumnsCount && that._columns.length) {\n            result[rowCount].push({\n              command: \"empty\"\n            });\n          }\n\n          return result;\n        },\n        getInvisibleColumns: function getInvisibleColumns(columns, bandColumnIndex) {\n          var that = this;\n          var result = [];\n          var hiddenColumnsByBand;\n          columns = columns || that._columns;\n          each(columns, function (_, column) {\n            if (column.ownerBand !== bandColumnIndex) {\n              return;\n            }\n\n            if (column.isBand) {\n              if (!column.visible) {\n                hiddenColumnsByBand = that.getChildrenByBandColumn(column.index);\n              } else {\n                hiddenColumnsByBand = that.getInvisibleColumns(that.getChildrenByBandColumn(column.index), column.index);\n              }\n\n              if (hiddenColumnsByBand.length) {\n                result.push(column);\n                result = result.concat(hiddenColumnsByBand);\n              }\n\n              return;\n            }\n\n            if (!column.visible) {\n              result.push(column);\n            }\n          });\n          return result;\n        },\n        getChooserColumns: function getChooserColumns(getAllColumns) {\n          var columns = getAllColumns ? this.getColumns() : this.getInvisibleColumns();\n          var columnChooserColumns = columns.filter(function (column) {\n            return column.showInColumnChooser;\n          });\n          var sortOrder = this.option(\"columnChooser.sortOrder\");\n          return function (columns, sortOrder) {\n            if (\"asc\" !== sortOrder && \"desc\" !== sortOrder) {\n              return columns;\n            }\n\n            var sign = \"asc\" === sortOrder ? 1 : -1;\n            columns.sort(function (column1, column2) {\n              var caption1 = column1.caption || \"\";\n              var caption2 = column2.caption || \"\";\n              return sign * caption1.localeCompare(caption2);\n            });\n            return columns;\n          }(columnChooserColumns, sortOrder);\n        },\n        allowMoveColumn: function allowMoveColumn(fromVisibleIndex, toVisibleIndex, sourceLocation, targetLocation) {\n          var columnIndex = getColumnIndexByVisibleIndex(this, fromVisibleIndex, sourceLocation);\n          var sourceColumn = this._columns[columnIndex];\n\n          if (sourceColumn && (sourceColumn.allowReordering || sourceColumn.allowGrouping || sourceColumn.allowHiding)) {\n            if (sourceLocation === targetLocation) {\n              if (\"columnChooser\" === sourceLocation) {\n                return false;\n              }\n\n              fromVisibleIndex = isObject(fromVisibleIndex) ? fromVisibleIndex.columnIndex : fromVisibleIndex;\n              toVisibleIndex = isObject(toVisibleIndex) ? toVisibleIndex.columnIndex : toVisibleIndex;\n              return fromVisibleIndex !== toVisibleIndex && fromVisibleIndex + 1 !== toVisibleIndex;\n            } else if (\"group\" === sourceLocation && \"columnChooser\" !== targetLocation || \"group\" === targetLocation) {\n              return sourceColumn && sourceColumn.allowGrouping;\n            } else if (\"columnChooser\" === sourceLocation || \"columnChooser\" === targetLocation) {\n              return sourceColumn && sourceColumn.allowHiding;\n            }\n\n            return true;\n          }\n\n          return false;\n        },\n        moveColumn: function moveColumn(fromVisibleIndex, toVisibleIndex, sourceLocation, targetLocation) {\n          var options = {};\n          var prevGroupIndex;\n          var fromIndex = getColumnIndexByVisibleIndex(this, fromVisibleIndex, sourceLocation);\n          var toIndex = getColumnIndexByVisibleIndex(this, toVisibleIndex, targetLocation);\n          var targetGroupIndex;\n\n          if (fromIndex >= 0) {\n            var column = this._columns[fromIndex];\n            toVisibleIndex = isObject(toVisibleIndex) ? toVisibleIndex.columnIndex : toVisibleIndex;\n            targetGroupIndex = toIndex >= 0 ? this._columns[toIndex].groupIndex : -1;\n\n            if (isDefined(column.groupIndex) && \"group\" === sourceLocation) {\n              if (targetGroupIndex > column.groupIndex) {\n                targetGroupIndex--;\n              }\n\n              if (\"group\" !== targetLocation) {\n                options.groupIndex = void 0;\n              } else {\n                prevGroupIndex = column.groupIndex;\n                delete column.groupIndex;\n                updateColumnGroupIndexes(this);\n              }\n            }\n\n            if (\"group\" === targetLocation) {\n              options.groupIndex = function (that, column, groupIndex) {\n                var groupColumns = that.getGroupColumns();\n                var i;\n\n                if (groupIndex >= 0) {\n                  for (i = 0; i < groupColumns.length; i++) {\n                    if (groupColumns[i].groupIndex >= groupIndex) {\n                      groupColumns[i].groupIndex++;\n                    }\n                  }\n                } else {\n                  groupIndex = 0;\n\n                  for (i = 0; i < groupColumns.length; i++) {\n                    groupIndex = Math.max(groupIndex, groupColumns[i].groupIndex + 1);\n                  }\n                }\n\n                return groupIndex;\n              }(this, 0, targetGroupIndex);\n\n              column.groupIndex = prevGroupIndex;\n            } else if (toVisibleIndex >= 0) {\n              var targetColumn = this._columns[toIndex];\n\n              if (!targetColumn || column.ownerBand !== targetColumn.ownerBand) {\n                options.visibleIndex = MAX_SAFE_INTEGER;\n              } else if (isColumnFixed(this, column) ^ isColumnFixed(this, targetColumn)) {\n                options.visibleIndex = MAX_SAFE_INTEGER;\n              } else {\n                options.visibleIndex = targetColumn.visibleIndex;\n              }\n            }\n\n            var isVisible = \"columnChooser\" !== targetLocation;\n\n            if (column.visible !== isVisible) {\n              options.visible = isVisible;\n            }\n\n            this.columnOption(column.index, options);\n          }\n        },\n        changeSortOrder: function changeSortOrder(columnIndex, sortOrder) {\n          var options = {};\n          var sortingOptions = this.option(\"sorting\");\n          var sortingMode = sortingOptions && sortingOptions.mode;\n          var needResetSorting = \"single\" === sortingMode || !sortOrder;\n          var allowSorting = \"single\" === sortingMode || \"multiple\" === sortingMode;\n          var column = this._columns[columnIndex];\n\n          if (allowSorting && column && column.allowSorting) {\n            if (needResetSorting && !isDefined(column.groupIndex)) {\n              each(this._columns, function (index) {\n                if (index !== columnIndex && this.sortOrder) {\n                  if (!isDefined(this.groupIndex)) {\n                    delete this.sortOrder;\n                  }\n\n                  delete this.sortIndex;\n                }\n              });\n            }\n\n            if (isSortOrderValid(sortOrder)) {\n              if (column.sortOrder !== sortOrder) {\n                options.sortOrder = sortOrder;\n              }\n            } else if (\"none\" === sortOrder) {\n              if (column.sortOrder) {\n                options.sortIndex = void 0;\n                options.sortOrder = void 0;\n              }\n            } else {\n              !function (column) {\n                if (\"ctrl\" === sortOrder) {\n                  if (!(\"sortOrder\" in column && \"sortIndex\" in column)) {\n                    return false;\n                  }\n\n                  options.sortOrder = void 0;\n                  options.sortIndex = void 0;\n                } else if (isDefined(column.groupIndex) || isDefined(column.sortIndex)) {\n                  options.sortOrder = \"desc\" === column.sortOrder ? \"asc\" : \"desc\";\n                } else {\n                  options.sortOrder = \"asc\";\n                }\n\n                return true;\n              }(column);\n            }\n          }\n\n          this.columnOption(column.index, options);\n        },\n        getSortDataSourceParameters: function getSortDataSourceParameters(useLocalSelector) {\n          var sortColumns = [];\n          var sort = [];\n          each(this._columns, function () {\n            if ((this.dataField || this.selector || this.calculateCellValue) && isDefined(this.sortIndex) && !isDefined(this.groupIndex)) {\n              sortColumns[this.sortIndex] = this;\n            }\n          });\n          each(sortColumns, function () {\n            var sortOrder = this && this.sortOrder;\n\n            if (isSortOrderValid(sortOrder)) {\n              var sortItem = {\n                selector: this.calculateSortValue || this.displayField || this.calculateDisplayValue || useLocalSelector && this.selector || this.dataField || this.calculateCellValue,\n                desc: \"desc\" === this.sortOrder\n              };\n\n              if (this.sortingMethod) {\n                sortItem.compare = this.sortingMethod.bind(this);\n              }\n\n              sort.push(sortItem);\n            }\n          });\n          return sort.length > 0 ? sort : null;\n        },\n        getGroupDataSourceParameters: function getGroupDataSourceParameters(useLocalSelector) {\n          var group = [];\n          each(this.getGroupColumns(), function () {\n            var selector = this.calculateGroupValue || this.displayField || this.calculateDisplayValue || useLocalSelector && this.selector || this.dataField || this.calculateCellValue;\n\n            if (selector) {\n              var groupItem = {\n                selector: selector,\n                desc: \"desc\" === this.sortOrder,\n                isExpanded: !!this.autoExpandGroup\n              };\n\n              if (this.sortingMethod) {\n                groupItem.compare = this.sortingMethod.bind(this);\n              }\n\n              group.push(groupItem);\n            }\n          });\n          return group.length > 0 ? group : null;\n        },\n        refresh: function refresh(updateNewLookupsOnly) {\n          var deferreds = [];\n          each(this._columns, function () {\n            var lookup = this.lookup;\n\n            if (lookup && !this.calculateDisplayValue) {\n              if (updateNewLookupsOnly && lookup.valueMap) {\n                return;\n              }\n\n              if (lookup.update) {\n                deferreds.push(lookup.update());\n              }\n            }\n          });\n          return when.apply($, deferreds).done(resetColumnsCache.bind(null, this));\n        },\n        _updateColumnOptions: function _updateColumnOptions(column, columnIndex) {\n          column.selector = column.selector || function (data) {\n            return column.calculateCellValue(data);\n          };\n\n          each([\"calculateSortValue\", \"calculateGroupValue\", \"calculateDisplayValue\"], function (_, calculateCallbackName) {\n            var calculateCallback = column[calculateCallbackName];\n\n            if (isFunction(calculateCallback)) {\n              if (!calculateCallback.originalCallback) {\n                var context = {\n                  column: column\n                };\n\n                column[calculateCallbackName] = function (data) {\n                  return calculateCallback.call(context.column, data);\n                };\n\n                column[calculateCallbackName].originalCallback = calculateCallback;\n                column[calculateCallbackName].columnIndex = columnIndex;\n                column[calculateCallbackName].context = context;\n              } else {\n                column[calculateCallbackName].context.column = column;\n              }\n            }\n          });\n\n          if (isString(column.calculateDisplayValue)) {\n            column.displayField = column.calculateDisplayValue;\n            column.calculateDisplayValue = compileGetter(column.displayField);\n          }\n\n          if (column.calculateDisplayValue) {\n            column.displayValueMap = column.displayValueMap || {};\n          }\n\n          updateSerializers(column, column.dataType);\n          var lookup = column.lookup;\n\n          if (lookup) {\n            updateSerializers(lookup, lookup.dataType);\n          }\n\n          var dataType = lookup ? lookup.dataType : column.dataType;\n\n          if (dataType) {\n            column.alignment = column.alignment || function (dataType, isRTL) {\n              switch (dataType) {\n                case \"number\":\n                  return \"right\";\n\n                case \"boolean\":\n                  return \"center\";\n\n                default:\n                  return getDefaultAlignment(isRTL);\n              }\n            }(dataType, this.option(\"rtlEnabled\"));\n\n            column.format = column.format || gridCoreUtils.getFormatByDataType(dataType);\n            column.customizeText = column.customizeText || getCustomizeTextByDataType(dataType);\n            column.defaultFilterOperations = column.defaultFilterOperations || !lookup && DATATYPE_OPERATIONS[dataType] || [];\n\n            if (!isDefined(column.filterOperations)) {\n              setFilterOperationsAsDefaultValues(column);\n            }\n\n            column.defaultFilterOperation = column.filterOperations && column.filterOperations[0] || \"=\";\n            column.showEditorAlways = isDefined(column.showEditorAlways) ? column.showEditorAlways : \"boolean\" === dataType && !column.cellTemplate && !column.lookup;\n          }\n        },\n        updateColumnDataTypes: function updateColumnDataTypes(dataSource) {\n          var that = this;\n          var dateSerializationFormat = that.option(\"dateSerializationFormat\");\n\n          var firstItems = that._getFirstItems(dataSource);\n\n          var isColumnDataTypesUpdated = false;\n          each(that._columns, function (index, column) {\n            var i;\n            var value;\n            var dataType;\n            var lookupDataType;\n            var valueDataType;\n            var lookup = column.lookup;\n\n            if (gridCoreUtils.isDateType(column.dataType) && void 0 === column.serializationFormat) {\n              column.serializationFormat = dateSerializationFormat;\n            }\n\n            if (lookup && gridCoreUtils.isDateType(lookup.dataType) && void 0 === column.serializationFormat) {\n              lookup.serializationFormat = dateSerializationFormat;\n            }\n\n            if (column.calculateCellValue && firstItems.length) {\n              if (!column.dataType || lookup && !lookup.dataType) {\n                for (i = 0; i < firstItems.length; i++) {\n                  value = column.calculateCellValue(firstItems[i]);\n\n                  if (!column.dataType) {\n                    valueDataType = getValueDataType(value);\n                    dataType = dataType || valueDataType;\n\n                    if (dataType && valueDataType && dataType !== valueDataType) {\n                      dataType = \"string\";\n                    }\n                  }\n\n                  if (lookup && !lookup.dataType) {\n                    valueDataType = getValueDataType(gridCoreUtils.getDisplayValue(column, value, firstItems[i]));\n                    lookupDataType = lookupDataType || valueDataType;\n\n                    if (lookupDataType && valueDataType && lookupDataType !== valueDataType) {\n                      lookupDataType = \"string\";\n                    }\n                  }\n                }\n\n                if (dataType || lookupDataType) {\n                  if (dataType) {\n                    column.dataType = dataType;\n                  }\n\n                  if (lookup && lookupDataType) {\n                    lookup.dataType = lookupDataType;\n                  }\n\n                  isColumnDataTypesUpdated = true;\n                }\n              }\n\n              if (void 0 === column.serializationFormat || lookup && void 0 === lookup.serializationFormat) {\n                for (i = 0; i < firstItems.length; i++) {\n                  value = column.calculateCellValue(firstItems[i], true);\n\n                  if (void 0 === column.serializationFormat) {\n                    column.serializationFormat = getSerializationFormat(column.dataType, value);\n                  }\n\n                  if (lookup && void 0 === lookup.serializationFormat) {\n                    lookup.serializationFormat = getSerializationFormat(lookup.dataType, lookup.calculateCellValue(value, true));\n                  }\n                }\n              }\n            }\n\n            that._updateColumnOptions(column, index);\n          });\n          return isColumnDataTypesUpdated;\n        },\n        _customizeColumns: function _customizeColumns(columns) {\n          var customizeColumns = this.option(\"customizeColumns\");\n\n          if (customizeColumns) {\n            var hasOwnerBand = columns.some(function (column) {\n              return isObject(column.ownerBand);\n            });\n\n            if (hasOwnerBand) {\n              updateIndexes(this);\n            }\n\n            customizeColumns(columns);\n            assignColumns(this, createColumnsFromOptions(this, columns));\n          }\n        },\n        updateColumns: function updateColumns(dataSource, forceApplying) {\n          var _this = this;\n\n          if (!forceApplying) {\n            this.updateSortingGrouping(dataSource);\n          }\n\n          if (!dataSource || dataSource.isLoaded()) {\n            var sortParameters = dataSource ? dataSource.sort() || [] : this.getSortDataSourceParameters();\n            var groupParameters = dataSource ? dataSource.group() || [] : this.getGroupDataSourceParameters();\n            var filterParameters = null === dataSource || void 0 === dataSource ? void 0 : dataSource.lastLoadOptions().filter;\n\n            this._customizeColumns(this._columns);\n\n            updateIndexes(this);\n            var columns = this._columns;\n            return when(this.refresh(true)).always(function () {\n              if (_this._columns !== columns) {\n                return;\n              }\n\n              _this._updateChanges(dataSource, {\n                sorting: sortParameters,\n                grouping: groupParameters,\n                filtering: filterParameters\n              });\n\n              fireColumnsChanged(_this);\n            });\n          }\n        },\n        _updateChanges: function _updateChanges(dataSource, parameters) {\n          if (dataSource) {\n            this.updateColumnDataTypes(dataSource);\n            this._dataSourceApplied = true;\n          }\n\n          if (!gridCoreUtils.equalSortParameters(parameters.sorting, this.getSortDataSourceParameters())) {\n            updateColumnChanges(this, \"sorting\");\n          }\n\n          if (!gridCoreUtils.equalSortParameters(parameters.grouping, this.getGroupDataSourceParameters())) {\n            updateColumnChanges(this, \"grouping\");\n          }\n\n          var dataController = this.getController(\"data\");\n\n          if (dataController && !gridCoreUtils.equalFilterParameters(parameters.filtering, dataController.getCombinedFilter())) {\n            updateColumnChanges(this, \"filtering\");\n          }\n\n          updateColumnChanges(this, \"columns\");\n        },\n        updateSortingGrouping: function updateSortingGrouping(dataSource, fromDataSource) {\n          var that = this;\n          var sortParameters;\n          var isColumnsChanged;\n\n          var updateSortGroupParameterIndexes = function updateSortGroupParameterIndexes(columns, sortParameters, indexParameterName) {\n            each(columns, function (index, column) {\n              delete column[indexParameterName];\n\n              if (sortParameters) {\n                for (var i = 0; i < sortParameters.length; i++) {\n                  var selector = sortParameters[i].selector;\n                  var isExpanded = sortParameters[i].isExpanded;\n\n                  if (selector === column.dataField || selector === column.name || selector === column.selector || selector === column.calculateCellValue || selector === column.calculateGroupValue || selector === column.calculateDisplayValue) {\n                    column.sortOrder = column.sortOrder || (sortParameters[i].desc ? \"desc\" : \"asc\");\n\n                    if (void 0 !== isExpanded) {\n                      column.autoExpandGroup = isExpanded;\n                    }\n\n                    column[indexParameterName] = i;\n                    break;\n                  }\n                }\n              }\n            });\n          };\n\n          if (dataSource) {\n            sortParameters = gridCoreUtils.normalizeSortingInfo(dataSource.sort());\n            var groupParameters = gridCoreUtils.normalizeSortingInfo(dataSource.group());\n            var columnsGroupParameters = that.getGroupDataSourceParameters();\n            var columnsSortParameters = that.getSortDataSourceParameters();\n            var groupingChanged = !gridCoreUtils.equalSortParameters(groupParameters, columnsGroupParameters, true);\n            var groupExpandingChanged = !groupingChanged && !gridCoreUtils.equalSortParameters(groupParameters, columnsGroupParameters);\n\n            if (!that._columns.length) {\n              each(groupParameters, function (index, group) {\n                that._columns.push(group.selector);\n              });\n              each(sortParameters, function (index, sort) {\n                that._columns.push(sort.selector);\n              });\n              assignColumns(that, createColumnsFromOptions(that, that._columns));\n            }\n\n            if ((fromDataSource || !columnsGroupParameters && !that._hasUserState) && (groupingChanged || groupExpandingChanged)) {\n              updateSortGroupParameterIndexes(that._columns, groupParameters, \"groupIndex\");\n\n              if (fromDataSource) {\n                groupingChanged && updateColumnChanges(that, \"grouping\");\n                groupExpandingChanged && updateColumnChanges(that, \"groupExpanding\");\n                isColumnsChanged = true;\n              }\n            }\n\n            if ((fromDataSource || !columnsSortParameters && !that._hasUserState) && !gridCoreUtils.equalSortParameters(sortParameters, columnsSortParameters)) {\n              updateSortGroupParameterIndexes(that._columns, sortParameters, \"sortIndex\");\n\n              if (fromDataSource) {\n                updateColumnChanges(that, \"sorting\");\n                isColumnsChanged = true;\n              }\n            }\n\n            if (isColumnsChanged) {\n              fireColumnsChanged(that);\n            }\n          }\n        },\n        updateFilter: function updateFilter(filter, remoteFiltering, columnIndex, filterValue) {\n          if (!Array.isArray(filter)) {\n            return filter;\n          }\n\n          filter = extend([], filter);\n          columnIndex = void 0 !== filter.columnIndex ? filter.columnIndex : columnIndex;\n          filterValue = void 0 !== filter.filterValue ? filter.filterValue : filterValue;\n\n          if (isString(filter[0]) && \"!\" !== filter[0]) {\n            var column = this.columnOption(filter[0]);\n\n            if (remoteFiltering) {\n              if (config().forceIsoDateParsing && column && column.serializeValue && filter.length > 1) {\n                filter[filter.length - 1] = column.serializeValue(filter[filter.length - 1], \"filter\");\n              }\n            } else if (column && column.selector) {\n              filter[0] = column.selector;\n              filter[0].columnIndex = column.index;\n            }\n          } else if (isFunction(filter[0])) {\n            filter[0].columnIndex = columnIndex;\n            filter[0].filterValue = filterValue;\n          }\n\n          for (var i = 0; i < filter.length; i++) {\n            filter[i] = this.updateFilter(filter[i], remoteFiltering, columnIndex, filterValue);\n          }\n\n          return filter;\n        },\n        columnCount: function columnCount() {\n          return this._columns ? this._columns.length : 0;\n        },\n        columnOption: function columnOption(identifier, option, value, notFireEvent) {\n          var that = this;\n\n          var columns = that._columns.concat(that._commandColumns);\n\n          var column = findColumn(columns, identifier);\n\n          if (column) {\n            if (1 === arguments.length) {\n              return extend({}, column);\n            }\n\n            if (isString(option)) {\n              if (2 === arguments.length) {\n                return columnOptionCore(that, column, option);\n              } else {\n                columnOptionCore(that, column, option, value, notFireEvent);\n              }\n            } else if (isObject(option)) {\n              each(option, function (optionName, value) {\n                columnOptionCore(that, column, optionName, value, notFireEvent);\n              });\n            }\n\n            fireColumnsChanged(that);\n          }\n        },\n        clearSorting: function clearSorting() {\n          var columnCount = this.columnCount();\n          this.beginUpdate();\n\n          for (var i = 0; i < columnCount; i++) {\n            this.columnOption(i, \"sortOrder\", void 0);\n          }\n\n          this.endUpdate();\n        },\n        clearGrouping: function clearGrouping() {\n          var columnCount = this.columnCount();\n          this.beginUpdate();\n\n          for (var i = 0; i < columnCount; i++) {\n            this.columnOption(i, \"groupIndex\", void 0);\n          }\n\n          this.endUpdate();\n        },\n        getVisibleIndex: function getVisibleIndex(index, rowIndex) {\n          var columns = this.getVisibleColumns(rowIndex);\n\n          for (var i = columns.length - 1; i >= 0; i--) {\n            if (columns[i].index === index) {\n              return i;\n            }\n          }\n\n          return -1;\n        },\n        getVisibleIndexByColumn: function getVisibleIndexByColumn(column, rowIndex) {\n          var visibleColumns = this.getVisibleColumns(rowIndex);\n          var visibleColumn = visibleColumns.filter(function (col) {\n            return col.index === column.index && col.command === column.command;\n          })[0];\n          return visibleColumns.indexOf(visibleColumn);\n        },\n        getVisibleColumnIndex: function getVisibleColumnIndex(id, rowIndex) {\n          var index = this.columnOption(id, \"index\");\n          return this.getVisibleIndex(index, rowIndex);\n        },\n        addColumn: function addColumn(options) {\n          var column = createColumn(this, options);\n          var index = this._columns.length;\n\n          this._columns.push(column);\n\n          if (column.isBand) {\n            this._columns = createColumnsFromOptions(this, this._columns);\n            column = this._columns[index];\n          }\n\n          column.added = options;\n          updateIndexes(this, column);\n          this.updateColumns(this._dataSource);\n\n          this._checkColumns();\n        },\n        deleteColumn: function deleteColumn(id) {\n          var column = this.columnOption(id);\n\n          if (column && column.index >= 0) {\n            columns = this._columns, void columns.forEach(function (column) {\n              if (isDefined(column.ownerBand)) {\n                column.ownerBand = columns[column.ownerBand];\n              }\n            });\n\n            this._columns.splice(column.index, 1);\n\n            if (column.isBand) {\n              var childIndexes = this.getChildrenByBandColumn(column.index).map(function (column) {\n                return column.index;\n              });\n              this._columns = this._columns.filter(function (column) {\n                return childIndexes.indexOf(column.index) < 0;\n              });\n            }\n\n            updateIndexes(this);\n            this.updateColumns(this._dataSource);\n          }\n\n          var columns;\n        },\n        addCommandColumn: function addCommandColumn(options) {\n          var commandColumn = this._commandColumns.filter(function (column) {\n            return column.command === options.command;\n          })[0];\n\n          if (!commandColumn) {\n            commandColumn = options;\n\n            this._commandColumns.push(commandColumn);\n          }\n        },\n        getUserState: function getUserState() {\n          var columns = this._columns;\n          var result = [];\n          var i;\n\n          function handleStateField(index, value) {\n            if (void 0 !== columns[i][value]) {\n              result[i][value] = columns[i][value];\n            }\n          }\n\n          for (i = 0; i < columns.length; i++) {\n            result[i] = {};\n            each(USER_STATE_FIELD_NAMES, handleStateField);\n          }\n\n          return result;\n        },\n        setName: function setName(column) {\n          column.name = column.name || column.dataField || column.type;\n        },\n        setUserState: function setUserState(state) {\n          var dataSource = this._dataSource;\n          var ignoreColumnOptionNames = this.option(\"stateStoring.ignoreColumnOptionNames\");\n          null === state || void 0 === state ? void 0 : state.forEach(this.setName);\n\n          if (!ignoreColumnOptionNames) {\n            ignoreColumnOptionNames = [];\n            var commonColumnSettings = this.getCommonSettings();\n\n            if (!this.option(\"columnChooser.enabled\")) {\n              ignoreColumnOptionNames.push(\"visible\");\n            }\n\n            if (\"none\" === this.option(\"sorting.mode\")) {\n              ignoreColumnOptionNames.push(\"sortIndex\", \"sortOrder\");\n            }\n\n            if (!commonColumnSettings.allowGrouping) {\n              ignoreColumnOptionNames.push(\"groupIndex\");\n            }\n\n            if (!commonColumnSettings.allowFixing) {\n              ignoreColumnOptionNames.push(\"fixed\", \"fixedPosition\");\n            }\n\n            if (!commonColumnSettings.allowResizing) {\n              ignoreColumnOptionNames.push(\"width\", \"visibleWidth\");\n            }\n\n            var isFilterPanelHidden = !this.option(\"filterPanel.visible\");\n\n            if (!this.option(\"filterRow.visible\") && isFilterPanelHidden) {\n              ignoreColumnOptionNames.push(\"filterValue\", \"selectedFilterOperation\");\n            }\n\n            if (!this.option(\"headerFilter.visible\") && isFilterPanelHidden) {\n              ignoreColumnOptionNames.push(\"filterValues\", \"filterType\");\n            }\n          }\n\n          this._columnsUserState = state;\n          this._ignoreColumnOptionNames = ignoreColumnOptionNames;\n          this._hasUserState = !!state;\n          updateColumnChanges(this, \"filtering\");\n          this.init();\n\n          if (dataSource) {\n            dataSource.sort(this.getSortDataSourceParameters());\n            dataSource.group(this.getGroupDataSourceParameters());\n          }\n        },\n        _checkColumns: function _checkColumns() {\n          var usedNames = {};\n          var hasEditableColumnWithoutName = false;\n          var duplicatedNames = [];\n\n          this._columns.forEach(function (column) {\n            var _column$columns;\n\n            var name = column.name;\n            var isBand = null === (_column$columns = column.columns) || void 0 === _column$columns ? void 0 : _column$columns.length;\n            var isEditable = column.allowEditing && (column.dataField || column.setCellValue) && !isBand;\n\n            if (name) {\n              if (usedNames[name]) {\n                duplicatedNames.push('\"'.concat(name, '\"'));\n              }\n\n              usedNames[name] = true;\n            } else if (isEditable) {\n              hasEditableColumnWithoutName = true;\n            }\n          });\n\n          if (duplicatedNames.length) {\n            errors.log(\"E1059\", duplicatedNames.join(\", \"));\n          }\n\n          if (hasEditableColumnWithoutName) {\n            errors.log(\"E1060\");\n          }\n        },\n        _createCalculatedColumnOptions: function _createCalculatedColumnOptions(columnOptions, bandColumn) {\n          var calculatedColumnOptions = {};\n          var dataField = columnOptions.dataField;\n\n          if (Array.isArray(columnOptions.columns) && columnOptions.columns.length || columnOptions.isBand) {\n            calculatedColumnOptions.isBand = true;\n            dataField = null;\n          }\n\n          if (dataField) {\n            if (isString(dataField)) {\n              var getter = compileGetter(dataField);\n              calculatedColumnOptions = {\n                caption: captionize(dataField),\n                calculateCellValue: function calculateCellValue(data, skipDeserialization) {\n                  var value = getter(data);\n                  return this.deserializeValue && !skipDeserialization ? this.deserializeValue(value) : value;\n                },\n                setCellValue: defaultSetCellValue,\n                parseValue: function parseValue(text) {\n                  var result;\n                  var parsedValue;\n\n                  if (\"number\" === this.dataType) {\n                    if (isString(text) && this.format) {\n                      result = function (text, format) {\n                        var parsedValue = numberLocalization.parse(text, format);\n\n                        if (isNumeric(parsedValue)) {\n                          var formattedValue = numberLocalization.format(parsedValue, format);\n                          var formattedValueWithDefaultFormat = numberLocalization.format(parsedValue, \"decimal\");\n\n                          if (formattedValue === text || formattedValueWithDefaultFormat === text) {\n                            return parsedValue;\n                          }\n                        }\n                      }(text.trim(), this.format);\n                    } else if (isDefined(text) && isNumeric(text)) {\n                      result = Number(text);\n                    }\n                  } else if (\"boolean\" === this.dataType) {\n                    if (text === this.trueText) {\n                      result = true;\n                    } else if (text === this.falseText) {\n                      result = false;\n                    }\n                  } else if (gridCoreUtils.isDateType(this.dataType)) {\n                    parsedValue = dateLocalization.parse(text, this.format);\n\n                    if (parsedValue) {\n                      result = parsedValue;\n                    }\n                  } else {\n                    result = text;\n                  }\n\n                  return result;\n                }\n              };\n            }\n\n            calculatedColumnOptions.allowFiltering = true;\n          } else {\n            calculatedColumnOptions.allowFiltering = !!columnOptions.calculateFilterExpression;\n          }\n\n          calculatedColumnOptions.calculateFilterExpression = function () {\n            return filterUtils.defaultCalculateFilterExpression.apply(this, arguments);\n          };\n\n          calculatedColumnOptions.createFilterExpression = function (filterValue) {\n            var result;\n\n            if (this.calculateFilterExpression) {\n              result = this.calculateFilterExpression.apply(this, arguments);\n            }\n\n            if (isFunction(result)) {\n              result = [result, \"=\", true];\n            }\n\n            if (result) {\n              result.columnIndex = this.index;\n              result.filterValue = filterValue;\n            }\n\n            return result;\n          };\n\n          if (!dataField || !isString(dataField)) {\n            extend(true, calculatedColumnOptions, {\n              allowSorting: false,\n              allowGrouping: false,\n              calculateCellValue: function calculateCellValue() {\n                return null;\n              }\n            });\n          }\n\n          if (bandColumn) {\n            calculatedColumnOptions.allowFixing = false;\n          }\n\n          if (columnOptions.dataType) {\n            calculatedColumnOptions.userDataType = columnOptions.dataType;\n          }\n\n          if (columnOptions.selectedFilterOperation && !(\"defaultSelectedFilterOperation\" in calculatedColumnOptions)) {\n            calculatedColumnOptions.defaultSelectedFilterOperation = columnOptions.selectedFilterOperation;\n          }\n\n          if (columnOptions.lookup) {\n            calculatedColumnOptions.lookup = {\n              calculateCellValue: function calculateCellValue(value, skipDeserialization) {\n                if (this.valueExpr) {\n                  value = this.valueMap && this.valueMap[value];\n                }\n\n                return this.deserializeValue && !skipDeserialization ? this.deserializeValue(value) : value;\n              },\n              updateValueMap: function updateValueMap() {\n                this.valueMap = {};\n\n                if (this.items) {\n                  var calculateValue = compileGetter(this.valueExpr);\n                  var calculateDisplayValue = compileGetter(this.displayExpr);\n\n                  for (var i = 0; i < this.items.length; i++) {\n                    var item = this.items[i];\n                    var displayValue = calculateDisplayValue(item);\n                    this.valueMap[calculateValue(item)] = displayValue;\n                    this.dataType = this.dataType || getValueDataType(displayValue);\n                  }\n                }\n              },\n              update: function update() {\n                var that = this;\n                var dataSource = that.dataSource;\n\n                if (dataSource) {\n                  if (isFunction(dataSource) && !variableWrapper.isWrapped(dataSource)) {\n                    dataSource = dataSource({});\n                  }\n\n                  if (isPlainObject(dataSource) || dataSource instanceof Store || Array.isArray(dataSource)) {\n                    if (that.valueExpr) {\n                      var dataSourceOptions = normalizeDataSourceOptions(dataSource);\n                      dataSourceOptions.paginate = false;\n                      dataSource = new DataSource(dataSourceOptions);\n                      return dataSource.load().done(function (data) {\n                        that.items = data;\n                        that.updateValueMap && that.updateValueMap();\n                      });\n                    }\n                  } else {\n                    errors.log(\"E1016\");\n                  }\n                } else {\n                  that.updateValueMap && that.updateValueMap();\n                }\n              }\n            };\n          }\n\n          calculatedColumnOptions.resizedCallbacks = Callbacks();\n\n          if (columnOptions.resized) {\n            calculatedColumnOptions.resizedCallbacks.add(columnOptions.resized.bind(columnOptions));\n          }\n\n          each(calculatedColumnOptions, function (optionName) {\n            if (isFunction(calculatedColumnOptions[optionName]) && 0 !== optionName.indexOf(\"default\")) {\n              var defaultOptionName = \"default\" + optionName.charAt(0).toUpperCase() + optionName.substr(1);\n              calculatedColumnOptions[defaultOptionName] = calculatedColumnOptions[optionName];\n            }\n          });\n          return calculatedColumnOptions;\n        },\n        getRowCount: function getRowCount() {\n          this._rowCount = this._rowCount || function (that) {\n            var rowCount = 1;\n            var bandColumnsCache = that.getBandColumnsCache();\n            var columnParentByIndex = bandColumnsCache.columnParentByIndex;\n\n            that._columns.forEach(function (column) {\n              var parents = getParentBandColumns(column.index, columnParentByIndex);\n              var invisibleParents = parents.filter(function (column) {\n                return !column.visible;\n              });\n\n              if (column.visible && !invisibleParents.length) {\n                rowCount = Math.max(rowCount, parents.length + 1);\n              }\n            });\n\n            return rowCount;\n          }(this);\n\n          return this._rowCount;\n        },\n        getRowIndex: function getRowIndex(columnIndex, alwaysGetRowIndex) {\n          var column = this._columns[columnIndex];\n          var bandColumnsCache = this.getBandColumnsCache();\n          return column && (alwaysGetRowIndex || column.visible && !(column.command || isDefined(column.groupIndex))) ? getParentBandColumns(columnIndex, bandColumnsCache.columnParentByIndex).length : 0;\n        },\n        getChildrenByBandColumn: function getChildrenByBandColumn(bandColumnIndex, onlyVisibleDirectChildren) {\n          var bandColumnsCache = this.getBandColumnsCache();\n\n          var result = _getChildrenByBandColumn(bandColumnIndex, bandColumnsCache.columnChildrenByIndex, !onlyVisibleDirectChildren);\n\n          if (onlyVisibleDirectChildren) {\n            return result.filter(function (column) {\n              return column.visible && !column.command;\n            }).sort(function (column1, column2) {\n              return column1.visibleIndex - column2.visibleIndex;\n            });\n          }\n\n          return result;\n        },\n        isParentBandColumn: function isParentBandColumn(columnIndex, bandColumnIndex) {\n          var result = false;\n          var column = this._columns[columnIndex];\n          var bandColumnsCache = this.getBandColumnsCache();\n          var parentBandColumns = column && getParentBandColumns(columnIndex, bandColumnsCache.columnParentByIndex);\n\n          if (parentBandColumns) {\n            each(parentBandColumns, function (_, bandColumn) {\n              if (bandColumn.index === bandColumnIndex) {\n                result = true;\n                return false;\n              }\n            });\n          }\n\n          return result;\n        },\n        isParentColumnVisible: function isParentColumnVisible(columnIndex) {\n          var result = true;\n          var bandColumnsCache = this.getBandColumnsCache();\n          var bandColumns = columnIndex >= 0 && getParentBandColumns(columnIndex, bandColumnsCache.columnParentByIndex);\n          bandColumns && each(bandColumns, function (_, bandColumn) {\n            result = result && bandColumn.visible;\n            return result;\n          });\n          return result;\n        },\n        getColumnId: function getColumnId(column) {\n          if (column.command && column.type === GROUP_COMMAND_COLUMN_NAME) {\n            if (isCustomCommandColumn(this, column)) {\n              return \"type:\" + column.type;\n            }\n\n            return \"command:\" + column.command;\n          }\n\n          return column.index;\n        },\n        getCustomizeTextByDataType: getCustomizeTextByDataType,\n        getHeaderContentAlignment: function getHeaderContentAlignment(columnAlignment) {\n          var rtlEnabled = this.option(\"rtlEnabled\");\n\n          if (rtlEnabled) {\n            return \"left\" === columnAlignment ? \"right\" : \"left\";\n          }\n\n          return columnAlignment;\n        }\n      };\n    }())\n  }\n};","map":null,"metadata":{},"sourceType":"module"}