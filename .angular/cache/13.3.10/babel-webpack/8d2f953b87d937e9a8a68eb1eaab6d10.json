{"ast":null,"code":"import _toConsumableArray from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\n\n/**\r\n * DevExtreme (esm/ui/pivot_grid/remote_store.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { isString, isDefined } from \"../../core/utils/type\";\nimport Class from \"../../core/class\";\nimport { extend } from \"../../core/utils/extend\";\nimport { each } from \"../../core/utils/iterator\";\nimport { DataSource } from \"../../data/data_source/data_source\";\nimport { when, Deferred } from \"../../core/utils/deferred\";\nimport { getFiltersByPath, capitalizeFirstLetter, getExpandedLevel, discoverObjectFields, setDefaultFieldValueFormatting } from \"./ui.pivot_grid.utils\";\nimport { forEachGroup } from \"./remote_store.utils\";\nimport dateSerialization from \"../../core/utils/date_serialization\";\nimport { normalizeLoadResult } from \"../../data/data_source/utils\";\n\nfunction createGroupingOptions(dimensionOptions, useSortOrder) {\n  var groupingOptions = [];\n  each(dimensionOptions, function (index, dimensionOption) {\n    groupingOptions.push({\n      selector: dimensionOption.dataField,\n      groupInterval: dimensionOption.groupInterval,\n      desc: useSortOrder && \"desc\" === dimensionOption.sortOrder,\n      isExpanded: index < dimensionOptions.length - 1\n    });\n  });\n  return groupingOptions;\n}\n\nfunction getFieldFilterSelector(field) {\n  var selector = field.dataField;\n  var groupInterval = field.groupInterval;\n\n  if (\"date\" === field.dataType && \"string\" === typeof groupInterval) {\n    if (\"quarter\" === groupInterval.toLowerCase()) {\n      groupInterval = \"Month\";\n    }\n\n    selector = selector + \".\" + capitalizeFirstLetter(groupInterval);\n  }\n\n  return selector;\n}\n\nfunction getIntervalFilterExpression(selector, numericInterval, numericValue, isExcludedFilterType) {\n  var startFilterValue = [selector, isExcludedFilterType ? \"<\" : \">=\", numericValue];\n  var endFilterValue = [selector, isExcludedFilterType ? \">=\" : \"<\", numericValue + numericInterval];\n  return [startFilterValue, isExcludedFilterType ? \"or\" : \"and\", endFilterValue];\n}\n\nfunction getFilterExpressionForFilterValue(field, filterValue) {\n  var selector = getFieldFilterSelector(field);\n  var isExcludedFilterType = \"exclude\" === field.filterType;\n  var expression = [selector, isExcludedFilterType ? \"<>\" : \"=\", filterValue];\n\n  if (isDefined(field.groupInterval)) {\n    if (\"string\" === typeof field.groupInterval && \"quarter\" === field.groupInterval.toLowerCase()) {\n      expression = getIntervalFilterExpression(selector, 3, 3 * (filterValue - 1) + 1, isExcludedFilterType);\n    } else if (\"number\" === typeof field.groupInterval && \"date\" !== field.dataType) {\n      expression = getIntervalFilterExpression(selector, field.groupInterval, filterValue, isExcludedFilterType);\n    }\n  }\n\n  return expression;\n}\n\nfunction createFieldFilterExpressions(field, operation) {\n  var fieldFilterExpressions = [];\n\n  if (field.searchValue) {\n    return [field.dataField, \"contains\", field.searchValue];\n  }\n\n  if (\"exclude\" === field.filterType) {\n    operation = operation || \"and\";\n  } else {\n    operation = operation || \"or\";\n  }\n\n  each(field.filterValues, function (index, filterValue) {\n    var currentExpression = [];\n\n    if (Array.isArray(filterValue)) {\n      var parseLevelsRecursive = field.levels && field.levels.length;\n\n      if (parseLevelsRecursive) {\n        currentExpression = createFieldFilterExpressions({\n          filterValues: filterValue,\n          filterType: field.filterType,\n          levels: field.levels\n        }, \"and\");\n      }\n    } else {\n      var currentField = field.levels ? field.levels[index] : field;\n      currentExpression = getFilterExpressionForFilterValue(currentField, filterValue);\n    }\n\n    if (!currentExpression.length) {\n      return;\n    }\n\n    if (fieldFilterExpressions.length) {\n      fieldFilterExpressions.push(operation);\n    }\n\n    fieldFilterExpressions.push(currentExpression);\n  });\n  return fieldFilterExpressions;\n}\n\nfunction createFilterExpressions(fields) {\n  var filterExpressions = [];\n  each(fields, function (_, field) {\n    var fieldExpressions = createFieldFilterExpressions(field);\n\n    if (!fieldExpressions.length) {\n      return [];\n    }\n\n    if (filterExpressions.length) {\n      filterExpressions.push(\"and\");\n    }\n\n    filterExpressions.push(fieldExpressions);\n  });\n\n  if (1 === filterExpressions.length) {\n    filterExpressions = filterExpressions[0];\n  }\n\n  return filterExpressions;\n}\n\nfunction mergeFilters(filter1, filter2) {\n  var mergedFilter;\n\n  var notEmpty = function notEmpty(filter) {\n    return filter && filter.length;\n  };\n\n  if (notEmpty(filter1) && notEmpty(filter2)) {\n    mergedFilter = [filter1, \"and\", filter2];\n  } else {\n    mergedFilter = notEmpty(filter1) ? filter1 : filter2;\n  }\n\n  return mergedFilter;\n}\n\nfunction createLoadOptions(options, externalFilterExpr, hasRows) {\n  var filterExpressions = createFilterExpressions(options.filters);\n  var groupingOptions = createGroupingOptions(options.rows, options.rowTake).concat(createGroupingOptions(options.columns, options.columnTake));\n  var loadOptions = {\n    groupSummary: [],\n    totalSummary: [],\n    group: groupingOptions.length ? groupingOptions : void 0,\n    take: groupingOptions.length ? void 0 : 1\n  };\n\n  if (options.rows.length && options.rowTake) {\n    loadOptions.skip = options.rowSkip;\n    loadOptions.take = options.rowTake;\n    loadOptions.requireGroupCount = true;\n  } else if (options.columns.length && options.columnTake && !hasRows) {\n    loadOptions.skip = options.columnSkip;\n    loadOptions.take = options.columnTake;\n    loadOptions.requireGroupCount = true;\n  }\n\n  if (externalFilterExpr) {\n    filterExpressions = mergeFilters(filterExpressions, externalFilterExpr);\n  }\n\n  if (filterExpressions.length) {\n    loadOptions.filter = filterExpressions;\n  }\n\n  each(options.values, function (_, value) {\n    var summaryOption = {\n      selector: value.dataField,\n      summaryType: value.summaryType || \"count\"\n    };\n    loadOptions.groupSummary.push(summaryOption);\n    options.includeTotalSummary && loadOptions.totalSummary.push(summaryOption);\n  });\n  return loadOptions;\n}\n\nfunction setValue(valuesArray, value, rowIndex, columnIndex, dataIndex) {\n  valuesArray[rowIndex] = valuesArray[rowIndex] || [];\n  valuesArray[rowIndex][columnIndex] = valuesArray[rowIndex][columnIndex] || [];\n\n  if (!isDefined(valuesArray[rowIndex][columnIndex][dataIndex])) {\n    valuesArray[rowIndex][columnIndex][dataIndex] = value;\n  }\n}\n\nfunction parseValue(value, field) {\n  if (field && \"number\" === field.dataType && isString(value)) {\n    return Number(value);\n  }\n\n  if (field && \"date\" === field.dataType && !field.groupInterval && !(value instanceof Date)) {\n    return dateSerialization.deserializeDate(value);\n  }\n\n  return value;\n}\n\nfunction parseResult(data, total, descriptions, result) {\n  var rowPath = [];\n  var columnPath = [];\n  var rowHash = result.rowHash;\n  var columnHash = result.columnHash;\n\n  if (total && total.summary) {\n    each(total.summary, function (index, summary) {\n      setValue(result.values, summary, result.grandTotalRowIndex, result.grandTotalColumnIndex, index);\n    });\n  }\n\n  if (total && total.groupCount >= 0) {\n    var skip = descriptions.rows.length ? descriptions.rowSkip : descriptions.columnSkip;\n    data = _toConsumableArray(Array(skip)).concat(data);\n    data.length = total.groupCount;\n  }\n\n  function getItem(dataItem, dimensionName, path, level, field) {\n    var dimensionHash = result[dimensionName + \"Hash\"];\n    var parentItem;\n    var parentItemChildren;\n    var item;\n    var pathValue = path.slice(0, level + 1).join(\"/\");\n    var parentPathValue;\n\n    if (void 0 !== dimensionHash[pathValue]) {\n      item = dimensionHash[pathValue];\n    } else {\n      item = {\n        value: parseValue(dataItem.key, field),\n        index: result[dimensionName + \"Index\"]++,\n        displayText: dataItem.displayText\n      };\n      parentPathValue = path.slice(0, level).join(\"/\");\n\n      if (level > 0 && void 0 !== dimensionHash[parentPathValue]) {\n        parentItem = dimensionHash[parentPathValue];\n        parentItemChildren = parentItem.children = parentItem.children || [];\n      } else {\n        parentItemChildren = result[dimensionName + \"s\"];\n      }\n\n      parentItemChildren.push(item);\n      dimensionHash[pathValue] = item;\n    }\n\n    return item;\n  }\n\n  forEachGroup(data, function (item, level) {\n    var rowLevel = level >= descriptions.rows.length ? descriptions.rows.length : level;\n    var columnLevel = level >= descriptions.rows.length ? level - descriptions.rows.length : 0;\n    var columnItem;\n    var rowItem;\n\n    if (level >= descriptions.rows.length && columnLevel >= descriptions.columns.length) {\n      return;\n    }\n\n    if (level < descriptions.rows.length) {\n      columnPath = [];\n    }\n\n    if (level >= descriptions.rows.length) {\n      if (item) {\n        columnPath[columnLevel] = item.key + \"\";\n        columnItem = getItem(item, \"column\", columnPath, columnLevel, descriptions.columns[columnLevel]);\n        rowItem = rowHash[rowPath.slice(0, rowLevel + 1).join(\"/\")];\n      } else {\n        result.columns.push({});\n      }\n    } else if (item) {\n      rowPath[rowLevel] = item.key + \"\";\n      rowItem = getItem(item, \"row\", rowPath, rowLevel, descriptions.rows[rowLevel]);\n      columnItem = columnHash[columnPath.slice(0, columnLevel + 1).join(\"/\")];\n    } else {\n      result.rows.push({});\n    }\n\n    var currentRowIndex = rowItem && rowItem.index || result.grandTotalRowIndex;\n    var currentColumnIndex = columnItem && columnItem.index || result.grandTotalColumnIndex;\n    each(item && item.summary || [], function (i, summary) {\n      setValue(result.values, summary, currentRowIndex, currentColumnIndex, i);\n    });\n  });\n  return result;\n}\n\nfunction getFiltersForDimension(fields) {\n  return (fields || []).filter(function (f) {\n    return f.filterValues && f.filterValues.length || f.searchValue;\n  });\n}\n\nfunction getExpandedIndex(options, axis) {\n  if (options.headerName) {\n    if (axis === options.headerName) {\n      return options.path.length;\n    } else if (options.oppositePath) {\n      return options.oppositePath.length;\n    }\n  }\n\n  return 0;\n}\n\nfunction getFiltersForExpandedDimension(options) {\n  return getFiltersByPath(options[options.headerName], options.path).concat(getFiltersByPath(options[\"rows\" === options.headerName ? \"columns\" : \"rows\"], options.oppositePath || []));\n}\n\nfunction getExpandedPathSliceFilter(options, dimensionName, level, firstCollapsedFieldIndex) {\n  var result = [];\n  var startSliceIndex = level > firstCollapsedFieldIndex ? 0 : firstCollapsedFieldIndex;\n  var fields = options.headerName !== dimensionName ? options[dimensionName].slice(startSliceIndex, level) : [];\n  var paths = \"rows\" === dimensionName ? options.rowExpandedPaths : options.columnExpandedPaths;\n  each(fields, function (index, field) {\n    var filterValues = [];\n    each(paths, function (_, path) {\n      path = path.slice(startSliceIndex, level);\n\n      if (index < path.length) {\n        var filterValue = path[index];\n\n        if (-1 === filterValues.indexOf(filterValue)) {\n          filterValues.push(filterValue);\n        }\n      }\n    });\n\n    if (filterValues.length) {\n      result.push(extend({}, field, {\n        filterType: \"include\",\n        filterValues: filterValues\n      }));\n    }\n  });\n  return result;\n}\n\nfunction getGrandTotalRequest(options, dimensionName, expandedIndex, expandedLevel, commonFilters, firstCollapsedFieldIndex) {\n  var expandedPaths = (\"columns\" === dimensionName ? options.columnExpandedPaths : options.rowExpandedPaths) || [];\n  var oppositeDimensionName = \"columns\" === dimensionName ? \"rows\" : \"columns\";\n  var fields = options[dimensionName];\n  var result = [];\n  var newOptions;\n\n  if (expandedPaths.length) {\n    for (var i = expandedIndex; i < expandedLevel + 1; i++) {\n      newOptions = {\n        filters: commonFilters.concat(getExpandedPathSliceFilter(options, dimensionName, i, firstCollapsedFieldIndex))\n      };\n      newOptions[dimensionName] = fields.slice(expandedIndex, i + 1);\n      newOptions[oppositeDimensionName] = [];\n      result.push(extend({}, options, newOptions));\n    }\n  } else {\n    newOptions = {\n      filters: commonFilters\n    };\n    newOptions[dimensionName] = fields.slice(expandedIndex, expandedLevel + 1);\n    newOptions[oppositeDimensionName] = [];\n    result.push(extend({}, options, newOptions));\n  }\n\n  result[0].includeTotalSummary = true;\n  return result;\n}\n\nfunction getFirstCollapsedIndex(fields) {\n  var firstCollapsedIndex = 0;\n  each(fields, function (index, field) {\n    if (!field.expanded) {\n      firstCollapsedIndex = index;\n      return false;\n    }\n  });\n  return firstCollapsedIndex;\n}\n\nfunction getRequestsData(options) {\n  var rowExpandedLevel = getExpandedLevel(options, \"rows\");\n  var columnExpandedLevel = getExpandedLevel(options, \"columns\");\n  var filters = options.filters || [];\n  var columnExpandedIndex = getExpandedIndex(options, \"columns\");\n  var firstCollapsedColumnIndex = getFirstCollapsedIndex(options.columns);\n  var firstCollapsedRowIndex = getFirstCollapsedIndex(options.rows);\n  var rowExpandedIndex = getExpandedIndex(options, \"rows\");\n  var data = [];\n  filters = filters.concat(getFiltersForDimension(options.rows)).concat(getFiltersForDimension(options.columns)).concat(getFiltersForExpandedDimension(options));\n  var columnTotalsOptions = getGrandTotalRequest(options, \"columns\", columnExpandedIndex, columnExpandedLevel, filters, firstCollapsedColumnIndex);\n\n  if (options.rows.length && options.columns.length) {\n    if (\"rows\" !== options.headerName) {\n      data = data.concat(columnTotalsOptions);\n    }\n\n    for (var i = rowExpandedIndex; i < rowExpandedLevel + 1; i++) {\n      var rows = options.rows.slice(rowExpandedIndex, i + 1);\n      var rowFilterByExpandedPaths = getExpandedPathSliceFilter(options, \"rows\", i, firstCollapsedRowIndex);\n\n      for (var j = columnExpandedIndex; j < columnExpandedLevel + 1; j++) {\n        var preparedOptions = extend({}, options, {\n          columns: options.columns.slice(columnExpandedIndex, j + 1),\n          rows: rows,\n          filters: filters.concat(getExpandedPathSliceFilter(options, \"columns\", j, firstCollapsedColumnIndex)).concat(rowFilterByExpandedPaths)\n        });\n        data.push(preparedOptions);\n      }\n    }\n  } else {\n    data = options.columns.length ? columnTotalsOptions : getGrandTotalRequest(options, \"rows\", rowExpandedIndex, rowExpandedLevel, filters, firstCollapsedRowIndex);\n  }\n\n  return data;\n}\n\nfunction prepareFields(fields) {\n  each(fields || [], function (_, field) {\n    var levels = field.levels;\n\n    if (levels) {\n      prepareFields(levels);\n    }\n\n    setDefaultFieldValueFormatting(field);\n  });\n}\n\nexport default Class.inherit({\n  ctor: function ctor(options) {\n    this._dataSource = new DataSource(options);\n    this._store = this._dataSource.store();\n  },\n  getFields: function getFields(fields) {\n    var d = new Deferred();\n\n    this._store.load({\n      skip: 0,\n      take: 20\n    }).done(function (data) {\n      var normalizedArguments = normalizeLoadResult(data);\n      d.resolve(discoverObjectFields(normalizedArguments.data, fields));\n    }).fail(d.reject);\n\n    return d;\n  },\n  key: function key() {\n    return this._store.key();\n  },\n  load: function load(options) {\n    var that = this;\n    var d = new Deferred();\n    var result = {\n      rows: [],\n      columns: [],\n      values: [],\n      grandTotalRowIndex: 0,\n      grandTotalColumnIndex: 0,\n      rowHash: {},\n      columnHash: {},\n      rowIndex: 1,\n      columnIndex: 1\n    };\n    var requestsData = getRequestsData(options);\n    var deferreds = [];\n    prepareFields(options.rows);\n    prepareFields(options.columns);\n    prepareFields(options.filters);\n    each(requestsData, function (_, dataItem) {\n      deferreds.push(that._store.load(createLoadOptions(dataItem, that.filter(), options.rows.length)));\n    });\n    when.apply(null, deferreds).done(function () {\n      var args = deferreds.length > 1 ? arguments : [arguments];\n      each(args, function (index, argument) {\n        var normalizedArguments = normalizeLoadResult(argument[0], argument[1]);\n        parseResult(normalizedArguments.data, normalizedArguments.extra, requestsData[index], result);\n      });\n      d.resolve({\n        rows: result.rows,\n        columns: result.columns,\n        values: result.values,\n        grandTotalRowIndex: result.grandTotalRowIndex,\n        grandTotalColumnIndex: result.grandTotalColumnIndex\n      });\n    }).fail(d.reject);\n    return d;\n  },\n  filter: function filter() {\n    return this._dataSource.filter.apply(this._dataSource, arguments);\n  },\n  supportPaging: function supportPaging() {\n    return false;\n  },\n  createDrillDownDataSource: function createDrillDownDataSource(loadOptions, params) {\n    loadOptions = loadOptions || {};\n    params = params || {};\n    var store = this._store;\n    var filters = getFiltersByPath(loadOptions.rows, params.rowPath).concat(getFiltersByPath(loadOptions.columns, params.columnPath)).concat(getFiltersForDimension(loadOptions.rows)).concat(loadOptions.filters || []).concat(getFiltersForDimension(loadOptions.columns));\n    var filterExp = createFilterExpressions(filters);\n    return new DataSource({\n      load: function load(loadOptions) {\n        return store.load(extend({}, loadOptions, {\n          filter: mergeFilters(filterExp, loadOptions.filter),\n          select: params.customColumns\n        }));\n      }\n    });\n  }\n});","map":null,"metadata":{},"sourceType":"module"}