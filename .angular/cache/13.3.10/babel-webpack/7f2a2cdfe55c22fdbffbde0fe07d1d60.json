{"ast":null,"code":"import _slicedToArray from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _classCallCheck from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n\n/**\r\n * DevExtreme (esm/ui/scheduler/recurrence.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport errors from \"../../core/errors\";\nimport { each } from \"../../core/utils/iterator\";\nimport { inArray } from \"../../core/utils/array\";\nimport { RRule, RRuleSet } from \"rrule\";\nimport dateUtils from \"../../core/utils/date\";\nimport timeZoneUtils from \"./utils.timeZone\";\nvar toMs = dateUtils.dateToMilliseconds;\nvar ruleNames = [\"freq\", \"interval\", \"byday\", \"byweekno\", \"byyearday\", \"bymonth\", \"bymonthday\", \"count\", \"until\", \"byhour\", \"byminute\", \"bysecond\", \"bysetpos\", \"wkst\"];\nvar freqNames = [\"DAILY\", \"WEEKLY\", \"MONTHLY\", \"YEARLY\", \"SECONDLY\", \"MINUTELY\", \"HOURLY\"];\nvar days = {\n  SU: 0,\n  MO: 1,\n  TU: 2,\n  WE: 3,\n  TH: 4,\n  FR: 5,\n  SA: 6\n};\nvar loggedWarnings = [];\nvar recurrence = null;\nexport function getRecurrenceProcessor() {\n  if (!recurrence) {\n    recurrence = new RecurrenceProcessor();\n  }\n\n  return recurrence;\n}\n\nvar RecurrenceProcessor = /*#__PURE__*/function () {\n  function RecurrenceProcessor() {\n    _classCallCheck(this, RecurrenceProcessor);\n\n    this.rRule = null;\n    this.rRuleSet = null;\n    this.validator = new RecurrenceValidator();\n  }\n\n  _createClass(RecurrenceProcessor, [{\n    key: \"generateDates\",\n    value: function generateDates(options) {\n      var result = [];\n      var recurrenceRule = this.evalRecurrenceRule(options.rule);\n      var rule = recurrenceRule.rule;\n\n      if (!recurrenceRule.isValid || !rule.freq) {\n        return result;\n      }\n\n      var startDateUtc = timeZoneUtils.createUTCDateWithLocalOffset(options.start);\n      var endDateUtc = timeZoneUtils.createUTCDateWithLocalOffset(options.end);\n      var minDateUtc = timeZoneUtils.createUTCDateWithLocalOffset(options.min);\n      var maxDateUtc = timeZoneUtils.createUTCDateWithLocalOffset(options.max);\n      var duration = endDateUtc ? endDateUtc.getTime() - startDateUtc.getTime() : 0;\n\n      this._initializeRRule(options, startDateUtc, rule.until);\n\n      var minTime = minDateUtc.getTime();\n\n      var leftBorder = this._getLeftBorder(options, minDateUtc, duration);\n\n      this.rRuleSet.between(leftBorder, maxDateUtc, true).forEach(function (date) {\n        var endAppointmentTime = date.getTime() + duration;\n\n        if (endAppointmentTime >= minTime) {\n          var correctDate = timeZoneUtils.createDateFromUTCWithLocalOffset(date);\n          result.push(correctDate);\n        }\n      });\n      return result;\n    }\n  }, {\n    key: \"hasRecurrence\",\n    value: function hasRecurrence(options) {\n      return !!this.generateDates(options).length;\n    }\n  }, {\n    key: \"evalRecurrenceRule\",\n    value: function evalRecurrenceRule(rule) {\n      var result = {\n        rule: {},\n        isValid: false\n      };\n\n      if (rule) {\n        result.rule = this._parseRecurrenceRule(rule);\n        result.isValid = this.validator.validateRRule(result.rule, rule);\n      }\n\n      return result;\n    }\n  }, {\n    key: \"isValidRecurrenceRule\",\n    value: function isValidRecurrenceRule(rule) {\n      return this.evalRecurrenceRule(rule).isValid;\n    }\n  }, {\n    key: \"daysFromByDayRule\",\n    value: function daysFromByDayRule(rule) {\n      var result = [];\n\n      if (rule.byday) {\n        if (Array.isArray(rule.byday)) {\n          result = rule.byday;\n        } else {\n          result = rule.byday.split(\",\");\n        }\n      }\n\n      return result.map(function (item) {\n        var match = item.match(/[A-Za-z]+/);\n        return !!match && match[0];\n      }).filter(function (item) {\n        return !!item;\n      });\n    }\n  }, {\n    key: \"getAsciiStringByDate\",\n    value: function getAsciiStringByDate(date) {\n      var currentOffset = date.getTimezoneOffset() * toMs(\"minute\");\n      var offsetDate = new Date(date.getTime() + currentOffset);\n      return offsetDate.getFullYear() + (\"0\" + (offsetDate.getMonth() + 1)).slice(-2) + (\"0\" + offsetDate.getDate()).slice(-2) + \"T\" + (\"0\" + offsetDate.getHours()).slice(-2) + (\"0\" + offsetDate.getMinutes()).slice(-2) + (\"0\" + offsetDate.getSeconds()).slice(-2) + \"Z\";\n    }\n  }, {\n    key: \"getRecurrenceString\",\n    value: function getRecurrenceString(object) {\n      if (!object || !object.freq) {\n        return;\n      }\n\n      var result = \"\";\n\n      for (var field in object) {\n        var value = object[field];\n\n        if (\"interval\" === field && value < 2) {\n          continue;\n        }\n\n        if (\"until\" === field) {\n          value = this.getAsciiStringByDate(value);\n        }\n\n        result += field + \"=\" + value + \";\";\n      }\n\n      result = result.substring(0, result.length - 1);\n      return result.toUpperCase();\n    }\n  }, {\n    key: \"_parseExceptionToRawArray\",\n    value: function _parseExceptionToRawArray(value) {\n      return value.match(/(\\d{4})(\\d{2})(\\d{2})(T(\\d{2})(\\d{2})(\\d{2}))?(Z)?/);\n    }\n  }, {\n    key: \"getDateByAsciiString\",\n    value: function getDateByAsciiString(exceptionText) {\n      if (\"string\" !== typeof exceptionText) {\n        return exceptionText;\n      }\n\n      var result = this._parseExceptionToRawArray(exceptionText);\n\n      if (!result) {\n        return null;\n      }\n\n      var _this$_createDateTupl = this._createDateTuple(result),\n          _this$_createDateTupl2 = _slicedToArray(_this$_createDateTupl, 7),\n          year = _this$_createDateTupl2[0],\n          month = _this$_createDateTupl2[1],\n          date = _this$_createDateTupl2[2],\n          hours = _this$_createDateTupl2[3],\n          minutes = _this$_createDateTupl2[4],\n          seconds = _this$_createDateTupl2[5],\n          isUtc = _this$_createDateTupl2[6];\n\n      if (isUtc) {\n        return new Date(Date.UTC(year, month, date, hours, minutes, seconds));\n      }\n\n      return new Date(year, month, date, hours, minutes, seconds);\n    }\n  }, {\n    key: \"_dispose\",\n    value: function _dispose() {\n      if (this.rRuleSet) {\n        delete this.rRuleSet;\n        this.rRuleSet = null;\n      }\n\n      if (this.rRule) {\n        delete this.rRule;\n        this.rRule = null;\n      }\n    }\n  }, {\n    key: \"_getTimeZoneOffset\",\n    value: function _getTimeZoneOffset() {\n      return new Date().getTimezoneOffset();\n    }\n  }, {\n    key: \"_initializeRRule\",\n    value: function _initializeRRule(options, startDateUtc, until) {\n      var _this = this;\n\n      var ruleOptions = RRule.parseString(options.rule);\n      var firstDayOfWeek = options.firstDayOfWeek;\n      ruleOptions.dtstart = startDateUtc;\n\n      if (!ruleOptions.wkst && firstDayOfWeek) {\n        ruleOptions.wkst = [6, 0, 1, 2, 3, 4, 5][firstDayOfWeek];\n      }\n\n      ruleOptions.until = timeZoneUtils.createUTCDateWithLocalOffset(until);\n\n      this._createRRule(ruleOptions);\n\n      if (options.exception) {\n        var exceptionStrings = options.exception;\n        var exceptionDates = exceptionStrings.split(\",\").map(function (rule) {\n          return _this.getDateByAsciiString(rule);\n        });\n        exceptionDates.forEach(function (date) {\n          if (options.getPostProcessedException) {\n            date = options.getPostProcessedException(date);\n          }\n\n          var utcDate = timeZoneUtils.createUTCDateWithLocalOffset(date);\n\n          _this.rRuleSet.exdate(utcDate);\n        });\n      }\n    }\n  }, {\n    key: \"_createRRule\",\n    value: function _createRRule(ruleOptions) {\n      this._dispose();\n\n      var rRuleSet = new RRuleSet();\n      this.rRuleSet = rRuleSet;\n      this.rRule = new RRule(ruleOptions);\n      this.rRuleSet.rrule(this.rRule);\n    }\n  }, {\n    key: \"_getLeftBorder\",\n    value: function _getLeftBorder(options, minDateUtc, appointmentDuration) {\n      if (options.end && !timeZoneUtils.isSameAppointmentDates(options.start, options.end)) {\n        return new Date(minDateUtc.getTime() - appointmentDuration);\n      }\n\n      return minDateUtc;\n    }\n  }, {\n    key: \"_parseRecurrenceRule\",\n    value: function _parseRecurrenceRule(recurrence) {\n      var ruleObject = {};\n      var ruleParts = recurrence.split(\";\");\n\n      for (var i = 0, len = ruleParts.length; i < len; i++) {\n        var rule = ruleParts[i].split(\"=\");\n        var ruleName = rule[0].toLowerCase();\n        var ruleValue = rule[1];\n        ruleObject[ruleName] = ruleValue;\n      }\n\n      var count = parseInt(ruleObject.count);\n\n      if (!isNaN(count)) {\n        ruleObject.count = count;\n      }\n\n      if (ruleObject.interval) {\n        var interval = parseInt(ruleObject.interval);\n\n        if (!isNaN(interval)) {\n          ruleObject.interval = interval;\n        }\n      } else {\n        ruleObject.interval = 1;\n      }\n\n      if (ruleObject.freq && ruleObject.until) {\n        ruleObject.until = this.getDateByAsciiString(ruleObject.until);\n      }\n\n      return ruleObject;\n    }\n  }, {\n    key: \"_createDateTuple\",\n    value: function _createDateTuple(parseResult) {\n      var isUtc = void 0 !== parseResult[8];\n      parseResult.shift();\n\n      if (void 0 === parseResult[3]) {\n        parseResult.splice(3);\n      } else {\n        parseResult.splice(3, 1);\n        parseResult.splice(6);\n      }\n\n      parseResult[1]--;\n      parseResult.unshift(null);\n      return [parseInt(parseResult[1]), parseInt(parseResult[2]), parseInt(parseResult[3]), parseInt(parseResult[4]) || 0, parseInt(parseResult[5]) || 0, parseInt(parseResult[6]) || 0, isUtc];\n    }\n  }]);\n\n  return RecurrenceProcessor;\n}();\n\nvar RecurrenceValidator = /*#__PURE__*/function () {\n  function RecurrenceValidator() {\n    _classCallCheck(this, RecurrenceValidator);\n  }\n\n  _createClass(RecurrenceValidator, [{\n    key: \"validateRRule\",\n    value: function validateRRule(rule, recurrence) {\n      if (this._brokenRuleNameExists(rule) || -1 === inArray(rule.freq, freqNames) || this._wrongCountRule(rule) || this._wrongIntervalRule(rule) || this._wrongDayOfWeek(rule) || this._wrongByMonthDayRule(rule) || this._wrongByMonth(rule) || this._wrongUntilRule(rule)) {\n        this._logBrokenRule(recurrence);\n\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"_wrongUntilRule\",\n    value: function _wrongUntilRule(rule) {\n      var wrongUntil = false;\n      var until = rule.until;\n\n      if (void 0 !== until && !(until instanceof Date)) {\n        wrongUntil = true;\n      }\n\n      return wrongUntil;\n    }\n  }, {\n    key: \"_wrongCountRule\",\n    value: function _wrongCountRule(rule) {\n      var wrongCount = false;\n      var count = rule.count;\n\n      if (count && \"string\" === typeof count) {\n        wrongCount = true;\n      }\n\n      return wrongCount;\n    }\n  }, {\n    key: \"_wrongByMonthDayRule\",\n    value: function _wrongByMonthDayRule(rule) {\n      var wrongByMonthDay = false;\n      var byMonthDay = rule.bymonthday;\n\n      if (byMonthDay && isNaN(parseInt(byMonthDay))) {\n        wrongByMonthDay = true;\n      }\n\n      return wrongByMonthDay;\n    }\n  }, {\n    key: \"_wrongByMonth\",\n    value: function _wrongByMonth(rule) {\n      var wrongByMonth = false;\n      var byMonth = rule.bymonth;\n\n      if (byMonth && isNaN(parseInt(byMonth))) {\n        wrongByMonth = true;\n      }\n\n      return wrongByMonth;\n    }\n  }, {\n    key: \"_wrongIntervalRule\",\n    value: function _wrongIntervalRule(rule) {\n      var wrongInterval = false;\n      var interval = rule.interval;\n\n      if (interval && \"string\" === typeof interval) {\n        wrongInterval = true;\n      }\n\n      return wrongInterval;\n    }\n  }, {\n    key: \"_wrongDayOfWeek\",\n    value: function _wrongDayOfWeek(rule) {\n      var byDay = rule.byday;\n      var daysByRule = getRecurrenceProcessor().daysFromByDayRule(rule);\n      var brokenDaysExist = false;\n\n      if (\"\" === byDay) {\n        brokenDaysExist = true;\n      }\n\n      each(daysByRule, function (_, day) {\n        if (!Object.prototype.hasOwnProperty.call(days, day)) {\n          brokenDaysExist = true;\n          return false;\n        }\n      });\n      return brokenDaysExist;\n    }\n  }, {\n    key: \"_brokenRuleNameExists\",\n    value: function _brokenRuleNameExists(rule) {\n      var brokenRuleExists = false;\n      each(rule, function (ruleName) {\n        if (-1 === inArray(ruleName, ruleNames)) {\n          brokenRuleExists = true;\n          return false;\n        }\n      });\n      return brokenRuleExists;\n    }\n  }, {\n    key: \"_logBrokenRule\",\n    value: function _logBrokenRule(recurrence) {\n      if (-1 === inArray(recurrence, loggedWarnings)) {\n        errors.log(\"W0006\", recurrence);\n        loggedWarnings.push(recurrence);\n      }\n    }\n  }]);\n\n  return RecurrenceValidator;\n}();","map":null,"metadata":{},"sourceType":"module"}