{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/data_grid/aggregate_calculator.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport Class from \"../../core/class\";\nimport { compileGetter } from \"../../core/utils/data\";\nimport { isFunction } from \"../../core/utils/type\";\nimport { errors } from \"../../data/errors\";\nimport { aggregators } from \"../../data/utils\";\n\nfunction depthFirstSearch(i, depth, root, callback) {\n  var j = 0;\n\n  if (i < depth) {\n    for (; j < root.items.length; j++) {\n      depthFirstSearch(i + 1, depth, root.items[j], callback);\n    }\n  }\n\n  if (i === depth) {\n    callback(root);\n  }\n}\n\nfunction map(array, callback) {\n  var i;\n\n  if (\"map\" in array) {\n    return array.map(callback);\n  }\n\n  var result = new Array(array.length);\n\n  for (i in array) {\n    result[i] = callback(array[i], i);\n  }\n\n  return result;\n}\n\nfunction isEmpty(x) {\n  return x !== x || \"\" === x || null === x || void 0 === x;\n}\n\nfunction isCount(aggregator) {\n  return aggregator === aggregators.count;\n}\n\nfunction normalizeAggregate(aggregate) {\n  var selector = compileGetter(aggregate.selector);\n  var skipEmptyValues = \"skipEmptyValues\" in aggregate ? aggregate.skipEmptyValues : true;\n  var aggregator = aggregate.aggregator;\n\n  if (\"string\" === typeof aggregator) {\n    aggregator = aggregators[aggregator];\n\n    if (!aggregator) {\n      throw errors.Error(\"E4001\", aggregate.aggregator);\n    }\n  }\n\n  return {\n    selector: selector,\n    aggregator: aggregator,\n    skipEmptyValues: skipEmptyValues\n  };\n}\n\nexport default Class.inherit({\n  ctor: function ctor(options) {\n    this._data = options.data;\n    this._groupLevel = options.groupLevel || 0;\n    this._totalAggregates = map(options.totalAggregates || [], normalizeAggregate);\n    this._groupAggregates = map(options.groupAggregates || [], normalizeAggregate);\n    this._totals = [];\n  },\n  calculate: function calculate() {\n    if (this._totalAggregates.length) {\n      this._calculateTotals(0, {\n        items: this._data\n      });\n    }\n\n    if (this._groupAggregates.length && this._groupLevel > 0) {\n      this._calculateGroups({\n        items: this._data\n      });\n    }\n  },\n  totalAggregates: function totalAggregates() {\n    return this._totals;\n  },\n  _aggregate: function _aggregate(aggregates, data, container) {\n    var length = data.items ? data.items.length : 0;\n\n    for (var i = 0; i < aggregates.length; i++) {\n      if (isCount(aggregates[i].aggregator)) {\n        container[i] = (container[i] || 0) + length;\n        continue;\n      }\n\n      for (var j = 0; j < length; j++) {\n        this._accumulate(i, aggregates[i], container, data.items[j]);\n      }\n    }\n  },\n  _calculateTotals: function _calculateTotals(level, data) {\n    if (0 === level) {\n      this._totals = this._seed(this._totalAggregates);\n    }\n\n    if (level === this._groupLevel) {\n      this._aggregate(this._totalAggregates, data, this._totals);\n    } else {\n      for (var i = 0; i < data.items.length; i++) {\n        this._calculateTotals(level + 1, data.items[i]);\n      }\n    }\n\n    if (0 === level) {\n      this._totals = this._finalize(this._totalAggregates, this._totals);\n    }\n  },\n  _calculateGroups: function _calculateGroups(root) {\n    var maxLevel = this._groupLevel;\n    var currentLevel = maxLevel + 1;\n\n    var seedFn = this._seed.bind(this, this._groupAggregates);\n\n    var stepFn = this._aggregate.bind(this, this._groupAggregates);\n\n    var finalizeFn = this._finalize.bind(this, this._groupAggregates);\n\n    function aggregator(node) {\n      node.aggregates = seedFn(currentLevel - 1);\n\n      if (currentLevel === maxLevel) {\n        stepFn(node, node.aggregates);\n      } else {\n        depthFirstSearch(currentLevel, maxLevel, node, function (innerNode) {\n          stepFn(innerNode, node.aggregates);\n        });\n      }\n\n      node.aggregates = finalizeFn(node.aggregates);\n    }\n\n    while (--currentLevel > 0) {\n      depthFirstSearch(0, currentLevel, root, aggregator);\n    }\n  },\n  _seed: function _seed(aggregates, groupIndex) {\n    return map(aggregates, function (aggregate) {\n      var aggregator = aggregate.aggregator;\n      var seed = \"seed\" in aggregator ? isFunction(aggregator.seed) ? aggregator.seed(groupIndex) : aggregator.seed : NaN;\n      return seed;\n    });\n  },\n  _accumulate: function _accumulate(aggregateIndex, aggregate, results, item) {\n    var value = aggregate.selector(item);\n    var aggregator = aggregate.aggregator;\n    var skipEmptyValues = aggregate.skipEmptyValues;\n\n    if (skipEmptyValues && isEmpty(value)) {\n      return;\n    }\n\n    if (results[aggregateIndex] !== results[aggregateIndex]) {\n      results[aggregateIndex] = value;\n    } else {\n      results[aggregateIndex] = aggregator.step(results[aggregateIndex], value);\n    }\n  },\n  _finalize: function _finalize(aggregates, results) {\n    return map(aggregates, function (aggregate, index) {\n      var fin = aggregate.aggregator.finalize;\n      return fin ? fin(results[index]) : results[index];\n    });\n  }\n});","map":null,"metadata":{},"sourceType":"module"}