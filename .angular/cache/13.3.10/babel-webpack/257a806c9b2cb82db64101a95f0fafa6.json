{"ast":null,"code":"import _classCallCheck from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n\n/**\r\n * DevExtreme (esm/ui/text_box/texteditor_button_collection/index.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport $ from \"../../../core/renderer\";\nimport CustomButton from \"./custom\";\nimport { extend } from \"../../../core/utils/extend\";\nimport { find } from \"../../../core/utils/array\";\nimport errors from \"../../widget/ui.errors\";\nvar TEXTEDITOR_BUTTONS_CONTAINER_CLASS = \"dx-texteditor-buttons-container\";\n\nfunction checkButtonInfo(buttonInfo) {\n  (function () {\n    if (!buttonInfo || \"object\" !== typeof buttonInfo || Array.isArray(buttonInfo)) {\n      throw errors.Error(\"E1053\");\n    }\n  })();\n\n  (function () {\n    if (!(\"name\" in buttonInfo)) {\n      throw errors.Error(\"E1054\");\n    }\n  })();\n\n  (function () {\n    var name = buttonInfo.name;\n\n    if (\"string\" !== typeof name) {\n      throw errors.Error(\"E1055\");\n    }\n  })();\n\n  (function () {\n    var location = buttonInfo.location;\n\n    if (\"location\" in buttonInfo && \"after\" !== location && \"before\" !== location) {\n      buttonInfo.location = \"after\";\n    }\n  })();\n}\n\nfunction checkNamesUniqueness(existingNames, newName) {\n  if (-1 !== existingNames.indexOf(newName)) {\n    throw errors.Error(\"E1055\", newName);\n  }\n\n  existingNames.push(newName);\n}\n\nfunction isPredefinedButtonName(name, predefinedButtonsInfo) {\n  return !!find(predefinedButtonsInfo, function (info) {\n    return info.name === name;\n  });\n}\n\nvar TextEditorButtonCollection = /*#__PURE__*/function () {\n  function TextEditorButtonCollection(editor, defaultButtonsInfo) {\n    _classCallCheck(this, TextEditorButtonCollection);\n\n    this.buttons = [];\n    this.defaultButtonsInfo = defaultButtonsInfo;\n    this.editor = editor;\n  }\n\n  _createClass(TextEditorButtonCollection, [{\n    key: \"_compileButtonInfo\",\n    value: function _compileButtonInfo(buttons) {\n      var _this = this;\n\n      var names = [];\n      return buttons.map(function (button) {\n        var isStringButton = \"string\" === typeof button;\n\n        if (!isStringButton) {\n          checkButtonInfo(button);\n        }\n\n        var isDefaultButton = isStringButton || isPredefinedButtonName(button.name, _this.defaultButtonsInfo);\n\n        if (isDefaultButton) {\n          var defaultButtonInfo = find(_this.defaultButtonsInfo, function (_ref) {\n            var name = _ref.name;\n            return name === button || name === button.name;\n          });\n\n          if (!defaultButtonInfo) {\n            throw errors.Error(\"E1056\", _this.editor.NAME, button);\n          }\n\n          checkNamesUniqueness(names, button);\n          return defaultButtonInfo;\n        } else {\n          var name = button.name;\n          checkNamesUniqueness(names, name);\n          return extend(button, {\n            Ctor: CustomButton\n          });\n        }\n      });\n    }\n  }, {\n    key: \"_createButton\",\n    value: function _createButton(buttonsInfo) {\n      var Ctor = buttonsInfo.Ctor,\n          options = buttonsInfo.options,\n          name = buttonsInfo.name;\n      var button = new Ctor(name, this.editor, options);\n      this.buttons.push(button);\n      return button;\n    }\n  }, {\n    key: \"_renderButtons\",\n    value: function _renderButtons(buttons, $container, targetLocation) {\n      var _this2 = this;\n\n      var $buttonsContainer = null;\n      var buttonsInfo = buttons ? this._compileButtonInfo(buttons) : this.defaultButtonsInfo;\n      buttonsInfo.forEach(function (buttonsInfo) {\n        var _buttonsInfo$location = buttonsInfo.location,\n            location = _buttonsInfo$location === void 0 ? \"after\" : _buttonsInfo$location;\n\n        if (location === targetLocation) {\n          _this2._createButton(buttonsInfo).render(function () {\n            $buttonsContainer = $buttonsContainer || $(\"<div>\").addClass(TEXTEDITOR_BUTTONS_CONTAINER_CLASS);\n            \"before\" === targetLocation ? $container.prepend($buttonsContainer) : $container.append($buttonsContainer);\n            return $buttonsContainer;\n          }());\n        }\n      });\n      return $buttonsContainer;\n    }\n  }, {\n    key: \"clean\",\n    value: function clean() {\n      this.buttons.forEach(function (button) {\n        return button.dispose();\n      });\n      this.buttons = [];\n    }\n  }, {\n    key: \"getButton\",\n    value: function getButton(buttonName) {\n      var button = find(this.buttons, function (_ref2) {\n        var name = _ref2.name;\n        return name === buttonName;\n      });\n      return button && button.instance;\n    }\n  }, {\n    key: \"renderAfterButtons\",\n    value: function renderAfterButtons(buttons, $container) {\n      return this._renderButtons(buttons, $container, \"after\");\n    }\n  }, {\n    key: \"renderBeforeButtons\",\n    value: function renderBeforeButtons(buttons, $container) {\n      return this._renderButtons(buttons, $container, \"before\");\n    }\n  }, {\n    key: \"updateButtons\",\n    value: function updateButtons(names) {\n      this.buttons.forEach(function (button) {\n        if (!names || -1 !== names.indexOf(button.name)) {\n          button.update();\n        }\n      });\n    }\n  }]);\n\n  return TextEditorButtonCollection;\n}();\n\nexport { TextEditorButtonCollection as default };","map":null,"metadata":{},"sourceType":"module"}