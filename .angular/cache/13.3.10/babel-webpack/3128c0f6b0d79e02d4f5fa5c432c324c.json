{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/number_box/number_box.mask.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport eventsEngine from \"../../events/core/events_engine\";\nimport { extend } from \"../../core/utils/extend\";\nimport { isNumeric, isDefined, isFunction, isString } from \"../../core/utils/type\";\nimport devices from \"../../core/devices\";\nimport { fitIntoRange, inRange } from \"../../core/utils/math\";\nimport number from \"../../localization/number\";\nimport { getCaretWithOffset, isCaretInBoundaries, getCaretInBoundaries, getCaretBoundaries, getCaretAfterFormat, getCaretOffset } from \"./number_box.caret\";\nimport { getFormat as getLDMLFormat } from \"../../localization/ldml/number\";\nimport NumberBoxBase from \"./number_box.base\";\nimport { addNamespace, getChar, normalizeKeyName, isCommandKeyPressed } from \"../../events/utils/index\";\nimport { ensureDefined, escapeRegExp } from \"../../core/utils/common\";\nimport { getRealSeparatorIndex, getNthOccurrence, splitByIndex, adjustPercentValue } from \"./utils\";\nvar NUMBER_FORMATTER_NAMESPACE = \"dxNumberFormatter\";\nvar MOVE_FORWARD = 1;\nvar MOVE_BACKWARD = -1;\nvar MINUS = \"-\";\nvar MINUS_KEY = \"minus\";\nvar INPUT_EVENT = \"input\";\nvar CARET_TIMEOUT_DURATION = 0;\nvar NumberBoxMask = NumberBoxBase.inherit({\n  _getDefaultOptions: function _getDefaultOptions() {\n    return extend(this.callBase(), {\n      useMaskBehavior: true,\n      format: null\n    });\n  },\n  _isDeleteKey: function _isDeleteKey(key) {\n    return \"del\" === key;\n  },\n  _supportedKeys: function _supportedKeys() {\n    if (!this._useMaskBehavior()) {\n      return this.callBase();\n    }\n\n    return extend(this.callBase(), {\n      minus: this._revertSign.bind(this),\n      del: this._removeHandler.bind(this),\n      backspace: this._removeHandler.bind(this),\n      leftArrow: this._arrowHandler.bind(this, MOVE_BACKWARD),\n      rightArrow: this._arrowHandler.bind(this, MOVE_FORWARD),\n      home: this._moveCaretToBoundaryEventHandler.bind(this, MOVE_FORWARD),\n      enter: this._updateFormattedValue.bind(this),\n      end: this._moveCaretToBoundaryEventHandler.bind(this, MOVE_BACKWARD)\n    });\n  },\n  _getTextSeparatorIndex: function _getTextSeparatorIndex(text) {\n    var decimalSeparator = number.getDecimalSeparator();\n    var realSeparatorOccurrenceIndex = getRealSeparatorIndex(this.option(\"format\")).occurrence;\n    return getNthOccurrence(text, decimalSeparator, realSeparatorOccurrenceIndex);\n  },\n  _focusInHandler: function _focusInHandler(e) {\n    if (!this._preventNestedFocusEvent(e)) {\n      this.clearCaretTimeout();\n      this._caretTimeout = setTimeout(function () {\n        this._caretTimeout = void 0;\n\n        var caret = this._caret();\n\n        if (caret.start === caret.end && this._useMaskBehavior()) {\n          var text = this._getInputVal();\n\n          var decimalSeparatorIndex = this._getTextSeparatorIndex(text);\n\n          if (decimalSeparatorIndex >= 0) {\n            this._caret({\n              start: decimalSeparatorIndex,\n              end: decimalSeparatorIndex\n            });\n          } else {\n            this._moveCaretToBoundaryEventHandler(MOVE_BACKWARD, e);\n          }\n        }\n      }.bind(this), CARET_TIMEOUT_DURATION);\n    }\n\n    this.callBase(e);\n  },\n  _focusOutHandler: function _focusOutHandler(e) {\n    var shouldHandleEvent = !this._preventNestedFocusEvent(e);\n\n    if (shouldHandleEvent) {\n      this._focusOutOccurs = true;\n\n      if (this._useMaskBehavior()) {\n        this._updateFormattedValue();\n      }\n    }\n\n    this.callBase(e);\n\n    if (shouldHandleEvent) {\n      this._focusOutOccurs = false;\n    }\n  },\n  _hasValueBeenChanged: function _hasValueBeenChanged(inputValue) {\n    var format = this._getFormatPattern();\n\n    var value = this.option(\"value\");\n    var formatted = this._format(value, format) || \"\";\n    return formatted !== inputValue;\n  },\n  _updateFormattedValue: function _updateFormattedValue() {\n    var inputValue = this._getInputVal();\n\n    if (this._hasValueBeenChanged(inputValue)) {\n      this._updateParsedValue();\n\n      this._adjustParsedValue();\n\n      this._setTextByParsedValue();\n\n      if (this._parsedValue !== this.option(\"value\")) {\n        eventsEngine.trigger(this._input(), \"change\");\n      }\n    }\n  },\n  _arrowHandler: function _arrowHandler(step, e) {\n    if (!this._useMaskBehavior()) {\n      return;\n    }\n\n    var text = this._getInputVal();\n\n    var format = this._getFormatPattern();\n\n    var nextCaret = getCaretWithOffset(this._caret(), step);\n\n    if (!isCaretInBoundaries(nextCaret, text, format)) {\n      nextCaret = step === MOVE_FORWARD ? nextCaret.end : nextCaret.start;\n      e.preventDefault();\n\n      this._caret(getCaretInBoundaries(nextCaret, text, format));\n    }\n  },\n  _moveCaretToBoundary: function _moveCaretToBoundary(direction) {\n    var boundaries = getCaretBoundaries(this._getInputVal(), this._getFormatPattern());\n    var newCaret = getCaretWithOffset(direction === MOVE_FORWARD ? boundaries.start : boundaries.end, 0);\n\n    this._caret(newCaret);\n  },\n  _moveCaretToBoundaryEventHandler: function _moveCaretToBoundaryEventHandler(direction, e) {\n    if (!this._useMaskBehavior() || e && e.shiftKey) {\n      return;\n    }\n\n    this._moveCaretToBoundary(direction);\n\n    e && e.preventDefault();\n  },\n  _shouldMoveCaret: function _shouldMoveCaret(text, caret) {\n    var decimalSeparator = number.getDecimalSeparator();\n    var isDecimalSeparatorNext = text.charAt(caret.end) === decimalSeparator;\n    var moveToFloat = (this._lastKey === decimalSeparator || \".\" === this._lastKey) && isDecimalSeparatorNext;\n    return moveToFloat;\n  },\n  _getInputVal: function _getInputVal() {\n    return number.convertDigits(this._input().val(), true);\n  },\n  _keyboardHandler: function _keyboardHandler(e) {\n    this.clearCaretTimeout();\n    this._lastKey = number.convertDigits(getChar(e), true);\n    this._lastKeyName = normalizeKeyName(e);\n\n    if (!this._shouldHandleKey(e.originalEvent)) {\n      return this.callBase(e);\n    }\n\n    var normalizedText = this._getInputVal();\n\n    var caret = this._caret();\n\n    var enteredChar = this._lastKeyName === MINUS_KEY ? \"\" : this._lastKey;\n\n    var newValue = this._tryParse(normalizedText, caret, enteredChar);\n\n    if (this._shouldMoveCaret(normalizedText, caret)) {\n      this._moveCaret(1);\n\n      e.originalEvent.preventDefault();\n    }\n\n    if (void 0 === newValue) {\n      if (this._lastKeyName !== MINUS_KEY) {\n        e.originalEvent.preventDefault();\n      }\n    } else {\n      this._parsedValue = newValue;\n    }\n\n    return this.callBase(e);\n  },\n  _keyPressHandler: function _keyPressHandler(e) {\n    if (!this._useMaskBehavior()) {\n      this.callBase(e);\n    }\n  },\n  _removeHandler: function _removeHandler(e) {\n    var caret = this._caret();\n\n    var text = this._getInputVal();\n\n    var start = caret.start;\n    var end = caret.end;\n    this._lastKey = getChar(e);\n    this._lastKeyName = normalizeKeyName(e);\n\n    var isDeleteKey = this._isDeleteKey(this._lastKeyName);\n\n    var isBackspaceKey = !isDeleteKey;\n\n    if (start === end) {\n      var caretPosition = start;\n      var canDelete = isBackspaceKey && caretPosition > 0 || isDeleteKey && caretPosition < text.length;\n\n      if (canDelete) {\n        isDeleteKey && end++;\n        isBackspaceKey && start--;\n      } else {\n        e.preventDefault();\n        return;\n      }\n    }\n\n    var char = text.slice(start, end);\n\n    if (this._isStub(char)) {\n      this._moveCaret(isDeleteKey ? 1 : -1);\n\n      if (this._parsedValue < 0 || 1 / this._parsedValue === -1 / 0) {\n        this._revertSign(e);\n\n        this._setTextByParsedValue();\n      }\n\n      e.preventDefault();\n      return;\n    }\n\n    var decimalSeparator = number.getDecimalSeparator();\n\n    if (char === decimalSeparator) {\n      var decimalSeparatorIndex = text.indexOf(decimalSeparator);\n\n      if (this._isNonStubAfter(decimalSeparatorIndex + 1)) {\n        this._moveCaret(isDeleteKey ? 1 : -1);\n\n        e.preventDefault();\n      }\n\n      return;\n    }\n\n    if (end - start < text.length) {\n      var editedText = this._replaceSelectedText(text, {\n        start: start,\n        end: end\n      }, \"\");\n\n      var noDigits = editedText.search(/[0-9]/) < 0;\n\n      if (noDigits && this._isValueInRange(0)) {\n        this._parsedValue = this._parsedValue < 0 || 1 / this._parsedValue === -1 / 0 ? -0 : 0;\n        return;\n      }\n    }\n\n    var valueAfterRemoving = this._tryParse(text, {\n      start: start,\n      end: end\n    }, \"\");\n\n    if (void 0 === valueAfterRemoving) {\n      e.preventDefault();\n    } else {\n      this._parsedValue = valueAfterRemoving;\n    }\n  },\n  _isPercentFormat: function _isPercentFormat() {\n    var format = this._getFormatPattern();\n\n    var noEscapedFormat = format.replace(/'[^']+'/g, \"\");\n    return -1 !== noEscapedFormat.indexOf(\"%\");\n  },\n  _parse: function _parse(text, format) {\n    var formatOption = this.option(\"format\");\n    var isCustomParser = isFunction(formatOption.parser);\n    var parser = isCustomParser ? formatOption.parser : number.parse;\n    var integerPartStartIndex = 0;\n\n    if (!isCustomParser) {\n      var formatPointIndex = getRealSeparatorIndex(format).index;\n\n      var textPointIndex = this._getTextSeparatorIndex(text);\n\n      var formatIntegerPartLength = -1 !== formatPointIndex ? formatPointIndex : format.length;\n      var textIntegerPartLength = -1 !== textPointIndex ? textPointIndex : text.length;\n\n      if (textIntegerPartLength > formatIntegerPartLength && -1 === format.indexOf(\"#\")) {\n        integerPartStartIndex = textIntegerPartLength - formatIntegerPartLength;\n      }\n    }\n\n    text = this._removeStubs(text, true);\n    text = text.substr(integerPartStartIndex);\n    return parser(text, format);\n  },\n  _format: function _format(value, format) {\n    var formatOption = this.option(\"format\");\n    var customFormatter = (null === formatOption || void 0 === formatOption ? void 0 : formatOption.formatter) || formatOption;\n    var formatter = isFunction(customFormatter) ? customFormatter : number.format;\n    var formattedValue = null === value ? \"\" : formatter(value, format);\n    return formattedValue;\n  },\n  _getFormatPattern: function _getFormatPattern() {\n    if (!this._currentFormat) {\n      this._updateFormat();\n    }\n\n    return this._currentFormat;\n  },\n  _updateFormat: function _updateFormat() {\n    var _this = this;\n\n    var format = this.option(\"format\");\n    var isCustomParser = isFunction(null === format || void 0 === format ? void 0 : format.parser);\n    var isLDMLPattern = isString(format) && (format.indexOf(\"0\") >= 0 || format.indexOf(\"#\") >= 0);\n    this._currentFormat = isCustomParser || isLDMLPattern ? format : getLDMLFormat(function (value) {\n      var text = _this._format(value, format);\n\n      return number.convertDigits(text, true);\n    });\n  },\n  _getFormatForSign: function _getFormatForSign(text) {\n    var format = this._getFormatPattern();\n\n    if (isString(format)) {\n      var signParts = format.split(\";\");\n      var sign = number.getSign(text, format);\n      signParts[1] = signParts[1] || \"-\" + signParts[0];\n      return sign < 0 ? signParts[1] : signParts[0];\n    } else {\n      var _sign = number.getSign(text);\n\n      return _sign < 0 ? \"-\" : \"\";\n    }\n  },\n  _removeStubs: function _removeStubs(text, excludeComma) {\n    var format = this._getFormatForSign(text);\n\n    var thousandsSeparator = number.getThousandsSeparator();\n\n    var stubs = this._getStubs(format);\n\n    var result = text;\n\n    if (stubs.length) {\n      var prefixStubs = stubs[0];\n      var postfixRegex = new RegExp(\"(\" + escapeRegExp(stubs[1] || \"\") + \")$\", \"g\");\n      var decoratorsRegex = new RegExp(\"[-\" + escapeRegExp(excludeComma ? \"\" : thousandsSeparator) + \"]\", \"g\");\n      result = result.replace(prefixStubs, \"\").replace(postfixRegex, \"\").replace(decoratorsRegex, \"\");\n    }\n\n    return result;\n  },\n  _getStubs: function _getStubs(format) {\n    var regExpResult = /[^']([#0.,]+)/g.exec(format);\n    var pattern = regExpResult && regExpResult[0].trim();\n    return format.split(pattern).map(function (stub) {\n      return stub.replace(/'/g, \"\");\n    });\n  },\n  _truncateToPrecision: function _truncateToPrecision(value, maxPrecision) {\n    if (isDefined(value)) {\n      var strValue = value.toString();\n      var decimalSeparatorIndex = strValue.indexOf(\".\");\n\n      if (strValue && decimalSeparatorIndex > -1) {\n        var parsedValue = parseFloat(strValue.substr(0, decimalSeparatorIndex + maxPrecision + 1));\n        return isNaN(parsedValue) ? value : parsedValue;\n      }\n    }\n\n    return value;\n  },\n  _tryParse: function _tryParse(text, selection, char) {\n    var editedText = this._replaceSelectedText(text, selection, char);\n\n    var format = this._getFormatPattern();\n\n    var isTextSelected = selection.start !== selection.end;\n\n    var parsedValue = this._getParsedValue(editedText, format);\n\n    var maxPrecision = !format.parser && this._getPrecisionLimits(editedText).max;\n\n    var isValueChanged = parsedValue !== this._parsedValue;\n    var decimalSeparator = number.getDecimalSeparator();\n    var isDecimalPointRestricted = char === decimalSeparator && 0 === maxPrecision;\n\n    var isUselessCharRestricted = !isTextSelected && !isValueChanged && char !== MINUS && !this._isValueIncomplete(editedText) && this._isStub(char);\n\n    if (isDecimalPointRestricted || isUselessCharRestricted) {\n      return;\n    }\n\n    if (\"\" === this._removeStubs(editedText)) {\n      parsedValue = Math.abs(0 * this._parsedValue);\n    }\n\n    if (isNaN(parsedValue)) {\n      return;\n    }\n\n    var value = null === parsedValue ? this._parsedValue : parsedValue;\n    parsedValue = maxPrecision ? this._truncateToPrecision(value, maxPrecision) : parsedValue;\n    return !format.parser && this._isPercentFormat() ? adjustPercentValue(parsedValue, maxPrecision) : parsedValue;\n  },\n  _getParsedValue: function _getParsedValue(text, format) {\n    var sign = number.getSign(text, (null === format || void 0 === format ? void 0 : format.formatter) || format);\n\n    var parsedValue = this._parse(text, format);\n\n    var parsedValueSign = parsedValue < 0 ? -1 : 1;\n    var parsedValueWithSign = isNumeric(parsedValue) && sign !== parsedValueSign ? sign * parsedValue : parsedValue;\n    return parsedValueWithSign;\n  },\n  _isValueIncomplete: function _isValueIncomplete(text) {\n    if (!this._useMaskBehavior()) {\n      return this.callBase(text);\n    }\n\n    var caret = this._caret();\n\n    var point = number.getDecimalSeparator();\n\n    var pointIndex = this._getTextSeparatorIndex(text);\n\n    var isCaretOnFloat = pointIndex >= 0 && pointIndex < caret.start;\n\n    var textParts = this._removeStubs(text, true).split(point);\n\n    if (!isCaretOnFloat || 2 !== textParts.length) {\n      return false;\n    }\n\n    var floatLength = textParts[1].length;\n\n    var format = this._getFormatPattern();\n\n    var isCustomParser = !!format.parser;\n\n    var precision = !isCustomParser && this._getPrecisionLimits(this._getFormatPattern(), text);\n\n    var isPrecisionInRange = isCustomParser ? true : inRange(floatLength, precision.min, precision.max);\n    var endsWithZero = \"0\" === textParts[1].charAt(floatLength - 1);\n    return isPrecisionInRange && (endsWithZero || !floatLength);\n  },\n  _isValueInRange: function _isValueInRange(value) {\n    var min = ensureDefined(this.option(\"min\"), -1 / 0);\n    var max = ensureDefined(this.option(\"max\"), 1 / 0);\n    return inRange(value, min, max);\n  },\n  _setInputText: function _setInputText(text) {\n    var normalizedText = number.convertDigits(text, true);\n    var newCaret = getCaretAfterFormat(this._getInputVal(), normalizedText, this._caret(), this._getFormatPattern());\n\n    this._input().val(text);\n\n    this._toggleEmptinessEventHandler();\n\n    this._formattedValue = text;\n\n    if (!this._focusOutOccurs) {\n      this._caret(newCaret);\n    }\n  },\n  _useMaskBehavior: function _useMaskBehavior() {\n    return !!this.option(\"format\") && this.option(\"useMaskBehavior\");\n  },\n  _renderInputType: function _renderInputType() {\n    var isNumberType = \"number\" === this.option(\"mode\");\n    var isDesktop = \"desktop\" === devices.real().deviceType;\n\n    if (this._useMaskBehavior() && isNumberType) {\n      this._setInputType(isDesktop || this._isSupportInputMode() ? \"text\" : \"tel\");\n    } else {\n      this.callBase();\n    }\n  },\n  _isChar: function _isChar(str) {\n    return isString(str) && 1 === str.length;\n  },\n  _moveCaret: function _moveCaret(offset) {\n    if (!offset) {\n      return;\n    }\n\n    var newCaret = getCaretWithOffset(this._caret(), offset);\n    var adjustedCaret = getCaretInBoundaries(newCaret, this._getInputVal(), this._getFormatPattern());\n\n    this._caret(adjustedCaret);\n  },\n  _shouldHandleKey: function _shouldHandleKey(e) {\n    var keyName = normalizeKeyName(e);\n    var isSpecialChar = isCommandKeyPressed(e) || e.altKey || e.shiftKey || !this._isChar(keyName);\n    var isMinusKey = keyName === MINUS_KEY;\n\n    var useMaskBehavior = this._useMaskBehavior();\n\n    return useMaskBehavior && !isSpecialChar && !isMinusKey;\n  },\n  _renderInput: function _renderInput() {\n    this.callBase();\n\n    this._renderFormatter();\n  },\n  _renderFormatter: function _renderFormatter() {\n    this._clearCache();\n\n    this._detachFormatterEvents();\n\n    if (this._useMaskBehavior()) {\n      this._attachFormatterEvents();\n    }\n  },\n  _detachFormatterEvents: function _detachFormatterEvents() {\n    eventsEngine.off(this._input(), \".\" + NUMBER_FORMATTER_NAMESPACE);\n  },\n  _isInputFromPaste: function _isInputFromPaste(e) {\n    var inputType = e.originalEvent && e.originalEvent.inputType;\n\n    if (isDefined(inputType)) {\n      return \"insertFromPaste\" === inputType;\n    } else {\n      return this._isValuePasted;\n    }\n  },\n  _attachFormatterEvents: function _attachFormatterEvents() {\n    var $input = this._input();\n\n    eventsEngine.on($input, addNamespace(INPUT_EVENT, NUMBER_FORMATTER_NAMESPACE), function (e) {\n      this._formatValue(e);\n\n      this._isValuePasted = false;\n    }.bind(this));\n    eventsEngine.on($input, addNamespace(\"dxclick\", NUMBER_FORMATTER_NAMESPACE), function () {\n      if (!this._caretTimeout) {\n        this._caretTimeout = setTimeout(function () {\n          this._caretTimeout = void 0;\n\n          this._caret(getCaretInBoundaries(this._caret(), this._getInputVal(), this._getFormatPattern()));\n        }.bind(this), CARET_TIMEOUT_DURATION);\n      }\n    }.bind(this));\n    eventsEngine.on($input, \"dxdblclick\", function () {\n      this.clearCaretTimeout();\n    }.bind(this));\n  },\n  clearCaretTimeout: function clearCaretTimeout() {\n    clearTimeout(this._caretTimeout);\n    this._caretTimeout = void 0;\n  },\n  _forceRefreshInputValue: function _forceRefreshInputValue() {\n    if (!this._useMaskBehavior()) {\n      return this.callBase();\n    }\n  },\n  _isNonStubAfter: function _isNonStubAfter(index) {\n    var text = this._getInputVal().slice(index);\n\n    return text && !this._isStub(text, true);\n  },\n  _isStub: function _isStub(str, isString) {\n    var escapedDecimalSeparator = escapeRegExp(number.getDecimalSeparator());\n    var regExpString = \"^[^0-9\" + escapedDecimalSeparator + \"]+$\";\n    var stubRegExp = new RegExp(regExpString, \"g\");\n    return stubRegExp.test(str) && (isString || this._isChar(str));\n  },\n  _parseValue: function _parseValue(text) {\n    if (!this._useMaskBehavior()) {\n      return this.callBase(text);\n    }\n\n    return this._parsedValue;\n  },\n  _getPrecisionLimits: function _getPrecisionLimits(text) {\n    var currentFormat = this._getFormatForSign(text);\n\n    var realSeparatorIndex = getRealSeparatorIndex(currentFormat).index;\n    var floatPart = (splitByIndex(currentFormat, realSeparatorIndex)[1] || \"\").replace(/[^#0]/g, \"\");\n    var minPrecision = floatPart.replace(/^(0*)#*/, \"$1\").length;\n    var maxPrecision = floatPart.length;\n    return {\n      min: minPrecision,\n      max: maxPrecision\n    };\n  },\n  _revertSign: function _revertSign(e) {\n    if (!this._useMaskBehavior()) {\n      return;\n    }\n\n    var caret = this._caret();\n\n    if (caret.start !== caret.end) {\n      if (normalizeKeyName(e) === MINUS_KEY) {\n        this._applyRevertedSign(e, caret, true);\n\n        return;\n      } else {\n        this._caret(getCaretInBoundaries(0, this._getInputVal(), this._getFormatPattern()));\n      }\n    }\n\n    this._applyRevertedSign(e, caret);\n  },\n  _applyRevertedSign: function _applyRevertedSign(e, caret, preserveSelectedText) {\n    var newValue = -1 * ensureDefined(this._parsedValue, null);\n\n    if (this._isValueInRange(newValue)) {\n      this._parsedValue = newValue;\n\n      if (preserveSelectedText) {\n        var format = this._getFormatPattern();\n\n        var previousText = this._getInputVal();\n\n        this._setTextByParsedValue();\n\n        e.preventDefault();\n\n        var currentText = this._getInputVal();\n\n        var offset = getCaretOffset(previousText, currentText, format);\n        caret = getCaretWithOffset(caret, offset);\n        var caretInBoundaries = getCaretInBoundaries(caret, currentText, format);\n\n        this._caret(caretInBoundaries);\n      }\n    }\n  },\n  _removeMinusFromText: function _removeMinusFromText(text, caret) {\n    var isMinusPressed = this._lastKeyName === MINUS_KEY && text.charAt(caret.start - 1) === MINUS;\n    return isMinusPressed ? this._replaceSelectedText(text, {\n      start: caret.start - 1,\n      end: caret.start\n    }, \"\") : text;\n  },\n  _setTextByParsedValue: function _setTextByParsedValue() {\n    var format = this._getFormatPattern();\n\n    var parsed = this._parseValue();\n\n    var formatted = this._format(parsed, format) || \"\";\n\n    this._setInputText(formatted);\n  },\n  _formatValue: function _formatValue(e) {\n    var normalizedText = this._getInputVal();\n\n    var caret = this._caret();\n\n    var textWithoutMinus = this._removeMinusFromText(normalizedText, caret);\n\n    var wasMinusRemoved = textWithoutMinus !== normalizedText;\n    normalizedText = textWithoutMinus;\n\n    if (!this._isInputFromPaste(e) && this._isValueIncomplete(textWithoutMinus)) {\n      this._formattedValue = normalizedText;\n\n      if (wasMinusRemoved) {\n        this._setTextByParsedValue();\n      }\n\n      return;\n    }\n\n    var textWasChanged = number.convertDigits(this._formattedValue, true) !== normalizedText;\n\n    if (textWasChanged) {\n      var value = this._tryParse(normalizedText, caret, \"\");\n\n      if (isDefined(value)) {\n        this._parsedValue = value;\n      }\n    }\n\n    this._setTextByParsedValue();\n  },\n  _renderDisplayText: function _renderDisplayText() {\n    if (this._useMaskBehavior()) {\n      this._toggleEmptinessEventHandler();\n    } else {\n      this.callBase.apply(this, arguments);\n    }\n  },\n  _renderValue: function _renderValue() {\n    if (this._useMaskBehavior()) {\n      this._parsedValue = this.option(\"value\");\n\n      this._setTextByParsedValue();\n    }\n\n    return this.callBase();\n  },\n  _updateParsedValue: function _updateParsedValue() {\n    var inputValue = this._getInputVal();\n\n    this._parsedValue = this._tryParse(inputValue, this._caret());\n  },\n  _adjustParsedValue: function _adjustParsedValue() {\n    if (!this._useMaskBehavior()) {\n      return;\n    }\n\n    var clearedText = this._removeStubs(this._getInputVal());\n\n    var parsedValue = clearedText ? this._parseValue() : null;\n\n    if (!isNumeric(parsedValue)) {\n      this._parsedValue = parsedValue;\n      return;\n    }\n\n    this._parsedValue = fitIntoRange(parsedValue, this.option(\"min\"), this.option(\"max\"));\n  },\n  _valueChangeEventHandler: function _valueChangeEventHandler(e) {\n    if (!this._useMaskBehavior()) {\n      return this.callBase(e);\n    }\n\n    var caret = this._caret();\n\n    this._saveValueChangeEvent(e);\n\n    this._lastKey = null;\n    this._lastKeyName = null;\n\n    this._updateParsedValue();\n\n    this._adjustParsedValue();\n\n    this.option(\"value\", this._parsedValue);\n\n    if (caret) {\n      this._caret(caret);\n    }\n  },\n  _optionChanged: function _optionChanged(args) {\n    switch (args.name) {\n      case \"format\":\n      case \"useMaskBehavior\":\n        this._renderInputType();\n\n        this._updateFormat();\n\n        this._renderFormatter();\n\n        this._renderValue();\n\n        this._refreshValueChangeEvent();\n\n        this._refreshEvents();\n\n        break;\n\n      case \"min\":\n      case \"max\":\n        this._adjustParsedValue();\n\n        this.callBase(args);\n        break;\n\n      default:\n        this.callBase(args);\n    }\n  },\n  _clearCache: function _clearCache() {\n    delete this._formattedValue;\n    delete this._lastKey;\n    delete this._lastKeyName;\n    delete this._parsedValue;\n    delete this._focusOutOccurs;\n    clearTimeout(this._caretTimeout);\n    delete this._caretTimeout;\n  },\n  _clean: function _clean() {\n    this._clearCache();\n\n    this.callBase();\n  }\n});\nexport default NumberBoxMask;","map":null,"metadata":{},"sourceType":"module"}