{"ast":null,"code":"import _toConsumableArray from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\n\n/**\r\n * DevExtreme (esm/ui/scheduler/workspaces/ui.scheduler.work_space.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { setWidth, getOuterHeight, getOuterWidth, setOuterHeight, getHeight, getWidth } from \"../../../core/utils/size\";\nimport $ from \"../../../core/renderer\";\nimport domAdapter from \"../../../core/dom_adapter\";\nimport eventsEngine from \"../../../events/core/events_engine\";\nimport dateUtils from \"../../../core/utils/date\";\nimport { getWindow, hasWindow } from \"../../../core/utils/window\";\nimport { getPublicElement } from \"../../../core/element\";\nimport { extend } from \"../../../core/utils/extend\";\nimport { getBoundingRect } from \"../../../core/utils/position\";\nimport messageLocalization from \"../../../localization/message\";\nimport { noop } from \"../../../core/utils/common\";\nimport { isDefined } from \"../../../core/utils/type\";\nimport { addNamespace, isMouseEvent } from \"../../../events/utils/index\";\nimport pointerEvents from \"../../../events/pointer\";\nimport errors from \"../../widget/ui.errors\";\nimport { name as clickEventName } from \"../../../events/click\";\nimport { name as contextMenuEventName } from \"../../../events/contextmenu\";\nimport { enter as dragEventEnter, leave as dragEventLeave, drop as dragEventDrop } from \"../../../events/drag\";\nimport Scrollable from \"../../scroll_view/ui.scrollable\";\nimport HorizontalGroupedStrategy from \"./ui.scheduler.work_space.grouped.strategy.horizontal\";\nimport VerticalGroupedStrategy from \"./ui.scheduler.work_space.grouped.strategy.vertical\";\nimport tableCreatorModule from \"../table_creator\";\nvar tableCreator = tableCreatorModule.tableCreator;\nimport VerticalShader from \"../shaders/ui.scheduler.current_time_shader.vertical\";\nimport AppointmentDragBehavior from \"../appointmentDragBehavior\";\nimport { APPOINTMENT_SETTINGS_KEY } from \"../constants\";\nimport { FIXED_CONTAINER_CLASS, VIRTUAL_CELL_CLASS, TIME_PANEL_CLASS, DATE_TABLE_CLASS, DATE_TABLE_ROW_CLASS, GROUP_ROW_CLASS, GROUP_HEADER_CONTENT_CLASS, VERTICAL_GROUP_COUNT_CLASSES } from \"../classes\";\nimport WidgetObserver from \"../base/widgetObserver\";\nimport { resetPosition, locate } from \"../../../animation/translator\";\nimport { VirtualScrollingDispatcher, VirtualScrollingRenderer } from \"./ui.scheduler.virtual_scrolling\";\nimport ViewDataProvider from \"./view_model/view_data_provider\";\nimport dxrDateTableLayout from \"../../../renovation/ui/scheduler/workspaces/base/date_table/layout.j\";\nimport dxrAllDayPanelTable from \"../../../renovation/ui/scheduler/workspaces/base/date_table/all_day_panel/table.j\";\nimport dxrAllDayPanelTitle from \"../../../renovation/ui/scheduler/workspaces/base/date_table/all_day_panel/title.j\";\nimport dxrTimePanelTableLayout from \"../../../renovation/ui/scheduler/workspaces/base/time_panel/layout.j\";\nimport dxrGroupPanel from \"../../../renovation/ui/scheduler/workspaces/base/group_panel/group_panel.j\";\nimport dxrDateHeader from \"../../../renovation/ui/scheduler/workspaces/base/header_panel/layout.j\";\nimport CellsSelectionState from \"./cells_selection_state\";\nimport { Cache } from \"./cache\";\nimport { CellsSelectionController } from \"./cells_selection_controller\";\nimport { calculateViewStartDate, getViewStartByOptions, validateDayHours, getStartViewDateTimeOffset, isDateAndTimeView, calculateIsGroupedAllDayPanel, getCellDuration as _getCellDuration } from \"../../../renovation/ui/scheduler/view_model/to_test/views/utils/base\";\nimport { createResourcesTree, getCellGroups, getGroupsObjectFromGroupsArray, getGroupCount } from \"../resources/utils\";\nimport { ScrollSemaphore } from \"../../../renovation/ui/scheduler/utils/semaphore/scrollSemaphore\";\nimport { getCellWidth as _getCellWidth, getCellHeight as _getCellHeight, getAllDayHeight as _getAllDayHeight, getMaxAllowedPosition as _getMaxAllowedPosition, PositionHelper } from \"./helpers/positionHelper\";\nimport { utils } from \"../utils\";\nimport { compileGetter } from \"../../../core/utils/data\";\nvar abstract = WidgetObserver.abstract;\nvar toMs = dateUtils.dateToMilliseconds;\nvar COMPONENT_CLASS = \"dx-scheduler-work-space\";\nvar GROUPED_WORKSPACE_CLASS = \"dx-scheduler-work-space-grouped\";\nvar VERTICAL_GROUPED_WORKSPACE_CLASS = \"dx-scheduler-work-space-vertical-grouped\";\nvar WORKSPACE_VERTICAL_GROUP_TABLE_CLASS = \"dx-scheduler-work-space-vertical-group-table\";\nvar WORKSPACE_WITH_BOTH_SCROLLS_CLASS = \"dx-scheduler-work-space-both-scrollbar\";\nvar WORKSPACE_WITH_COUNT_CLASS = \"dx-scheduler-work-space-count\";\nvar WORKSPACE_WITH_GROUP_BY_DATE_CLASS = \"dx-scheduler-work-space-group-by-date\";\nvar WORKSPACE_WITH_ODD_CELLS_CLASS = \"dx-scheduler-work-space-odd-cells\";\nvar TIME_PANEL_CELL_CLASS = \"dx-scheduler-time-panel-cell\";\nvar TIME_PANEL_ROW_CLASS = \"dx-scheduler-time-panel-row\";\nvar ALL_DAY_PANEL_CLASS = \"dx-scheduler-all-day-panel\";\nvar ALL_DAY_TABLE_CLASS = \"dx-scheduler-all-day-table\";\nvar ALL_DAY_CONTAINER_CLASS = \"dx-scheduler-all-day-appointments\";\nvar ALL_DAY_TITLE_CLASS = \"dx-scheduler-all-day-title\";\nvar ALL_DAY_TABLE_CELL_CLASS = \"dx-scheduler-all-day-table-cell\";\nvar ALL_DAY_TABLE_ROW_CLASS = \"dx-scheduler-all-day-table-row\";\nvar WORKSPACE_WITH_ALL_DAY_CLASS = \"dx-scheduler-work-space-all-day\";\nvar WORKSPACE_WITH_COLLAPSED_ALL_DAY_CLASS = \"dx-scheduler-work-space-all-day-collapsed\";\nvar WORKSPACE_WITH_MOUSE_SELECTION_CLASS = \"dx-scheduler-work-space-mouse-selection\";\nvar HORIZONTAL_SIZES_CLASS = \"dx-scheduler-cell-sizes-horizontal\";\nvar VERTICAL_SIZES_CLASS = \"dx-scheduler-cell-sizes-vertical\";\nvar HEADER_PANEL_CLASS = \"dx-scheduler-header-panel\";\nvar HEADER_PANEL_CELL_CLASS = \"dx-scheduler-header-panel-cell\";\nvar HEADER_ROW_CLASS = \"dx-scheduler-header-row\";\nvar GROUP_HEADER_CLASS = \"dx-scheduler-group-header\";\nvar DATE_TABLE_CELL_CLASS = \"dx-scheduler-date-table-cell\";\nvar DATE_TABLE_FOCUSED_CELL_CLASS = \"dx-scheduler-focused-cell\";\nvar VIRTUAL_ROW_CLASS = \"dx-scheduler-virtual-row\";\nvar DATE_TABLE_DROPPABLE_CELL_CLASS = \"dx-scheduler-date-table-droppable-cell\";\nvar SCHEDULER_HEADER_SCROLLABLE_CLASS = \"dx-scheduler-header-scrollable\";\nvar SCHEDULER_SIDEBAR_SCROLLABLE_CLASS = \"dx-scheduler-sidebar-scrollable\";\nvar SCHEDULER_DATE_TABLE_SCROLLABLE_CLASS = \"dx-scheduler-date-table-scrollable\";\nvar SCHEDULER_WORKSPACE_DXPOINTERDOWN_EVENT_NAME = addNamespace(pointerEvents.down, \"dxSchedulerWorkSpace\");\nvar DragEventNames = {\n  ENTER: addNamespace(dragEventEnter, \"dxSchedulerDateTable\"),\n  DROP: addNamespace(dragEventDrop, \"dxSchedulerDateTable\"),\n  LEAVE: addNamespace(dragEventLeave, \"dxSchedulerDateTable\")\n};\nvar SCHEDULER_CELL_DXCLICK_EVENT_NAME = addNamespace(clickEventName, \"dxSchedulerDateTable\");\nvar SCHEDULER_CELL_DXPOINTERDOWN_EVENT_NAME = addNamespace(pointerEvents.down, \"dxSchedulerDateTable\");\nvar SCHEDULER_CELL_DXPOINTERUP_EVENT_NAME = addNamespace(pointerEvents.up, \"dxSchedulerDateTable\");\nvar SCHEDULER_CELL_DXPOINTERMOVE_EVENT_NAME = addNamespace(pointerEvents.move, \"dxSchedulerDateTable\");\nvar CELL_DATA = \"dxCellData\";\nvar DATE_TABLE_MIN_CELL_WIDTH = 75;\nvar DAY_MS = toMs(\"day\");\nvar HOUR_MS = toMs(\"hour\");\nvar DRAG_AND_DROP_SELECTOR = \".\".concat(DATE_TABLE_CLASS, \" td, .\").concat(ALL_DAY_TABLE_CLASS, \" td\");\nvar CELL_SELECTOR = \".\".concat(DATE_TABLE_CELL_CLASS, \", .\").concat(ALL_DAY_TABLE_CELL_CLASS);\n\nvar SchedulerWorkSpace = /*#__PURE__*/function (_WidgetObserver) {\n  _inherits(SchedulerWorkSpace, _WidgetObserver);\n\n  var _super = _createSuper(SchedulerWorkSpace);\n\n  function SchedulerWorkSpace() {\n    _classCallCheck(this, SchedulerWorkSpace);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(SchedulerWorkSpace, [{\n    key: \"viewDataProvider\",\n    get: function get() {\n      if (!this._viewDataProvider) {\n        this._viewDataProvider = new ViewDataProvider(this.type);\n      }\n\n      return this._viewDataProvider;\n    }\n  }, {\n    key: \"cache\",\n    get: function get() {\n      if (!this._cache) {\n        this._cache = new Cache();\n      }\n\n      return this._cache;\n    }\n  }, {\n    key: \"cellsSelectionState\",\n    get: function get() {\n      var _this = this;\n\n      if (!this._cellsSelectionState) {\n        this._cellsSelectionState = new CellsSelectionState(this.viewDataProvider);\n        var selectedCellsOption = this.option(\"selectedCellData\");\n\n        if ((null === selectedCellsOption || void 0 === selectedCellsOption ? void 0 : selectedCellsOption.length) > 0) {\n          var validSelectedCells = selectedCellsOption.map(function (selectedCell) {\n            var groups = selectedCell.groups;\n\n            if (!groups || 0 === _this._getGroupCount()) {\n              return _extends({}, selectedCell, {\n                groupIndex: 0\n              });\n            }\n\n            var groupIndex = _this._getGroupIndexByResourceId(groups);\n\n            return _extends({}, selectedCell, {\n              groupIndex: groupIndex\n            });\n          });\n\n          this._cellsSelectionState.setSelectedCellsByData(validSelectedCells);\n        }\n      }\n\n      return this._cellsSelectionState;\n    }\n  }, {\n    key: \"cellsSelectionController\",\n    get: function get() {\n      if (!this._cellsSelectionController) {\n        this._cellsSelectionController = new CellsSelectionController();\n      }\n\n      return this._cellsSelectionController;\n    }\n  }, {\n    key: \"isAllDayPanelVisible\",\n    get: function get() {\n      return this._isShowAllDayPanel() && this.supportAllDayRow();\n    }\n  }, {\n    key: \"verticalGroupTableClass\",\n    get: function get() {\n      return WORKSPACE_VERTICAL_GROUP_TABLE_CLASS;\n    }\n  }, {\n    key: \"viewDirection\",\n    get: function get() {\n      return \"vertical\";\n    }\n  }, {\n    key: \"renovatedHeaderPanelComponent\",\n    get: function get() {\n      return dxrDateHeader;\n    }\n  }, {\n    key: \"timeZoneCalculator\",\n    get: function get() {\n      return this.option(\"timeZoneCalculator\");\n    }\n  }, {\n    key: \"_supportedKeys\",\n    value: function _supportedKeys() {\n      var _this3 = this;\n\n      var clickHandler = function clickHandler(e) {\n        var _this2 = this;\n\n        e.preventDefault();\n        e.stopPropagation();\n        var selectedCells = this.cellsSelectionState.getSelectedCells();\n\n        if (null !== selectedCells && void 0 !== selectedCells && selectedCells.length) {\n          var selectedCellsElement = selectedCells.map(function (cellData) {\n            return _this2._getCellByData(cellData);\n          }).filter(function (cell) {\n            return !!cell;\n          });\n          e.target = selectedCellsElement;\n          this._showPopup = true;\n\n          this._cellClickAction({\n            event: e,\n            cellElement: $(selectedCellsElement),\n            cellData: selectedCells[0]\n          });\n        }\n      };\n\n      var onArrowPressed = function onArrowPressed(e, key) {\n        var _this$cellsSelectionS;\n\n        e.preventDefault();\n        e.stopPropagation();\n        var focusedCellData = null === (_this$cellsSelectionS = _this3.cellsSelectionState.focusedCell) || void 0 === _this$cellsSelectionS ? void 0 : _this$cellsSelectionS.cellData;\n\n        if (focusedCellData) {\n          var isAllDayPanelCell = focusedCellData.allDay && !_this3._isVerticalGroupedWorkSpace();\n          var isMultiSelection = e.shiftKey;\n\n          var isMultiSelectionAllowed = _this3.option(\"allowMultipleCellSelection\");\n\n          var isRTL = _this3._isRTL();\n\n          var groupCount = _this3._getGroupCount();\n\n          var isGroupedByDate = _this3.isGroupedByDate();\n\n          var isHorizontalGrouping = _this3._isHorizontalGroupedWorkSpace();\n\n          var focusedCellPosition = _this3.viewDataProvider.findCellPositionInMap(_extends({}, focusedCellData, {\n            isAllDay: focusedCellData.allDay\n          }));\n\n          var edgeIndices = isHorizontalGrouping && isMultiSelection && !isGroupedByDate ? _this3.viewDataProvider.getGroupEdgeIndices(focusedCellData.groupIndex, isAllDayPanelCell) : _this3.viewDataProvider.getViewEdgeIndices(isAllDayPanelCell);\n\n          var nextCellData = _this3.cellsSelectionController.handleArrowClick({\n            focusedCellPosition: focusedCellPosition,\n            edgeIndices: edgeIndices,\n            isRTL: isRTL,\n            isGroupedByDate: isGroupedByDate,\n            groupCount: groupCount,\n            isMultiSelection: isMultiSelection,\n            isMultiSelectionAllowed: isMultiSelectionAllowed,\n            viewType: _this3.type,\n            key: key,\n            getCellDataByPosition: _this3.viewDataProvider.getCellData.bind(_this3.viewDataProvider),\n            isAllDayPanelCell: isAllDayPanelCell,\n            focusedCellData: focusedCellData\n          });\n\n          _this3._processNextSelectedCell(nextCellData, focusedCellData, isMultiSelection && isMultiSelectionAllowed);\n        }\n      };\n\n      return extend(_get(_getPrototypeOf(SchedulerWorkSpace.prototype), \"_supportedKeys\", this).call(this), {\n        enter: clickHandler,\n        space: clickHandler,\n        downArrow: function downArrow(e) {\n          onArrowPressed(e, \"down\");\n        },\n        upArrow: function upArrow(e) {\n          onArrowPressed(e, \"up\");\n        },\n        rightArrow: function rightArrow(e) {\n          onArrowPressed(e, \"right\");\n        },\n        leftArrow: function leftArrow(e) {\n          onArrowPressed(e, \"left\");\n        }\n      });\n    }\n  }, {\n    key: \"_isRTL\",\n    value: function _isRTL() {\n      return this.option(\"rtlEnabled\");\n    }\n  }, {\n    key: \"_moveToCell\",\n    value: function _moveToCell($cell, isMultiSelection) {\n      if (!isDefined($cell) || !$cell.length) {\n        return;\n      }\n\n      var isMultiSelectionAllowed = this.option(\"allowMultipleCellSelection\");\n\n      var currentCellData = this._getFullCellData($cell);\n\n      var focusedCellData = this.cellsSelectionState.focusedCell.cellData;\n      var nextFocusedCellData = this.cellsSelectionController.moveToCell({\n        isMultiSelection: isMultiSelection,\n        isMultiSelectionAllowed: isMultiSelectionAllowed,\n        currentCellData: currentCellData,\n        focusedCellData: focusedCellData,\n        isVirtualCell: $cell.hasClass(VIRTUAL_CELL_CLASS)\n      });\n\n      this._processNextSelectedCell(nextFocusedCellData, focusedCellData, isMultiSelectionAllowed && isMultiSelection);\n    }\n  }, {\n    key: \"_processNextSelectedCell\",\n    value: function _processNextSelectedCell(nextCellData, focusedCellData, isMultiSelection) {\n      var nextCellPosition = this.viewDataProvider.findCellPositionInMap({\n        startDate: nextCellData.startDate,\n        groupIndex: nextCellData.groupIndex,\n        isAllDay: nextCellData.allDay,\n        index: nextCellData.index\n      });\n\n      if (!this.viewDataProvider.isSameCell(focusedCellData, nextCellData)) {\n        var $cell = nextCellData.allDay && !this._isVerticalGroupedWorkSpace() ? this._dom_getAllDayPanelCell(nextCellPosition.columnIndex) : this._dom_getDateCell(nextCellPosition);\n        var isNextCellAllDay = nextCellData.allDay;\n\n        this._setSelectedCellsStateAndUpdateSelection(isNextCellAllDay, nextCellPosition, isMultiSelection, $cell);\n\n        this._dateTableScrollable.scrollToElement($cell);\n      }\n    }\n  }, {\n    key: \"_setSelectedCellsStateAndUpdateSelection\",\n    value: function _setSelectedCellsStateAndUpdateSelection(isAllDay, cellPosition, isMultiSelection, $nextFocusedCell) {\n      var nextCellCoordinates = {\n        rowIndex: cellPosition.rowIndex,\n        columnIndex: cellPosition.columnIndex,\n        allDay: isAllDay\n      };\n      this.cellsSelectionState.setFocusedCell(nextCellCoordinates.rowIndex, nextCellCoordinates.columnIndex, isAllDay);\n\n      if (isMultiSelection) {\n        this.cellsSelectionState.setSelectedCells(nextCellCoordinates);\n      } else {\n        this.cellsSelectionState.setSelectedCells(nextCellCoordinates, nextCellCoordinates);\n      }\n\n      this.updateCellsSelection();\n\n      this._updateSelectedCellDataOption(this.cellsSelectionState.getSelectedCells(), $nextFocusedCell);\n    }\n  }, {\n    key: \"_hasAllDayClass\",\n    value: function _hasAllDayClass($cell) {\n      return $cell.hasClass(ALL_DAY_TABLE_CELL_CLASS);\n    }\n  }, {\n    key: \"_focusInHandler\",\n    value: function _focusInHandler(e) {\n      if ($(e.target).is(this._focusTarget()) && false !== this._isCellClick) {\n        delete this._isCellClick;\n        delete this._contextMenuHandled;\n\n        _get(_getPrototypeOf(SchedulerWorkSpace.prototype), \"_focusInHandler\", this).apply(this, arguments);\n\n        this.cellsSelectionState.restoreSelectedAndFocusedCells();\n\n        if (!this.cellsSelectionState.focusedCell) {\n          var cellCoordinates = {\n            columnIndex: 0,\n            rowIndex: 0,\n            allDay: this._isVerticalGroupedWorkSpace() && this.isAllDayPanelVisible\n          };\n          this.cellsSelectionState.setFocusedCell(cellCoordinates.rowIndex, cellCoordinates.columnIndex, cellCoordinates.allDay);\n          this.cellsSelectionState.setSelectedCells(cellCoordinates, cellCoordinates);\n        }\n\n        this.updateCellsSelection();\n\n        this._updateSelectedCellDataOption(this.cellsSelectionState.getSelectedCells());\n      }\n    }\n  }, {\n    key: \"_focusOutHandler\",\n    value: function _focusOutHandler() {\n      _get(_getPrototypeOf(SchedulerWorkSpace.prototype), \"_focusOutHandler\", this).apply(this, arguments);\n\n      if (!this._contextMenuHandled && !this._disposed) {\n        this.cellsSelectionState.releaseSelectedAndFocusedCells();\n        this.viewDataProvider.updateViewData(this.generateRenderOptions());\n        this.updateCellsSelection();\n      }\n    }\n  }, {\n    key: \"_focusTarget\",\n    value: function _focusTarget() {\n      return this.$element();\n    }\n  }, {\n    key: \"_isVerticalGroupedWorkSpace\",\n    value: function _isVerticalGroupedWorkSpace() {\n      return !!this.option(\"groups\").length && \"vertical\" === this.option(\"groupOrientation\");\n    }\n  }, {\n    key: \"_isHorizontalGroupedWorkSpace\",\n    value: function _isHorizontalGroupedWorkSpace() {\n      return !!this.option(\"groups\").length && \"horizontal\" === this.option(\"groupOrientation\");\n    }\n  }, {\n    key: \"_isWorkSpaceWithCount\",\n    value: function _isWorkSpaceWithCount() {\n      return this.option(\"intervalCount\") > 1;\n    }\n  }, {\n    key: \"_isWorkspaceWithOddCells\",\n    value: function _isWorkspaceWithOddCells() {\n      return .5 === this.option(\"hoursInterval\") && !this.isVirtualScrolling();\n    }\n  }, {\n    key: \"_getRealGroupOrientation\",\n    value: function _getRealGroupOrientation() {\n      return this._isVerticalGroupedWorkSpace() ? \"vertical\" : \"horizontal\";\n    }\n  }, {\n    key: \"createRAllDayPanelElements\",\n    value: function createRAllDayPanelElements() {\n      this._$allDayPanel = $(\"<div>\").addClass(ALL_DAY_PANEL_CLASS);\n      this._$allDayTitle = $(\"<div>\").appendTo(this._$headerPanelEmptyCell);\n    }\n  }, {\n    key: \"_dateTableScrollableConfig\",\n    value: function _dateTableScrollableConfig() {\n      var _this4 = this;\n\n      var config = {\n        useKeyboard: false,\n        bounceEnabled: false,\n        updateManually: true,\n        onScroll: function onScroll() {\n          var _this$_groupedStrateg;\n\n          null === (_this$_groupedStrateg = _this4._groupedStrategy.cache) || void 0 === _this$_groupedStrateg ? void 0 : _this$_groupedStrateg.clear();\n        }\n      };\n\n      if (this._needCreateCrossScrolling()) {\n        config = extend(config, this._createCrossScrollingConfig(config));\n      }\n\n      if (this.isVirtualScrolling() && (this.virtualScrollingDispatcher.horizontalScrollingAllowed || this.virtualScrollingDispatcher.height)) {\n        var currentOnScroll = config.onScroll;\n        config = _extends({}, config, {\n          onScroll: function onScroll(e) {\n            null === currentOnScroll || void 0 === currentOnScroll ? void 0 : currentOnScroll(e);\n\n            _this4.virtualScrollingDispatcher.handleOnScrollEvent(null === e || void 0 === e ? void 0 : e.scrollOffset);\n          }\n        });\n      }\n\n      return config;\n    }\n  }, {\n    key: \"_createCrossScrollingConfig\",\n    value: function _createCrossScrollingConfig(currentConfig) {\n      var _this5 = this;\n\n      var config = {};\n      config.direction = \"both\";\n      var currentOnScroll = currentConfig.onScroll;\n\n      config.onScroll = function (e) {\n        currentOnScroll();\n\n        _this5._dataTableSemaphore.take(e.scrollOffset);\n\n        if (_this5._sideBarSemaphore.isFree(e.scrollOffset)) {\n          var _this$_sidebarScrolla;\n\n          null === (_this$_sidebarScrolla = _this5._sidebarScrollable) || void 0 === _this$_sidebarScrolla ? void 0 : _this$_sidebarScrolla.scrollTo({\n            top: e.scrollOffset.top\n          });\n        }\n\n        if (_this5._headerSemaphore.isFree(e.scrollOffset)) {\n          var _this$_headerScrollab;\n\n          null === (_this$_headerScrollab = _this5._headerScrollable) || void 0 === _this$_headerScrollab ? void 0 : _this$_headerScrollab.scrollTo({\n            left: e.scrollOffset.left\n          });\n        }\n\n        _this5._dataTableSemaphore.release();\n      };\n\n      config.onEnd = function () {\n        _this5.option(\"onScrollEnd\")();\n      };\n\n      return config;\n    }\n  }, {\n    key: \"_headerScrollableConfig\",\n    value: function _headerScrollableConfig() {\n      var _this6 = this;\n\n      var config = {\n        useKeyboard: false,\n        showScrollbar: \"never\",\n        direction: \"horizontal\",\n        useNative: false,\n        updateManually: true,\n        bounceEnabled: false,\n        onScroll: function onScroll(e) {\n          _this6._headerSemaphore.take(e.scrollOffset);\n\n          _this6._dataTableSemaphore.isFree(e.scrollOffset) && _this6._dateTableScrollable.scrollTo({\n            left: e.scrollOffset.left\n          });\n\n          _this6._headerSemaphore.release();\n        }\n      };\n      return config;\n    }\n  }, {\n    key: \"_visibilityChanged\",\n    value: function _visibilityChanged(visible) {\n      this.cache.clear();\n\n      if (visible) {\n        this._updateGroupTableHeight();\n      }\n\n      if (visible && this._needCreateCrossScrolling()) {\n        this._setTableSizes();\n      }\n    }\n  }, {\n    key: \"_setTableSizes\",\n    value: function _setTableSizes() {\n      this.cache.clear();\n\n      this._attachTableClasses();\n\n      var cellWidth = this.getCellWidth();\n\n      if (cellWidth < this.getCellMinWidth()) {\n        cellWidth = this.getCellMinWidth();\n      }\n\n      var minWidth = this.getWorkSpaceMinWidth();\n\n      var groupCount = this._getGroupCount();\n\n      var totalCellCount = this._getTotalCellCount(groupCount);\n\n      var width = cellWidth * totalCellCount;\n\n      if (width < minWidth) {\n        width = minWidth;\n      }\n\n      setWidth(this._$headerPanel, width);\n      setWidth(this._$dateTable, width);\n\n      if (this._$allDayTable) {\n        setWidth(this._$allDayTable, width);\n      }\n\n      this._attachHeaderTableClasses();\n\n      this._updateGroupTableHeight();\n\n      this._updateScrollable();\n    }\n  }, {\n    key: \"getWorkSpaceMinWidth\",\n    value: function getWorkSpaceMinWidth() {\n      return this._groupedStrategy.getWorkSpaceMinWidth();\n    }\n  }, {\n    key: \"_dimensionChanged\",\n    value: function _dimensionChanged() {\n      if (!this._isVisible()) {\n        return;\n      }\n\n      if (this.option(\"crossScrollingEnabled\")) {\n        this._setTableSizes();\n      }\n\n      this.updateHeaderEmptyCellWidth();\n\n      this._updateScrollable();\n\n      this.cache.clear();\n    }\n  }, {\n    key: \"_needCreateCrossScrolling\",\n    value: function _needCreateCrossScrolling() {\n      return this.option(\"crossScrollingEnabled\");\n    }\n  }, {\n    key: \"_getElementClass\",\n    value: function _getElementClass() {\n      return noop();\n    }\n  }, {\n    key: \"_getRowCount\",\n    value: function _getRowCount() {\n      return this.viewDataProvider.getRowCount({\n        intervalCount: this.option(\"intervalCount\"),\n        currentDate: this.option(\"currentDate\"),\n        viewType: this.type,\n        hoursInterval: this.option(\"hoursInterval\"),\n        startDayHour: this.option(\"startDayHour\"),\n        endDayHour: this.option(\"endDayHour\")\n      });\n    }\n  }, {\n    key: \"_getCellCount\",\n    value: function _getCellCount() {\n      return this.viewDataProvider.getCellCount({\n        intervalCount: this.option(\"intervalCount\"),\n        currentDate: this.option(\"currentDate\"),\n        viewType: this.type,\n        hoursInterval: this.option(\"hoursInterval\"),\n        startDayHour: this.option(\"startDayHour\"),\n        endDayHour: this.option(\"endDayHour\")\n      });\n    }\n  }, {\n    key: \"isRenovatedRender\",\n    value: function isRenovatedRender() {\n      return this.renovatedRenderSupported() && this.option(\"renovateRender\");\n    }\n  }, {\n    key: \"_isVirtualModeOn\",\n    value: function _isVirtualModeOn() {\n      return \"virtual\" === this.option(\"scrolling.mode\");\n    }\n  }, {\n    key: \"isVirtualScrolling\",\n    value: function isVirtualScrolling() {\n      return this.isRenovatedRender() && this._isVirtualModeOn();\n    }\n  }, {\n    key: \"_initVirtualScrolling\",\n    value: function _initVirtualScrolling() {\n      if (this.virtualScrollingDispatcher) {\n        this.virtualScrollingDispatcher.dispose();\n        this.virtualScrollingDispatcher = null;\n      }\n\n      this.virtualScrollingDispatcher = new VirtualScrollingDispatcher(this._getVirtualScrollingDispatcherOptions());\n      this.virtualScrollingDispatcher.attachScrollableEvents();\n      this.renderer = new VirtualScrollingRenderer(this);\n    }\n  }, {\n    key: \"onDataSourceChanged\",\n    value: function onDataSourceChanged() {}\n  }, {\n    key: \"isGroupedAllDayPanel\",\n    value: function isGroupedAllDayPanel() {\n      return calculateIsGroupedAllDayPanel(this.option(\"groups\"), this.option(\"groupOrientation\"), this.isAllDayPanelVisible);\n    }\n  }, {\n    key: \"generateRenderOptions\",\n    value: function generateRenderOptions(isProvideVirtualCellsWidth) {\n      var _this$_getToday;\n\n      var groupCount = this._getGroupCount();\n\n      var groupOrientation = groupCount > 0 ? this.option(\"groupOrientation\") : this._getDefaultGroupStrategy();\n\n      var options = _extends({\n        groupByDate: this.option(\"groupByDate\"),\n        startRowIndex: 0,\n        startCellIndex: 0,\n        groupOrientation: groupOrientation,\n        today: null === (_this$_getToday = this._getToday) || void 0 === _this$_getToday ? void 0 : _this$_getToday.call(this),\n        groups: this.option(\"groups\"),\n        isProvideVirtualCellsWidth: isProvideVirtualCellsWidth,\n        isAllDayPanelVisible: this.isAllDayPanelVisible,\n        selectedCells: this.cellsSelectionState.getSelectedCells(),\n        focusedCell: this.cellsSelectionState.focusedCell,\n        headerCellTextFormat: this._getFormat(),\n        getDateForHeaderText: function getDateForHeaderText(_, date) {\n          return date;\n        },\n        startDayHour: this.option(\"startDayHour\"),\n        endDayHour: this.option(\"endDayHour\"),\n        cellDuration: this.getCellDuration(),\n        viewType: this.type,\n        intervalCount: this.option(\"intervalCount\"),\n        hoursInterval: this.option(\"hoursInterval\"),\n        currentDate: this.option(\"currentDate\"),\n        startDate: this.option(\"startDate\"),\n        firstDayOfWeek: this.option(\"firstDayOfWeek\")\n      }, this.virtualScrollingDispatcher.getRenderState());\n\n      return options;\n    }\n  }, {\n    key: \"renovatedRenderSupported\",\n    value: function renovatedRenderSupported() {\n      return true;\n    }\n  }, {\n    key: \"_updateGroupTableHeight\",\n    value: function _updateGroupTableHeight() {\n      if (this._isVerticalGroupedWorkSpace() && hasWindow()) {\n        this._setHorizontalGroupHeaderCellsHeight();\n      }\n    }\n  }, {\n    key: \"updateHeaderEmptyCellWidth\",\n    value: function updateHeaderEmptyCellWidth() {\n      if (hasWindow() && this._isRenderHeaderPanelEmptyCell()) {\n        var timePanelWidth = this.getTimePanelWidth();\n        var groupPanelWidth = this.getGroupTableWidth();\n\n        this._$headerPanelEmptyCell.css(\"width\", timePanelWidth + groupPanelWidth);\n      }\n    }\n  }, {\n    key: \"_isGroupsSpecified\",\n    value: function _isGroupsSpecified(resources) {\n      return this.option(\"groups\").length && resources;\n    }\n  }, {\n    key: \"_getGroupIndexByResourceId\",\n    value: function _getGroupIndexByResourceId(id) {\n      var groups = this.option(\"groups\");\n      var resourceTree = createResourcesTree(groups);\n\n      if (!resourceTree.length) {\n        return 0;\n      }\n\n      return this._getGroupIndexRecursively(resourceTree, id);\n    }\n  }, {\n    key: \"_getGroupIndexRecursively\",\n    value: function _getGroupIndexRecursively(resourceTree, id) {\n      var _this7 = this;\n\n      var currentKey = resourceTree[0].name;\n      var currentValue = id[currentKey];\n      return resourceTree.reduce(function (prevIndex, _ref) {\n        var leafIndex = _ref.leafIndex,\n            value = _ref.value,\n            children = _ref.children;\n        var areValuesEqual = currentValue === value;\n\n        if (areValuesEqual && void 0 !== leafIndex) {\n          return leafIndex;\n        }\n\n        if (areValuesEqual) {\n          return _this7._getGroupIndexRecursively(children, id);\n        }\n\n        return prevIndex;\n      }, 0);\n    }\n  }, {\n    key: \"_getViewStartByOptions\",\n    value: function _getViewStartByOptions() {\n      return getViewStartByOptions(this.option(\"startDate\"), this.option(\"currentDate\"), this._getIntervalDuration(), this.option(\"startDate\") ? this._calculateViewStartDate() : void 0);\n    }\n  }, {\n    key: \"_getIntervalDuration\",\n    value: function _getIntervalDuration() {\n      return this.viewDataProvider.getIntervalDuration(this.option(\"intervalCount\"));\n    }\n  }, {\n    key: \"_getHeaderDate\",\n    value: function _getHeaderDate() {\n      return this.getStartViewDate();\n    }\n  }, {\n    key: \"_calculateViewStartDate\",\n    value: function _calculateViewStartDate() {\n      return calculateViewStartDate(this.option(\"startDate\"));\n    }\n  }, {\n    key: \"_firstDayOfWeek\",\n    value: function _firstDayOfWeek() {\n      return this.viewDataProvider.getFirstDayOfWeek(this.option(\"firstDayOfWeek\"));\n    }\n  }, {\n    key: \"_attachEvents\",\n    value: function _attachEvents() {\n      this._createSelectionChangedAction();\n\n      this._attachClickEvent();\n\n      this._attachContextMenuEvent();\n    }\n  }, {\n    key: \"_attachClickEvent\",\n    value: function _attachClickEvent() {\n      var that = this;\n\n      var pointerDownAction = this._createAction(function (e) {\n        that._pointerDownHandler(e.event);\n      });\n\n      this._createCellClickAction();\n\n      var cellSelector = \".\" + DATE_TABLE_CELL_CLASS + \",.\" + ALL_DAY_TABLE_CELL_CLASS;\n      var $element = this.$element();\n      eventsEngine.off($element, SCHEDULER_WORKSPACE_DXPOINTERDOWN_EVENT_NAME);\n      eventsEngine.off($element, SCHEDULER_CELL_DXCLICK_EVENT_NAME);\n      eventsEngine.on($element, SCHEDULER_WORKSPACE_DXPOINTERDOWN_EVENT_NAME, function (e) {\n        if (isMouseEvent(e) && e.which > 1) {\n          e.preventDefault();\n          return;\n        }\n\n        pointerDownAction({\n          event: e\n        });\n      });\n      eventsEngine.on($element, SCHEDULER_CELL_DXCLICK_EVENT_NAME, cellSelector, function (e) {\n        var $cell = $(e.target);\n\n        that._cellClickAction({\n          event: e,\n          cellElement: getPublicElement($cell),\n          cellData: that.getCellData($cell)\n        });\n      });\n    }\n  }, {\n    key: \"_createCellClickAction\",\n    value: function _createCellClickAction() {\n      var _this8 = this;\n\n      this._cellClickAction = this._createActionByOption(\"onCellClick\", {\n        afterExecute: function afterExecute(e) {\n          return _this8._cellClickHandler(e.args[0].event);\n        }\n      });\n    }\n  }, {\n    key: \"_createSelectionChangedAction\",\n    value: function _createSelectionChangedAction() {\n      this._selectionChangedAction = this._createActionByOption(\"onSelectionChanged\");\n    }\n  }, {\n    key: \"_cellClickHandler\",\n    value: function _cellClickHandler() {\n      if (this._showPopup) {\n        delete this._showPopup;\n\n        this._handleSelectedCellsClick();\n      }\n    }\n  }, {\n    key: \"_pointerDownHandler\",\n    value: function _pointerDownHandler(e) {\n      var $target = $(e.target);\n\n      if (!$target.hasClass(DATE_TABLE_CELL_CLASS) && !$target.hasClass(ALL_DAY_TABLE_CELL_CLASS)) {\n        this._isCellClick = false;\n        return;\n      }\n\n      this._isCellClick = true;\n\n      if ($target.hasClass(DATE_TABLE_FOCUSED_CELL_CLASS)) {\n        this._showPopup = true;\n      } else {\n        var cellCoordinates = this._getCoordinatesByCell($target);\n\n        var isAllDayCell = this._hasAllDayClass($target);\n\n        this._setSelectedCellsStateAndUpdateSelection(isAllDayCell, cellCoordinates, false, $target);\n      }\n    }\n  }, {\n    key: \"_handleSelectedCellsClick\",\n    value: function _handleSelectedCellsClick() {\n      var selectedCells = this.cellsSelectionState.getSelectedCells();\n      var firstCellData = selectedCells[0];\n      var lastCellData = selectedCells[selectedCells.length - 1];\n      var result = {\n        startDate: firstCellData.startDate,\n        endDate: lastCellData.endDate\n      };\n\n      if (void 0 !== lastCellData.allDay) {\n        result.allDay = lastCellData.allDay;\n      }\n\n      this.option(\"onSelectedCellsClick\")(result, lastCellData.groups);\n    }\n  }, {\n    key: \"_attachContextMenuEvent\",\n    value: function _attachContextMenuEvent() {\n      this._createContextMenuAction();\n\n      var cellSelector = \".\" + DATE_TABLE_CELL_CLASS + \",.\" + ALL_DAY_TABLE_CELL_CLASS;\n      var $element = this.$element();\n      var eventName = addNamespace(contextMenuEventName, this.NAME);\n      eventsEngine.off($element, eventName, cellSelector);\n      eventsEngine.on($element, eventName, cellSelector, this._contextMenuHandler.bind(this));\n    }\n  }, {\n    key: \"_contextMenuHandler\",\n    value: function _contextMenuHandler(e) {\n      var $cell = $(e.target);\n\n      this._contextMenuAction({\n        event: e,\n        cellElement: getPublicElement($cell),\n        cellData: this.getCellData($cell)\n      });\n\n      this._contextMenuHandled = true;\n    }\n  }, {\n    key: \"_createContextMenuAction\",\n    value: function _createContextMenuAction() {\n      this._contextMenuAction = this._createActionByOption(\"onCellContextMenu\");\n    }\n  }, {\n    key: \"_getGroupHeaderContainer\",\n    value: function _getGroupHeaderContainer() {\n      if (this._isVerticalGroupedWorkSpace()) {\n        return this._$groupTable;\n      }\n\n      return this._$thead;\n    }\n  }, {\n    key: \"_getDateHeaderContainer\",\n    value: function _getDateHeaderContainer() {\n      return this._$thead;\n    }\n  }, {\n    key: \"_getCalculateHeaderCellRepeatCount\",\n    value: function _getCalculateHeaderCellRepeatCount() {\n      return this._groupedStrategy.calculateHeaderCellRepeatCount();\n    }\n  }, {\n    key: \"_updateScrollable\",\n    value: function _updateScrollable() {\n      var _this$_headerScrollab2, _this$_sidebarScrolla2;\n\n      this._dateTableScrollable.update();\n\n      null === (_this$_headerScrollab2 = this._headerScrollable) || void 0 === _this$_headerScrollab2 ? void 0 : _this$_headerScrollab2.update();\n      null === (_this$_sidebarScrolla2 = this._sidebarScrollable) || void 0 === _this$_sidebarScrolla2 ? void 0 : _this$_sidebarScrolla2.update();\n    }\n  }, {\n    key: \"_getTimePanelRowCount\",\n    value: function _getTimePanelRowCount() {\n      return this._getCellCountInDay();\n    }\n  }, {\n    key: \"_getCellCountInDay\",\n    value: function _getCellCountInDay() {\n      var hoursInterval = this.option(\"hoursInterval\");\n      var startDayHour = this.option(\"startDayHour\");\n      var endDayHour = this.option(\"endDayHour\");\n      return this.viewDataProvider.getCellCountInDay(startDayHour, endDayHour, hoursInterval);\n    }\n  }, {\n    key: \"_getTotalCellCount\",\n    value: function _getTotalCellCount(groupCount) {\n      return this._groupedStrategy.getTotalCellCount(groupCount);\n    }\n  }, {\n    key: \"_getTotalRowCount\",\n    value: function _getTotalRowCount(groupCount, includeAllDayPanelRows) {\n      var result = this._groupedStrategy.getTotalRowCount(groupCount);\n\n      if (includeAllDayPanelRows && this.isAllDayPanelVisible) {\n        result += groupCount;\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_getGroupIndex\",\n    value: function _getGroupIndex(rowIndex, columnIndex) {\n      return this._groupedStrategy.getGroupIndex(rowIndex, columnIndex);\n    }\n  }, {\n    key: \"calculateEndDate\",\n    value: function calculateEndDate(startDate) {\n      var viewDataGenerator = this.viewDataProvider.viewDataGenerator;\n      return viewDataGenerator.calculateEndDate(startDate, viewDataGenerator.getInterval(this.option(\"hoursInterval\")), this.option(\"endDayHour\"));\n    }\n  }, {\n    key: \"_getGroupCount\",\n    value: function _getGroupCount() {\n      return getGroupCount(this.option(\"groups\"));\n    }\n  }, {\n    key: \"_attachTablesEvents\",\n    value: function _attachTablesEvents() {\n      var element = this.$element();\n\n      this._attachDragEvents(element);\n\n      this._attachPointerEvents(element);\n    }\n  }, {\n    key: \"_detachDragEvents\",\n    value: function _detachDragEvents(element) {\n      eventsEngine.off(element, DragEventNames.ENTER);\n      eventsEngine.off(element, DragEventNames.LEAVE);\n      eventsEngine.off(element, DragEventNames.DROP);\n    }\n  }, {\n    key: \"_attachDragEvents\",\n    value: function _attachDragEvents(element) {\n      var _this9 = this;\n\n      this._detachDragEvents(element);\n\n      eventsEngine.on(element, DragEventNames.ENTER, DRAG_AND_DROP_SELECTOR, {\n        checkDropTarget: function checkDropTarget(target, event) {\n          return !_this9._isOutsideScrollable(target, event);\n        }\n      }, function (e) {\n        _this9.removeDroppableCellClass();\n\n        $(e.target).addClass(DATE_TABLE_DROPPABLE_CELL_CLASS);\n      });\n      eventsEngine.on(element, DragEventNames.LEAVE, function () {\n        return _this9.removeDroppableCellClass();\n      });\n      eventsEngine.on(element, DragEventNames.DROP, DRAG_AND_DROP_SELECTOR, function () {\n        return _this9.removeDroppableCellClass();\n      });\n    }\n  }, {\n    key: \"_attachPointerEvents\",\n    value: function _attachPointerEvents(element) {\n      var _this10 = this;\n\n      var isPointerDown = false;\n      eventsEngine.off(element, SCHEDULER_CELL_DXPOINTERMOVE_EVENT_NAME);\n      eventsEngine.off(element, SCHEDULER_CELL_DXPOINTERDOWN_EVENT_NAME);\n      eventsEngine.on(element, SCHEDULER_CELL_DXPOINTERDOWN_EVENT_NAME, DRAG_AND_DROP_SELECTOR, function (e) {\n        if (isMouseEvent(e) && 1 === e.which) {\n          isPointerDown = true;\n\n          _this10.$element().addClass(WORKSPACE_WITH_MOUSE_SELECTION_CLASS);\n\n          eventsEngine.off(domAdapter.getDocument(), SCHEDULER_CELL_DXPOINTERUP_EVENT_NAME);\n          eventsEngine.on(domAdapter.getDocument(), SCHEDULER_CELL_DXPOINTERUP_EVENT_NAME, function () {\n            isPointerDown = false;\n\n            _this10.$element().removeClass(WORKSPACE_WITH_MOUSE_SELECTION_CLASS);\n          });\n        }\n      });\n      eventsEngine.on(element, SCHEDULER_CELL_DXPOINTERMOVE_EVENT_NAME, DRAG_AND_DROP_SELECTOR, function (e) {\n        if (isPointerDown && _this10._dateTableScrollable && !_this10._dateTableScrollable.option(\"scrollByContent\")) {\n          e.preventDefault();\n          e.stopPropagation();\n\n          _this10._moveToCell($(e.target), true);\n        }\n      });\n    }\n  }, {\n    key: \"_getFormat\",\n    value: function _getFormat() {\n      return abstract();\n    }\n  }, {\n    key: \"getWorkArea\",\n    value: function getWorkArea() {\n      return this._$dateTableContainer;\n    }\n  }, {\n    key: \"getScrollable\",\n    value: function getScrollable() {\n      return this._dateTableScrollable;\n    }\n  }, {\n    key: \"getScrollableScrollTop\",\n    value: function getScrollableScrollTop() {\n      return this._dateTableScrollable.scrollTop();\n    }\n  }, {\n    key: \"getGroupedScrollableScrollTop\",\n    value: function getGroupedScrollableScrollTop(allDay) {\n      return this._groupedStrategy.getScrollableScrollTop(allDay);\n    }\n  }, {\n    key: \"getScrollableScrollLeft\",\n    value: function getScrollableScrollLeft() {\n      return this._dateTableScrollable.scrollLeft();\n    }\n  }, {\n    key: \"getScrollableOuterWidth\",\n    value: function getScrollableOuterWidth() {\n      return this._dateTableScrollable.scrollWidth();\n    }\n  }, {\n    key: \"getScrollableContainer\",\n    value: function getScrollableContainer() {\n      return $(this._dateTableScrollable.container());\n    }\n  }, {\n    key: \"getHeaderPanelHeight\",\n    value: function getHeaderPanelHeight() {\n      return this._$headerPanel && getOuterHeight(this._$headerPanel, true);\n    }\n  }, {\n    key: \"getTimePanelWidth\",\n    value: function getTimePanelWidth() {\n      return this._$timePanel && getBoundingRect(this._$timePanel.get(0)).width;\n    }\n  }, {\n    key: \"getGroupTableWidth\",\n    value: function getGroupTableWidth() {\n      return this._$groupTable ? getOuterWidth(this._$groupTable) : 0;\n    }\n  }, {\n    key: \"getWorkSpaceLeftOffset\",\n    value: function getWorkSpaceLeftOffset() {\n      return this._groupedStrategy.getLeftOffset();\n    }\n  }, {\n    key: \"_getCellCoordinatesByIndex\",\n    value: function _getCellCoordinatesByIndex(index) {\n      var columnIndex = Math.floor(index / this._getRowCount());\n      var rowIndex = index - this._getRowCount() * columnIndex;\n      return {\n        columnIndex: columnIndex,\n        rowIndex: rowIndex\n      };\n    }\n  }, {\n    key: \"_getDateGenerationOptions\",\n    value: function _getDateGenerationOptions() {\n      var _this$viewDataProvide;\n\n      return {\n        startDayHour: this.option(\"startDayHour\"),\n        endDayHour: this.option(\"endDayHour\"),\n        isWorkView: this.viewDataProvider.viewDataGenerator.isWorkView,\n        interval: null === (_this$viewDataProvide = this.viewDataProvider.viewDataGenerator) || void 0 === _this$viewDataProvide ? void 0 : _this$viewDataProvide.getInterval(this.option(\"hoursInterval\")),\n        startViewDate: this.getStartViewDate(),\n        firstDayOfWeek: this._firstDayOfWeek()\n      };\n    }\n  }, {\n    key: \"_getIntervalBetween\",\n    value: function _getIntervalBetween(currentDate, allDay) {\n      var firstViewDate = this.getStartViewDate();\n      var startDayTime = this.option(\"startDayHour\") * HOUR_MS;\n      var timeZoneOffset = dateUtils.getTimezonesDifference(firstViewDate, currentDate);\n      var fullInterval = currentDate.getTime() - firstViewDate.getTime() - timeZoneOffset;\n\n      var days = this._getDaysOfInterval(fullInterval, startDayTime);\n\n      var weekendsCount = this._getWeekendsCount(days);\n\n      var result = (days - weekendsCount) * DAY_MS;\n\n      if (!allDay) {\n        var hiddenInterval = this.viewDataProvider.hiddenInterval;\n        var visibleDayDuration = this.getVisibleDayDuration();\n        result = fullInterval - days * hiddenInterval - weekendsCount * visibleDayDuration;\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_getWeekendsCount\",\n    value: function _getWeekendsCount() {\n      return 0;\n    }\n  }, {\n    key: \"_getDaysOfInterval\",\n    value: function _getDaysOfInterval(fullInterval, startDayTime) {\n      return Math.floor((fullInterval + startDayTime) / DAY_MS);\n    }\n  }, {\n    key: \"_updateIndex\",\n    value: function _updateIndex(index) {\n      return index * this._getRowCount();\n    }\n  }, {\n    key: \"_getDroppableCell\",\n    value: function _getDroppableCell() {\n      return this._getDateTables().find(\".\" + DATE_TABLE_DROPPABLE_CELL_CLASS);\n    }\n  }, {\n    key: \"_getWorkSpaceWidth\",\n    value: function _getWorkSpaceWidth() {\n      var _this11 = this;\n\n      return this.cache.get(\"workspaceWidth\", function () {\n        if (_this11._needCreateCrossScrolling()) {\n          return getBoundingRect(_this11._$dateTable.get(0)).width;\n        }\n\n        var totalWidth = getBoundingRect(_this11.$element().get(0)).width;\n\n        var timePanelWidth = _this11.getTimePanelWidth();\n\n        var groupTableWidth = _this11.getGroupTableWidth();\n\n        return totalWidth - timePanelWidth - groupTableWidth;\n      });\n    }\n  }, {\n    key: \"_getCellByCoordinates\",\n    value: function _getCellByCoordinates(cellCoordinates, groupIndex, inAllDayRow) {\n      var indexes = this._groupedStrategy.prepareCellIndexes(cellCoordinates, groupIndex, inAllDayRow);\n\n      return this._dom_getDateCell(indexes);\n    }\n  }, {\n    key: \"_dom_getDateCell\",\n    value: function _dom_getDateCell(position) {\n      return this._$dateTable.find(\"tr:not(.\".concat(VIRTUAL_ROW_CLASS, \")\")).eq(position.rowIndex).find(\"td:not(.\".concat(VIRTUAL_CELL_CLASS, \")\")).eq(position.columnIndex);\n    }\n  }, {\n    key: \"_dom_getAllDayPanelCell\",\n    value: function _dom_getAllDayPanelCell(columnIndex) {\n      return this._$allDayPanel.find(\"tr\").eq(0).find(\"td\").eq(columnIndex);\n    }\n  }, {\n    key: \"_getCells\",\n    value: function _getCells(allDay, direction) {\n      var cellClass = allDay ? ALL_DAY_TABLE_CELL_CLASS : DATE_TABLE_CELL_CLASS;\n\n      if (\"vertical\" === direction) {\n        var result = [];\n\n        for (var i = 1;; i++) {\n          var cells = this.$element().find(\"tr .\".concat(cellClass, \":nth-child(\").concat(i, \")\"));\n\n          if (!cells.length) {\n            break;\n          }\n\n          result = result.concat(cells.toArray());\n        }\n\n        return $(result);\n      } else {\n        return this.$element().find(\".\" + cellClass);\n      }\n    }\n  }, {\n    key: \"_getAllCells\",\n    value: function _getAllCells(allDay) {\n      if (this._isVerticalGroupedWorkSpace()) {\n        return this._$dateTable.find(\"td:not(.\".concat(VIRTUAL_CELL_CLASS, \")\"));\n      }\n\n      var cellClass = allDay && this.supportAllDayRow() ? ALL_DAY_TABLE_CELL_CLASS : DATE_TABLE_CELL_CLASS;\n      return this.$element().find(\".\".concat(cellClass));\n    }\n  }, {\n    key: \"_setHorizontalGroupHeaderCellsHeight\",\n    value: function _setHorizontalGroupHeaderCellsHeight() {\n      var height = getBoundingRect(this._$dateTable.get(0)).height;\n      setOuterHeight(this._$groupTable, height);\n    }\n  }, {\n    key: \"_getGroupHeaderCells\",\n    value: function _getGroupHeaderCells() {\n      return this.$element().find(\".\" + GROUP_HEADER_CLASS);\n    }\n  }, {\n    key: \"_getScrollCoordinates\",\n    value: function _getScrollCoordinates(hours, minutes, date, groupIndex, allDay) {\n      var currentDate = date || new Date(this.option(\"currentDate\"));\n      var startDayHour = this.option(\"startDayHour\");\n      var endDayHour = this.option(\"endDayHour\");\n\n      if (hours < startDayHour) {\n        hours = startDayHour;\n      }\n\n      if (hours >= endDayHour) {\n        hours = endDayHour - 1;\n      }\n\n      currentDate.setHours(hours, minutes, 0, 0);\n      var cell = this.viewDataProvider.findGlobalCellPosition(currentDate, groupIndex, allDay);\n      var position = cell.position,\n          cellData = cell.cellData;\n      return this.virtualScrollingDispatcher.calculateCoordinatesByDataAndPosition(cellData, position, currentDate, isDateAndTimeView(this.type), \"vertical\" === this.viewDirection);\n    }\n  }, {\n    key: \"_isOutsideScrollable\",\n    value: function _isOutsideScrollable(target, event) {\n      var $dateTableScrollableElement = this._dateTableScrollable.$element();\n\n      var scrollableSize = getBoundingRect($dateTableScrollableElement.get(0));\n      var window = getWindow();\n      var isTargetInAllDayPanel = !$(target).closest($dateTableScrollableElement).length;\n      var isOutsideHorizontalScrollable = event.pageX < scrollableSize.left || event.pageX > scrollableSize.left + scrollableSize.width + (window.scrollX || 0);\n      var isOutsideVerticalScrollable = event.pageY < scrollableSize.top || event.pageY > scrollableSize.top + scrollableSize.height + (window.scrollY || 0);\n\n      if (isTargetInAllDayPanel && !isOutsideHorizontalScrollable) {\n        return false;\n      }\n\n      return isOutsideVerticalScrollable || isOutsideHorizontalScrollable;\n    }\n  }, {\n    key: \"setCellDataCache\",\n    value: function setCellDataCache(cellCoordinates, groupIndex, $cell) {\n      var key = JSON.stringify({\n        rowIndex: cellCoordinates.rowIndex,\n        columnIndex: cellCoordinates.columnIndex,\n        groupIndex: groupIndex\n      });\n      this.cache.set(key, this.getCellData($cell));\n    }\n  }, {\n    key: \"setCellDataCacheAlias\",\n    value: function setCellDataCacheAlias(appointment, geometry) {\n      var key = JSON.stringify({\n        rowIndex: appointment.rowIndex,\n        columnIndex: appointment.columnIndex,\n        groupIndex: appointment.groupIndex\n      });\n      var aliasKey = JSON.stringify({\n        top: geometry.top,\n        left: geometry.left\n      });\n      this.cache.set(aliasKey, this.cache.get(key));\n    }\n  }, {\n    key: \"supportAllDayRow\",\n    value: function supportAllDayRow() {\n      return true;\n    }\n  }, {\n    key: \"keepOriginalHours\",\n    value: function keepOriginalHours() {\n      return false;\n    }\n  }, {\n    key: \"_filterCellDataFields\",\n    value: function _filterCellDataFields(cellData) {\n      return extend(true, {}, {\n        startDate: cellData.startDate,\n        endDate: cellData.endDate,\n        groups: cellData.groups,\n        groupIndex: cellData.groupIndex,\n        allDay: cellData.allDay\n      });\n    }\n  }, {\n    key: \"getCellData\",\n    value: function getCellData($cell) {\n      var cellData = this._getFullCellData($cell) || {};\n      return this._filterCellDataFields(cellData);\n    }\n  }, {\n    key: \"_getFullCellData\",\n    value: function _getFullCellData($cell) {\n      var currentCell = $cell[0];\n\n      if (currentCell) {\n        return this._getDataByCell($cell);\n      }\n\n      return;\n    }\n  }, {\n    key: \"_getVirtualRowOffset\",\n    value: function _getVirtualRowOffset() {\n      return this.virtualScrollingDispatcher.virtualRowOffset;\n    }\n  }, {\n    key: \"_getVirtualCellOffset\",\n    value: function _getVirtualCellOffset() {\n      return this.virtualScrollingDispatcher.virtualCellOffset;\n    }\n  }, {\n    key: \"_getDataByCell\",\n    value: function _getDataByCell($cell) {\n      var rowIndex = $cell.parent().index() - this.virtualScrollingDispatcher.topVirtualRowsCount;\n      var columnIndex = $cell.index() - this.virtualScrollingDispatcher.leftVirtualCellsCount;\n      var viewDataProvider = this.viewDataProvider;\n\n      var isAllDayCell = this._hasAllDayClass($cell);\n\n      var cellData = viewDataProvider.getCellData(rowIndex, columnIndex, isAllDayCell);\n      return cellData ? cellData : void 0;\n    }\n  }, {\n    key: \"isGroupedByDate\",\n    value: function isGroupedByDate() {\n      return this.option(\"groupByDate\") && this._isHorizontalGroupedWorkSpace() && this._getGroupCount() > 0;\n    }\n  }, {\n    key: \"getCellIndexByDate\",\n    value: function getCellIndexByDate(date, inAllDayRow) {\n      var viewDataGenerator = this.viewDataProvider.viewDataGenerator;\n      var timeInterval = inAllDayRow ? 864e5 : viewDataGenerator.getInterval(this.option(\"hoursInterval\"));\n      var startViewDateOffset = getStartViewDateTimeOffset(this.getStartViewDate(), this.option(\"startDayHour\"));\n      var dateTimeStamp = this._getIntervalBetween(date, inAllDayRow) + startViewDateOffset;\n      var index = Math.floor(dateTimeStamp / timeInterval);\n\n      if (inAllDayRow) {\n        index = this._updateIndex(index);\n      }\n\n      if (index < 0) {\n        index = 0;\n      }\n\n      return index;\n    }\n  }, {\n    key: \"getDroppableCellIndex\",\n    value: function getDroppableCellIndex() {\n      var $droppableCell = this._getDroppableCell();\n\n      var $row = $droppableCell.parent();\n      var rowIndex = $row.index();\n      return rowIndex * $row.find(\"td\").length + $droppableCell.index();\n    }\n  }, {\n    key: \"getDataByDroppableCell\",\n    value: function getDataByDroppableCell() {\n      var cellData = this.getCellData($(this._getDroppableCell()));\n      var allDay = cellData.allDay;\n      var startDate = cellData.startDate;\n      var endDate = cellData.endDate;\n      return {\n        startDate: startDate,\n        endDate: endDate,\n        allDay: allDay,\n        groups: cellData.groups\n      };\n    }\n  }, {\n    key: \"getDateRange\",\n    value: function getDateRange() {\n      return [this.getStartViewDate(), this.getEndViewDateByEndDayHour()];\n    }\n  }, {\n    key: \"getCellMinWidth\",\n    value: function getCellMinWidth() {\n      return DATE_TABLE_MIN_CELL_WIDTH;\n    }\n  }, {\n    key: \"getRoundedCellWidth\",\n    value: function getRoundedCellWidth(groupIndex, startIndex, cellCount) {\n      if (groupIndex < 0 || !hasWindow()) {\n        return 0;\n      }\n\n      var $row = this.$element().find(\".\".concat(DATE_TABLE_ROW_CLASS)).eq(0);\n      var width = 0;\n      var $cells = $row.find(\".\" + DATE_TABLE_CELL_CLASS);\n      var totalCellCount = this._getCellCount() * groupIndex;\n      cellCount = cellCount || this._getCellCount();\n\n      if (!isDefined(startIndex)) {\n        startIndex = totalCellCount;\n      }\n\n      for (var i = startIndex; i < totalCellCount + cellCount; i++) {\n        var element = $($cells).eq(i).get(0);\n        var elementWidth = element ? getBoundingRect(element).width : 0;\n        width += elementWidth;\n      }\n\n      return width / (totalCellCount + cellCount - startIndex);\n    }\n  }, {\n    key: \"getCellWidth\",\n    value: function getCellWidth() {\n      return _getCellWidth(this.getDOMElementsMetaData());\n    }\n  }, {\n    key: \"getCellHeight\",\n    value: function getCellHeight() {\n      return _getCellHeight(this.getDOMElementsMetaData());\n    }\n  }, {\n    key: \"getAllDayHeight\",\n    value: function getAllDayHeight() {\n      return _getAllDayHeight(this.option(\"showAllDayPanel\"), this._isVerticalGroupedWorkSpace(), this.getDOMElementsMetaData());\n    }\n  }, {\n    key: \"getMaxAllowedPosition\",\n    value: function getMaxAllowedPosition(groupIndex) {\n      return _getMaxAllowedPosition(groupIndex, this.viewDataProvider, this.option(\"rtlEnabled\"), this.getDOMElementsMetaData());\n    }\n  }, {\n    key: \"getAllDayOffset\",\n    value: function getAllDayOffset() {\n      return this._groupedStrategy.getAllDayOffset();\n    }\n  }, {\n    key: \"getCellIndexByCoordinates\",\n    value: function getCellIndexByCoordinates(coordinates, allDay) {\n      var cellCount = this._getTotalCellCount(this._getGroupCount());\n\n      var cellWidth = Math.floor(this._getWorkSpaceWidth() / cellCount);\n      var cellHeight = allDay ? this.getAllDayHeight() : this.getCellHeight();\n      var topIndex = Math.floor(Math.floor(coordinates.top) / Math.floor(cellHeight));\n      var leftIndex = Math.floor((coordinates.left + 5) / cellWidth);\n\n      if (this._isRTL()) {\n        leftIndex = cellCount - leftIndex - 1;\n      }\n\n      return cellCount * topIndex + leftIndex;\n    }\n  }, {\n    key: \"getStartViewDate\",\n    value: function getStartViewDate() {\n      return this.viewDataProvider.getStartViewDate();\n    }\n  }, {\n    key: \"getEndViewDate\",\n    value: function getEndViewDate() {\n      return this.viewDataProvider.getLastCellEndDate();\n    }\n  }, {\n    key: \"getEndViewDateByEndDayHour\",\n    value: function getEndViewDateByEndDayHour() {\n      return this.viewDataProvider.getLastViewDateByEndDayHour(this.option(\"endDayHour\"));\n    }\n  }, {\n    key: \"getCellDuration\",\n    value: function getCellDuration() {\n      return _getCellDuration(this.type, this.option(\"startDayHour\"), this.option(\"endDayHour\"), this.option(\"hoursInterval\"));\n    }\n  }, {\n    key: \"getIntervalDuration\",\n    value: function getIntervalDuration(allDay) {\n      return allDay ? toMs(\"day\") : this.getCellDuration();\n    }\n  }, {\n    key: \"getVisibleDayDuration\",\n    value: function getVisibleDayDuration() {\n      var startDayHour = this.option(\"startDayHour\");\n      var endDayHour = this.option(\"endDayHour\");\n      var hoursInterval = this.option(\"hoursInterval\");\n      return this.viewDataProvider.getVisibleDayDuration(startDayHour, endDayHour, hoursInterval);\n    }\n  }, {\n    key: \"getGroupBounds\",\n    value: function getGroupBounds(coordinates) {\n      var cellCount = this._getCellCount();\n\n      var $cells = this._getCells();\n\n      var cellWidth = this.getCellWidth();\n      var groupedDataMap = this.viewDataProvider.groupedDataMap;\n\n      var result = this._groupedStrategy.getGroupBoundsOffset(cellCount, $cells, cellWidth, coordinates, groupedDataMap);\n\n      if (this._isRTL()) {\n        var startOffset = result.left;\n        result.left = result.right - 2 * cellWidth;\n        result.right = startOffset + 2 * cellWidth;\n      }\n\n      return result;\n    }\n  }, {\n    key: \"needRecalculateResizableArea\",\n    value: function needRecalculateResizableArea() {\n      return this._isVerticalGroupedWorkSpace() && 0 !== this.getScrollable().scrollTop();\n    }\n  }, {\n    key: \"getCellDataByCoordinates\",\n    value: function getCellDataByCoordinates(coordinates, allDay) {\n      var _this12 = this;\n\n      var key = JSON.stringify({\n        top: coordinates.top,\n        left: coordinates.left\n      });\n      return this.cache.get(key, function () {\n        var $cells = _this12._getCells(allDay);\n\n        var cellIndex = _this12.getCellIndexByCoordinates(coordinates, allDay);\n\n        var $cell = $cells.eq(cellIndex);\n        return _this12.getCellData($cell);\n      });\n    }\n  }, {\n    key: \"getVisibleBounds\",\n    value: function getVisibleBounds() {\n      var result = {};\n      var $scrollable = this.getScrollable().$element();\n      var cellHeight = this.getCellHeight();\n      var scrolledCellCount = this.getScrollableScrollTop() / cellHeight;\n      var totalCellCount = scrolledCellCount + getHeight($scrollable) / cellHeight;\n      result.top = {\n        hours: Math.floor(scrolledCellCount * this.option(\"hoursInterval\")) + this.option(\"startDayHour\"),\n        minutes: scrolledCellCount % 2 ? 30 : 0\n      };\n      result.bottom = {\n        hours: Math.floor(totalCellCount * this.option(\"hoursInterval\")) + this.option(\"startDayHour\"),\n        minutes: Math.floor(totalCellCount) % 2 ? 30 : 0\n      };\n      return result;\n    }\n  }, {\n    key: \"updateScrollPosition\",\n    value: function updateScrollPosition(date, groups) {\n      var allDay = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : false;\n      var newDate = this.timeZoneCalculator.createDate(date, {\n        path: \"toGrid\"\n      });\n      var inAllDayRow = allDay && this.isAllDayPanelVisible;\n\n      if (this.needUpdateScrollPosition(newDate, groups, inAllDayRow)) {\n        this.scrollTo(newDate, groups, inAllDayRow, false);\n      }\n    }\n  }, {\n    key: \"needUpdateScrollPosition\",\n    value: function needUpdateScrollPosition(date, groups, inAllDayRow) {\n      var _this13 = this;\n\n      var cells = this._getCellsInViewport(inAllDayRow);\n\n      var groupIndex = this._isGroupsSpecified(groups) ? this._getGroupIndexByResourceId(groups) : 0;\n      var time = date.getTime();\n      var trimmedTime = dateUtils.trimTime(date).getTime();\n      return cells.reduce(function (currentResult, cell) {\n        var _this13$getCellData = _this13.getCellData(cell),\n            cellStartDate = _this13$getCellData.startDate,\n            cellEndDate = _this13$getCellData.endDate,\n            cellGroupIndex = _this13$getCellData.groupIndex;\n\n        var cellStartTime = cellStartDate.getTime();\n        var cellEndTime = cellEndDate.getTime();\n\n        if ((!inAllDayRow && cellStartTime <= time && time < cellEndTime || inAllDayRow && trimmedTime === cellStartTime) && groupIndex === cellGroupIndex) {\n          return false;\n        }\n\n        return currentResult;\n      }, true);\n    }\n  }, {\n    key: \"_getCellsInViewport\",\n    value: function _getCellsInViewport(inAllDayRow) {\n      var $scrollable = this.getScrollable().$element();\n      var cellHeight = this.getCellHeight();\n      var cellWidth = this.getCellWidth();\n\n      var totalColumnCount = this._getTotalCellCount(this._getGroupCount());\n\n      var scrollableScrollTop = this.getScrollableScrollTop();\n      var scrollableScrollLeft = this.getScrollableScrollLeft();\n      var fullScrolledRowCount = scrollableScrollTop / cellHeight - this.virtualScrollingDispatcher.topVirtualRowsCount;\n      var scrolledRowCount = Math.floor(fullScrolledRowCount);\n\n      if (scrollableScrollTop % cellHeight !== 0) {\n        scrolledRowCount += 1;\n      }\n\n      var fullScrolledColumnCount = scrollableScrollLeft / cellWidth;\n      var scrolledColumnCount = Math.floor(fullScrolledColumnCount);\n\n      if (scrollableScrollLeft % cellWidth !== 0) {\n        scrolledColumnCount += 1;\n      }\n\n      var rowCount = Math.floor(fullScrolledRowCount + getHeight($scrollable) / cellHeight);\n      var columnCount = Math.floor(fullScrolledColumnCount + getWidth($scrollable) / cellWidth);\n\n      var $cells = this._getAllCells(inAllDayRow);\n\n      var result = [];\n      $cells.each(function (index) {\n        var $cell = $(this);\n        var columnIndex = index % totalColumnCount;\n        var rowIndex = index / totalColumnCount;\n\n        if (scrolledColumnCount <= columnIndex && columnIndex < columnCount && scrolledRowCount <= rowIndex && rowIndex < rowCount) {\n          result.push($cell);\n        }\n      });\n      return result;\n    }\n  }, {\n    key: \"scrollToTime\",\n    value: function scrollToTime(hours, minutes, date) {\n      if (!this._isValidScrollDate(date)) {\n        return;\n      }\n\n      var coordinates = this._getScrollCoordinates(hours, minutes, date);\n\n      var scrollable = this.getScrollable();\n      scrollable.scrollBy({\n        top: coordinates.top - scrollable.scrollTop(),\n        left: 0\n      });\n    }\n  }, {\n    key: \"scrollTo\",\n    value: function scrollTo(date, groups) {\n      var allDay = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : false;\n      var throwWarning = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : true;\n\n      if (!this._isValidScrollDate(date, throwWarning)) {\n        return;\n      }\n\n      var groupIndex = this._getGroupCount() && groups ? this._getGroupIndexByResourceId(groups) : 0;\n      var isScrollToAllDay = allDay && this.isAllDayPanelVisible;\n\n      var coordinates = this._getScrollCoordinates(date.getHours(), date.getMinutes(), date, groupIndex, isScrollToAllDay);\n\n      var scrollable = this.getScrollable();\n      var $scrollable = scrollable.$element();\n      var cellWidth = this.getCellWidth();\n      var offset = this.option(\"rtlEnabled\") ? cellWidth : 0;\n      var scrollableHeight = getHeight($scrollable);\n      var scrollableWidth = getWidth($scrollable);\n      var cellHeight = this.getCellHeight();\n      var xShift = (scrollableWidth - cellWidth) / 2;\n      var yShift = (scrollableHeight - cellHeight) / 2;\n      var left = coordinates.left - scrollable.scrollLeft() - xShift - offset;\n      var top = coordinates.top - scrollable.scrollTop() - yShift;\n\n      if (isScrollToAllDay && !this._isVerticalGroupedWorkSpace()) {\n        top = 0;\n      }\n\n      if (this.option(\"templatesRenderAsynchronously\")) {\n        setTimeout(function () {\n          scrollable.scrollBy({\n            left: left,\n            top: top\n          });\n        });\n      } else {\n        scrollable.scrollBy({\n          left: left,\n          top: top\n        });\n      }\n    }\n  }, {\n    key: \"_isValidScrollDate\",\n    value: function _isValidScrollDate(date) {\n      var throwWarning = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : true;\n      var min = this.getStartViewDate();\n      var max = this.getEndViewDate();\n\n      if (date < min || date > max) {\n        throwWarning && errors.log(\"W1008\", date);\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"needApplyCollectorOffset\",\n    value: function needApplyCollectorOffset() {\n      return false;\n    }\n  }, {\n    key: \"removeDroppableCellClass\",\n    value: function removeDroppableCellClass($cellElement) {\n      ($cellElement || this._getDroppableCell()).removeClass(DATE_TABLE_DROPPABLE_CELL_CLASS);\n    }\n  }, {\n    key: \"_getCoordinatesByCell\",\n    value: function _getCoordinatesByCell($cell) {\n      var columnIndex = $cell.index() - this.virtualScrollingDispatcher.leftVirtualCellsCount;\n      var rowIndex = $cell.parent().index();\n\n      var isAllDayCell = this._hasAllDayClass($cell);\n\n      var isVerticalGrouping = this._isVerticalGroupedWorkSpace();\n\n      if (!(isAllDayCell && !isVerticalGrouping)) {\n        rowIndex -= this.virtualScrollingDispatcher.topVirtualRowsCount;\n      }\n\n      return {\n        rowIndex: rowIndex,\n        columnIndex: columnIndex\n      };\n    }\n  }, {\n    key: \"_isShowAllDayPanel\",\n    value: function _isShowAllDayPanel() {\n      return this.option(\"showAllDayPanel\");\n    }\n  }, {\n    key: \"_getTimePanelCells\",\n    value: function _getTimePanelCells() {\n      return this.$element().find(\".\".concat(TIME_PANEL_CELL_CLASS));\n    }\n  }, {\n    key: \"_getRDateTableProps\",\n    value: function _getRDateTableProps() {\n      return {\n        viewData: this.viewDataProvider.viewData,\n        dataCellTemplate: this.option(\"dataCellTemplate\"),\n        addDateTableClass: !this.option(\"crossScrollingEnabled\") || this.isVirtualScrolling(),\n        groupOrientation: this.option(\"groupOrientation\"),\n        addVerticalSizesClassToRows: false\n      };\n    }\n  }, {\n    key: \"_updateSelectedCellDataOption\",\n    value: function _updateSelectedCellDataOption(selectedCellData) {\n      var correctedSelectedCellData = selectedCellData.map(function (_ref2) {\n        var startDate = _ref2.startDate,\n            endDate = _ref2.endDate,\n            allDay = _ref2.allDay,\n            groupIndex = _ref2.groupIndex,\n            groups = _ref2.groups;\n        return {\n          startDate: startDate,\n          endDate: endDate,\n          allDay: allDay,\n          groupIndex: groupIndex,\n          groups: groups\n        };\n      });\n      this.option(\"selectedCellData\", correctedSelectedCellData);\n\n      this._selectionChangedAction({\n        selectedCellData: correctedSelectedCellData\n      });\n    }\n  }, {\n    key: \"_getCellByData\",\n    value: function _getCellByData(cellData) {\n      var startDate = cellData.startDate,\n          groupIndex = cellData.groupIndex,\n          allDay = cellData.allDay,\n          index = cellData.index;\n      var position = this.viewDataProvider.findCellPositionInMap({\n        startDate: startDate,\n        groupIndex: groupIndex,\n        isAllDay: allDay,\n        index: index\n      });\n\n      if (!position) {\n        return;\n      }\n\n      return allDay && !this._isVerticalGroupedWorkSpace() ? this._dom_getAllDayPanelCell(position.columnIndex) : this._dom_getDateCell(position);\n    }\n  }, {\n    key: \"getDOMElementsMetaData\",\n    value: function getDOMElementsMetaData() {\n      var _this14 = this;\n\n      return this.cache.get(\"cellElementsMeta\", function () {\n        return {\n          dateTableCellsMeta: _this14._getDateTableDOMElementsInfo(),\n          allDayPanelCellsMeta: _this14._getAllDayPanelDOMElementsInfo()\n        };\n      });\n    }\n  }, {\n    key: \"_getDateTableDOMElementsInfo\",\n    value: function _getDateTableDOMElementsInfo() {\n      var _this15 = this;\n\n      var dateTableCells = this._getAllCells(false);\n\n      if (!dateTableCells.length || !hasWindow()) {\n        return [[{}]];\n      }\n\n      var dateTable = this._getDateTable();\n\n      var dateTableRect = getBoundingRect(dateTable.get(0));\n      var columnsCount = this.viewDataProvider.getColumnsCount();\n      var result = [];\n      dateTableCells.each(function (index, cell) {\n        var rowIndex = Math.floor(index / columnsCount);\n\n        if (result.length === rowIndex) {\n          result.push([]);\n        }\n\n        _this15._addCellMetaData(result[rowIndex], cell, dateTableRect);\n      });\n      return result;\n    }\n  }, {\n    key: \"_getAllDayPanelDOMElementsInfo\",\n    value: function _getAllDayPanelDOMElementsInfo() {\n      var _this16 = this;\n\n      var result = [];\n\n      if (this.isAllDayPanelVisible && !this._isVerticalGroupedWorkSpace() && hasWindow()) {\n        var allDayCells = this._getAllCells(true);\n\n        if (!allDayCells.length) {\n          return [{}];\n        }\n\n        var allDayAppointmentContainer = this._$allDayPanel;\n        var allDayPanelRect = getBoundingRect(allDayAppointmentContainer.get(0));\n        allDayCells.each(function (_, cell) {\n          _this16._addCellMetaData(result, cell, allDayPanelRect);\n        });\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_addCellMetaData\",\n    value: function _addCellMetaData(cellMetaDataArray, cell, parentRect) {\n      var cellRect = getBoundingRect(cell);\n      cellMetaDataArray.push({\n        left: cellRect.left - parentRect.left,\n        top: cellRect.top - parentRect.top,\n        width: cellRect.width,\n        height: cellRect.height\n      });\n    }\n  }, {\n    key: \"_oldRender_getAllDayCellData\",\n    value: function _oldRender_getAllDayCellData(groupIndex) {\n      var _this17 = this;\n\n      return function (cell, rowIndex, columnIndex) {\n        var validColumnIndex = columnIndex % _this17._getCellCount();\n\n        var options = _this17._getDateGenerationOptions(true);\n\n        var startDate = _this17.viewDataProvider.viewDataGenerator.getDateByCellIndices(options, rowIndex, validColumnIndex, _this17._getCellCountInDay());\n\n        startDate = dateUtils.trimTime(startDate);\n        var validGroupIndex = groupIndex || 0;\n\n        if (_this17.isGroupedByDate()) {\n          validGroupIndex = Math.floor(columnIndex % _this17._getGroupCount());\n        } else if (_this17._isHorizontalGroupedWorkSpace()) {\n          validGroupIndex = Math.floor(columnIndex / _this17._getCellCount());\n        }\n\n        var data = {\n          startDate: startDate,\n          endDate: startDate,\n          allDay: true,\n          groupIndex: validGroupIndex\n        };\n        var groupsArray = getCellGroups(validGroupIndex, _this17.option(\"groups\"));\n\n        if (groupsArray.length) {\n          data.groups = getGroupsObjectFromGroupsArray(groupsArray);\n        }\n\n        return {\n          key: CELL_DATA,\n          value: data\n        };\n      };\n    }\n  }, {\n    key: \"renderRWorkSpace\",\n    value: function renderRWorkSpace(componentsToRender) {\n      var components = null !== componentsToRender && void 0 !== componentsToRender ? componentsToRender : {\n        header: true,\n        timePanel: true,\n        dateTable: true,\n        allDayPanel: true\n      };\n      components.header && this.renderRHeaderPanel();\n      components.timePanel && this.renderRTimeTable();\n      components.dateTable && this.renderRDateTable();\n      components.allDayPanel && this.renderRAllDayPanel();\n    }\n  }, {\n    key: \"renderRDateTable\",\n    value: function renderRDateTable() {\n      utils.renovation.renderComponent(this, this._$dateTable, dxrDateTableLayout, \"renovatedDateTable\", this._getRDateTableProps());\n    }\n  }, {\n    key: \"renderRGroupPanel\",\n    value: function renderRGroupPanel() {\n      var options = {\n        groups: this.option(\"groups\"),\n        groupOrientation: this.option(\"groupOrientation\"),\n        groupByDate: this.isGroupedByDate(),\n        resourceCellTemplate: this.option(\"resourceCellTemplate\"),\n        className: this.verticalGroupTableClass,\n        groupPanelData: this.viewDataProvider.getGroupPanelData(this.generateRenderOptions())\n      };\n\n      if (this.option(\"groups\").length) {\n        this._attachGroupCountClass();\n\n        utils.renovation.renderComponent(this, this._getGroupHeaderContainer(), dxrGroupPanel, \"renovatedGroupPanel\", options);\n      } else {\n        this._detachGroupCountClass();\n      }\n    }\n  }, {\n    key: \"renderRAllDayPanel\",\n    value: function renderRAllDayPanel() {\n      var visible = this.isAllDayPanelVisible && !this.isGroupedAllDayPanel();\n\n      if (visible) {\n        var _this$virtualScrollin;\n\n        this._toggleAllDayVisibility(false);\n\n        var options = _extends({\n          viewData: this.viewDataProvider.viewData,\n          dataCellTemplate: this.option(\"dataCellTemplate\"),\n          startCellIndex: 0\n        }, (null === (_this$virtualScrollin = this.virtualScrollingDispatcher.horizontalVirtualScrolling) || void 0 === _this$virtualScrollin ? void 0 : _this$virtualScrollin.getRenderState()) || {});\n\n        utils.renovation.renderComponent(this, this._$allDayTable, dxrAllDayPanelTable, \"renovatedAllDayPanel\", options);\n        utils.renovation.renderComponent(this, this._$allDayTitle, dxrAllDayPanelTitle, \"renovatedAllDayPanelTitle\", {});\n      }\n\n      this._toggleAllDayVisibility(true);\n    }\n  }, {\n    key: \"renderRTimeTable\",\n    value: function renderRTimeTable() {\n      utils.renovation.renderComponent(this, this._$timePanel, dxrTimePanelTableLayout, \"renovatedTimePanel\", {\n        timePanelData: this.viewDataProvider.timePanelData,\n        timeCellTemplate: this.option(\"timeCellTemplate\"),\n        groupOrientation: this.option(\"groupOrientation\")\n      });\n    }\n  }, {\n    key: \"renderRHeaderPanel\",\n    value: function renderRHeaderPanel() {\n      var isRenderDateHeader = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : true;\n\n      if (this.option(\"groups\").length) {\n        this._attachGroupCountClass();\n      } else {\n        this._detachGroupCountClass();\n      }\n\n      utils.renovation.renderComponent(this, this._$thead, this.renovatedHeaderPanelComponent, \"renovatedHeaderPanel\", {\n        dateHeaderData: this.viewDataProvider.dateHeaderData,\n        groupPanelData: this.viewDataProvider.getGroupPanelData(this.generateRenderOptions()),\n        dateCellTemplate: this.option(\"dateCellTemplate\"),\n        timeCellTemplate: this.option(\"timeCellTemplate\"),\n        groups: this.option(\"groups\"),\n        groupByDate: this.isGroupedByDate(),\n        groupOrientation: this.option(\"groupOrientation\"),\n        resourceCellTemplate: this.option(\"resourceCellTemplate\"),\n        isRenderDateHeader: isRenderDateHeader\n      });\n    }\n  }, {\n    key: \"initDragBehavior\",\n    value: function initDragBehavior(scheduler) {\n      if (!this.dragBehavior && scheduler) {\n        this.dragBehavior = new AppointmentDragBehavior(scheduler);\n\n        this._createDragBehavior(this.getWorkArea());\n\n        this._createDragBehavior(this.getAllDayContainer());\n\n        this._createDragBehavior(this._$allDayPanel);\n      }\n    }\n  }, {\n    key: \"_createDragBehavior\",\n    value: function _createDragBehavior($element) {\n      var options = {\n        getItemData: function getItemData(itemElement, appointments) {\n          return appointments._getItemData(itemElement);\n        },\n        getItemSettings: function getItemSettings($itemElement) {\n          return $itemElement.data(APPOINTMENT_SETTINGS_KEY);\n        }\n      };\n\n      this._createDragBehaviorBase($element, options);\n    }\n  }, {\n    key: \"_createDragBehaviorBase\",\n    value: function _createDragBehaviorBase($element, options) {\n      var _this18 = this;\n\n      var container = this.$element().find(\".\".concat(FIXED_CONTAINER_CLASS));\n      var element = this.$element();\n      var isDefaultDraggingMode = \"default\" === this.option(\"draggingMode\");\n      this.dragBehavior.addTo($element, createDragBehaviorConfig(container, isDefaultDraggingMode, this.dragBehavior, function () {\n        return _this18._attachDragEvents(element);\n      }, function () {\n        return _this18._detachDragEvents(element);\n      }, function () {\n        return _this18._getDroppableCell();\n      }, function () {\n        return _this18._getDateTables();\n      }, function () {\n        return _this18.removeDroppableCellClass();\n      }, function () {\n        return _this18.getCellWidth();\n      }, options));\n    }\n  }, {\n    key: \"_isRenderHeaderPanelEmptyCell\",\n    value: function _isRenderHeaderPanelEmptyCell() {\n      return this._isVerticalGroupedWorkSpace();\n    }\n  }, {\n    key: \"_dispose\",\n    value: function _dispose() {\n      _get(_getPrototypeOf(SchedulerWorkSpace.prototype), \"_dispose\", this).call(this);\n\n      this.virtualScrollingDispatcher.dispose();\n    }\n  }, {\n    key: \"_getDefaultOptions\",\n    value: function _getDefaultOptions() {\n      return extend(_get(_getPrototypeOf(SchedulerWorkSpace.prototype), \"_getDefaultOptions\", this).call(this), {\n        currentDate: new Date(),\n        intervalCount: 1,\n        startDate: null,\n        firstDayOfWeek: void 0,\n        startDayHour: 0,\n        endDayHour: 24,\n        hoursInterval: .5,\n        activeStateEnabled: true,\n        hoverStateEnabled: true,\n        groups: [],\n        showAllDayPanel: true,\n        allDayExpanded: false,\n        onCellClick: null,\n        crossScrollingEnabled: false,\n        dataCellTemplate: null,\n        timeCellTemplate: null,\n        resourceCellTemplate: null,\n        dateCellTemplate: null,\n        allowMultipleCellSelection: true,\n        indicatorTime: new Date(),\n        indicatorUpdateInterval: 5 * toMs(\"minute\"),\n        shadeUntilCurrentTime: true,\n        groupOrientation: \"horizontal\",\n        selectedCellData: [],\n        groupByDate: false,\n        scrolling: {\n          mode: \"standard\"\n        },\n        renovateRender: true,\n        height: void 0,\n        draggingMode: \"outlook\",\n        onScrollEnd: function onScrollEnd() {},\n        getHeaderHeight: void 0,\n        onVirtualScrollingUpdated: void 0,\n        onSelectedCellsClick: function onSelectedCellsClick() {},\n        timeZoneCalculator: void 0,\n        schedulerHeight: void 0,\n        schedulerWidth: void 0\n      });\n    }\n  }, {\n    key: \"_optionChanged\",\n    value: function _optionChanged(args) {\n      switch (args.name) {\n        case \"startDayHour\":\n          validateDayHours(args.value, this.option(\"endDayHour\"));\n\n          this._cleanWorkSpace();\n\n          break;\n\n        case \"endDayHour\":\n          validateDayHours(this.option(\"startDayHour\"), args.value);\n\n          this._cleanWorkSpace();\n\n          break;\n\n        case \"dateCellTemplate\":\n        case \"resourceCellTemplate\":\n        case \"dataCellTemplate\":\n        case \"timeCellTemplate\":\n        case \"hoursInterval\":\n        case \"firstDayOfWeek\":\n        case \"currentDate\":\n        case \"startDate\":\n          this._cleanWorkSpace();\n\n          break;\n\n        case \"groups\":\n          this._cleanView();\n\n          this._removeAllDayElements();\n\n          this._initGrouping();\n\n          this.repaint();\n          break;\n\n        case \"groupOrientation\":\n          this._initGroupedStrategy();\n\n          this._createAllDayPanelElements();\n\n          this._removeAllDayElements();\n\n          this._cleanWorkSpace();\n\n          this._toggleGroupByDateClass();\n\n          break;\n\n        case \"showAllDayPanel\":\n          if (this._isVerticalGroupedWorkSpace()) {\n            this._cleanView();\n\n            this._removeAllDayElements();\n\n            this._initGrouping();\n\n            this.repaint();\n          } else if (!this.isRenovatedRender()) {\n            this._toggleAllDayVisibility(true);\n          } else {\n            this.renderWorkSpace();\n          }\n\n          break;\n\n        case \"allDayExpanded\":\n          this._changeAllDayVisibility();\n\n          this._attachTablesEvents();\n\n          this._updateScrollable();\n\n          break;\n\n        case \"onSelectionChanged\":\n          this._createSelectionChangedAction();\n\n          break;\n\n        case \"onCellClick\":\n          this._createCellClickAction();\n\n          break;\n\n        case \"onCellContextMenu\":\n          this._attachContextMenuEvent();\n\n          break;\n\n        case \"intervalCount\":\n          this._cleanWorkSpace();\n\n          this._toggleWorkSpaceCountClass();\n\n          break;\n\n        case \"groupByDate\":\n          this._cleanWorkSpace();\n\n          this._toggleGroupByDateClass();\n\n          break;\n\n        case \"crossScrollingEnabled\":\n          this._toggleHorizontalScrollClass();\n\n          this._dateTableScrollable.option(this._dateTableScrollableConfig());\n\n          break;\n\n        case \"width\":\n          _get(_getPrototypeOf(SchedulerWorkSpace.prototype), \"_optionChanged\", this).call(this, args);\n\n          this._dimensionChanged();\n\n          break;\n\n        case \"timeZoneCalculator\":\n        case \"allowMultipleCellSelection\":\n        case \"selectedCellData\":\n          break;\n\n        case \"renovateRender\":\n        case \"scrolling\":\n          this.repaint();\n          break;\n\n        case \"schedulerHeight\":\n        case \"schedulerWidth\":\n          this.virtualScrollingDispatcher.updateDimensions(true);\n          break;\n\n        default:\n          _get(_getPrototypeOf(SchedulerWorkSpace.prototype), \"_optionChanged\", this).call(this, args);\n\n      }\n    }\n  }, {\n    key: \"_getVirtualScrollingDispatcherOptions\",\n    value: function _getVirtualScrollingDispatcherOptions() {\n      var _this19 = this;\n\n      return {\n        getCellHeight: this.getCellHeight.bind(this),\n        getCellWidth: this.getCellWidth.bind(this),\n        getCellMinWidth: this.getCellMinWidth.bind(this),\n        isRTL: this._isRTL.bind(this),\n        getSchedulerHeight: function getSchedulerHeight() {\n          return _this19.option(\"schedulerHeight\");\n        },\n        getSchedulerWidth: function getSchedulerWidth() {\n          return _this19.option(\"schedulerWidth\");\n        },\n        getViewHeight: function getViewHeight() {\n          return _this19.$element().height ? _this19.$element().height() : getHeight(_this19.$element());\n        },\n        getViewWidth: function getViewWidth() {\n          return _this19.$element().width ? _this19.$element().width() : getWidth(_this19.$element());\n        },\n        getScrolling: function getScrolling() {\n          return _this19.option(\"scrolling\");\n        },\n        getScrollableOuterWidth: this.getScrollableOuterWidth.bind(this),\n        getScrollable: this.getScrollable.bind(this),\n        createAction: this._createAction.bind(this),\n        updateRender: this.updateRender.bind(this),\n        updateGrid: this.updateGrid.bind(this),\n        getGroupCount: this._getGroupCount.bind(this),\n        isVerticalGrouping: this._isVerticalGroupedWorkSpace.bind(this),\n        getTotalRowCount: this._getTotalRowCount.bind(this),\n        getTotalCellCount: this._getTotalCellCount.bind(this)\n      };\n    }\n  }, {\n    key: \"_cleanWorkSpace\",\n    value: function _cleanWorkSpace() {\n      this._cleanView();\n\n      this._toggleGroupedClass();\n\n      this._toggleWorkSpaceWithOddCells();\n\n      this.virtualScrollingDispatcher.updateDimensions(true);\n\n      this._renderView();\n\n      this.option(\"crossScrollingEnabled\") && this._setTableSizes();\n      this.cache.clear();\n    }\n  }, {\n    key: \"_init\",\n    value: function _init() {\n      this._headerSemaphore = new ScrollSemaphore();\n      this._sideBarSemaphore = new ScrollSemaphore();\n      this._dataTableSemaphore = new ScrollSemaphore();\n      this._viewDataProvider = null;\n      this._cellsSelectionState = null;\n      this._activeStateUnit = CELL_SELECTOR;\n\n      _get(_getPrototypeOf(SchedulerWorkSpace.prototype), \"_init\", this).call(this);\n\n      this._initGrouping();\n\n      this._toggleHorizontalScrollClass();\n\n      this._toggleWorkSpaceCountClass();\n\n      this._toggleGroupByDateClass();\n\n      this._toggleWorkSpaceWithOddCells();\n\n      this.$element().addClass(COMPONENT_CLASS).addClass(this._getElementClass());\n    }\n  }, {\n    key: \"_initPositionHelper\",\n    value: function _initPositionHelper() {\n      this.positionHelper = new PositionHelper({\n        key: this.option(\"key\"),\n        viewDataProvider: this.viewDataProvider,\n        viewStartDayHour: this.option(\"startDayHour\"),\n        viewEndDayHour: this.option(\"endDayHour\"),\n        cellDuration: this.getCellDuration(),\n        groupedStrategy: this._groupedStrategy,\n        isGroupedByDate: this.isGroupedByDate(),\n        rtlEnabled: this.option(\"rtlEnabled\"),\n        startViewDate: this.getStartViewDate(),\n        isVerticalGrouping: this._isVerticalGroupedWorkSpace(),\n        groupCount: this._getGroupCount(),\n        isVirtualScrolling: this.isVirtualScrolling(),\n        getDOMMetaDataCallback: this.getDOMElementsMetaData.bind(this)\n      });\n    }\n  }, {\n    key: \"_initGrouping\",\n    value: function _initGrouping() {\n      this._initGroupedStrategy();\n\n      this._toggleGroupingDirectionClass();\n\n      this._toggleGroupByDateClass();\n    }\n  }, {\n    key: \"isVerticalOrientation\",\n    value: function isVerticalOrientation() {\n      var orientation = this.option(\"groups\").length ? this.option(\"groupOrientation\") : this._getDefaultGroupStrategy();\n      return \"vertical\" === orientation;\n    }\n  }, {\n    key: \"_initGroupedStrategy\",\n    value: function _initGroupedStrategy() {\n      var Strategy = this.isVerticalOrientation() ? VerticalGroupedStrategy : HorizontalGroupedStrategy;\n      this._groupedStrategy = new Strategy(this);\n    }\n  }, {\n    key: \"_getDefaultGroupStrategy\",\n    value: function _getDefaultGroupStrategy() {\n      return \"horizontal\";\n    }\n  }, {\n    key: \"_toggleHorizontalScrollClass\",\n    value: function _toggleHorizontalScrollClass() {\n      this.$element().toggleClass(WORKSPACE_WITH_BOTH_SCROLLS_CLASS, this.option(\"crossScrollingEnabled\"));\n    }\n  }, {\n    key: \"_toggleGroupByDateClass\",\n    value: function _toggleGroupByDateClass() {\n      this.$element().toggleClass(WORKSPACE_WITH_GROUP_BY_DATE_CLASS, this.isGroupedByDate());\n    }\n  }, {\n    key: \"_toggleWorkSpaceCountClass\",\n    value: function _toggleWorkSpaceCountClass() {\n      this.$element().toggleClass(WORKSPACE_WITH_COUNT_CLASS, this._isWorkSpaceWithCount());\n    }\n  }, {\n    key: \"_toggleWorkSpaceWithOddCells\",\n    value: function _toggleWorkSpaceWithOddCells() {\n      this.$element().toggleClass(WORKSPACE_WITH_ODD_CELLS_CLASS, this._isWorkspaceWithOddCells());\n    }\n  }, {\n    key: \"_toggleGroupingDirectionClass\",\n    value: function _toggleGroupingDirectionClass() {\n      this.$element().toggleClass(VERTICAL_GROUPED_WORKSPACE_CLASS, this._isVerticalGroupedWorkSpace());\n    }\n  }, {\n    key: \"_getDateTableCellClass\",\n    value: function _getDateTableCellClass(rowIndex, columnIndex) {\n      var cellClass = DATE_TABLE_CELL_CLASS + \" \" + HORIZONTAL_SIZES_CLASS + \" \" + VERTICAL_SIZES_CLASS;\n      return this._groupedStrategy.addAdditionalGroupCellClasses(cellClass, columnIndex + 1, rowIndex, columnIndex);\n    }\n  }, {\n    key: \"_getGroupHeaderClass\",\n    value: function _getGroupHeaderClass(i) {\n      var cellClass = GROUP_HEADER_CLASS;\n      return this._groupedStrategy.addAdditionalGroupCellClasses(cellClass, i + 1);\n    }\n  }, {\n    key: \"_initWorkSpaceUnits\",\n    value: function _initWorkSpaceUnits() {\n      this._$headerPanelContainer = $(\"<div>\").addClass(\"dx-scheduler-header-panel-container\");\n      this._$headerTablesContainer = $(\"<div>\").addClass(\"dx-scheduler-header-tables-container\");\n      this._$headerPanel = $(\"<table>\");\n      this._$thead = $(\"<thead>\").appendTo(this._$headerPanel);\n      this._$headerPanelEmptyCell = $(\"<div>\").addClass(\"dx-scheduler-header-panel-empty-cell\");\n      this._$allDayTable = $(\"<table>\");\n      this._$fixedContainer = $(\"<div>\").addClass(FIXED_CONTAINER_CLASS);\n      this._$allDayContainer = $(\"<div>\").addClass(ALL_DAY_CONTAINER_CLASS);\n      this._$dateTableScrollableContent = $(\"<div>\").addClass(\"dx-scheduler-date-table-scrollable-content\");\n      this._$sidebarScrollableContent = $(\"<div>\").addClass(\"dx-scheduler-side-bar-scrollable-content\");\n\n      this._initAllDayPanelElements();\n\n      if (this.isRenovatedRender()) {\n        this.createRAllDayPanelElements();\n      } else {\n        this._createAllDayPanelElements();\n      }\n\n      this._$timePanel = $(\"<table>\").addClass(TIME_PANEL_CLASS);\n      this._$dateTable = $(\"<table>\");\n      this._$dateTableContainer = $(\"<div>\").addClass(\"dx-scheduler-date-table-container\");\n      this._$groupTable = $(\"<div>\").addClass(WORKSPACE_VERTICAL_GROUP_TABLE_CLASS);\n    }\n  }, {\n    key: \"_initAllDayPanelElements\",\n    value: function _initAllDayPanelElements() {\n      this._allDayTitles = [];\n      this._allDayTables = [];\n      this._allDayPanels = [];\n    }\n  }, {\n    key: \"_initDateTableScrollable\",\n    value: function _initDateTableScrollable() {\n      var $dateTableScrollable = $(\"<div>\").addClass(SCHEDULER_DATE_TABLE_SCROLLABLE_CLASS);\n      this._dateTableScrollable = this._createComponent($dateTableScrollable, Scrollable, this._dateTableScrollableConfig());\n    }\n  }, {\n    key: \"_createWorkSpaceElements\",\n    value: function _createWorkSpaceElements() {\n      if (this.option(\"crossScrollingEnabled\")) {\n        this._createWorkSpaceScrollableElements();\n      } else {\n        this._createWorkSpaceStaticElements();\n      }\n    }\n  }, {\n    key: \"_createWorkSpaceStaticElements\",\n    value: function _createWorkSpaceStaticElements() {\n      this._$dateTableContainer.append(this._$dateTable);\n\n      if (this._isVerticalGroupedWorkSpace()) {\n        this._$dateTableContainer.append(this._$allDayContainer);\n\n        this._$dateTableScrollableContent.append(this._$groupTable, this._$timePanel, this._$dateTableContainer);\n\n        this._dateTableScrollable.$content().append(this._$dateTableScrollableContent);\n\n        this._$headerTablesContainer.append(this._$headerPanel);\n      } else {\n        var _this$_$allDayPanel;\n\n        this._$dateTableScrollableContent.append(this._$timePanel, this._$dateTableContainer);\n\n        this._dateTableScrollable.$content().append(this._$dateTableScrollableContent);\n\n        this._$headerTablesContainer.append(this._$headerPanel, this._$allDayPanel);\n\n        null === (_this$_$allDayPanel = this._$allDayPanel) || void 0 === _this$_$allDayPanel ? void 0 : _this$_$allDayPanel.append(this._$allDayContainer, this._$allDayTable);\n      }\n\n      this._appendHeaderPanelEmptyCellIfNecessary();\n\n      this._$headerPanelContainer.append(this._$headerTablesContainer);\n\n      this.$element().append(this._$fixedContainer, this._$headerPanelContainer, this._dateTableScrollable.$element());\n    }\n  }, {\n    key: \"_createWorkSpaceScrollableElements\",\n    value: function _createWorkSpaceScrollableElements() {\n      this.$element().append(this._$fixedContainer);\n      this._$flexContainer = $(\"<div>\").addClass(\"dx-scheduler-work-space-flex-container\");\n\n      this._createHeaderScrollable();\n\n      this._headerScrollable.$content().append(this._$headerPanel);\n\n      this._appendHeaderPanelEmptyCellIfNecessary();\n\n      this._$headerPanelContainer.append(this._$headerTablesContainer);\n\n      this.$element().append(this._$headerPanelContainer);\n      this.$element().append(this._$flexContainer);\n\n      this._createSidebarScrollable();\n\n      this._$flexContainer.append(this._dateTableScrollable.$element());\n\n      this._$dateTableContainer.append(this._$dateTable);\n\n      this._$dateTableScrollableContent.append(this._$dateTableContainer);\n\n      this._dateTableScrollable.$content().append(this._$dateTableScrollableContent);\n\n      if (this._isVerticalGroupedWorkSpace()) {\n        this._$dateTableContainer.append(this._$allDayContainer);\n\n        this._$sidebarScrollableContent.append(this._$groupTable, this._$timePanel);\n      } else {\n        var _this$_$allDayPanel2;\n\n        this._headerScrollable.$content().append(this._$allDayPanel);\n\n        null === (_this$_$allDayPanel2 = this._$allDayPanel) || void 0 === _this$_$allDayPanel2 ? void 0 : _this$_$allDayPanel2.append(this._$allDayContainer, this._$allDayTable);\n\n        this._$sidebarScrollableContent.append(this._$timePanel);\n      }\n\n      this._sidebarScrollable.$content().append(this._$sidebarScrollableContent);\n    }\n  }, {\n    key: \"_appendHeaderPanelEmptyCellIfNecessary\",\n    value: function _appendHeaderPanelEmptyCellIfNecessary() {\n      this._isRenderHeaderPanelEmptyCell() && this._$headerPanelContainer.append(this._$headerPanelEmptyCell);\n    }\n  }, {\n    key: \"_createHeaderScrollable\",\n    value: function _createHeaderScrollable() {\n      var $headerScrollable = $(\"<div>\").addClass(SCHEDULER_HEADER_SCROLLABLE_CLASS).appendTo(this._$headerTablesContainer);\n      this._headerScrollable = this._createComponent($headerScrollable, Scrollable, this._headerScrollableConfig());\n    }\n  }, {\n    key: \"_createSidebarScrollable\",\n    value: function _createSidebarScrollable() {\n      var _this20 = this;\n\n      var $timePanelScrollable = $(\"<div>\").addClass(SCHEDULER_SIDEBAR_SCROLLABLE_CLASS).appendTo(this._$flexContainer);\n      this._sidebarScrollable = this._createComponent($timePanelScrollable, Scrollable, {\n        useKeyboard: false,\n        showScrollbar: \"never\",\n        direction: \"vertical\",\n        useNative: false,\n        updateManually: true,\n        bounceEnabled: false,\n        onScroll: function onScroll(e) {\n          _this20._sideBarSemaphore.take(e.scrollOffset);\n\n          if (_this20._dataTableSemaphore.isFree(e.scrollOffset)) {\n            _this20._dateTableScrollable.scrollTo({\n              top: e.scrollOffset.top\n            });\n          }\n\n          _this20._sideBarSemaphore.release();\n        }\n      });\n    }\n  }, {\n    key: \"_attachTableClasses\",\n    value: function _attachTableClasses() {\n      this._addTableClass(this._$dateTable, DATE_TABLE_CLASS);\n\n      if (this._isVerticalGroupedWorkSpace()) {\n        var groupCount = this._getGroupCount();\n\n        for (var i = 0; i < groupCount; i++) {\n          this._addTableClass(this._allDayTables[i], ALL_DAY_TABLE_CLASS);\n        }\n      } else if (!this.isRenovatedRender()) {\n        this._addTableClass(this._$allDayTable, ALL_DAY_TABLE_CLASS);\n      }\n    }\n  }, {\n    key: \"_attachHeaderTableClasses\",\n    value: function _attachHeaderTableClasses() {\n      this._addTableClass(this._$headerPanel, HEADER_PANEL_CLASS);\n    }\n  }, {\n    key: \"_addTableClass\",\n    value: function _addTableClass($el, className) {\n      $el && !$el.hasClass(className) && $el.addClass(className);\n    }\n  }, {\n    key: \"_initMarkup\",\n    value: function _initMarkup() {\n      this.cache.clear();\n\n      this._initWorkSpaceUnits();\n\n      this._initVirtualScrolling();\n\n      this._initDateTableScrollable();\n\n      this._createWorkSpaceElements();\n\n      _get(_getPrototypeOf(SchedulerWorkSpace.prototype), \"_initMarkup\", this).call(this);\n\n      if (!this.option(\"crossScrollingEnabled\")) {\n        this._attachTableClasses();\n\n        this._attachHeaderTableClasses();\n      }\n\n      this._toggleGroupedClass();\n\n      this._renderView();\n\n      this._attachEvents();\n    }\n  }, {\n    key: \"_render\",\n    value: function _render() {\n      _get(_getPrototypeOf(SchedulerWorkSpace.prototype), \"_render\", this).call(this);\n\n      this._renderDateTimeIndication();\n\n      this._setIndicationUpdateInterval();\n    }\n  }, {\n    key: \"_toggleGroupedClass\",\n    value: function _toggleGroupedClass() {\n      this.$element().toggleClass(GROUPED_WORKSPACE_CLASS, this._getGroupCount() > 0);\n    }\n  }, {\n    key: \"_renderView\",\n    value: function _renderView() {\n      if (this.isRenovatedRender()) {\n        if (this._isVerticalGroupedWorkSpace()) {\n          this.renderRGroupPanel();\n        }\n      } else {\n        this._applyCellTemplates(this._renderGroupHeader());\n      }\n\n      this.renderWorkSpace();\n\n      this._updateGroupTableHeight();\n\n      this.updateHeaderEmptyCellWidth();\n      this._shader = new VerticalShader(this);\n    }\n  }, {\n    key: \"updateCellsSelection\",\n    value: function updateCellsSelection() {\n      var renderOptions = this.generateRenderOptions();\n      this.viewDataProvider.updateViewData(renderOptions);\n      this.renderRWorkSpace({\n        timePanel: true,\n        dateTable: true,\n        allDayPanel: true\n      });\n    }\n  }, {\n    key: \"_renderDateTimeIndication\",\n    value: function _renderDateTimeIndication() {\n      return noop();\n    }\n  }, {\n    key: \"_setIndicationUpdateInterval\",\n    value: function _setIndicationUpdateInterval() {\n      return noop();\n    }\n  }, {\n    key: \"_refreshDateTimeIndication\",\n    value: function _refreshDateTimeIndication() {\n      return noop();\n    }\n  }, {\n    key: \"_detachGroupCountClass\",\n    value: function _detachGroupCountClass() {\n      var _this21 = this;\n\n      _toConsumableArray(VERTICAL_GROUP_COUNT_CLASSES).forEach(function (className) {\n        _this21.$element().removeClass(className);\n      });\n    }\n  }, {\n    key: \"_attachGroupCountClass\",\n    value: function _attachGroupCountClass() {\n      var className = this._groupedStrategy.getGroupCountClass(this.option(\"groups\"));\n\n      this.$element().addClass(className);\n    }\n  }, {\n    key: \"_getDateHeaderTemplate\",\n    value: function _getDateHeaderTemplate() {\n      return this.option(\"dateCellTemplate\");\n    }\n  }, {\n    key: \"_toggleAllDayVisibility\",\n    value: function _toggleAllDayVisibility(isUpdateScrollable) {\n      var showAllDayPanel = this._isShowAllDayPanel();\n\n      this.$element().toggleClass(WORKSPACE_WITH_ALL_DAY_CLASS, showAllDayPanel);\n\n      this._changeAllDayVisibility();\n\n      isUpdateScrollable && this._updateScrollable();\n    }\n  }, {\n    key: \"_changeAllDayVisibility\",\n    value: function _changeAllDayVisibility() {\n      this.cache.clear();\n      this.$element().toggleClass(WORKSPACE_WITH_COLLAPSED_ALL_DAY_CLASS, !this.option(\"allDayExpanded\") && this._isShowAllDayPanel());\n    }\n  }, {\n    key: \"_getDateTables\",\n    value: function _getDateTables() {\n      return this._$dateTable.add(this._$allDayTable);\n    }\n  }, {\n    key: \"_getDateTable\",\n    value: function _getDateTable() {\n      return this._$dateTable;\n    }\n  }, {\n    key: \"_removeAllDayElements\",\n    value: function _removeAllDayElements() {\n      this._$allDayTable && this._$allDayTable.remove();\n      this._$allDayTitle && this._$allDayTitle.remove();\n    }\n  }, {\n    key: \"_cleanView\",\n    value: function _cleanView() {\n      var _this$_shader;\n\n      this.cache.clear();\n\n      this._cleanTableWidths();\n\n      this.cellsSelectionState.clearSelectedAndFocusedCells();\n\n      if (!this.isRenovatedRender()) {\n        var _this$_$allDayTable, _this$_$sidebarTable;\n\n        this._$thead.empty();\n\n        this._$dateTable.empty();\n\n        this._$timePanel.empty();\n\n        this._$groupTable.empty();\n\n        null === (_this$_$allDayTable = this._$allDayTable) || void 0 === _this$_$allDayTable ? void 0 : _this$_$allDayTable.empty();\n        null === (_this$_$sidebarTable = this._$sidebarTable) || void 0 === _this$_$sidebarTable ? void 0 : _this$_$sidebarTable.empty();\n      }\n\n      null === (_this$_shader = this._shader) || void 0 === _this$_shader ? void 0 : _this$_shader.clean();\n      delete this._interval;\n    }\n  }, {\n    key: \"_clean\",\n    value: function _clean() {\n      eventsEngine.off(domAdapter.getDocument(), SCHEDULER_CELL_DXPOINTERUP_EVENT_NAME);\n\n      this._disposeRenovatedComponents();\n\n      _get(_getPrototypeOf(SchedulerWorkSpace.prototype), \"_clean\", this).call(this);\n    }\n  }, {\n    key: \"_cleanTableWidths\",\n    value: function _cleanTableWidths() {\n      this._$headerPanel.css(\"width\", \"\");\n\n      this._$dateTable.css(\"width\", \"\");\n\n      this._$allDayTable && this._$allDayTable.css(\"width\", \"\");\n    }\n  }, {\n    key: \"_disposeRenovatedComponents\",\n    value: function _disposeRenovatedComponents() {\n      var _this$renovatedAllDay, _this$renovatedDateTa, _this$renovatedTimePa, _this$renovatedGroupP, _this$renovatedHeader;\n\n      null === (_this$renovatedAllDay = this.renovatedAllDayPanel) || void 0 === _this$renovatedAllDay ? void 0 : _this$renovatedAllDay.dispose();\n      this.renovatedAllDayPanel = void 0;\n      null === (_this$renovatedDateTa = this.renovatedDateTable) || void 0 === _this$renovatedDateTa ? void 0 : _this$renovatedDateTa.dispose();\n      this.renovatedDateTable = void 0;\n      null === (_this$renovatedTimePa = this.renovatedTimePanel) || void 0 === _this$renovatedTimePa ? void 0 : _this$renovatedTimePa.dispose();\n      this.renovatedTimePanel = void 0;\n      null === (_this$renovatedGroupP = this.renovatedGroupPanel) || void 0 === _this$renovatedGroupP ? void 0 : _this$renovatedGroupP.dispose();\n      this.renovatedGroupPanel = void 0;\n      null === (_this$renovatedHeader = this.renovatedHeaderPanel) || void 0 === _this$renovatedHeader ? void 0 : _this$renovatedHeader.dispose();\n      this.renovatedHeaderPanel = void 0;\n    }\n  }, {\n    key: \"getGroupedStrategy\",\n    value: function getGroupedStrategy() {\n      return this._groupedStrategy;\n    }\n  }, {\n    key: \"getFixedContainer\",\n    value: function getFixedContainer() {\n      return this._$fixedContainer;\n    }\n  }, {\n    key: \"getAllDayContainer\",\n    value: function getAllDayContainer() {\n      return this._$allDayContainer;\n    }\n  }, {\n    key: \"updateRender\",\n    value: function updateRender() {\n      this.renderer.updateRender();\n    }\n  }, {\n    key: \"updateGrid\",\n    value: function updateGrid() {\n      this.renderer._renderGrid();\n    }\n  }, {\n    key: \"updateAppointments\",\n    value: function updateAppointments() {\n      var _this$dragBehavior;\n\n      this.option(\"onVirtualScrollingUpdated\")();\n      null === (_this$dragBehavior = this.dragBehavior) || void 0 === _this$dragBehavior ? void 0 : _this$dragBehavior.updateDragSource();\n    }\n  }, {\n    key: \"_createAllDayPanelElements\",\n    value: function _createAllDayPanelElements() {\n      var groupCount = this._getGroupCount();\n\n      if (this._isVerticalGroupedWorkSpace() && 0 !== groupCount) {\n        for (var i = 0; i < groupCount; i++) {\n          var $allDayTitle = $(\"<div>\").addClass(ALL_DAY_TITLE_CLASS).text(messageLocalization.format(\"dxScheduler-allDay\"));\n\n          this._allDayTitles.push($allDayTitle);\n\n          this._$allDayTable = $(\"<table>\");\n\n          this._allDayTables.push(this._$allDayTable);\n\n          this._$allDayPanel = $(\"<div>\").addClass(ALL_DAY_PANEL_CLASS).append(this._$allDayTable);\n\n          this._allDayPanels.push(this._$allDayPanel);\n        }\n      } else {\n        this._$allDayTitle = $(\"<div>\").addClass(ALL_DAY_TITLE_CLASS).text(messageLocalization.format(\"dxScheduler-allDay\")).appendTo(this.$element());\n        this._$allDayTable = $(\"<table>\");\n        this._$allDayPanel = $(\"<div>\").addClass(ALL_DAY_PANEL_CLASS).append(this._$allDayTable);\n      }\n    }\n  }, {\n    key: \"renderWorkSpace\",\n    value: function renderWorkSpace() {\n      var isGenerateNewViewData = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : true;\n      this.cache.clear();\n      this.viewDataProvider.update(this.generateRenderOptions(), isGenerateNewViewData);\n\n      if (this.isRenovatedRender()) {\n        this.renderRWorkSpace();\n        this.virtualScrollingDispatcher.updateDimensions();\n      } else {\n        this._renderDateHeader();\n\n        this._renderTimePanel();\n\n        this._renderGroupAllDayPanel();\n\n        this._renderDateTable();\n\n        this._renderAllDayPanel();\n      }\n\n      this._initPositionHelper();\n    }\n  }, {\n    key: \"_renderGroupHeader\",\n    value: function _renderGroupHeader() {\n      var $container = this._getGroupHeaderContainer();\n\n      var groupCount = this._getGroupCount();\n\n      var cellTemplates = [];\n\n      if (groupCount) {\n        var groupRows = this._makeGroupRows(this.option(\"groups\"), this.option(\"groupByDate\"));\n\n        this._attachGroupCountClass();\n\n        $container.append(groupRows.elements);\n        cellTemplates = groupRows.cellTemplates;\n      } else {\n        this._detachGroupCountClass();\n      }\n\n      return cellTemplates;\n    }\n  }, {\n    key: \"_applyCellTemplates\",\n    value: function _applyCellTemplates(templates) {\n      null === templates || void 0 === templates ? void 0 : templates.forEach(function (template) {\n        template();\n      });\n    }\n  }, {\n    key: \"_makeGroupRows\",\n    value: function _makeGroupRows(groups, groupByDate) {\n      var tableCreatorStrategy = this._isVerticalGroupedWorkSpace() ? tableCreator.VERTICAL : tableCreator.HORIZONTAL;\n      return tableCreator.makeGroupedTable(tableCreatorStrategy, groups, {\n        groupHeaderRowClass: GROUP_ROW_CLASS,\n        groupRowClass: GROUP_ROW_CLASS,\n        groupHeaderClass: this._getGroupHeaderClass.bind(this),\n        groupHeaderContentClass: GROUP_HEADER_CONTENT_CLASS\n      }, this._getCellCount() || 1, this.option(\"resourceCellTemplate\"), this._getGroupCount(), groupByDate);\n    }\n  }, {\n    key: \"_renderDateHeader\",\n    value: function _renderDateHeader() {\n      var container = this._getDateHeaderContainer();\n\n      var $headerRow = $(\"<tr>\").addClass(HEADER_ROW_CLASS);\n\n      var count = this._getCellCount();\n\n      var cellTemplate = this._getDateHeaderTemplate();\n\n      var repeatCount = this._getCalculateHeaderCellRepeatCount();\n\n      var templateCallbacks = [];\n      var groupByDate = this.isGroupedByDate();\n\n      if (!groupByDate) {\n        for (var rowIndex = 0; rowIndex < repeatCount; rowIndex++) {\n          for (var columnIndex = 0; columnIndex < count; columnIndex++) {\n            var templateIndex = rowIndex * count + columnIndex;\n\n            this._renderDateHeaderTemplate($headerRow, columnIndex, templateIndex, cellTemplate, templateCallbacks);\n          }\n        }\n\n        container.append($headerRow);\n      } else {\n        var colSpan = groupByDate ? this._getGroupCount() : 1;\n\n        for (var _columnIndex = 0; _columnIndex < count; _columnIndex++) {\n          var _templateIndex = _columnIndex * repeatCount;\n\n          var cellElement = this._renderDateHeaderTemplate($headerRow, _columnIndex, _templateIndex, cellTemplate, templateCallbacks);\n\n          cellElement.attr(\"colSpan\", colSpan);\n        }\n\n        container.prepend($headerRow);\n      }\n\n      this._applyCellTemplates(templateCallbacks);\n\n      return $headerRow;\n    }\n  }, {\n    key: \"_renderDateHeaderTemplate\",\n    value: function _renderDateHeaderTemplate(container, panelCellIndex, templateIndex, cellTemplate, templateCallbacks) {\n      var validTemplateIndex = this.isGroupedByDate() ? Math.floor(templateIndex / this._getGroupCount()) : templateIndex;\n      var completeDateHeaderMap = this.viewDataProvider.completeDateHeaderMap;\n      var _completeDateHeaderMa = completeDateHeaderMap[completeDateHeaderMap.length - 1][validTemplateIndex],\n          text = _completeDateHeaderMa.text,\n          date = _completeDateHeaderMa.startDate;\n      var $cell = $(\"<th>\").addClass(this._getHeaderPanelCellClass(panelCellIndex)).attr(\"title\", text);\n\n      if (null !== cellTemplate && void 0 !== cellTemplate && cellTemplate.render) {\n        templateCallbacks.push(cellTemplate.render.bind(cellTemplate, {\n          model: _extends({\n            text: text,\n            date: date\n          }, this._getGroupsForDateHeaderTemplate(templateIndex)),\n          index: templateIndex,\n          container: getPublicElement($cell)\n        }));\n      } else {\n        $cell.text(text);\n      }\n\n      container.append($cell);\n      return $cell;\n    }\n  }, {\n    key: \"_getGroupsForDateHeaderTemplate\",\n    value: function _getGroupsForDateHeaderTemplate(templateIndex) {\n      var indexMultiplier = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;\n      var groupIndex;\n      var groups;\n\n      if (this._isHorizontalGroupedWorkSpace() && !this.isGroupedByDate()) {\n        groupIndex = this._getGroupIndex(0, templateIndex * indexMultiplier);\n        var groupsArray = getCellGroups(groupIndex, this.option(\"groups\"));\n        groups = getGroupsObjectFromGroupsArray(groupsArray);\n      }\n\n      return {\n        groups: groups,\n        groupIndex: groupIndex\n      };\n    }\n  }, {\n    key: \"_getHeaderPanelCellClass\",\n    value: function _getHeaderPanelCellClass(i) {\n      var cellClass = HEADER_PANEL_CELL_CLASS + \" \" + HORIZONTAL_SIZES_CLASS;\n      return this._groupedStrategy.addAdditionalGroupCellClasses(cellClass, i + 1, void 0, void 0, this.isGroupedByDate());\n    }\n  }, {\n    key: \"_renderAllDayPanel\",\n    value: function _renderAllDayPanel(index) {\n      var cellCount = this._getCellCount();\n\n      if (!this._isVerticalGroupedWorkSpace()) {\n        cellCount *= this._getGroupCount() || 1;\n      }\n\n      var cellTemplates = this._renderTableBody({\n        container: this._allDayPanels.length ? getPublicElement(this._allDayTables[index]) : getPublicElement(this._$allDayTable),\n        rowCount: 1,\n        cellCount: cellCount,\n        cellClass: this._getAllDayPanelCellClass.bind(this),\n        rowClass: ALL_DAY_TABLE_ROW_CLASS,\n        cellTemplate: this.option(\"dataCellTemplate\"),\n        getCellData: this._oldRender_getAllDayCellData(index),\n        groupIndex: index\n      }, true);\n\n      this._toggleAllDayVisibility(true);\n\n      this._applyCellTemplates(cellTemplates);\n    }\n  }, {\n    key: \"_renderGroupAllDayPanel\",\n    value: function _renderGroupAllDayPanel() {\n      if (this._isVerticalGroupedWorkSpace()) {\n        var groupCount = this._getGroupCount();\n\n        for (var i = 0; i < groupCount; i++) {\n          this._renderAllDayPanel(i);\n        }\n      }\n    }\n  }, {\n    key: \"_getAllDayPanelCellClass\",\n    value: function _getAllDayPanelCellClass(i, j) {\n      var cellClass = ALL_DAY_TABLE_CELL_CLASS + \" \" + HORIZONTAL_SIZES_CLASS;\n      return this._groupedStrategy.addAdditionalGroupCellClasses(cellClass, j + 1);\n    }\n  }, {\n    key: \"_renderTimePanel\",\n    value: function _renderTimePanel() {\n      var _this22 = this;\n\n      var repeatCount = this._groupedStrategy.calculateTimeCellRepeatCount();\n\n      var getData = function getData(rowIndex, field) {\n        var allDayPanelsCount = 0;\n\n        if (_this22.isAllDayPanelVisible) {\n          allDayPanelsCount = 1;\n        }\n\n        if (_this22.isGroupedAllDayPanel()) {\n          allDayPanelsCount = Math.ceil((rowIndex + 1) / _this22._getRowCount());\n        }\n\n        var validRowIndex = rowIndex + allDayPanelsCount;\n        return _this22.viewDataProvider.completeTimePanelMap[validRowIndex][field];\n      };\n\n      this._renderTableBody({\n        container: getPublicElement(this._$timePanel),\n        rowCount: this._getTimePanelRowCount() * repeatCount,\n        cellCount: 1,\n        cellClass: this._getTimeCellClass.bind(this),\n        rowClass: TIME_PANEL_ROW_CLASS,\n        cellTemplate: this.option(\"timeCellTemplate\"),\n        getCellText: function getCellText(rowIndex) {\n          return getData(rowIndex, \"text\");\n        },\n        getCellDate: function getCellDate(rowIndex) {\n          return getData(rowIndex, \"startDate\");\n        },\n        groupCount: this._getGroupCount(),\n        allDayElements: this._insertAllDayRowsIntoDateTable() ? this._allDayTitles : void 0,\n        getTemplateData: function (rowIndex) {\n          if (!_this22._isVerticalGroupedWorkSpace()) {\n            return {};\n          }\n\n          var groupIndex = _this22._getGroupIndex(rowIndex, 0);\n\n          var groupsArray = getCellGroups(groupIndex, _this22.option(\"groups\"));\n          var groups = getGroupsObjectFromGroupsArray(groupsArray);\n          return {\n            groupIndex: groupIndex,\n            groups: groups\n          };\n        }.bind(this)\n      });\n    }\n  }, {\n    key: \"_getTimeCellClass\",\n    value: function _getTimeCellClass(i) {\n      var cellClass = TIME_PANEL_CELL_CLASS + \" \" + VERTICAL_SIZES_CLASS;\n      return this._isVerticalGroupedWorkSpace() ? this._groupedStrategy.addAdditionalGroupCellClasses(cellClass, i, i) : cellClass;\n    }\n  }, {\n    key: \"_renderDateTable\",\n    value: function _renderDateTable() {\n      var _this23 = this;\n\n      var groupCount = this._getGroupCount();\n\n      this._renderTableBody({\n        container: getPublicElement(this._$dateTable),\n        rowCount: this._getTotalRowCount(groupCount),\n        cellCount: this._getTotalCellCount(groupCount),\n        cellClass: this._getDateTableCellClass.bind(this),\n        rowClass: DATE_TABLE_ROW_CLASS,\n        cellTemplate: this.option(\"dataCellTemplate\"),\n        getCellData: function getCellData(_, rowIndex, columnIndex) {\n          var isGroupedAllDayPanel = _this23.isGroupedAllDayPanel();\n\n          var validRowIndex = rowIndex;\n\n          if (isGroupedAllDayPanel) {\n            var rowCount = _this23._getRowCount();\n\n            var allDayPanelsCount = Math.ceil(rowIndex / rowCount);\n            validRowIndex += allDayPanelsCount;\n          }\n\n          var cellData = _this23.viewDataProvider.viewDataMap.dateTableMap[validRowIndex][columnIndex].cellData;\n          return {\n            value: _this23._filterCellDataFields(cellData),\n            fullValue: cellData,\n            key: CELL_DATA\n          };\n        },\n        allDayElements: this._insertAllDayRowsIntoDateTable() ? this._allDayPanels : void 0,\n        groupCount: groupCount,\n        groupByDate: this.option(\"groupByDate\")\n      });\n    }\n  }, {\n    key: \"_insertAllDayRowsIntoDateTable\",\n    value: function _insertAllDayRowsIntoDateTable() {\n      return this._groupedStrategy.insertAllDayRowsIntoDateTable();\n    }\n  }, {\n    key: \"_renderTableBody\",\n    value: function _renderTableBody(options, delayCellTemplateRendering) {\n      var result = [];\n\n      if (!delayCellTemplateRendering) {\n        this._applyCellTemplates(tableCreator.makeTable(options));\n      } else {\n        result = tableCreator.makeTable(options);\n      }\n\n      return result;\n    }\n  }]);\n\n  return SchedulerWorkSpace;\n}(WidgetObserver);\n\nvar createDragBehaviorConfig = function createDragBehaviorConfig(container, isDefaultDraggingMode, dragBehavior, attachGeneralEvents, detachGeneralEvents, getDroppableCell, getDateTables, removeDroppableCellClass, getCellWidth, options) {\n  var state = {\n    dragElement: void 0,\n    itemData: void 0\n  };\n\n  var isItemDisabled = function isItemDisabled() {\n    var itemData = state.itemData;\n\n    if (itemData) {\n      var getter = compileGetter(\"disabled\");\n      return getter(itemData);\n    }\n\n    return true;\n  };\n\n  var cursorOffset = options.isSetCursorOffset ? function () {\n    var $dragElement = $(state.dragElement);\n    return {\n      x: getWidth($dragElement) / 2,\n      y: getHeight($dragElement) / 2\n    };\n  } : void 0;\n  return {\n    container: container,\n    dragTemplate: function dragTemplate() {\n      return state.dragElement;\n    },\n    onDragStart: function onDragStart(e) {\n      if (!isDefaultDraggingMode) {\n        detachGeneralEvents();\n      }\n\n      var canceled = e.cancel;\n      var event = e.event;\n      var $itemElement = $(e.itemElement);\n      var appointments = e.component._appointments;\n      state.itemData = options.getItemData(e.itemElement, appointments);\n      var settings = options.getItemSettings($itemElement, e);\n      var initialPosition = options.initialPosition;\n\n      if (!isItemDisabled()) {\n        event.data = event.data || {};\n\n        if (!canceled) {\n          if (!settings.isCompact) {\n            dragBehavior.updateDragSource(state.itemData, settings);\n          }\n\n          state.dragElement = function (itemData, settings, appointments) {\n            var appointmentIndex = appointments.option(\"items\").length;\n            settings.isCompact = false;\n            settings.virtual = false;\n\n            var items = appointments._renderItem(appointmentIndex, {\n              itemData: itemData,\n              settings: [settings]\n            });\n\n            return items[0];\n          }(state.itemData, settings, appointments);\n\n          event.data.itemElement = state.dragElement;\n          event.data.initialPosition = null !== initialPosition && void 0 !== initialPosition ? initialPosition : locate($(state.dragElement));\n          event.data.itemData = state.itemData;\n          event.data.itemSettings = settings;\n          dragBehavior.onDragStart(event.data);\n          resetPosition($(state.dragElement));\n        }\n      }\n    },\n    onDragMove: function onDragMove() {\n      if (isDefaultDraggingMode) {\n        return;\n      }\n\n      var appointmentWidth = getWidth(state.dragElement);\n      var cellWidth = getCellWidth();\n      var isWideAppointment = appointmentWidth > cellWidth;\n      var dragElementContainer = $(state.dragElement).parent();\n      var boundingRect = getBoundingRect(dragElementContainer.get(0));\n      var newX = boundingRect.left + 10;\n      var newY = boundingRect.top + 10;\n      var elements = isWideAppointment ? domAdapter.elementsFromPoint(newX, newY) : domAdapter.elementsFromPoint(newX + appointmentWidth / 2, newY);\n      var dateTables = getDateTables();\n      var droppableCell = elements.find(function (el) {\n        var classList = el.classList;\n        var isCurrentSchedulerElement = 1 === dateTables.find(el).length;\n        return isCurrentSchedulerElement && (classList.contains(DATE_TABLE_CELL_CLASS) || classList.contains(ALL_DAY_TABLE_CELL_CLASS));\n      });\n\n      if (droppableCell) {\n        var oldDroppableCell = getDroppableCell();\n\n        if (!oldDroppableCell.is(droppableCell)) {\n          removeDroppableCellClass();\n        }\n\n        $(droppableCell).addClass(DATE_TABLE_DROPPABLE_CELL_CLASS);\n      }\n    },\n    onDragEnd: function onDragEnd(e) {\n      var _state$dragElement;\n\n      if (!isDefaultDraggingMode) {\n        attachGeneralEvents();\n      }\n\n      if (!isItemDisabled()) {\n        dragBehavior.onDragEnd(e);\n      }\n\n      null === (_state$dragElement = state.dragElement) || void 0 === _state$dragElement ? void 0 : _state$dragElement.remove();\n      removeDroppableCellClass();\n    },\n    cursorOffset: cursorOffset,\n    filter: options.filter\n  };\n};\n\nexport default SchedulerWorkSpace;","map":null,"metadata":{},"sourceType":"module"}