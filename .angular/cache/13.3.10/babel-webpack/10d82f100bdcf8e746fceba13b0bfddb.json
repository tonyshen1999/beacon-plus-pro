{"ast":null,"code":"/**\r\n * DevExtreme (esm/viz/series/area_series.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { clone } from \"../../core/utils/object\";\nimport { extend } from \"../../core/utils/extend\";\nimport { chart as scatterSeries } from \"./scatter_series\";\nimport { chart as lineSeriesChart, polar as lineSeriesPolar } from \"./line_series\";\nvar chartLineSeries = lineSeriesChart.line;\nvar polarLineSeries = lineSeriesPolar.line;\nimport { map as _map } from \"../core/utils\";\nvar _extend = extend;\nvar calculateBezierPoints = lineSeriesChart.spline._calculateBezierPoints;\nvar chart = {};\nvar polar = {};\nvar baseAreaMethods = {\n  _createBorderElement: chartLineSeries._createMainElement,\n  _createLegendState: function _createLegendState(styleOptions, defaultColor) {\n    return {\n      fill: styleOptions.color || defaultColor,\n      opacity: styleOptions.opacity,\n      hatching: styleOptions.hatching\n    };\n  },\n  getValueRangeInitialValue: function getValueRangeInitialValue() {\n    if (\"logarithmic\" !== this.valueAxisType && \"datetime\" !== this.valueType && false !== this.showZero) {\n      return 0;\n    } else {\n      return scatterSeries.getValueRangeInitialValue.call(this);\n    }\n  },\n  _getDefaultSegment: function _getDefaultSegment(segment) {\n    var defaultSegment = chartLineSeries._getDefaultSegment(segment);\n\n    defaultSegment.area = defaultSegment.line.concat(defaultSegment.line.slice().reverse());\n    return defaultSegment;\n  },\n  _updateElement: function _updateElement(element, segment, animate, complete) {\n    var lineParams = {\n      points: segment.line\n    };\n    var areaParams = {\n      points: segment.area\n    };\n    var borderElement = element.line;\n\n    if (animate) {\n      borderElement && borderElement.animate(lineParams);\n      element.area.animate(areaParams, {}, complete);\n    } else {\n      borderElement && borderElement.attr(lineParams);\n      element.area.attr(areaParams);\n    }\n  },\n  _removeElement: function _removeElement(element) {\n    element.line && element.line.remove();\n    element.area.remove();\n  },\n  _drawElement: function _drawElement(segment) {\n    return {\n      line: this._bordersGroup && this._createBorderElement(segment.line, {\n        \"stroke-width\": this._styles.normal.border[\"stroke-width\"]\n      }).append(this._bordersGroup),\n      area: this._createMainElement(segment.area).append(this._elementsGroup)\n    };\n  },\n  _applyStyle: function _applyStyle(style) {\n    this._elementsGroup && this._elementsGroup.smartAttr(style.elements);\n    this._bordersGroup && this._bordersGroup.attr(style.border);\n    (this._graphics || []).forEach(function (graphic) {\n      graphic.line && graphic.line.attr({\n        \"stroke-width\": style.border[\"stroke-width\"]\n      }).sharp();\n    });\n  },\n  _parseStyle: function _parseStyle(options, defaultColor, defaultBorderColor) {\n    var borderOptions = options.border || {};\n\n    var borderStyle = chartLineSeries._parseLineOptions(borderOptions, defaultBorderColor);\n\n    borderStyle.stroke = borderOptions.visible && borderStyle[\"stroke-width\"] ? borderStyle.stroke : \"none\";\n    borderStyle[\"stroke-width\"] = borderStyle[\"stroke-width\"] || 1;\n    return {\n      border: borderStyle,\n      elements: {\n        stroke: \"none\",\n        fill: options.color || defaultColor,\n        hatching: options.hatching,\n        opacity: options.opacity\n      }\n    };\n  },\n  _areBordersVisible: function _areBordersVisible() {\n    var options = this._options;\n    return options.border.visible || options.hoverStyle.border.visible || options.selectionStyle.border.visible;\n  },\n  _createMainElement: function _createMainElement(points, settings) {\n    return this._renderer.path(points, \"area\").attr(settings);\n  },\n  _getTrackerSettings: function _getTrackerSettings(segment) {\n    return {\n      \"stroke-width\": segment.singlePointSegment ? this._defaultTrackerWidth : 0\n    };\n  },\n  _getMainPointsFromSegment: function _getMainPointsFromSegment(segment) {\n    return segment.area;\n  }\n};\n\nfunction createAreaPoints(points) {\n  return _map(points, function (pt) {\n    return pt.getCoords();\n  }).concat(_map(points.slice().reverse(), function (pt) {\n    return pt.getCoords(true);\n  }));\n}\n\nvar areaSeries = chart.area = _extend({}, chartLineSeries, baseAreaMethods, {\n  _prepareSegment: function _prepareSegment(points, rotated) {\n    var processedPoints = this._processSinglePointsAreaSegment(points, rotated);\n\n    var areaPoints = createAreaPoints(processedPoints);\n    var argAxis = this.getArgumentAxis();\n\n    if (argAxis.getAxisPosition) {\n      var argAxisPosition = argAxis.getAxisPosition();\n      var axisOptions = argAxis.getOptions();\n      var edgeOffset = (!rotated ? -1 : 1) * Math.round(axisOptions.width / 2);\n\n      if (axisOptions.visible) {\n        areaPoints.forEach(function (p, i) {\n          if (p) {\n            var index = 1 === points.length ? 0 : i < points.length ? i : areaPoints.length - 1 - i;\n            rotated && p.x === points[index].defaultX && p.x === argAxisPosition - argAxis.getAxisShift() && (p.x += edgeOffset);\n            !rotated && p.y === points[index].defaultY && p.y === argAxisPosition - argAxis.getAxisShift() && (p.y += edgeOffset);\n          }\n        });\n      }\n    }\n\n    return {\n      line: processedPoints,\n      area: areaPoints,\n      singlePointSegment: processedPoints !== points\n    };\n  },\n  _processSinglePointsAreaSegment: function _processSinglePointsAreaSegment(points, rotated) {\n    if (points && 1 === points.length) {\n      var p = points[0];\n      var p1 = clone(p);\n      p1[rotated ? \"y\" : \"x\"] += 1;\n      p1.argument = null;\n      return [p, p1];\n    }\n\n    return points;\n  }\n});\n\npolar.area = _extend({}, polarLineSeries, baseAreaMethods, {\n  _prepareSegment: function _prepareSegment(points, rotated, lastSegment) {\n    lastSegment && polarLineSeries._closeSegment.call(this, points);\n    return areaSeries._prepareSegment.call(this, points);\n  },\n  _processSinglePointsAreaSegment: function _processSinglePointsAreaSegment(points) {\n    return lineSeriesPolar.line._prepareSegment.call(this, points).line;\n  }\n});\nchart.steparea = _extend({}, areaSeries, {\n  _prepareSegment: function _prepareSegment(points, rotated) {\n    var stepLineSeries = lineSeriesChart.stepline;\n    points = areaSeries._processSinglePointsAreaSegment(points, rotated);\n    return areaSeries._prepareSegment.call(this, stepLineSeries._calculateStepLinePoints.call(this, points), rotated);\n  },\n  getSeriesPairCoord: lineSeriesChart.stepline.getSeriesPairCoord\n});\nchart.splinearea = _extend({}, areaSeries, {\n  _areaPointsToSplineAreaPoints: function _areaPointsToSplineAreaPoints(areaPoints) {\n    var previousMiddlePoint = areaPoints[areaPoints.length / 2 - 1];\n    var middlePoint = areaPoints[areaPoints.length / 2];\n    areaPoints.splice(areaPoints.length / 2, 0, {\n      x: previousMiddlePoint.x,\n      y: previousMiddlePoint.y\n    }, {\n      x: middlePoint.x,\n      y: middlePoint.y\n    });\n  },\n  _prepareSegment: function _prepareSegment(points, rotated) {\n    var processedPoints = areaSeries._processSinglePointsAreaSegment(points, rotated);\n\n    var areaSegment = areaSeries._prepareSegment.call(this, calculateBezierPoints(processedPoints, rotated));\n\n    this._areaPointsToSplineAreaPoints(areaSegment.area);\n\n    areaSegment.singlePointSegment = processedPoints !== points;\n    return areaSegment;\n  },\n  _getDefaultSegment: function _getDefaultSegment(segment) {\n    var areaDefaultSegment = areaSeries._getDefaultSegment(segment);\n\n    this._areaPointsToSplineAreaPoints(areaDefaultSegment.area);\n\n    return areaDefaultSegment;\n  },\n  _createMainElement: function _createMainElement(points, settings) {\n    return this._renderer.path(points, \"bezierarea\").attr(settings);\n  },\n  _createBorderElement: lineSeriesChart.spline._createMainElement,\n  getSeriesPairCoord: lineSeriesChart.spline.getSeriesPairCoord,\n  _getNearestPoints: lineSeriesChart.spline._getNearestPoints,\n  _getBezierPoints: lineSeriesChart.spline._getBezierPoints,\n  obtainCubicBezierTCoef: lineSeriesChart.spline.obtainCubicBezierTCoef\n});\nexport { chart, polar };","map":null,"metadata":{},"sourceType":"module"}