{"ast":null,"code":"/**\r\n * DevExtreme (esm/viz/range_selector/sliders_controller.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { noop } from \"../../core/utils/common\";\nimport { utils, consts } from \"./common\";\nimport Slider from \"./slider\";\nimport { normalizeEnum as _normalizeEnum, rangesAreEqual, adjustVisualRange } from \"../core/utils\";\nimport { isNumeric, isDefined } from \"../../core/utils/type\";\nimport { adjust } from \"../../core/utils/math\";\nvar animationSettings = utils.animationSettings;\nvar emptySliderMarkerText = consts.emptySliderMarkerText;\n\nfunction buildRectPoints(left, top, right, bottom) {\n  return [left, top, right, top, right, bottom, left, bottom];\n}\n\nfunction isLess(a, b) {\n  return a < b;\n}\n\nfunction isGreater(a, b) {\n  return a > b;\n}\n\nfunction selectClosestValue(target, values) {\n  var start = 0;\n  var end = values ? values.length - 1 : 0;\n  var middle;\n  var val = target;\n\n  while (end - start > 1) {\n    middle = start + end >> 1;\n    val = values[middle];\n\n    if (val === target) {\n      return target;\n    } else if (target < val) {\n      end = middle;\n    } else {\n      start = middle;\n    }\n  }\n\n  if (values) {\n    val = values[target - values[start] <= values[end] - target ? start : end];\n  }\n\n  return val;\n}\n\nfunction dummyProcessSelectionChanged() {\n  this._lastSelectedRange = this.getSelectedRange();\n  delete this._processSelectionChanged;\n}\n\nfunction suppressSetSelectedRange(controller) {\n  controller.setSelectedRange = noop;\n\n  if (controller._processSelectionChanged === dummyProcessSelectionChanged) {\n    controller._processSelectionChanged();\n  }\n}\n\nfunction restoreSetSelectedRange(controller) {\n  delete controller.setSelectedRange;\n}\n\nexport function SlidersController(params) {\n  var sliderParams = {\n    renderer: params.renderer,\n    root: params.root,\n    trackersGroup: params.trackersGroup,\n    translator: params.translator\n  };\n  this._params = params;\n  this._areaTracker = params.renderer.path(null, \"area\").attr({\n    class: \"area-tracker\",\n    fill: \"#000000\",\n    opacity: 1e-4\n  }).append(params.trackersGroup);\n  this._selectedAreaTracker = params.renderer.path(null, \"area\").attr({\n    class: \"selected-area-tracker\",\n    fill: \"#000000\",\n    opacity: 1e-4\n  }).append(params.trackersGroup);\n  this._shutter = params.renderer.path(null, \"area\").append(params.root);\n  this._sliders = [new Slider(sliderParams, 0), new Slider(sliderParams, 1)];\n  this._processSelectionChanged = dummyProcessSelectionChanged;\n}\nSlidersController.prototype = {\n  constructor: SlidersController,\n  dispose: function dispose() {\n    this._sliders[0].dispose();\n\n    this._sliders[1].dispose();\n  },\n  getTrackerTargets: function getTrackerTargets() {\n    return {\n      area: this._areaTracker,\n      selectedArea: this._selectedAreaTracker,\n      sliders: this._sliders\n    };\n  },\n  _processSelectionChanged: function _processSelectionChanged(e) {\n    var selectedRange = this.getSelectedRange();\n\n    if (!rangesAreEqual(selectedRange, this._lastSelectedRange)) {\n      this._params.updateSelectedRange(selectedRange, this._lastSelectedRange, e);\n\n      this._lastSelectedRange = selectedRange;\n    }\n  },\n  update: function update(verticalRange, behavior, isCompactMode, sliderHandleOptions, sliderMarkerOptions, shutterOptions, rangeBounds, fullTicks, selectedRangeColor) {\n    var screenRange = this._params.translator.getScreenRange();\n\n    this._verticalRange = verticalRange;\n    this._minRange = rangeBounds.minRange;\n    this._maxRange = rangeBounds.maxRange;\n    this._animationEnabled = behavior.animationEnabled && this._params.renderer.animationEnabled();\n    this._allowSlidersSwap = behavior.allowSlidersSwap;\n\n    this._sliders[0].update(verticalRange, sliderHandleOptions, sliderMarkerOptions);\n\n    this._sliders[1].update(verticalRange, sliderHandleOptions, sliderMarkerOptions);\n\n    this._sliders[0]._position = this._sliders[1]._position = screenRange[0];\n    this._values = !this._params.translator.isValueProlonged && behavior.snapToTicks ? fullTicks : null;\n\n    this._areaTracker.attr({\n      points: buildRectPoints(screenRange[0], verticalRange[0], screenRange[1], verticalRange[1])\n    });\n\n    this._isCompactMode = isCompactMode;\n    this._shutterOffset = sliderHandleOptions.width / 2;\n\n    this._updateSelectedView(shutterOptions, selectedRangeColor);\n\n    this._isOnMoving = \"onmoving\" === _normalizeEnum(behavior.callValueChanged);\n\n    this._updateSelectedRange();\n\n    this._applyTotalPosition(false);\n  },\n  _updateSelectedView: function _updateSelectedView(shutterOptions, selectedRangeColor) {\n    var settings = {\n      fill: null,\n      \"fill-opacity\": null,\n      stroke: null,\n      \"stroke-width\": null\n    };\n\n    if (this._isCompactMode) {\n      settings.stroke = selectedRangeColor;\n      settings[\"stroke-width\"] = 3;\n      settings.sharp = \"v\";\n    } else {\n      settings.fill = shutterOptions.color;\n      settings[\"fill-opacity\"] = shutterOptions.opacity;\n    }\n\n    this._shutter.attr(settings);\n  },\n  _updateSelectedRange: function _updateSelectedRange() {\n    var sliders = this._sliders;\n    sliders[0].cancelAnimation();\n    sliders[1].cancelAnimation();\n\n    this._shutter.stopAnimation();\n\n    if (this._params.translator.getBusinessRange().isEmpty()) {\n      sliders[0]._setText(emptySliderMarkerText);\n\n      sliders[1]._setText(emptySliderMarkerText);\n\n      sliders[0]._value = sliders[1]._value = void 0;\n      sliders[0]._position = this._params.translator.getScreenRange()[0];\n      sliders[1]._position = this._params.translator.getScreenRange()[1];\n\n      this._applyTotalPosition(false);\n\n      suppressSetSelectedRange(this);\n    } else {\n      restoreSetSelectedRange(this);\n    }\n  },\n  _applyTotalPosition: function _applyTotalPosition(isAnimated) {\n    var sliders = this._sliders;\n    isAnimated = this._animationEnabled && isAnimated;\n    sliders[0].applyPosition(isAnimated);\n    sliders[1].applyPosition(isAnimated);\n    var areOverlapped = sliders[0].getCloudBorder() > sliders[1].getCloudBorder();\n    sliders[0].setOverlapped(areOverlapped);\n    sliders[1].setOverlapped(areOverlapped);\n\n    this._applyAreaTrackersPosition();\n\n    this._applySelectedRangePosition(isAnimated);\n  },\n  _applyAreaTrackersPosition: function _applyAreaTrackersPosition() {\n    var position1 = this._sliders[0].getPosition();\n\n    var position2 = this._sliders[1].getPosition();\n\n    this._selectedAreaTracker.attr({\n      points: buildRectPoints(position1, this._verticalRange[0], position2, this._verticalRange[1])\n    }).css({\n      cursor: Math.abs(this._params.translator.getScreenRange()[1] - this._params.translator.getScreenRange()[0] - position2 + position1) < .001 ? \"default\" : \"pointer\"\n    });\n  },\n  _applySelectedRangePosition: function _applySelectedRangePosition(isAnimated) {\n    var verticalRange = this._verticalRange;\n\n    var pos1 = this._sliders[0].getPosition();\n\n    var pos2 = this._sliders[1].getPosition();\n\n    var screenRange;\n    var points;\n\n    if (this._isCompactMode) {\n      points = [pos1 + Math.ceil(this._shutterOffset), (verticalRange[0] + verticalRange[1]) / 2, pos2 - Math.floor(this._shutterOffset), (verticalRange[0] + verticalRange[1]) / 2];\n    } else {\n      screenRange = this._params.axis.getVisibleArea();\n      points = [buildRectPoints(screenRange[0], verticalRange[0], Math.max(pos1 - Math.floor(this._shutterOffset), screenRange[0]), verticalRange[1]), buildRectPoints(screenRange[1], verticalRange[0], Math.min(pos2 + Math.ceil(this._shutterOffset), screenRange[1]), verticalRange[1])];\n    }\n\n    if (isAnimated) {\n      this._shutter.animate({\n        points: points\n      }, animationSettings);\n    } else {\n      this._shutter.attr({\n        points: points\n      });\n    }\n  },\n  getSelectedRange: function getSelectedRange() {\n    return {\n      startValue: this._sliders[0].getValue(),\n      endValue: this._sliders[1].getValue()\n    };\n  },\n  setSelectedRange: function setSelectedRange(visualRange, e) {\n    visualRange = visualRange || {};\n    var translator = this._params.translator;\n    var businessRange = translator.getBusinessRange();\n    var compare = \"discrete\" === businessRange.axisType ? function (a, b) {\n      return a < b;\n    } : function (a, b) {\n      return a <= b;\n    };\n\n    var _adjustVisualRange = adjustVisualRange({\n      dataType: businessRange.dataType,\n      axisType: businessRange.axisType,\n      base: businessRange.base\n    }, {\n      startValue: translator.isValid(visualRange.startValue) ? translator.getCorrectValue(visualRange.startValue, 1) : void 0,\n      endValue: translator.isValid(visualRange.endValue) ? translator.getCorrectValue(visualRange.endValue, -1) : void 0,\n      length: visualRange.length\n    }, {\n      min: businessRange.minVisible,\n      max: businessRange.maxVisible,\n      categories: businessRange.categories\n    }),\n        startValue = _adjustVisualRange.startValue,\n        endValue = _adjustVisualRange.endValue;\n\n    startValue = isNumeric(startValue) ? adjust(startValue) : startValue;\n    endValue = isNumeric(endValue) ? adjust(endValue) : endValue;\n    var values = compare(translator.to(startValue, -1), translator.to(endValue, 1)) ? [startValue, endValue] : [endValue, startValue];\n\n    this._sliders[0].setDisplayValue(values[0]);\n\n    this._sliders[1].setDisplayValue(values[1]);\n\n    this._sliders[0]._position = translator.to(values[0], -1);\n    this._sliders[1]._position = translator.to(values[1], 1);\n\n    this._applyTotalPosition(true);\n\n    this._processSelectionChanged(e);\n  },\n  beginSelectedAreaMoving: function beginSelectedAreaMoving(initialPosition) {\n    var that = this;\n    var sliders = that._sliders;\n    var offset = (sliders[0].getPosition() + sliders[1].getPosition()) / 2 - initialPosition;\n    var currentPosition = initialPosition;\n\n    move.complete = function (e) {\n      that._dockSelectedArea(e);\n    };\n\n    return move;\n\n    function move(position, e) {\n      if (position !== currentPosition && position > currentPosition === position > (sliders[0].getPosition() + sliders[1].getPosition()) / 2 - offset) {\n        that._moveSelectedArea(position + offset, false, e);\n      }\n\n      currentPosition = position;\n    }\n  },\n  _dockSelectedArea: function _dockSelectedArea(e) {\n    var translator = this._params.translator;\n    var sliders = this._sliders;\n    sliders[0]._position = translator.to(sliders[0].getValue(), -1);\n    sliders[1]._position = translator.to(sliders[1].getValue(), 1);\n\n    this._applyTotalPosition(true);\n\n    this._processSelectionChanged(e);\n  },\n  moveSelectedArea: function moveSelectedArea(screenPosition, e) {\n    this._moveSelectedArea(screenPosition, true, e);\n\n    this._dockSelectedArea(e);\n  },\n  _moveSelectedArea: function _moveSelectedArea(screenPosition, isAnimated, e) {\n    var translator = this._params.translator;\n    var sliders = this._sliders;\n    var interval = sliders[1].getPosition() - sliders[0].getPosition();\n    var startPosition = screenPosition - interval / 2;\n    var endPosition = screenPosition + interval / 2;\n\n    if (startPosition < translator.getScreenRange()[0]) {\n      startPosition = translator.getScreenRange()[0];\n      endPosition = startPosition + interval;\n    }\n\n    if (endPosition > translator.getScreenRange()[1]) {\n      endPosition = translator.getScreenRange()[1];\n      startPosition = endPosition - interval;\n    }\n\n    var startValue = selectClosestValue(translator.from(startPosition, -1), this._values);\n    sliders[0].setDisplayValue(startValue);\n    sliders[1].setDisplayValue(selectClosestValue(translator.from(translator.to(startValue, -1) + interval, 1), this._values));\n    sliders[0]._position = startPosition;\n    sliders[1]._position = endPosition;\n\n    this._applyTotalPosition(isAnimated);\n\n    if (this._isOnMoving) {\n      this._processSelectionChanged(e);\n    }\n  },\n  placeSliderAndBeginMoving: function placeSliderAndBeginMoving(firstPosition, secondPosition, e) {\n    var translator = this._params.translator;\n    var sliders = this._sliders;\n    var index = firstPosition < secondPosition ? 0 : 1;\n    var dir = index > 0 ? 1 : -1;\n    var compare = index > 0 ? isGreater : isLess;\n    var antiCompare = index > 0 ? isLess : isGreater;\n    var thresholdPosition;\n    var positions = [];\n    var values = [];\n    values[index] = translator.from(firstPosition, dir);\n    values[1 - index] = translator.from(secondPosition, -dir);\n    positions[1 - index] = secondPosition;\n\n    if (translator.isValueProlonged) {\n      if (compare(firstPosition, translator.to(values[index], dir))) {\n        values[index] = translator.from(firstPosition, -dir);\n      }\n\n      if (compare(secondPosition, translator.to(values[index], -dir))) {\n        values[1 - index] = values[index];\n      }\n    }\n\n    if (this._minRange) {\n      thresholdPosition = translator.to(translator.add(selectClosestValue(values[index], this._values), this._minRange, -dir), -dir);\n\n      if (compare(secondPosition, thresholdPosition)) {\n        values[1 - index] = translator.add(values[index], this._minRange, -dir);\n      }\n\n      thresholdPosition = translator.to(translator.add(translator.getRange()[1 - index], this._minRange, dir), -dir);\n\n      if (antiCompare(firstPosition, thresholdPosition)) {\n        values[1 - index] = translator.getRange()[1 - index];\n        values[index] = translator.add(values[1 - index], this._minRange, dir);\n        positions[1 - index] = firstPosition;\n      }\n    }\n\n    values[0] = selectClosestValue(values[0], this._values);\n    values[1] = selectClosestValue(values[1], this._values);\n    positions[index] = translator.to(values[index], dir);\n    sliders[0].setDisplayValue(values[0]);\n    sliders[1].setDisplayValue(values[1]);\n    sliders[0]._position = positions[0];\n    sliders[1]._position = positions[1];\n\n    this._applyTotalPosition(true);\n\n    if (this._isOnMoving) {\n      this._processSelectionChanged(e);\n    }\n\n    var handler = this.beginSliderMoving(1 - index, secondPosition);\n\n    sliders[1 - index]._sliderGroup.stopAnimation();\n\n    this._shutter.stopAnimation();\n\n    handler(secondPosition);\n    return handler;\n  },\n  beginSliderMoving: function beginSliderMoving(initialIndex, initialPosition) {\n    var that = this;\n    var translator = that._params.translator;\n    var sliders = that._sliders;\n    var minPosition = translator.getScreenRange()[0];\n    var maxPosition = translator.getScreenRange()[1];\n    var index = initialIndex;\n    var staticPosition = sliders[1 - index].getPosition();\n    var currentPosition = initialPosition;\n    var dir = index > 0 ? 1 : -1;\n    var compareMin = index > 0 ? isLess : isGreater;\n    var compareMax = index > 0 ? isGreater : isLess;\n    var moveOffset = sliders[index].getPosition() - initialPosition;\n    var swapOffset = compareMin(sliders[index].getPosition(), initialPosition) ? -moveOffset : moveOffset;\n\n    move.complete = function (e) {\n      sliders[index]._setValid(true);\n\n      that._dockSelectedArea(e);\n    };\n\n    return move;\n\n    function move(position, e) {\n      var isValid;\n      var temp;\n      var pos;\n      var slider;\n      var value;\n\n      if (position !== currentPosition) {\n        if (compareMin(position + swapOffset, staticPosition)) {\n          isValid = that._allowSlidersSwap;\n\n          if (isValid && !translator.isValueProlonged && that._minRange) {\n            isValid = translator.isValid(translator.add(sliders[1 - index].getValue(), that._minRange, -dir));\n          }\n\n          if (isValid) {\n            that._changeMovingSlider(index);\n\n            index = 1 - index;\n            dir = -dir;\n            temp = compareMin;\n            compareMin = compareMax;\n            compareMax = temp;\n            moveOffset = -dir * Math.abs(moveOffset);\n            swapOffset = -moveOffset;\n          }\n        }\n\n        if (compareMax(position + moveOffset, staticPosition)) {\n          slider = sliders[index];\n          value = sliders[1 - index].getValue();\n          pos = Math.max(Math.min(position + moveOffset, maxPosition), minPosition);\n          isValid = translator.isValueProlonged ? !compareMin(pos, translator.to(value, dir)) : true;\n          var invalidStateValue;\n\n          if (isValid && that._minRange) {\n            isValid = !compareMin(pos, translator.to(translator.add(value, that._minRange, dir), dir));\n\n            if (!isValid) {\n              invalidStateValue = translator.add(value, that._minRange, dir);\n            }\n          }\n\n          if (isValid && that._maxRange) {\n            isValid = !compareMax(pos, translator.to(translator.add(value, that._maxRange, dir), dir));\n\n            if (!isValid) {\n              invalidStateValue = translator.add(value, that._maxRange, dir);\n            }\n          }\n\n          slider._setValid(isValid);\n\n          slider.setDisplayValue(isValid ? selectClosestValue(translator.from(pos, dir), that._values) : isDefined(invalidStateValue) ? invalidStateValue : slider.getValue());\n          slider._position = pos;\n\n          that._applyTotalPosition(false);\n\n          slider.toForeground();\n\n          if (that._isOnMoving) {\n            that._processSelectionChanged(e);\n          }\n        }\n      }\n\n      currentPosition = position;\n    }\n  },\n  _changeMovingSlider: function _changeMovingSlider(index) {\n    var translator = this._params.translator;\n    var sliders = this._sliders;\n    var position = sliders[1 - index].getPosition();\n    var dir = index > 0 ? 1 : -1;\n    var newValue;\n    sliders[index].setDisplayValue(selectClosestValue(translator.from(position, dir), this._values));\n    newValue = translator.from(position, -dir);\n\n    if (translator.isValueProlonged) {\n      newValue = translator.from(position, dir);\n    } else if (this._minRange) {\n      newValue = translator.add(newValue, this._minRange, -dir);\n    }\n\n    sliders[1 - index].setDisplayValue(selectClosestValue(newValue, this._values));\n\n    sliders[index]._setValid(true);\n\n    sliders[index]._marker._update();\n\n    sliders[0]._position = sliders[1]._position = position;\n  },\n  foregroundSlider: function foregroundSlider(index) {\n    this._sliders[index].toForeground();\n  }\n};","map":null,"metadata":{},"sourceType":"module"}