{"ast":null,"code":"import _defineProperty from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\n\n/**\r\n * DevExtreme (esm/viz/series/scatter_series.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { extend as _extend } from \"../../core/utils/extend\";\nimport { inArray } from \"../../core/utils/array\";\nimport { each as _each } from \"../../core/utils/iterator\";\nimport rangeCalculator from \"./helpers/range_data_calculator\";\nimport { isDefined as _isDefined, isString as _isString } from \"../../core/utils/type\";\nimport { map as _map, normalizeEnum as _normalizeEnum, convertXYToPolar } from \"../core/utils\";\nimport { noop as _noop } from \"../../core/utils/common\";\nvar math = Math;\nvar _abs = math.abs;\nvar _sqrt = math.sqrt;\nvar _max = math.max;\nvar DEFAULT_TRACKER_WIDTH = 12;\nvar DEFAULT_DURATION = 400;\nvar HIGH_ERROR = \"highError\";\nvar LOW_ERROR = \"lowError\";\nvar VARIANCE = \"variance\";\nvar STANDARD_DEVIATION = \"stddeviation\";\nvar STANDARD_ERROR = \"stderror\";\nvar PERCENT = \"percent\";\nvar FIXED = \"fixed\";\nvar UNDEFINED = \"undefined\";\nvar DISCRETE = \"discrete\";\nvar LOGARITHMIC = \"logarithmic\";\nvar DATETIME = \"datetime\";\nvar chart = {};\nvar polar = {};\n\nfunction sum(array) {\n  var result = 0;\n\n  _each(array, function (_, value) {\n    result += value;\n  });\n\n  return result;\n}\n\nfunction isErrorBarTypeCorrect(type) {\n  return -1 !== inArray(type, [FIXED, PERCENT, VARIANCE, STANDARD_DEVIATION, STANDARD_ERROR]);\n}\n\nfunction variance(array, expectedValue) {\n  return sum(_map(array, function (value) {\n    return (value - expectedValue) * (value - expectedValue);\n  })) / array.length;\n}\n\nfunction calculateAvgErrorBars(result, data, series) {\n  var errorBarsOptions = series.getOptions().valueErrorBar;\n  var valueField = series.getValueFields()[0];\n  var lowValueField = errorBarsOptions.lowValueField || LOW_ERROR;\n  var highValueField = errorBarsOptions.highValueField || HIGH_ERROR;\n\n  if (series.areErrorBarsVisible() && void 0 === errorBarsOptions.type) {\n    var fusionData = data.reduce(function (result, item) {\n      if (_isDefined(item[lowValueField])) {\n        result[0] += item[valueField] - item[lowValueField];\n        result[1]++;\n      }\n\n      if (_isDefined(item[highValueField])) {\n        result[2] += item[highValueField] - item[valueField];\n        result[3]++;\n      }\n\n      return result;\n    }, [0, 0, 0, 0]);\n\n    if (fusionData[1]) {\n      result[lowValueField] = result[valueField] - fusionData[0] / fusionData[1];\n    }\n\n    if (fusionData[2]) {\n      result[highValueField] = result[valueField] + fusionData[2] / fusionData[3];\n    }\n  }\n\n  return result;\n}\n\nfunction calculateSumErrorBars(result, data, series) {\n  var errorBarsOptions = series.getOptions().valueErrorBar;\n  var lowValueField = errorBarsOptions.lowValueField || LOW_ERROR;\n  var highValueField = errorBarsOptions.highValueField || HIGH_ERROR;\n\n  if (series.areErrorBarsVisible() && void 0 === errorBarsOptions.type) {\n    result[lowValueField] = 0;\n    result[highValueField] = 0;\n    result = data.reduce(function (result, item) {\n      result[lowValueField] += item[lowValueField];\n      result[highValueField] += item[highValueField];\n      return result;\n    }, result);\n  }\n\n  return result;\n}\n\nfunction getMinMaxAggregator(compare) {\n  return function (_ref, series) {\n    var intervalStart = _ref.intervalStart,\n        intervalEnd = _ref.intervalEnd,\n        data = _ref.data;\n    var valueField = series.getValueFields()[0];\n    var targetData = data[0];\n    targetData = data.reduce(function (result, item) {\n      var value = item[valueField];\n\n      if (null === result[valueField]) {\n        result = item;\n      }\n\n      if (null !== value && compare(value, result[valueField])) {\n        return item;\n      }\n\n      return result;\n    }, targetData);\n    return _extend({}, targetData, _defineProperty({}, series.getArgumentField(), series._getIntervalCenter(intervalStart, intervalEnd)));\n  };\n}\n\nfunction checkFields(data, fieldsToCheck, skippedFields) {\n  var allFieldsIsValid = true;\n\n  for (var field in fieldsToCheck) {\n    var isArgument = \"argument\" === field;\n\n    if (isArgument || \"size\" === field ? !_isDefined(data[field]) : void 0 === data[field]) {\n      var selector = fieldsToCheck[field];\n\n      if (!isArgument) {\n        skippedFields[selector] = (skippedFields[selector] || 0) + 1;\n      }\n\n      allFieldsIsValid = false;\n    }\n  }\n\n  return allFieldsIsValid;\n}\n\nvar baseScatterMethods = {\n  _defaultDuration: DEFAULT_DURATION,\n  _defaultTrackerWidth: DEFAULT_TRACKER_WIDTH,\n  _applyStyle: _noop,\n  _updateOptions: _noop,\n  _parseStyle: _noop,\n  _prepareSegment: _noop,\n  _drawSegment: _noop,\n  _appendInGroup: function _appendInGroup() {\n    this._group.append(this._extGroups.seriesGroup);\n  },\n  _createLegendState: function _createLegendState(styleOptions, defaultColor) {\n    return {\n      fill: styleOptions.color || defaultColor,\n      hatching: styleOptions.hatching ? _extend({}, styleOptions.hatching, {\n        direction: \"right\"\n      }) : void 0\n    };\n  },\n  _applyElementsClipRect: function _applyElementsClipRect(settings) {\n    settings[\"clip-path\"] = this._paneClipRectID;\n  },\n  _applyMarkerClipRect: function _applyMarkerClipRect(settings) {\n    settings[\"clip-path\"] = this._forceClipping ? this._paneClipRectID : null;\n  },\n  _createGroup: function _createGroup(groupName, parent, target, settings) {\n    var group = parent[groupName] = parent[groupName] || this._renderer.g();\n\n    target && group.append(target);\n    settings && group.attr(settings);\n  },\n  _applyClearingSettings: function _applyClearingSettings(settings) {\n    settings.opacity = null;\n    settings.scale = null;\n\n    if (this._options.rotated) {\n      settings.translateX = null;\n    } else {\n      settings.translateY = null;\n    }\n  },\n  _createGroups: function _createGroups() {\n    this._createGroup(\"_markersGroup\", this, this._group);\n\n    this._createGroup(\"_labelsGroup\", this);\n  },\n  _setMarkerGroupSettings: function _setMarkerGroupSettings() {\n    var settings = this._createPointStyles(this._getMarkerGroupOptions()).normal;\n\n    settings.class = \"dxc-markers\";\n    settings.opacity = 1;\n\n    this._applyMarkerClipRect(settings);\n\n    this._markersGroup.attr(settings);\n  },\n  getVisibleArea: function getVisibleArea() {\n    return this._visibleArea;\n  },\n  areErrorBarsVisible: function areErrorBarsVisible() {\n    var errorBarOptions = this._options.valueErrorBar;\n    return errorBarOptions && this._errorBarsEnabled() && \"none\" !== errorBarOptions.displayMode && (isErrorBarTypeCorrect(_normalizeEnum(errorBarOptions.type)) || _isDefined(errorBarOptions.lowValueField) || _isDefined(errorBarOptions.highValueField));\n  },\n  groupPointsByCoords: function groupPointsByCoords(rotated) {\n    var cat = [];\n\n    _each(this.getVisiblePoints(), function (_, p) {\n      var pointCoord = parseInt(rotated ? p.vy : p.vx);\n\n      if (!cat[pointCoord]) {\n        cat[pointCoord] = p;\n      } else {\n        Array.isArray(cat[pointCoord]) ? cat[pointCoord].push(p) : cat[pointCoord] = [cat[pointCoord], p];\n      }\n    });\n\n    return cat;\n  },\n  _createErrorBarGroup: function _createErrorBarGroup(animationEnabled) {\n    var errorBarOptions = this._options.valueErrorBar;\n    var settings;\n\n    if (this.areErrorBarsVisible()) {\n      settings = {\n        class: \"dxc-error-bars\",\n        stroke: errorBarOptions.color,\n        \"stroke-width\": errorBarOptions.lineWidth,\n        opacity: animationEnabled ? .001 : errorBarOptions.opacity || 1,\n        \"stroke-linecap\": \"square\",\n        sharp: true,\n        \"clip-path\": this._forceClipping ? this._paneClipRectID : this._widePaneClipRectID\n      };\n\n      this._createGroup(\"_errorBarGroup\", this, this._group, settings);\n    }\n  },\n  _setGroupsSettings: function _setGroupsSettings(animationEnabled) {\n    this._setMarkerGroupSettings();\n\n    this._setLabelGroupSettings(animationEnabled);\n\n    this._createErrorBarGroup(animationEnabled);\n  },\n  _getCreatingPointOptions: function _getCreatingPointOptions() {\n    var defaultPointOptions;\n    var creatingPointOptions = this._predefinedPointOptions;\n    var normalStyle;\n\n    if (!creatingPointOptions) {\n      defaultPointOptions = this._getPointOptions();\n      this._predefinedPointOptions = creatingPointOptions = _extend(true, {\n        styles: {}\n      }, defaultPointOptions);\n      normalStyle = defaultPointOptions.styles && defaultPointOptions.styles.normal || {};\n      creatingPointOptions.styles = creatingPointOptions.styles || {};\n      creatingPointOptions.styles.normal = {\n        \"stroke-width\": normalStyle[\"stroke-width\"],\n        r: normalStyle.r,\n        opacity: normalStyle.opacity\n      };\n    }\n\n    return creatingPointOptions;\n  },\n  _getPointOptions: function _getPointOptions() {\n    return this._parsePointOptions(this._preparePointOptions(), this._options.label);\n  },\n  _getOptionsForPoint: function _getOptionsForPoint() {\n    return this._options.point;\n  },\n  _parsePointStyle: function _parsePointStyle(style, defaultColor, defaultBorderColor, defaultSize) {\n    var border = style.border || {};\n    var sizeValue = void 0 !== style.size ? style.size : defaultSize;\n    return {\n      fill: style.color || defaultColor,\n      stroke: border.color || defaultBorderColor,\n      \"stroke-width\": border.visible ? border.width : 0,\n      r: sizeValue / 2 + (border.visible && 0 !== sizeValue ? ~~(border.width / 2) || 0 : 0)\n    };\n  },\n  _createPointStyles: function _createPointStyles(pointOptions) {\n    var mainPointColor = pointOptions.color || this._options.mainSeriesColor;\n    var containerColor = this._options.containerBackgroundColor;\n\n    var normalStyle = this._parsePointStyle(pointOptions, mainPointColor, mainPointColor);\n\n    normalStyle.visibility = pointOptions.visible ? \"visible\" : \"hidden\";\n    return {\n      normal: normalStyle,\n      hover: this._parsePointStyle(pointOptions.hoverStyle, containerColor, mainPointColor, pointOptions.size),\n      selection: this._parsePointStyle(pointOptions.selectionStyle, containerColor, mainPointColor, pointOptions.size)\n    };\n  },\n  _checkData: function _checkData(data, skippedFields, fieldsToCheck) {\n    fieldsToCheck = fieldsToCheck || {\n      value: this.getValueFields()[0]\n    };\n    fieldsToCheck.argument = this.getArgumentField();\n    return checkFields(data, fieldsToCheck, skippedFields || {}) && data.value === data.value;\n  },\n  getArgumentRangeInitialValue: function getArgumentRangeInitialValue() {\n    var points = this.getPoints();\n\n    if (this.useAggregation() && points.length) {\n      var _points$0$aggregation, _points$aggregationIn;\n\n      return {\n        min: null === (_points$0$aggregation = points[0].aggregationInfo) || void 0 === _points$0$aggregation ? void 0 : _points$0$aggregation.intervalStart,\n        max: null === (_points$aggregationIn = points[points.length - 1].aggregationInfo) || void 0 === _points$aggregationIn ? void 0 : _points$aggregationIn.intervalEnd\n      };\n    }\n\n    return;\n  },\n  getValueRangeInitialValue: function getValueRangeInitialValue() {\n    return;\n  },\n  _getRangeData: function _getRangeData() {\n    return rangeCalculator.getRangeData(this);\n  },\n  _getPointDataSelector: function _getPointDataSelector() {\n    var _this = this;\n\n    var valueField = this.getValueFields()[0];\n    var argumentField = this.getArgumentField();\n    var tagField = this.getTagField();\n    var areErrorBarsVisible = this.areErrorBarsVisible();\n    var lowValueField;\n    var highValueField;\n\n    if (areErrorBarsVisible) {\n      var errorBarOptions = this._options.valueErrorBar;\n      lowValueField = errorBarOptions.lowValueField || LOW_ERROR;\n      highValueField = errorBarOptions.highValueField || HIGH_ERROR;\n    }\n\n    return function (data) {\n      var pointData = {\n        value: _this._processEmptyValue(data[valueField]),\n        argument: data[argumentField],\n        tag: data[tagField],\n        data: data\n      };\n\n      if (areErrorBarsVisible) {\n        pointData.lowError = data[lowValueField];\n        pointData.highError = data[highValueField];\n      }\n\n      return pointData;\n    };\n  },\n  _errorBarsEnabled: function _errorBarsEnabled() {\n    return this.valueAxisType !== DISCRETE && this.valueAxisType !== LOGARITHMIC && this.valueType !== DATETIME;\n  },\n  _drawPoint: function _drawPoint(options) {\n    var point = options.point;\n\n    if (point.isInVisibleArea()) {\n      point.clearVisibility();\n      point.draw(this._renderer, options.groups, options.hasAnimation, options.firstDrawing);\n\n      this._drawnPoints.push(point);\n    } else {\n      point.setInvisibility();\n    }\n  },\n  _animateComplete: function _animateComplete() {\n    var animationSettings = {\n      duration: this._defaultDuration\n    };\n    this._labelsGroup && this._labelsGroup.animate({\n      opacity: 1\n    }, animationSettings);\n    this._errorBarGroup && this._errorBarGroup.animate({\n      opacity: this._options.valueErrorBar.opacity || 1\n    }, animationSettings);\n  },\n  _animate: function _animate() {\n    var that = this;\n    var lastPointIndex = that._drawnPoints.length - 1;\n\n    _each(that._drawnPoints || [], function (i, p) {\n      p.animate(i === lastPointIndex ? function () {\n        that._animateComplete();\n      } : void 0, {\n        translateX: p.x,\n        translateY: p.y\n      });\n    });\n  },\n  _getIntervalCenter: function _getIntervalCenter(intervalStart, intervalEnd) {\n    var argAxis = this.getArgumentAxis();\n    return \"discrete\" !== argAxis.getOptions().type ? argAxis.getVisualRangeCenter({\n      minVisible: intervalStart,\n      maxVisible: intervalEnd\n    }, true) : intervalStart;\n  },\n  _defaultAggregator: \"avg\",\n  _aggregators: {\n    avg: function avg(_ref2, series) {\n      var _calculateAvgErrorBar;\n\n      var data = _ref2.data,\n          intervalStart = _ref2.intervalStart,\n          intervalEnd = _ref2.intervalEnd;\n\n      if (!data.length) {\n        return;\n      }\n\n      var valueField = series.getValueFields()[0];\n      var aggregationResult = data.reduce(function (result, item) {\n        var value = item[valueField];\n\n        if (_isDefined(value)) {\n          result[0] += value;\n          result[1]++;\n        } else if (null === value) {\n          result[2]++;\n        }\n\n        return result;\n      }, [0, 0, 0]);\n      return calculateAvgErrorBars((_calculateAvgErrorBar = {}, _defineProperty(_calculateAvgErrorBar, valueField, aggregationResult[2] === data.length ? null : aggregationResult[0] / aggregationResult[1]), _defineProperty(_calculateAvgErrorBar, series.getArgumentField(), series._getIntervalCenter(intervalStart, intervalEnd)), _calculateAvgErrorBar), data, series);\n    },\n    sum: function sum(_ref3, series) {\n      var _calculateSumErrorBar;\n\n      var intervalStart = _ref3.intervalStart,\n          intervalEnd = _ref3.intervalEnd,\n          data = _ref3.data;\n\n      if (!data.length) {\n        return;\n      }\n\n      var valueField = series.getValueFields()[0];\n      var aggregationResult = data.reduce(function (result, item) {\n        var value = item[valueField];\n\n        if (void 0 !== value) {\n          result[0] += value;\n        }\n\n        if (null === value) {\n          result[1]++;\n        } else if (void 0 === value) {\n          result[2]++;\n        }\n\n        return result;\n      }, [0, 0, 0]);\n      var value = aggregationResult[0];\n\n      if (aggregationResult[1] === data.length) {\n        value = null;\n      }\n\n      if (aggregationResult[2] === data.length) {\n        return;\n      }\n\n      return calculateSumErrorBars((_calculateSumErrorBar = {}, _defineProperty(_calculateSumErrorBar, valueField, value), _defineProperty(_calculateSumErrorBar, series.getArgumentField(), series._getIntervalCenter(intervalStart, intervalEnd)), _calculateSumErrorBar), data, series);\n    },\n    count: function count(_ref4, series) {\n      var _ref5;\n\n      var data = _ref4.data,\n          intervalStart = _ref4.intervalStart,\n          intervalEnd = _ref4.intervalEnd;\n      var valueField = series.getValueFields()[0];\n      return _ref5 = {}, _defineProperty(_ref5, series.getArgumentField(), series._getIntervalCenter(intervalStart, intervalEnd)), _defineProperty(_ref5, valueField, data.filter(function (i) {\n        return void 0 !== i[valueField];\n      }).length), _ref5;\n    },\n    min: getMinMaxAggregator(function (a, b) {\n      return a < b;\n    }),\n    max: getMinMaxAggregator(function (a, b) {\n      return a > b;\n    })\n  },\n  _endUpdateData: function _endUpdateData() {\n    delete this._predefinedPointOptions;\n  },\n  getArgumentField: function getArgumentField() {\n    return this._options.argumentField || \"arg\";\n  },\n  getValueFields: function getValueFields() {\n    var options = this._options;\n    var errorBarsOptions = options.valueErrorBar;\n    var valueFields = [options.valueField || \"val\"];\n    var lowValueField;\n    var highValueField;\n\n    if (errorBarsOptions) {\n      lowValueField = errorBarsOptions.lowValueField;\n      highValueField = errorBarsOptions.highValueField;\n      _isString(lowValueField) && valueFields.push(lowValueField);\n      _isString(highValueField) && valueFields.push(highValueField);\n    }\n\n    return valueFields;\n  },\n  _calculateErrorBars: function _calculateErrorBars(data) {\n    if (!this.areErrorBarsVisible()) {\n      return;\n    }\n\n    var options = this._options;\n    var errorBarsOptions = options.valueErrorBar;\n\n    var errorBarType = _normalizeEnum(errorBarsOptions.type);\n\n    var floatErrorValue = parseFloat(errorBarsOptions.value);\n    var valueField = this.getValueFields()[0];\n    var value;\n    var lowValueField = errorBarsOptions.lowValueField || LOW_ERROR;\n    var highValueField = errorBarsOptions.highValueField || HIGH_ERROR;\n    var valueArray;\n    var valueArrayLength;\n    var meanValue;\n    var processDataItem;\n\n    var addSubError = function addSubError(_i, item) {\n      value = item.value;\n      item.lowError = value - floatErrorValue;\n      item.highError = value + floatErrorValue;\n    };\n\n    switch (errorBarType) {\n      case FIXED:\n        processDataItem = addSubError;\n        break;\n\n      case PERCENT:\n        processDataItem = function processDataItem(_, item) {\n          value = item.value;\n          var error = value * floatErrorValue / 100;\n          item.lowError = value - error;\n          item.highError = value + error;\n        };\n\n        break;\n\n      case UNDEFINED:\n        processDataItem = function processDataItem(_, item) {\n          item.lowError = item.data[lowValueField];\n          item.highError = item.data[highValueField];\n        };\n\n        break;\n\n      default:\n        valueArray = _map(data, function (item) {\n          return _isDefined(item.data[valueField]) ? item.data[valueField] : null;\n        });\n        valueArrayLength = valueArray.length;\n        floatErrorValue = floatErrorValue || 1;\n\n        switch (errorBarType) {\n          case VARIANCE:\n            floatErrorValue = variance(valueArray, sum(valueArray) / valueArrayLength) * floatErrorValue;\n            processDataItem = addSubError;\n            break;\n\n          case STANDARD_DEVIATION:\n            meanValue = sum(valueArray) / valueArrayLength;\n            floatErrorValue = _sqrt(variance(valueArray, meanValue)) * floatErrorValue;\n\n            processDataItem = function processDataItem(_, item) {\n              item.lowError = meanValue - floatErrorValue;\n              item.highError = meanValue + floatErrorValue;\n            };\n\n            break;\n\n          case STANDARD_ERROR:\n            floatErrorValue = _sqrt(variance(valueArray, sum(valueArray) / valueArrayLength) / valueArrayLength) * floatErrorValue;\n            processDataItem = addSubError;\n        }\n\n    }\n\n    processDataItem && _each(data, processDataItem);\n  },\n  _patchMarginOptions: function _patchMarginOptions(options) {\n    var pointOptions = this._getCreatingPointOptions();\n\n    var styles = pointOptions.styles;\n    var maxSize = [styles.normal, styles.hover, styles.selection].reduce(function (max, style) {\n      return _max(max, 2 * style.r + style[\"stroke-width\"]);\n    }, 0);\n    options.size = pointOptions.visible ? maxSize : 0;\n    options.sizePointNormalState = pointOptions.visible ? 2 * styles.normal.r + styles.normal[\"stroke-width\"] : 2;\n    return options;\n  },\n  usePointsToDefineAutoHiding: function usePointsToDefineAutoHiding() {\n    return true;\n  }\n};\nchart = _extend({}, baseScatterMethods, {\n  drawTrackers: function drawTrackers() {\n    var that = this;\n    var trackers;\n    var trackersGroup;\n    var segments = that._segments || [];\n    var rotated = that._options.rotated;\n\n    if (!that.isVisible()) {\n      return;\n    }\n\n    if (segments.length) {\n      trackers = that._trackers = that._trackers || [];\n      trackersGroup = that._trackersGroup = (that._trackersGroup || that._renderer.g().attr({\n        fill: \"gray\",\n        opacity: .001,\n        stroke: \"gray\",\n        class: \"dxc-trackers\"\n      })).attr({\n        \"clip-path\": this._paneClipRectID || null\n      }).append(that._group);\n\n      _each(segments, function (i, segment) {\n        if (!trackers[i]) {\n          trackers[i] = that._drawTrackerElement(segment).data({\n            \"chart-data-series\": that\n          }).append(trackersGroup);\n        } else {\n          that._updateTrackerElement(segment, trackers[i]);\n        }\n      });\n    }\n\n    that._trackersTranslator = that.groupPointsByCoords(rotated);\n  },\n  _checkAxisVisibleAreaCoord: function _checkAxisVisibleAreaCoord(isArgument, coord) {\n    var axis = isArgument ? this.getArgumentAxis() : this.getValueAxis();\n    var visibleArea = axis.getVisibleArea();\n    return _isDefined(coord) && visibleArea[0] <= coord && visibleArea[1] >= coord;\n  },\n  checkSeriesViewportCoord: function checkSeriesViewportCoord(axis, coord) {\n    return this.getPoints().length && this.isVisible();\n  },\n  getSeriesPairCoord: function getSeriesPairCoord(coord, isArgument) {\n    var oppositeCoord = null;\n    var isOpposite = !isArgument && !this._options.rotated || isArgument && this._options.rotated;\n    var coordName = !isOpposite ? \"vx\" : \"vy\";\n    var oppositeCoordName = !isOpposite ? \"vy\" : \"vx\";\n    var points = this.getVisiblePoints();\n\n    for (var i = 0; i < points.length; i++) {\n      var p = points[i];\n      var tmpCoord = p[coordName] === coord ? p[oppositeCoordName] : void 0;\n\n      if (this._checkAxisVisibleAreaCoord(!isArgument, tmpCoord)) {\n        oppositeCoord = tmpCoord;\n        break;\n      }\n    }\n\n    return oppositeCoord;\n  },\n  _getNearestPoints: function _getNearestPoints(point, nextPoint) {\n    return [point, nextPoint];\n  },\n  _getBezierPoints: function _getBezierPoints() {\n    return [];\n  },\n  _getNearestPointsByCoord: function _getNearestPointsByCoord(coord, isArgument) {\n    var that = this;\n    var rotated = that.getOptions().rotated;\n    var isOpposite = !isArgument && !rotated || isArgument && rotated;\n    var coordName = isOpposite ? \"vy\" : \"vx\";\n    var allPoints = that.getPoints();\n\n    var bezierPoints = that._getBezierPoints();\n\n    var nearestPoints = [];\n\n    if (allPoints.length > 1) {\n      allPoints.forEach(function (point, i) {\n        var nextPoint = allPoints[i + 1];\n\n        if (nextPoint && (point[coordName] <= coord && nextPoint[coordName] >= coord || point[coordName] >= coord && nextPoint[coordName] <= coord)) {\n          nearestPoints.push(that._getNearestPoints(point, nextPoint, bezierPoints));\n        }\n      });\n    } else {\n      nearestPoints.push([allPoints[0], allPoints[0]]);\n    }\n\n    return nearestPoints;\n  },\n  getNeighborPoint: function getNeighborPoint(x, y) {\n    var pCoord = this._options.rotated ? y : x;\n    var nCoord = pCoord;\n    var cat = this._trackersTranslator;\n    var point = null;\n    var minDistance;\n    var oppositeCoord = this._options.rotated ? x : y;\n    var oppositeCoordName = this._options.rotated ? \"vx\" : \"vy\";\n\n    if (this.isVisible() && cat) {\n      point = cat[pCoord];\n\n      do {\n        point = cat[nCoord] || cat[pCoord];\n        pCoord--;\n        nCoord++;\n      } while ((pCoord >= 0 || nCoord < cat.length) && !point);\n\n      if (Array.isArray(point)) {\n        minDistance = _abs(point[0][oppositeCoordName] - oppositeCoord);\n\n        _each(point, function (i, p) {\n          var distance = _abs(p[oppositeCoordName] - oppositeCoord);\n\n          if (minDistance >= distance) {\n            minDistance = distance;\n            point = p;\n          }\n        });\n      }\n    }\n\n    return point;\n  },\n  _applyVisibleArea: function _applyVisibleArea() {\n    var rotated = this._options.rotated;\n    var visibleX = (rotated ? this.getValueAxis() : this.getArgumentAxis()).getVisibleArea();\n    var visibleY = (rotated ? this.getArgumentAxis() : this.getValueAxis()).getVisibleArea();\n    this._visibleArea = {\n      minX: visibleX[0],\n      maxX: visibleX[1],\n      minY: visibleY[0],\n      maxY: visibleY[1]\n    };\n  },\n  getPointCenterByArg: function getPointCenterByArg(arg) {\n    var point = this.getPointsByArg(arg)[0];\n    return point ? point.getCenterCoord() : void 0;\n  }\n});\npolar = _extend({}, baseScatterMethods, {\n  drawTrackers: function drawTrackers() {\n    chart.drawTrackers.call(this);\n    var cat = this._trackersTranslator;\n    var index;\n\n    if (!this.isVisible()) {\n      return;\n    }\n\n    _each(cat, function (i, category) {\n      if (category) {\n        index = i;\n        return false;\n      }\n    });\n\n    cat[index + 360] = cat[index];\n  },\n  getNeighborPoint: function getNeighborPoint(x, y) {\n    var pos = convertXYToPolar(this.getValueAxis().getCenter(), x, y);\n    return chart.getNeighborPoint.call(this, pos.phi, pos.r);\n  },\n  _applyVisibleArea: function _applyVisibleArea() {\n    var canvas = this.getValueAxis().getCanvas();\n    this._visibleArea = {\n      minX: canvas.left,\n      maxX: canvas.width - canvas.right,\n      minY: canvas.top,\n      maxY: canvas.height - canvas.bottom\n    };\n  },\n  getSeriesPairCoord: function getSeriesPairCoord(params, isArgument) {\n    var coords = null;\n    var paramName = isArgument ? \"argument\" : \"radius\";\n    var points = this.getVisiblePoints();\n\n    for (var i = 0; i < points.length; i++) {\n      var p = points[i];\n      var tmpPoint = _isDefined(p[paramName]) && _isDefined(params[paramName]) && p[paramName].valueOf() === params[paramName].valueOf() ? {\n        x: p.x,\n        y: p.y\n      } : void 0;\n\n      if (_isDefined(tmpPoint)) {\n        coords = tmpPoint;\n        break;\n      }\n    }\n\n    return coords;\n  }\n});\nexport { chart, polar };","map":null,"metadata":{},"sourceType":"module"}