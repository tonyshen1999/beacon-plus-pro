{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/themes.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { getOuterHeight } from \"../core/utils/size\";\nimport devices from \"../core/devices\";\nimport domAdapter from \"../core/dom_adapter\";\nimport Promise from \"../core/polyfills/promise\";\nimport $ from \"../core/renderer\";\nimport { Deferred } from \"../core/utils/deferred\";\nimport { parseHTML } from \"../core/utils/html_parser\";\nimport { each } from \"../core/utils/iterator\";\nimport readyCallbacks from \"../core/utils/ready_callbacks\";\nimport { value as viewPortValue, changeCallback, originalViewPort } from \"../core/utils/view_port\";\nimport { getWindow, hasWindow } from \"../core/utils/window\";\nimport { themeReadyCallback } from \"./themes_callback\";\nimport errors from \"./widget/ui.errors\";\nvar window = getWindow();\nvar ready = readyCallbacks.add;\nvar viewPort = viewPortValue;\nvar viewPortChanged = changeCallback;\nvar initDeferred = new Deferred();\nvar DX_LINK_SELECTOR = \"link[rel=dx-theme]\";\nvar THEME_ATTR = \"data-theme\";\nvar ACTIVE_ATTR = \"data-active\";\nvar DX_HAIRLINES_CLASS = \"dx-hairlines\";\nvar ANY_THEME = \"any\";\nvar context;\nvar $activeThemeLink;\nvar knownThemes;\nvar currentThemeName;\nvar pendingThemeName;\nvar defaultTimeout = 15e3;\nvar THEME_MARKER_PREFIX = \"dx.\";\n\nfunction readThemeMarker() {\n  if (!hasWindow()) {\n    return null;\n  }\n\n  var element = $(\"<div>\", context).addClass(\"dx-theme-marker\").appendTo(context.documentElement);\n  var result;\n\n  try {\n    result = window.getComputedStyle(element.get(0)).fontFamily;\n\n    if (!result) {\n      return null;\n    }\n\n    result = result.replace(/[\"']/g, \"\");\n\n    if (result.substr(0, THEME_MARKER_PREFIX.length) !== THEME_MARKER_PREFIX) {\n      return null;\n    }\n\n    return result.substr(THEME_MARKER_PREFIX.length);\n  } finally {\n    element.remove();\n  }\n}\n\nexport function waitForThemeLoad(themeName) {\n  var waitStartTime;\n  var timerId;\n  var intervalCleared = true;\n  pendingThemeName = themeName;\n\n  function handleLoaded() {\n    pendingThemeName = null;\n    clearInterval(timerId);\n    intervalCleared = true;\n    themeReadyCallback.fire();\n    themeReadyCallback.empty();\n    initDeferred.resolve();\n  }\n\n  if (isPendingThemeLoaded() || !defaultTimeout) {\n    handleLoaded();\n  } else {\n    if (!intervalCleared) {\n      if (pendingThemeName) {\n        pendingThemeName = themeName;\n      }\n\n      return;\n    }\n\n    waitStartTime = Date.now();\n    intervalCleared = false;\n    timerId = setInterval(function () {\n      var isLoaded = isPendingThemeLoaded();\n      var isTimeout = !isLoaded && Date.now() - waitStartTime > defaultTimeout;\n\n      if (isTimeout) {\n        errors.log(\"W0004\", pendingThemeName);\n      }\n\n      if (isLoaded || isTimeout) {\n        handleLoaded();\n      }\n    }, 10);\n  }\n}\nexport function isPendingThemeLoaded() {\n  if (!pendingThemeName) {\n    return true;\n  }\n\n  var anyThemePending = pendingThemeName === ANY_THEME;\n\n  if (\"resolved\" === initDeferred.state() && anyThemePending) {\n    return true;\n  }\n\n  var themeMarker = readThemeMarker();\n\n  if (themeMarker && anyThemePending) {\n    return true;\n  }\n\n  return themeMarker === pendingThemeName;\n}\n\nfunction processMarkup() {\n  var $allThemeLinks = $(DX_LINK_SELECTOR, context);\n\n  if (!$allThemeLinks.length) {\n    return;\n  }\n\n  knownThemes = {};\n  $activeThemeLink = $(parseHTML(\"<link rel=stylesheet>\"), context);\n  $allThemeLinks.each(function () {\n    var link = $(this, context);\n    var fullThemeName = link.attr(THEME_ATTR);\n    var url = link.attr(\"href\");\n    var isActive = \"true\" === link.attr(ACTIVE_ATTR);\n    knownThemes[fullThemeName] = {\n      url: url,\n      isActive: isActive\n    };\n  });\n  $allThemeLinks.last().after($activeThemeLink);\n  $allThemeLinks.remove();\n}\n\nfunction resolveFullThemeName(desiredThemeName) {\n  var desiredThemeParts = desiredThemeName ? desiredThemeName.split(\".\") : [];\n  var result = null;\n\n  if (knownThemes) {\n    if (desiredThemeName in knownThemes) {\n      return desiredThemeName;\n    }\n\n    each(knownThemes, function (knownThemeName, themeData) {\n      var knownThemeParts = knownThemeName.split(\".\");\n\n      if (desiredThemeParts[0] && knownThemeParts[0] !== desiredThemeParts[0]) {\n        return;\n      }\n\n      if (desiredThemeParts[1] && desiredThemeParts[1] !== knownThemeParts[1]) {\n        return;\n      }\n\n      if (desiredThemeParts[2] && desiredThemeParts[2] !== knownThemeParts[2]) {\n        return;\n      }\n\n      if (!result || themeData.isActive) {\n        result = knownThemeName;\n      }\n\n      if (themeData.isActive) {\n        return false;\n      }\n    });\n  }\n\n  return result;\n}\n\nfunction initContext(newContext) {\n  try {\n    if (newContext !== context) {\n      knownThemes = null;\n    }\n  } catch (x) {\n    knownThemes = null;\n  }\n\n  context = newContext;\n}\n\nexport function init(options) {\n  options = options || {};\n  initContext(options.context || domAdapter.getDocument());\n\n  if (!context) {\n    return;\n  }\n\n  processMarkup();\n  currentThemeName = void 0;\n  current(options);\n}\nexport function current(options) {\n  if (!arguments.length) {\n    currentThemeName = currentThemeName || readThemeMarker();\n    return currentThemeName;\n  }\n\n  detachCssClasses(viewPort());\n  options = options || {};\n\n  if (\"string\" === typeof options) {\n    options = {\n      theme: options\n    };\n  }\n\n  var isAutoInit = options._autoInit;\n  var loadCallback = options.loadCallback;\n  var currentThemeData;\n  currentThemeName = resolveFullThemeName(options.theme || currentThemeName);\n\n  if (currentThemeName) {\n    currentThemeData = knownThemes[currentThemeName];\n  }\n\n  if (loadCallback) {\n    themeReadyCallback.add(loadCallback);\n  }\n\n  if (currentThemeData) {\n    $activeThemeLink.attr(\"href\", knownThemes[currentThemeName].url);\n\n    if (themeReadyCallback.has() || \"resolved\" !== initDeferred.state() || options._forceTimeout) {\n      waitForThemeLoad(currentThemeName);\n    }\n  } else if (isAutoInit) {\n    if (hasWindow()) {\n      waitForThemeLoad(ANY_THEME);\n    }\n\n    themeReadyCallback.fire();\n    themeReadyCallback.empty();\n  } else {\n    throw errors.Error(\"E0021\", currentThemeName);\n  }\n\n  initDeferred.done(function () {\n    return attachCssClasses(originalViewPort(), currentThemeName);\n  });\n}\n\nfunction getCssClasses(themeName) {\n  themeName = themeName || current();\n  var result = [];\n  var themeNameParts = themeName && themeName.split(\".\");\n\n  if (themeNameParts) {\n    result.push(\"dx-theme-\" + themeNameParts[0], \"dx-theme-\" + themeNameParts[0] + \"-typography\");\n\n    if (themeNameParts.length > 1) {\n      result.push(\"dx-color-scheme-\" + themeNameParts[1] + (isMaterial(themeName) ? \"-\" + themeNameParts[2] : \"\"));\n    }\n  }\n\n  return result;\n}\n\nvar themeClasses;\nexport function attachCssClasses(element, themeName) {\n  themeClasses = getCssClasses(themeName).join(\" \");\n  $(element).addClass(themeClasses);\n  !function () {\n    var pixelRatio = hasWindow() && window.devicePixelRatio;\n\n    if (!pixelRatio || pixelRatio < 2) {\n      return;\n    }\n\n    var $tester = $(\"<div>\");\n    $tester.css(\"border\", \".5px solid transparent\");\n    $(\"body\").append($tester);\n\n    if (1 === getOuterHeight($tester)) {\n      $(element).addClass(DX_HAIRLINES_CLASS);\n      themeClasses += \" \" + DX_HAIRLINES_CLASS;\n    }\n\n    $tester.remove();\n  }();\n}\nexport function detachCssClasses(element) {\n  $(element).removeClass(themeClasses);\n}\n\nfunction themeReady(callback) {\n  themeReadyCallback.add(callback);\n}\n\nfunction isTheme(themeRegExp, themeName) {\n  if (!themeName) {\n    themeName = currentThemeName || readThemeMarker();\n  }\n\n  return new RegExp(themeRegExp).test(themeName);\n}\n\nexport function isMaterial(themeName) {\n  return isTheme(\"material\", themeName);\n}\nexport function isGeneric(themeName) {\n  return isTheme(\"generic\", themeName);\n}\nexport function isDark(themeName) {\n  return isTheme(\"dark\", themeName);\n}\nexport function isCompact(themeName) {\n  return isTheme(\"compact\", themeName);\n}\nexport function isWebFontLoaded(text, fontWeight) {\n  var document = domAdapter.getDocument();\n  var testElement = document.createElement(\"span\");\n  testElement.style.position = \"absolute\";\n  testElement.style.top = \"-9999px\";\n  testElement.style.left = \"-9999px\";\n  testElement.style.visibility = \"hidden\";\n  testElement.style.fontFamily = \"Arial\";\n  testElement.style.fontSize = \"250px\";\n  testElement.style.fontWeight = fontWeight;\n  testElement.innerHTML = text;\n  document.body.appendChild(testElement);\n  var etalonFontWidth = testElement.offsetWidth;\n  testElement.style.fontFamily = \"Roboto, RobotoFallback, Arial\";\n  var testedFontWidth = testElement.offsetWidth;\n  testElement.parentNode.removeChild(testElement);\n  return etalonFontWidth !== testedFontWidth;\n}\nexport function waitWebFont(text, fontWeight) {\n  return new Promise(function (resolve) {\n    var clear = function clear() {\n      clearInterval(intervalId);\n      clearTimeout(timeoutId);\n      resolve();\n    };\n\n    var intervalId = setInterval(function () {\n      if (isWebFontLoaded(text, fontWeight)) {\n        clear();\n      }\n    }, 15);\n    var timeoutId = setTimeout(clear, 2e3);\n  });\n}\n\nfunction autoInit() {\n  init({\n    _autoInit: true,\n    _forceTimeout: true\n  });\n\n  if ($(DX_LINK_SELECTOR, context).length) {\n    throw errors.Error(\"E0022\");\n  }\n}\n\nif (hasWindow()) {\n  autoInit();\n} else {\n  ready(autoInit);\n}\n\nviewPortChanged.add(function (viewPort, prevViewPort) {\n  initDeferred.done(function () {\n    detachCssClasses(prevViewPort);\n    attachCssClasses(viewPort);\n  });\n});\ndevices.changed.add(function () {\n  init({\n    _autoInit: true\n  });\n});\nexport { themeReady as ready };\nexport function resetTheme() {\n  $activeThemeLink && $activeThemeLink.attr(\"href\", \"about:blank\");\n  currentThemeName = null;\n  pendingThemeName = null;\n  initDeferred = new Deferred();\n}\nexport function initialized(callback) {\n  initDeferred.done(callback);\n}\nexport function setDefaultTimeout(timeout) {\n  defaultTimeout = timeout;\n}\nexport default {\n  setDefaultTimeout: setDefaultTimeout,\n  initialized: initialized,\n  resetTheme: resetTheme,\n  ready: themeReady,\n  waitWebFont: waitWebFont,\n  isWebFontLoaded: isWebFontLoaded,\n  isCompact: isCompact,\n  isDark: isDark,\n  isGeneric: isGeneric,\n  isMaterial: isMaterial,\n  detachCssClasses: detachCssClasses,\n  attachCssClasses: attachCssClasses,\n  current: current,\n  waitForThemeLoad: waitForThemeLoad,\n  isPendingThemeLoaded: isPendingThemeLoaded\n};","map":null,"metadata":{},"sourceType":"module"}