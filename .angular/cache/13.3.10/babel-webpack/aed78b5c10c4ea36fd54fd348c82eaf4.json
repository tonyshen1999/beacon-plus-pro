{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/grid_core/ui.grid_core.editing_cell_based.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport $ from \"../../core/renderer\";\nimport domAdapter from \"../../core/dom_adapter\";\nimport { getWindow } from \"../../core/utils/window\";\nimport eventsEngine from \"../../events/core/events_engine\";\nimport { isDefined, isString } from \"../../core/utils/type\";\nimport { name as clickEventName } from \"../../events/click\";\nimport pointerEvents from \"../../events/pointer\";\nimport { addNamespace } from \"../../events/utils/index\";\nimport holdEvent from \"../../events/hold\";\nimport { when, Deferred } from \"../../core/utils/deferred\";\nimport { deferRender } from \"../../core/utils/common\";\nimport { createObjectWithChanges } from \"../../data/array_utils\";\nimport { EDIT_MODE_BATCH, EDIT_MODE_CELL, TARGET_COMPONENT_NAME } from \"./ui.grid_core.editing_constants\";\nvar FOCUS_OVERLAY_CLASS = \"focus-overlay\";\nvar ADD_ROW_BUTTON_CLASS = \"addrow-button\";\nvar DROPDOWN_EDITOR_OVERLAY_CLASS = \"dx-dropdowneditor-overlay\";\nvar EDITOR_CELL_CLASS = \"dx-editor-cell\";\nvar ROW_CLASS = \"dx-row\";\nvar CELL_MODIFIED_CLASS = \"dx-cell-modified\";\nvar DATA_ROW_CLASS = \"dx-data-row\";\nvar ROW_REMOVED = \"dx-row-removed\";\nvar EDITING_EDITROWKEY_OPTION_NAME = \"editing.editRowKey\";\nvar EDITING_EDITCOLUMNNAME_OPTION_NAME = \"editing.editColumnName\";\nvar DATA_EDIT_DATA_REMOVE_TYPE = \"remove\";\nexport default {\n  extenders: {\n    controllers: {\n      editing: {\n        init: function init() {\n          var _this = this;\n\n          var needCreateHandlers = !this._saveEditorHandler;\n          this.callBase.apply(this, arguments);\n\n          if (needCreateHandlers) {\n            var $pointerDownTarget;\n            var isResizing;\n\n            this._pointerUpEditorHandler = function () {\n              var _this$getController;\n\n              isResizing = null === (_this$getController = _this.getController(\"columnsResizer\")) || void 0 === _this$getController ? void 0 : _this$getController.isResizing();\n            };\n\n            this._pointerDownEditorHandler = function (e) {\n              return $pointerDownTarget = $(e.target);\n            };\n\n            this._saveEditorHandler = this.createAction(function (e) {\n              var event = e.event;\n              var $target = $(event.target);\n              var targetComponent = event[TARGET_COMPONENT_NAME];\n\n              if ($pointerDownTarget && $pointerDownTarget.is(\"input\") && !$pointerDownTarget.is($target)) {\n                return;\n              }\n\n              function checkEditorPopup($element) {\n                return $element && !!$element.closest(\".\".concat(DROPDOWN_EDITOR_OVERLAY_CLASS)).length;\n              }\n\n              if (this.isCellOrBatchEditMode() && !this._editCellInProgress) {\n                var isEditorPopup = checkEditorPopup($target) || checkEditorPopup(null === targetComponent || void 0 === targetComponent ? void 0 : targetComponent.$element());\n                var isDomElement = !!$target.closest(getWindow().document).length;\n                var isAnotherComponent = targetComponent && !targetComponent._disposed && targetComponent !== this.component;\n                var isAddRowButton = !!$target.closest(\".\".concat(this.addWidgetPrefix(ADD_ROW_BUTTON_CLASS))).length;\n                var isFocusOverlay = $target.hasClass(this.addWidgetPrefix(FOCUS_OVERLAY_CLASS));\n                var isCellEditMode = this.isCellEditMode();\n\n                if (!isResizing && !isEditorPopup && !isFocusOverlay && !(isAddRowButton && isCellEditMode && this.isEditing()) && (isDomElement || isAnotherComponent)) {\n                  this._closeEditItem.bind(this)($target);\n                }\n              }\n            });\n            eventsEngine.on(domAdapter.getDocument(), pointerEvents.up, this._pointerUpEditorHandler);\n            eventsEngine.on(domAdapter.getDocument(), pointerEvents.down, this._pointerDownEditorHandler);\n            eventsEngine.on(domAdapter.getDocument(), clickEventName, this._saveEditorHandler);\n          }\n        },\n        isCellEditMode: function isCellEditMode() {\n          return this.option(\"editing.mode\") === EDIT_MODE_CELL;\n        },\n        isBatchEditMode: function isBatchEditMode() {\n          return this.option(\"editing.mode\") === EDIT_MODE_BATCH;\n        },\n        isCellOrBatchEditMode: function isCellOrBatchEditMode() {\n          return this.isCellEditMode() || this.isBatchEditMode();\n        },\n        _needToCloseEditableCell: function _needToCloseEditableCell($targetElement) {\n          var $element = this.component.$element();\n          var result = this.isEditing();\n          var isCurrentComponentElement = !$element || !!$targetElement.closest($element).length;\n\n          if (isCurrentComponentElement) {\n            var isDataRow = $targetElement.closest(\".\" + DATA_ROW_CLASS).length;\n\n            if (isDataRow) {\n              var rowsView = this.getView(\"rowsView\");\n              var $targetCell = $targetElement.closest(\".\" + ROW_CLASS + \"> td\");\n              var rowIndex = rowsView.getRowIndex($targetCell.parent());\n              var columnIndex = rowsView.getCellElements(rowIndex).index($targetCell);\n\n              var visibleColumns = this._columnsController.getVisibleColumns();\n\n              var allowEditing = visibleColumns[columnIndex] && visibleColumns[columnIndex].allowEditing;\n              result = result && !allowEditing && !this.isEditCell(rowIndex, columnIndex);\n            }\n          }\n\n          return result || this.callBase.apply(this, arguments);\n        },\n        _closeEditItem: function _closeEditItem($targetElement) {\n          if (this._needToCloseEditableCell($targetElement)) {\n            this.closeEditCell();\n          }\n        },\n        _focusEditorIfNeed: function _focusEditorIfNeed() {\n          var _this2 = this;\n\n          if (this._needFocusEditor && this.isCellOrBatchEditMode()) {\n            var _this$_rowsView;\n\n            var editColumnIndex = this._getVisibleEditColumnIndex();\n\n            var $cell = null === (_this$_rowsView = this._rowsView) || void 0 === _this$_rowsView ? void 0 : _this$_rowsView._getCellElement(this._getVisibleEditRowIndex(), editColumnIndex);\n\n            if ($cell && !$cell.find(\":focus\").length) {\n              this._focusEditingCell(function () {\n                _this2._editCellInProgress = false;\n              }, $cell, true);\n            } else {\n              this._editCellInProgress = false;\n            }\n\n            this._needFocusEditor = false;\n          } else {\n            this.callBase.apply(this, arguments);\n          }\n        },\n        isEditing: function isEditing() {\n          if (this.isCellOrBatchEditMode()) {\n            var isEditRowKeyDefined = isDefined(this.option(EDITING_EDITROWKEY_OPTION_NAME));\n            var isEditColumnNameDefined = isDefined(this.option(EDITING_EDITCOLUMNNAME_OPTION_NAME));\n            return isEditRowKeyDefined && isEditColumnNameDefined;\n          }\n\n          return this.callBase.apply(this, arguments);\n        },\n        _handleEditColumnNameChange: function _handleEditColumnNameChange(args) {\n          var oldRowIndex = this._getVisibleEditRowIndex(args.previousValue);\n\n          if (this.isCellOrBatchEditMode() && -1 !== oldRowIndex && isDefined(args.value) && args.value !== args.previousValue) {\n            var columnIndex = this._columnsController.getVisibleColumnIndex(args.value);\n\n            var oldColumnIndex = this._columnsController.getVisibleColumnIndex(args.previousValue);\n\n            this._editCellFromOptionChanged(columnIndex, oldColumnIndex, oldRowIndex);\n          }\n        },\n        _addRow: function _addRow(parentKey, deferred) {\n          var _this3 = this;\n\n          if (this.isCellEditMode() && this.hasChanges()) {\n            var _deferred = new Deferred();\n\n            this.saveEditData().done(function () {\n              if (!_this3.hasChanges()) {\n                _this3.addRow(parentKey).done(_deferred.resolve).fail(_deferred.reject);\n              } else {\n                _deferred.reject(\"cancel\");\n              }\n            });\n            return _deferred.promise();\n          }\n\n          return this.callBase.apply(this, arguments);\n        },\n        editCell: function editCell(rowIndex, columnIndex) {\n          return this._editCell({\n            rowIndex: rowIndex,\n            columnIndex: columnIndex\n          });\n        },\n        _editCell: function _editCell(options) {\n          var _this4 = this;\n\n          var d = new Deferred();\n          var coreResult;\n          this.executeOperation(d, function () {\n            coreResult = _this4._editCellCore(options);\n            when(coreResult).done(d.resolve).fail(d.reject);\n          });\n          return void 0 !== coreResult ? coreResult : d.promise();\n        },\n        _editCellCore: function _editCellCore(options) {\n          var _this5 = this;\n\n          var dataController = this._dataController;\n          var isEditByOptionChanged = isDefined(options.oldColumnIndex) || isDefined(options.oldRowIndex);\n\n          var _this$_getNormalizedE = this._getNormalizedEditCellOptions(options),\n              columnIndex = _this$_getNormalizedE.columnIndex,\n              rowIndex = _this$_getNormalizedE.rowIndex,\n              column = _this$_getNormalizedE.column,\n              item = _this$_getNormalizedE.item;\n\n          var params = {\n            data: null === item || void 0 === item ? void 0 : item.data,\n            cancel: false,\n            column: column\n          };\n\n          if (void 0 === item.key) {\n            this._dataController.fireError(\"E1043\");\n\n            return;\n          }\n\n          if (column && (\"data\" === item.rowType || \"detailAdaptive\" === item.rowType) && !item.removed && this.isCellOrBatchEditMode()) {\n            if (!isEditByOptionChanged && this.isEditCell(rowIndex, columnIndex)) {\n              return true;\n            }\n\n            var editRowIndex = rowIndex + dataController.getRowIndexOffset();\n            return when(this._beforeEditCell(rowIndex, columnIndex, item)).done(function (cancel) {\n              if (cancel) {\n                return;\n              }\n\n              if (!_this5._prepareEditCell(params, item, columnIndex, editRowIndex)) {\n                _this5._processCanceledEditingCell();\n              }\n            });\n          }\n\n          return false;\n        },\n        _beforeEditCell: function _beforeEditCell(rowIndex, columnIndex, item) {\n          var _this6 = this;\n\n          if (this.isCellEditMode() && !item.isNewRow && this.hasChanges()) {\n            var d = new Deferred();\n            this.saveEditData().always(function () {\n              d.resolve(_this6.hasChanges());\n            });\n            return d;\n          }\n        },\n        publicMethods: function publicMethods() {\n          var publicMethods = this.callBase.apply(this, arguments);\n          return publicMethods.concat([\"editCell\", \"closeEditCell\"]);\n        },\n        _getNormalizedEditCellOptions: function _getNormalizedEditCellOptions(_ref) {\n          var oldColumnIndex = _ref.oldColumnIndex,\n              oldRowIndex = _ref.oldRowIndex,\n              columnIndex = _ref.columnIndex,\n              rowIndex = _ref.rowIndex;\n          var columnsController = this._columnsController;\n          var visibleColumns = columnsController.getVisibleColumns();\n\n          var items = this._dataController.items();\n\n          var item = items[rowIndex];\n          var oldColumn;\n\n          if (isDefined(oldColumnIndex)) {\n            oldColumn = visibleColumns[oldColumnIndex];\n          } else {\n            oldColumn = this._getEditColumn();\n          }\n\n          if (!isDefined(oldRowIndex)) {\n            oldRowIndex = this._getVisibleEditRowIndex();\n          }\n\n          if (isString(columnIndex)) {\n            columnIndex = columnsController.columnOption(columnIndex, \"index\");\n            columnIndex = columnsController.getVisibleIndex(columnIndex);\n          }\n\n          var column = visibleColumns[columnIndex];\n          return {\n            oldColumn: oldColumn,\n            columnIndex: columnIndex,\n            oldRowIndex: oldRowIndex,\n            rowIndex: rowIndex,\n            column: column,\n            item: item\n          };\n        },\n        _prepareEditCell: function _prepareEditCell(params, item, editColumnIndex, editRowIndex) {\n          if (!item.isNewRow) {\n            params.key = item.key;\n          }\n\n          if (this._isEditingStart(params)) {\n            return false;\n          }\n\n          this._pageIndex = this._dataController.pageIndex();\n\n          this._setEditRowKey(item.key);\n\n          this._setEditColumnNameByIndex(editColumnIndex);\n\n          if (!params.column.showEditorAlways) {\n            var _item$oldData;\n\n            this._addInternalData({\n              key: item.key,\n              oldData: null !== (_item$oldData = item.oldData) && void 0 !== _item$oldData ? _item$oldData : item.data\n            });\n          }\n\n          return true;\n        },\n        closeEditCell: function closeEditCell(isError, withoutSaveEditData) {\n          var _this7 = this;\n\n          var result = when();\n\n          var oldEditRowIndex = this._getVisibleEditRowIndex();\n\n          if (this.isCellOrBatchEditMode()) {\n            var deferred = new Deferred();\n            result = new Deferred();\n            this.executeOperation(deferred, function () {\n              _this7._closeEditCellCore(isError, oldEditRowIndex, withoutSaveEditData).always(result.resolve);\n            });\n          }\n\n          return result.promise();\n        },\n        _closeEditCellCore: function _closeEditCellCore(isError, oldEditRowIndex, withoutSaveEditData) {\n          var _this8 = this;\n\n          var dataController = this._dataController;\n          var deferred = new Deferred();\n          var promise = deferred.promise();\n\n          if (this.isCellEditMode() && this.hasChanges()) {\n            if (!withoutSaveEditData) {\n              this.saveEditData().done(function (error) {\n                if (!_this8.hasChanges()) {\n                  _this8.closeEditCell(!!error).always(deferred.resolve);\n\n                  return;\n                }\n\n                deferred.resolve();\n              });\n              return promise;\n            }\n          } else {\n            this._resetEditRowKey();\n\n            this._resetEditColumnName();\n\n            if (oldEditRowIndex >= 0) {\n              var rowIndices = [oldEditRowIndex];\n\n              this._beforeCloseEditCellInBatchMode(rowIndices);\n\n              if (!isError) {\n                dataController.updateItems({\n                  changeType: \"update\",\n                  rowIndices: rowIndices\n                });\n              }\n            }\n          }\n\n          deferred.resolve();\n          return promise;\n        },\n        _resetModifiedClassCells: function _resetModifiedClassCells(changes) {\n          var _this9 = this;\n\n          if (this.isBatchEditMode()) {\n            var columnsCount = this._columnsController.getVisibleColumns().length;\n\n            changes.forEach(function (_ref2) {\n              var key = _ref2.key;\n\n              var rowIndex = _this9._dataController.getRowIndexByKey(key);\n\n              if (-1 !== rowIndex) {\n                for (var columnIndex = 0; columnIndex < columnsCount; columnIndex++) {\n                  _this9._rowsView._getCellElement(rowIndex, columnIndex).removeClass(CELL_MODIFIED_CLASS);\n                }\n              }\n            });\n          }\n        },\n        _prepareChange: function _prepareChange(options, value, text) {\n          var $cellElement = $(options.cellElement);\n\n          if (this.isBatchEditMode() && void 0 !== options.key) {\n            this._applyModified($cellElement, options);\n          }\n\n          return this.callBase.apply(this, arguments);\n        },\n        _cancelSaving: function _cancelSaving() {\n          var dataController = this._dataController;\n\n          if (this.isCellOrBatchEditMode()) {\n            if (this.isBatchEditMode()) {\n              this._resetEditIndices();\n            }\n\n            dataController.updateItems();\n          }\n\n          this.callBase.apply(this, arguments);\n        },\n        optionChanged: function optionChanged(args) {\n          var fullName = args.fullName;\n\n          if (\"editing\" === args.name && fullName === EDITING_EDITCOLUMNNAME_OPTION_NAME) {\n            this._handleEditColumnNameChange(args);\n\n            args.handled = true;\n          } else {\n            this.callBase(args);\n          }\n        },\n        _editCellFromOptionChanged: function _editCellFromOptionChanged(columnIndex, oldColumnIndex, oldRowIndex) {\n          var _this10 = this;\n\n          var columns = this._columnsController.getVisibleColumns();\n\n          if (columnIndex > -1) {\n            deferRender(function () {\n              _this10._repaintEditCell(columns[columnIndex], columns[oldColumnIndex], oldRowIndex);\n            });\n          }\n        },\n        _handleEditRowKeyChange: function _handleEditRowKeyChange(args) {\n          if (this.isCellOrBatchEditMode()) {\n            var columnIndex = this._getVisibleEditColumnIndex();\n\n            var oldRowIndexCorrection = this._getEditRowIndexCorrection();\n\n            var oldRowIndex = this._dataController.getRowIndexByKey(args.previousValue) + oldRowIndexCorrection;\n\n            if (isDefined(args.value) && args.value !== args.previousValue) {\n              var _this$_editCellFromOp;\n\n              null === (_this$_editCellFromOp = this._editCellFromOptionChanged) || void 0 === _this$_editCellFromOp ? void 0 : _this$_editCellFromOp.call(this, columnIndex, columnIndex, oldRowIndex);\n            }\n          } else {\n            this.callBase.apply(this, arguments);\n          }\n        },\n        deleteRow: function deleteRow(rowIndex) {\n          var _this11 = this;\n\n          if (this.isCellEditMode() && this.isEditing()) {\n            var isNewRow = this._dataController.items()[rowIndex].isNewRow;\n\n            var rowKey = this._dataController.getKeyByRowIndex(rowIndex);\n\n            this.closeEditCell(null, isNewRow).always(function () {\n              rowIndex = _this11._dataController.getRowIndexByKey(rowKey);\n\n              _this11._checkAndDeleteRow(rowIndex);\n            });\n          } else {\n            this.callBase.apply(this, arguments);\n          }\n        },\n        _checkAndDeleteRow: function _checkAndDeleteRow(rowIndex) {\n          if (this.isBatchEditMode()) {\n            this._deleteRowCore(rowIndex);\n          } else {\n            this.callBase.apply(this, arguments);\n          }\n        },\n        _refreshCore: function _refreshCore(isPageChanged) {\n          var needResetIndexes = this.isBatchEditMode() || isPageChanged && \"virtual\" !== this.option(\"scrolling.mode\");\n\n          if (this.isCellOrBatchEditMode()) {\n            if (needResetIndexes) {\n              this._resetEditColumnName();\n\n              this._resetEditRowKey();\n            }\n          } else {\n            this.callBase.apply(this, arguments);\n          }\n        },\n        _allowRowAdding: function _allowRowAdding(params) {\n          if (this.isBatchEditMode()) {\n            return true;\n          }\n\n          return this.callBase.apply(this, arguments);\n        },\n        _afterDeleteRow: function _afterDeleteRow(rowIndex, oldEditRowIndex) {\n          var dataController = this._dataController;\n\n          if (this.isBatchEditMode()) {\n            dataController.updateItems({\n              changeType: \"update\",\n              rowIndices: [oldEditRowIndex, rowIndex]\n            });\n            return new Deferred().resolve();\n          }\n\n          return this.callBase.apply(this, arguments);\n        },\n        _updateEditRow: function _updateEditRow(row, forceUpdateRow, isCustomSetCellValue) {\n          if (this.isCellOrBatchEditMode()) {\n            this._updateRowImmediately(row, forceUpdateRow, isCustomSetCellValue);\n          } else {\n            this.callBase.apply(this, arguments);\n          }\n        },\n        _isDefaultButtonVisible: function _isDefaultButtonVisible(button, options) {\n          if (this.isCellOrBatchEditMode()) {\n            var isBatchMode = this.isBatchEditMode();\n\n            switch (button.name) {\n              case \"save\":\n              case \"cancel\":\n              case \"edit\":\n                return false;\n\n              case \"delete\":\n                return this.callBase.apply(this, arguments) && (!isBatchMode || !options.row.removed);\n\n              case \"undelete\":\n                return isBatchMode && this.allowDeleting(options) && options.row.removed;\n\n              default:\n                return this.callBase.apply(this, arguments);\n            }\n          }\n\n          return this.callBase.apply(this, arguments);\n        },\n        _isRowDeleteAllowed: function _isRowDeleteAllowed() {\n          var callBase = this.callBase.apply(this, arguments);\n          return callBase || this.isBatchEditMode();\n        },\n        _beforeEndSaving: function _beforeEndSaving(changes) {\n          if (this.isCellEditMode()) {\n            var _changes$;\n\n            if (\"update\" !== (null === (_changes$ = changes[0]) || void 0 === _changes$ ? void 0 : _changes$.type)) {\n              this.callBase.apply(this, arguments);\n            }\n          } else {\n            if (this.isBatchEditMode()) {\n              this._resetModifiedClassCells(changes);\n            }\n\n            this.callBase.apply(this, arguments);\n          }\n        },\n        prepareEditButtons: function prepareEditButtons(headerPanel) {\n          var editingOptions = this.option(\"editing\") || {};\n          var buttonItems = this.callBase.apply(this, arguments);\n\n          if ((editingOptions.allowUpdating || editingOptions.allowAdding || editingOptions.allowDeleting) && this.isBatchEditMode()) {\n            buttonItems.push(this.prepareButtonItem(headerPanel, \"save\", \"saveEditData\", 21));\n            buttonItems.push(this.prepareButtonItem(headerPanel, \"revert\", \"cancelEditData\", 22));\n          }\n\n          return buttonItems;\n        },\n        _saveEditDataInner: function _saveEditDataInner() {\n          var _deferred2;\n\n          var editRow = this._dataController.getVisibleRows()[this.getEditRowIndex()];\n\n          var editColumn = this._getEditColumn();\n\n          var showEditorAlways = null === editColumn || void 0 === editColumn ? void 0 : editColumn.showEditorAlways;\n          var isUpdateInCellMode = this.isCellEditMode() && !(null !== editRow && void 0 !== editRow && editRow.isNewRow);\n          var deferred;\n\n          if (isUpdateInCellMode && showEditorAlways) {\n            deferred = new Deferred();\n            this.addDeferred(deferred);\n          }\n\n          return this.callBase.apply(this, arguments).always(null === (_deferred2 = deferred) || void 0 === _deferred2 ? void 0 : _deferred2.resolve);\n        },\n        _applyChange: function _applyChange(options, params, forceUpdateRow) {\n          var isUpdateInCellMode = this.isCellEditMode() && options.row && !options.row.isNewRow;\n          var showEditorAlways = options.column.showEditorAlways;\n          var isCustomSetCellValue = options.column.setCellValue !== options.column.defaultSetCellValue;\n          var focusPreviousEditingCell = showEditorAlways && !forceUpdateRow && isUpdateInCellMode && this.hasEditData() && !this.isEditCell(options.rowIndex, options.columnIndex);\n\n          if (focusPreviousEditingCell) {\n            this._focusEditingCell();\n\n            this._updateEditRow(options.row, true, isCustomSetCellValue);\n\n            return;\n          }\n\n          return this.callBase.apply(this, arguments);\n        },\n        _applyChangeCore: function _applyChangeCore(options, forceUpdateRow) {\n          var showEditorAlways = options.column.showEditorAlways;\n          var isUpdateInCellMode = this.isCellEditMode() && options.row && !options.row.isNewRow;\n\n          if (showEditorAlways && !forceUpdateRow) {\n            if (isUpdateInCellMode) {\n              this._setEditRowKey(options.row.key, true);\n\n              this._setEditColumnNameByIndex(options.columnIndex, true);\n\n              return this.saveEditData();\n            } else if (this.isBatchEditMode()) {\n              forceUpdateRow = this._needUpdateRow(options.column);\n              return this.callBase(options, forceUpdateRow);\n            }\n          }\n\n          return this.callBase.apply(this, arguments);\n        },\n        _processDataItemCore: function _processDataItemCore(item, _ref3) {\n          var data = _ref3.data,\n              type = _ref3.type;\n\n          if (this.isBatchEditMode() && type === DATA_EDIT_DATA_REMOVE_TYPE) {\n            item.data = createObjectWithChanges(item.data, data);\n          }\n\n          this.callBase.apply(this, arguments);\n        },\n        _processRemoveCore: function _processRemoveCore(changes, editIndex, processIfBatch) {\n          if (this.isBatchEditMode() && !processIfBatch) {\n            return;\n          }\n\n          return this.callBase.apply(this, arguments);\n        },\n        _processRemoveIfError: function _processRemoveIfError() {\n          if (this.isBatchEditMode()) {\n            return;\n          }\n\n          return this.callBase.apply(this, arguments);\n        },\n        _beforeFocusElementInRow: function _beforeFocusElementInRow(rowIndex) {\n          this.callBase.apply(this, arguments);\n          var editRowIndex = rowIndex >= 0 ? rowIndex : 0;\n          var columnIndex = this.getFirstEditableColumnIndex();\n          columnIndex >= 0 && this.editCell(editRowIndex, columnIndex);\n        }\n      }\n    },\n    views: {\n      rowsView: {\n        _createTable: function _createTable() {\n          var $table = this.callBase.apply(this, arguments);\n          var editingController = this._editingController;\n\n          if (editingController.isCellOrBatchEditMode() && this.option(\"editing.allowUpdating\")) {\n            eventsEngine.on($table, addNamespace(holdEvent.name, \"dxDataGridRowsView\"), \"td:not(.\" + EDITOR_CELL_CLASS + \")\", this.createAction(function () {\n              if (editingController.isEditing()) {\n                editingController.closeEditCell();\n              }\n            }));\n          }\n\n          return $table;\n        },\n        _createRow: function _createRow(row) {\n          var $row = this.callBase.apply(this, arguments);\n\n          if (row) {\n            var editingController = this._editingController;\n            var isRowRemoved = !!row.removed;\n\n            if (editingController.isBatchEditMode()) {\n              isRowRemoved && $row.addClass(ROW_REMOVED);\n            }\n          }\n\n          return $row;\n        }\n      },\n      headerPanel: {\n        isVisible: function isVisible() {\n          var editingOptions = this.getController(\"editing\").option(\"editing\");\n          return this.callBase() || editingOptions && (editingOptions.allowUpdating || editingOptions.allowDeleting) && editingOptions.mode === EDIT_MODE_BATCH;\n        }\n      }\n    }\n  }\n};","map":null,"metadata":{},"sourceType":"module"}