{"ast":null,"code":"/**\r\n * DevExtreme (esm/viz/vector_map/projection.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { projection } from \"./projection.main\";\nvar _min = Math.min;\nvar _max = Math.max;\nvar _sin = Math.sin;\nvar _asin = Math.asin;\nvar _tan = Math.tan;\nvar _atan = Math.atan;\nvar _exp = Math.exp;\nvar _log = Math.log;\nvar PI = Math.PI;\nvar PI_DIV_4 = PI / 4;\nvar GEO_LON_BOUND = 180;\nvar GEO_LAT_BOUND = 90;\nvar RADIANS = PI / 180;\nvar MERCATOR_LAT_BOUND = (2 * _atan(_exp(PI)) - PI / 2) / RADIANS;\nvar MILLER_LAT_BOUND = (2.5 * _atan(_exp(.8 * PI)) - .625 * PI) / RADIANS;\n\nfunction clamp(value, threshold) {\n  return _max(_min(value, +threshold), -threshold);\n}\n\nprojection.add(\"mercator\", projection({\n  aspectRatio: 1,\n  to: function to(coordinates) {\n    return [coordinates[0] / GEO_LON_BOUND, _log(_tan(PI_DIV_4 + clamp(coordinates[1], MERCATOR_LAT_BOUND) * RADIANS / 2)) / PI];\n  },\n  from: function from(coordinates) {\n    return [coordinates[0] * GEO_LON_BOUND, (2 * _atan(_exp(coordinates[1] * PI)) - PI / 2) / RADIANS];\n  }\n}));\nprojection.add(\"equirectangular\", projection({\n  aspectRatio: 2,\n  to: function to(coordinates) {\n    return [coordinates[0] / GEO_LON_BOUND, coordinates[1] / GEO_LAT_BOUND];\n  },\n  from: function from(coordinates) {\n    return [coordinates[0] * GEO_LON_BOUND, coordinates[1] * GEO_LAT_BOUND];\n  }\n}));\nprojection.add(\"lambert\", projection({\n  aspectRatio: 2,\n  to: function to(coordinates) {\n    return [coordinates[0] / GEO_LON_BOUND, _sin(clamp(coordinates[1], GEO_LAT_BOUND) * RADIANS)];\n  },\n  from: function from(coordinates) {\n    return [coordinates[0] * GEO_LON_BOUND, _asin(clamp(coordinates[1], 1)) / RADIANS];\n  }\n}));\nprojection.add(\"miller\", projection({\n  aspectRatio: 1,\n  to: function to(coordinates) {\n    return [coordinates[0] / GEO_LON_BOUND, 1.25 * _log(_tan(PI_DIV_4 + clamp(coordinates[1], MILLER_LAT_BOUND) * RADIANS * .4)) / PI];\n  },\n  from: function from(coordinates) {\n    return [coordinates[0] * GEO_LON_BOUND, (2.5 * _atan(_exp(.8 * coordinates[1] * PI)) - .625 * PI) / RADIANS];\n  }\n}));\nexport { projection };","map":null,"metadata":{},"sourceType":"module"}