{"ast":null,"code":"/**\r\n * DevExtreme (esm/viz/chart_components/multi_axes_synchronizer.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { debug } from \"../../core/utils/console\";\nimport { isDefined, isNumeric } from \"../../core/utils/type\";\nimport { each } from \"../../core/utils/iterator\";\nimport { getLogExt, raiseToExt } from \"../core/utils\";\nimport { adjust } from \"../../core/utils/math\";\nvar _math = Math;\nvar _floor = _math.floor;\nvar _max = _math.max;\nvar _abs = _math.abs;\n\nfunction getValueAxesPerPanes(valueAxes) {\n  var result = {};\n  valueAxes.forEach(function (axis) {\n    var pane = axis.pane;\n\n    if (!result[pane]) {\n      result[pane] = [];\n    }\n\n    result[pane].push(axis);\n  });\n  return result;\n}\n\nvar linearConverter = function linearConverter(br) {\n  return {\n    transform: function transform(v, b) {\n      return adjust(getLogExt(v, b, br.allowNegatives, br.linearThreshold));\n    },\n    getTicks: function getTicks(interval, tickValues, base) {\n      var ticks = [];\n      var tick = this.transform(tickValues[0], base);\n\n      while (ticks.length < tickValues.length) {\n        ticks.push(tick);\n        tick = adjust(tick + interval);\n      }\n\n      return ticks;\n    }\n  };\n};\n\nvar logConverter = function logConverter(br) {\n  return {\n    transform: function transform(v, b) {\n      return adjust(raiseToExt(v, b, br.allowNegatives, br.linearThreshold));\n    },\n    getTicks: function getTicks(interval, tickValues, base) {\n      var ticks = [];\n      var tick;\n\n      for (var i = 0; i < tickValues.length; i += 1) {\n        tick = this.transform(tickValues[i], base);\n        ticks.push(tick);\n      }\n\n      return ticks;\n    }\n  };\n};\n\nfunction convertAxisInfo(axisInfo, converter) {\n  if (!axisInfo.isLogarithmic) {\n    return;\n  }\n\n  var base = axisInfo.logarithmicBase;\n  var tickValues = axisInfo.tickValues;\n  axisInfo.minValue = converter.transform(axisInfo.minValue, base);\n  axisInfo.oldMinValue = converter.transform(axisInfo.oldMinValue, base);\n  axisInfo.maxValue = converter.transform(axisInfo.maxValue, base);\n  axisInfo.oldMaxValue = converter.transform(axisInfo.oldMaxValue, base);\n  axisInfo.tickInterval = _math.round(axisInfo.tickInterval);\n\n  if (axisInfo.tickInterval < 1) {\n    axisInfo.tickInterval = 1;\n  }\n\n  var ticks = converter.getTicks(axisInfo.tickInterval, tickValues, base);\n  ticks.tickInterval = axisInfo.tickInterval;\n  axisInfo.tickValues = ticks;\n}\n\nfunction populateAxesInfo(axes) {\n  return axes.reduce(function (result, axis) {\n    var ticksValues = axis.getTicksValues();\n    var majorTicks = ticksValues.majorTicksValues;\n    var options = axis.getOptions();\n    var businessRange = axis.getTranslator().getBusinessRange();\n    var visibleArea = axis.getVisibleArea();\n    var axisInfo;\n    var tickInterval = axis._tickInterval;\n    var synchronizedValue = options.synchronizedValue;\n    var action = axis.getViewport().action;\n\n    if (majorTicks && majorTicks.length > 0 && isNumeric(majorTicks[0]) && \"discrete\" !== options.type && !businessRange.isEmpty() && !(businessRange.breaks && businessRange.breaks.length) && \"zoom\" !== action && \"pan\" !== action) {\n      axis.applyMargins();\n      var startValue = axis.getTranslator().from(visibleArea[0]);\n      var endValue = axis.getTranslator().from(visibleArea[1]);\n      var minValue = startValue < endValue ? startValue : endValue;\n      var maxValue = startValue < endValue ? endValue : startValue;\n\n      if (minValue === maxValue && isDefined(synchronizedValue)) {\n        tickInterval = _abs(majorTicks[0] - synchronizedValue) || 1;\n        minValue = majorTicks[0] - tickInterval;\n        maxValue = majorTicks[0] + tickInterval;\n      }\n\n      axisInfo = {\n        axis: axis,\n        isLogarithmic: \"logarithmic\" === options.type,\n        logarithmicBase: businessRange.base,\n        tickValues: majorTicks,\n        minorValues: ticksValues.minorTicksValues,\n        minorTickInterval: axis._minorTickInterval,\n        minValue: minValue,\n        oldMinValue: minValue,\n        maxValue: maxValue,\n        oldMaxValue: maxValue,\n        inverted: businessRange.invert,\n        tickInterval: tickInterval,\n        synchronizedValue: synchronizedValue\n      };\n      convertAxisInfo(axisInfo, linearConverter(axis.getTranslator().getBusinessRange()));\n      result.push(axisInfo);\n    }\n\n    return result;\n  }, []);\n}\n\nfunction updateTickValues(axesInfo) {\n  var maxTicksCount = axesInfo.reduce(function (max, axisInfo) {\n    return _max(max, axisInfo.tickValues.length);\n  }, 0);\n  axesInfo.forEach(function (axisInfo) {\n    var ticksMultiplier;\n    var ticksCount;\n    var additionalStartTicksCount = 0;\n    var synchronizedValue = axisInfo.synchronizedValue;\n    var tickValues = axisInfo.tickValues;\n    var tickInterval = axisInfo.tickInterval;\n\n    if (isDefined(synchronizedValue)) {\n      axisInfo.baseTickValue = axisInfo.invertedBaseTickValue = synchronizedValue;\n      axisInfo.tickValues = [axisInfo.baseTickValue];\n    } else {\n      if (tickValues.length > 1 && tickInterval) {\n        ticksMultiplier = _floor((maxTicksCount + 1) / tickValues.length);\n        ticksCount = ticksMultiplier > 1 ? _floor((maxTicksCount + 1) / ticksMultiplier) : maxTicksCount;\n        additionalStartTicksCount = _floor((ticksCount - tickValues.length) / 2);\n\n        while (additionalStartTicksCount > 0 && 0 !== tickValues[0]) {\n          tickValues.unshift(adjust(tickValues[0] - tickInterval));\n          additionalStartTicksCount--;\n        }\n\n        while (tickValues.length < ticksCount) {\n          tickValues.push(adjust(tickValues[tickValues.length - 1] + tickInterval));\n        }\n\n        axisInfo.tickInterval = tickInterval / ticksMultiplier;\n      }\n\n      axisInfo.baseTickValue = tickValues[0];\n      axisInfo.invertedBaseTickValue = tickValues[tickValues.length - 1];\n    }\n  });\n}\n\nfunction getAxisRange(axisInfo) {\n  return axisInfo.maxValue - axisInfo.minValue || 1;\n}\n\nfunction getMainAxisInfo(axesInfo) {\n  for (var i = 0; i < axesInfo.length; i++) {\n    if (!axesInfo[i].stubData) {\n      return axesInfo[i];\n    }\n  }\n\n  return null;\n}\n\nfunction correctMinMaxValues(axesInfo) {\n  var mainAxisInfo = getMainAxisInfo(axesInfo);\n  var mainAxisInfoTickInterval = mainAxisInfo.tickInterval;\n  axesInfo.forEach(function (axisInfo) {\n    var scale;\n    var move;\n    var mainAxisBaseValueOffset;\n    var valueFromAxisInfo;\n\n    if (axisInfo !== mainAxisInfo) {\n      if (mainAxisInfoTickInterval && axisInfo.tickInterval) {\n        if (axisInfo.stubData && isDefined(axisInfo.synchronizedValue)) {\n          axisInfo.oldMinValue = axisInfo.minValue = axisInfo.baseTickValue - (mainAxisInfo.baseTickValue - mainAxisInfo.minValue) / mainAxisInfoTickInterval * axisInfo.tickInterval;\n          axisInfo.oldMaxValue = axisInfo.maxValue = axisInfo.baseTickValue - (mainAxisInfo.baseTickValue - mainAxisInfo.maxValue) / mainAxisInfoTickInterval * axisInfo.tickInterval;\n        }\n\n        scale = mainAxisInfoTickInterval / getAxisRange(mainAxisInfo) / axisInfo.tickInterval * getAxisRange(axisInfo);\n        axisInfo.maxValue = axisInfo.minValue + getAxisRange(axisInfo) / scale;\n      }\n\n      if (mainAxisInfo.inverted && !axisInfo.inverted || !mainAxisInfo.inverted && axisInfo.inverted) {\n        mainAxisBaseValueOffset = mainAxisInfo.maxValue - mainAxisInfo.invertedBaseTickValue;\n      } else {\n        mainAxisBaseValueOffset = mainAxisInfo.baseTickValue - mainAxisInfo.minValue;\n      }\n\n      valueFromAxisInfo = getAxisRange(axisInfo);\n      move = (mainAxisBaseValueOffset / getAxisRange(mainAxisInfo) - (axisInfo.baseTickValue - axisInfo.minValue) / valueFromAxisInfo) * valueFromAxisInfo;\n      axisInfo.minValue -= move;\n      axisInfo.maxValue -= move;\n    }\n  });\n}\n\nfunction calculatePaddings(axesInfo) {\n  var minPadding;\n  var maxPadding;\n  var startPadding = 0;\n  var endPadding = 0;\n  axesInfo.forEach(function (axisInfo) {\n    var inverted = axisInfo.inverted;\n    minPadding = axisInfo.minValue > axisInfo.oldMinValue ? (axisInfo.minValue - axisInfo.oldMinValue) / getAxisRange(axisInfo) : 0;\n    maxPadding = axisInfo.maxValue < axisInfo.oldMaxValue ? (axisInfo.oldMaxValue - axisInfo.maxValue) / getAxisRange(axisInfo) : 0;\n    startPadding = _max(startPadding, inverted ? maxPadding : minPadding);\n    endPadding = _max(endPadding, inverted ? minPadding : maxPadding);\n  });\n  return {\n    start: startPadding,\n    end: endPadding\n  };\n}\n\nfunction correctMinMaxValuesByPaddings(axesInfo, paddings) {\n  axesInfo.forEach(function (info) {\n    var range = getAxisRange(info);\n    var inverted = info.inverted;\n    info.minValue = adjust(info.minValue - paddings[inverted ? \"end\" : \"start\"] * range);\n    info.maxValue = adjust(info.maxValue + paddings[inverted ? \"start\" : \"end\"] * range);\n  });\n}\n\nfunction updateTickValuesIfSynchronizedValueUsed(axesInfo) {\n  var hasSynchronizedValue = false;\n  axesInfo.forEach(function (info) {\n    hasSynchronizedValue = hasSynchronizedValue || isDefined(info.synchronizedValue);\n  });\n  axesInfo.forEach(function (info) {\n    var tickInterval = info.tickInterval;\n    var tickValues = info.tickValues;\n    var maxValue = info.maxValue;\n    var minValue = info.minValue;\n    var tick;\n\n    if (hasSynchronizedValue && tickInterval) {\n      while ((tick = adjust(tickValues[0] - tickInterval)) >= minValue) {\n        tickValues.unshift(tick);\n      }\n\n      tick = tickValues[tickValues.length - 1];\n\n      while ((tick = adjust(tick + tickInterval)) <= maxValue) {\n        tickValues.push(tick);\n      }\n    }\n\n    while (tickValues[0] + tickInterval / 10 < minValue) {\n      tickValues.shift();\n    }\n\n    while (tickValues[tickValues.length - 1] - tickInterval / 10 > maxValue) {\n      tickValues.pop();\n    }\n  });\n}\n\nfunction applyMinMaxValues(axesInfo) {\n  axesInfo.forEach(function (info) {\n    var axis = info.axis;\n    var range = axis.getTranslator().getBusinessRange();\n\n    if (range.min === range.minVisible) {\n      range.min = info.minValue;\n    }\n\n    if (range.max === range.maxVisible) {\n      range.max = info.maxValue;\n    }\n\n    range.minVisible = info.minValue;\n    range.maxVisible = info.maxValue;\n\n    if (range.min > range.minVisible) {\n      range.min = range.minVisible;\n    }\n\n    if (range.max < range.maxVisible) {\n      range.max = range.maxVisible;\n    }\n\n    axis.getTranslator().updateBusinessRange(range);\n    axis.setTicks({\n      majorTicks: info.tickValues,\n      minorTicks: info.minorValues\n    });\n  });\n}\n\nfunction correctAfterSynchronize(axesInfo) {\n  var invalidAxisInfo = [];\n  var correctValue;\n  axesInfo.forEach(function (info) {\n    if (info.oldMaxValue - info.oldMinValue === 0) {\n      invalidAxisInfo.push(info);\n    } else if (!isDefined(correctValue) && !isDefined(info.synchronizedValue)) {\n      correctValue = _abs((info.maxValue - info.minValue) / (info.tickValues[_floor(info.tickValues.length / 2)] - info.minValue || info.maxValue));\n    }\n  });\n\n  if (!isDefined(correctValue)) {\n    return;\n  }\n\n  invalidAxisInfo.forEach(function (info) {\n    var firstTick = info.tickValues[0];\n    var correctedTick = firstTick * correctValue;\n\n    if (firstTick > 0) {\n      info.maxValue = correctedTick;\n      info.minValue = 0;\n    } else if (firstTick < 0) {\n      info.minValue = correctedTick;\n      info.maxValue = 0;\n    }\n  });\n}\n\nfunction updateMinorTicks(axesInfo) {\n  axesInfo.forEach(function (axisInfo) {\n    if (!axisInfo.minorTickInterval) {\n      return;\n    }\n\n    var ticks = [];\n    var interval = axisInfo.minorTickInterval;\n    var tickCount = axisInfo.tickInterval / interval - 1;\n\n    for (var i = 1; i < axisInfo.tickValues.length; i++) {\n      var tick = axisInfo.tickValues[i - 1];\n\n      for (var j = 0; j < tickCount; j++) {\n        tick += interval;\n        ticks.push(tick);\n      }\n    }\n\n    axisInfo.minorValues = ticks;\n  });\n}\n\nfunction correctPaddings(axesInfo, paddings) {\n  return axesInfo.reduce(function (prev, info) {\n    var inverted = info.inverted;\n\n    var _info$axis$getCorrect = info.axis.getCorrectedValuesToZero(info.minValue, info.maxValue),\n        start = _info$axis$getCorrect.start,\n        end = _info$axis$getCorrect.end;\n\n    if (isDefined(start) || isDefined(end)) {\n      return inverted ? {\n        start: prev.start,\n        end: Math.min(prev.end, end)\n      } : {\n        start: Math.min(prev.start, start),\n        end: prev.end\n      };\n    }\n\n    return prev;\n  }, paddings);\n}\n\nvar multiAxesSynchronizer = {\n  synchronize: function synchronize(valueAxes) {\n    each(getValueAxesPerPanes(valueAxes), function (_, axes) {\n      var axesInfo;\n      var paddings;\n\n      if (axes.length > 1) {\n        axesInfo = populateAxesInfo(axes);\n\n        if (axesInfo.length < 2 || !getMainAxisInfo(axesInfo)) {\n          return;\n        }\n\n        updateTickValues(axesInfo);\n        correctMinMaxValues(axesInfo);\n        paddings = calculatePaddings(axesInfo);\n        paddings = correctPaddings(axesInfo, paddings);\n        correctMinMaxValuesByPaddings(axesInfo, paddings);\n        correctAfterSynchronize(axesInfo);\n        updateTickValuesIfSynchronizedValueUsed(axesInfo);\n        updateMinorTicks(axesInfo);\n        axesInfo.forEach(function (info) {\n          convertAxisInfo(info, logConverter(info.axis.getTranslator().getBusinessRange()));\n        });\n        applyMinMaxValues(axesInfo);\n      }\n    });\n  }\n};\nexport default multiAxesSynchronizer;","map":null,"metadata":{},"sourceType":"module"}