{"ast":null,"code":"import _defineProperty from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\n\n/**\r\n * DevExtreme (esm/viz/series/range_series.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { extend } from \"../../core/utils/extend\";\nvar _extend = extend;\nimport { isDefined as _isDefined } from \"../../core/utils/type\";\nimport { map as _map } from \"../core/utils\";\nimport { noop as _noop } from \"../../core/utils/common\";\nimport { chart as scatterSeries } from \"./scatter_series\";\nimport { chart as barChart } from \"./bar_series\";\nimport { chart as areaChart } from \"./area_series\";\nvar barSeries = barChart.bar;\nvar areaSeries = areaChart.area;\nvar chart = {};\nvar baseRangeSeries = {\n  areErrorBarsVisible: _noop,\n  _createErrorBarGroup: _noop,\n  _checkData: function _checkData(data, skippedFields) {\n    var valueFields = this.getValueFields();\n    return scatterSeries._checkData.call(this, data, skippedFields, {\n      minValue: valueFields[0],\n      value: valueFields[1]\n    }) && data.minValue === data.minValue;\n  },\n  getValueRangeInitialValue: scatterSeries.getValueRangeInitialValue,\n  _getPointDataSelector: function _getPointDataSelector(data) {\n    var _this = this;\n\n    var valueFields = this.getValueFields();\n    var val1Field = valueFields[0];\n    var val2Field = valueFields[1];\n    var tagField = this.getTagField();\n    var argumentField = this.getArgumentField();\n    return function (data) {\n      return {\n        tag: data[tagField],\n        minValue: _this._processEmptyValue(data[val1Field]),\n        value: _this._processEmptyValue(data[val2Field]),\n        argument: data[argumentField],\n        data: data\n      };\n    };\n  },\n  _defaultAggregator: \"range\",\n  _aggregators: {\n    range: function range(_ref, series) {\n      var _data$reduce;\n\n      var intervalStart = _ref.intervalStart,\n          intervalEnd = _ref.intervalEnd,\n          data = _ref.data;\n\n      if (!data.length) {\n        return;\n      }\n\n      var valueFields = series.getValueFields();\n      var val1Field = valueFields[0];\n      var val2Field = valueFields[1];\n      var result = data.reduce(function (result, item) {\n        var val1 = item[val1Field];\n        var val2 = item[val2Field];\n\n        if (!_isDefined(val1) || !_isDefined(val2)) {\n          return result;\n        }\n\n        result[val1Field] = Math.min(result[val1Field], Math.min(val1, val2));\n        result[val2Field] = Math.max(result[val2Field], Math.max(val1, val2));\n        return result;\n      }, (_data$reduce = {}, _defineProperty(_data$reduce, val1Field, 1 / 0), _defineProperty(_data$reduce, val2Field, -1 / 0), _defineProperty(_data$reduce, series.getArgumentField(), series._getIntervalCenter(intervalStart, intervalEnd)), _data$reduce));\n\n      if (!isFinite(result[val1Field]) || !isFinite(result[val2Field])) {\n        if (data.filter(function (i) {\n          return null === i[val1Field] && null === i[val2Field];\n        }).length === data.length) {\n          result[val1Field] = result[val2Field] = null;\n        } else {\n          return;\n        }\n      }\n\n      return result;\n    }\n  },\n  getValueFields: function getValueFields() {\n    return [this._options.rangeValue1Field || \"val1\", this._options.rangeValue2Field || \"val2\"];\n  },\n  getSeriesPairCoord: function getSeriesPairCoord(coord, isArgument) {\n    var oppositeCoord = null;\n    var rotated = this._options.rotated;\n    var isOpposite = !isArgument && !rotated || isArgument && rotated;\n    var coordName = isOpposite ? \"vy\" : \"vx\";\n    var minCoordName = rotated ? \"minX\" : \"minY\";\n    var oppositeCoordName = isOpposite ? \"vx\" : \"vy\";\n    var points = this.getPoints();\n\n    for (var i = 0; i < points.length; i++) {\n      var p = points[i];\n      var tmpCoord = void 0;\n\n      if (isArgument) {\n        tmpCoord = p.getCenterCoord()[coordName[1]] === coord ? p[oppositeCoordName] : void 0;\n      } else {\n        var coords = [Math.min(p[coordName], p[minCoordName]), Math.max(p[coordName], p[minCoordName])];\n        tmpCoord = coord >= coords[0] && coord <= coords[1] ? p[oppositeCoordName] : void 0;\n      }\n\n      if (this._checkAxisVisibleAreaCoord(!isArgument, tmpCoord)) {\n        oppositeCoord = tmpCoord;\n        break;\n      }\n    }\n\n    return oppositeCoord;\n  }\n};\nchart.rangebar = _extend({}, barSeries, baseRangeSeries);\nchart.rangearea = _extend({}, areaSeries, {\n  _drawPoint: function _drawPoint(options) {\n    var point = options.point;\n\n    if (point.isInVisibleArea()) {\n      point.clearVisibility();\n      point.draw(this._renderer, options.groups);\n\n      this._drawnPoints.push(point);\n\n      if (!point.visibleTopMarker) {\n        point.hideMarker(\"top\");\n      }\n\n      if (!point.visibleBottomMarker) {\n        point.hideMarker(\"bottom\");\n      }\n    } else {\n      point.setInvisibility();\n    }\n  },\n  _prepareSegment: function _prepareSegment(points, rotated) {\n    var processedPoints = this._processSinglePointsAreaSegment(points, rotated);\n\n    var processedMinPointsCoords = _map(processedPoints, function (pt) {\n      return pt.getCoords(true);\n    });\n\n    return {\n      line: processedPoints,\n      bottomLine: processedMinPointsCoords,\n      area: _map(processedPoints, function (pt) {\n        return pt.getCoords();\n      }).concat(processedMinPointsCoords.slice().reverse()),\n      singlePointSegment: processedPoints !== points\n    };\n  },\n  _getDefaultSegment: function _getDefaultSegment(segment) {\n    var defaultSegment = areaSeries._getDefaultSegment.call(this, segment);\n\n    defaultSegment.bottomLine = defaultSegment.line;\n    return defaultSegment;\n  },\n  _removeElement: function _removeElement(element) {\n    areaSeries._removeElement.call(this, element);\n\n    element.bottomLine && element.bottomLine.remove();\n  },\n  _drawElement: function _drawElement(segment, group) {\n    var drawnElement = areaSeries._drawElement.call(this, segment, group);\n\n    drawnElement.bottomLine = this._bordersGroup && this._createBorderElement(segment.bottomLine, {\n      \"stroke-width\": this._styles.normal.border[\"stroke-width\"]\n    }).append(this._bordersGroup);\n    return drawnElement;\n  },\n  _applyStyle: function _applyStyle(style) {\n    var elementsGroup = this._elementsGroup;\n    var bordersGroup = this._bordersGroup;\n    elementsGroup && elementsGroup.smartAttr(style.elements);\n    bordersGroup && bordersGroup.attr(style.border);\n    (this._graphics || []).forEach(function (graphic) {\n      graphic.line && graphic.line.attr({\n        \"stroke-width\": style.border[\"stroke-width\"]\n      });\n      graphic.bottomLine && graphic.bottomLine.attr({\n        \"stroke-width\": style.border[\"stroke-width\"]\n      });\n    });\n  },\n  _updateElement: function _updateElement(element, segment, animate, complete) {\n    var bottomLineParams = {\n      points: segment.bottomLine\n    };\n    var bottomBorderElement = element.bottomLine;\n\n    areaSeries._updateElement.apply(this, arguments);\n\n    if (bottomBorderElement) {\n      animate ? bottomBorderElement.animate(bottomLineParams) : bottomBorderElement.attr(bottomLineParams);\n    }\n  }\n}, baseRangeSeries);\nexport { chart };","map":null,"metadata":{},"sourceType":"module"}