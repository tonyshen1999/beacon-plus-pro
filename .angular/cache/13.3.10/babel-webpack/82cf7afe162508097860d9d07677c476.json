{"ast":null,"code":"/**\r\n * DevExtreme (esm/viz/axes/polar_axes.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { map as _map, convertPolarToXY, convertXYToPolar, normalizeAngle, getVizRangeObject, getCosAndSin, getDistance } from \"../core/utils\";\nimport { isDefined } from \"../../core/utils/type\";\nimport { extend } from \"../../core/utils/extend\";\nimport constants from \"./axes_constants\";\nimport xyAxes from \"./xy_axes\";\nimport { tick } from \"./tick\";\nimport { calculateCanvasMargins, measureLabels } from \"./axes_utils\";\nimport { noop as _noop } from \"../../core/utils/common\";\nvar PI = Math.PI,\n    abs = Math.abs,\n    atan = Math.atan,\n    round = Math.round;\nvar _min = Math.min;\nvar _max = Math.max;\nvar xyAxesLinear = xyAxes.linear;\nvar HALF_PI_ANGLE = 90;\n\nfunction getPolarQuarter(angle) {\n  var quarter;\n  angle = normalizeAngle(angle);\n\n  if (angle >= 315 && angle <= 360 || angle < 45 && angle >= 0) {\n    quarter = 1;\n  } else if (angle >= 45 && angle < 135) {\n    quarter = 2;\n  } else if (angle >= 135 && angle < 225) {\n    quarter = 3;\n  } else if (angle >= 225 && angle < 315) {\n    quarter = 4;\n  }\n\n  return quarter;\n}\n\nvar circularAxes = {\n  _calculateValueMargins: function _calculateValueMargins(ticks) {\n    var _this$_getViewportRan = this._getViewportRange(),\n        minVisible = _this$_getViewportRan.minVisible,\n        maxVisible = _this$_getViewportRan.maxVisible;\n\n    if (ticks && ticks.length > 1) {\n      minVisible = minVisible < ticks[0].value ? minVisible : ticks[0].value;\n      maxVisible = minVisible > ticks[ticks.length - 1].value ? maxVisible : ticks[ticks.length - 1].value;\n    }\n\n    return {\n      minValue: minVisible,\n      maxValue: maxVisible\n    };\n  },\n  applyMargins: function applyMargins() {\n    var margins = this._calculateValueMargins(this._majorTicks);\n\n    var br = this._translator.getBusinessRange();\n\n    br.addRange({\n      minVisible: margins.minValue,\n      maxVisible: margins.maxValue,\n      interval: this._calculateRangeInterval(br.interval)\n    });\n\n    this._translator.updateBusinessRange(br);\n  },\n  _getTranslatorOptions: function _getTranslatorOptions() {\n    return {\n      isHorizontal: true,\n      conversionValue: true,\n      addSpiderCategory: this._getSpiderCategoryOption(),\n      stick: this._getStick()\n    };\n  },\n  getCenter: function getCenter() {\n    return this._center;\n  },\n  getRadius: function getRadius() {\n    return this._radius;\n  },\n  getAngles: function getAngles() {\n    var options = this._options;\n    return [options.startAngle, options.endAngle];\n  },\n  _updateRadius: function _updateRadius(canvas) {\n    var rad = _min(canvas.width - canvas.left - canvas.right, canvas.height - canvas.top - canvas.bottom) / 2;\n    this._radius = rad < 0 ? 0 : rad;\n  },\n  _updateCenter: function _updateCenter(canvas) {\n    this._center = {\n      x: canvas.left + (canvas.width - canvas.right - canvas.left) / 2,\n      y: canvas.top + (canvas.height - canvas.top - canvas.bottom) / 2\n    };\n  },\n  _processCanvas: function _processCanvas(canvas) {\n    this._updateRadius(canvas);\n\n    this._updateCenter(canvas);\n\n    return {\n      left: 0,\n      right: 0,\n      width: this._getScreenDelta()\n    };\n  },\n  _createAxisElement: function _createAxisElement() {\n    return this._renderer.circle();\n  },\n  _updateAxisElementPosition: function _updateAxisElementPosition() {\n    var center = this.getCenter();\n\n    this._axisElement.attr({\n      cx: center.x,\n      cy: center.y,\n      r: this.getRadius()\n    });\n  },\n  _boundaryTicksVisibility: {\n    min: true\n  },\n  _getSpiderCategoryOption: function _getSpiderCategoryOption() {\n    return this._options.firstPointOnStartAngle;\n  },\n  _validateOptions: function _validateOptions(options) {\n    var originValue = options.originValue;\n    var wholeRange = options.wholeRange = {};\n    var period = options.period;\n\n    if (isDefined(originValue)) {\n      originValue = this.validateUnit(originValue);\n    }\n\n    if (period > 0 && options.argumentType === constants.numeric) {\n      originValue = originValue || 0;\n      wholeRange.endValue = originValue + period;\n      this._viewport = getVizRangeObject([originValue, wholeRange.endValue]);\n    }\n\n    if (isDefined(originValue)) {\n      wholeRange.startValue = originValue;\n    }\n  },\n  getMargins: function getMargins() {\n    var tickOptions = this._options.tick;\n\n    var tickOuterLength = _max(tickOptions.visible ? tickOptions.length / 2 + tickOptions.shift : 0, 0);\n\n    var radius = this.getRadius();\n    var _this$_center = this._center,\n        x = _this$_center.x,\n        y = _this$_center.y;\n\n    var labelBoxes = this._majorTicks.map(function (t) {\n      return t.label && t.label.getBBox();\n    }).filter(function (b) {\n      return b;\n    });\n\n    var canvas = extend({}, this._canvas, {\n      left: x - radius,\n      top: y - radius,\n      right: this._canvas.width - (x + radius),\n      bottom: this._canvas.height - (y + radius)\n    });\n    var margins = calculateCanvasMargins(labelBoxes, canvas);\n    Object.keys(margins).forEach(function (k) {\n      return margins[k] = margins[k] < tickOuterLength ? tickOuterLength : margins[k];\n    });\n    return margins;\n  },\n  _updateLabelsPosition: function _updateLabelsPosition() {\n    measureLabels(this._majorTicks);\n\n    this._adjustLabelsCoord(0, 0, true);\n\n    this._checkBoundedLabelsOverlapping(this._majorTicks, this._majorTicks.map(function (t) {\n      return t.labelBBox;\n    }));\n  },\n  _setVisualRange: _noop,\n  applyVisualRangeSetter: _noop,\n  _getStick: function _getStick() {\n    return this._options.firstPointOnStartAngle || this._options.type !== constants.discrete;\n  },\n  _getTranslatedCoord: function _getTranslatedCoord(value, offset) {\n    return this._translator.translate(value, offset) - HALF_PI_ANGLE;\n  },\n  _getCanvasStartEnd: function _getCanvasStartEnd() {\n    return {\n      start: 0 - HALF_PI_ANGLE,\n      end: 360 - HALF_PI_ANGLE\n    };\n  },\n  _getStripGraphicAttributes: function _getStripGraphicAttributes(fromAngle, toAngle) {\n    var center = this.getCenter();\n    var angle = this.getAngles()[0];\n    var r = this.getRadius();\n    return {\n      x: center.x,\n      y: center.y,\n      innerRadius: 0,\n      outerRadius: r,\n      startAngle: -toAngle - angle,\n      endAngle: -fromAngle - angle\n    };\n  },\n  _createStrip: function _createStrip(coords) {\n    return this._renderer.arc(coords.x, coords.y, coords.innerRadius, coords.outerRadius, coords.startAngle, coords.endAngle);\n  },\n  _getStripLabelCoords: function _getStripLabelCoords(from, to) {\n    var coords = this._getStripGraphicAttributes(from, to);\n\n    var angle = coords.startAngle + (coords.endAngle - coords.startAngle) / 2;\n    var cosSin = getCosAndSin(angle);\n    var halfRad = this.getRadius() / 2;\n    var center = this.getCenter();\n    var x = round(center.x + halfRad * cosSin.cos);\n    var y = round(center.y - halfRad * cosSin.sin);\n    return {\n      x: x,\n      y: y,\n      align: constants.center\n    };\n  },\n  _getConstantLineGraphicAttributes: function _getConstantLineGraphicAttributes(value) {\n    var center = this.getCenter();\n    var r = this.getRadius();\n    return {\n      points: [center.x, center.y, center.x + r, center.y]\n    };\n  },\n  _createConstantLine: function _createConstantLine(value, attr) {\n    return this._createPathElement(this._getConstantLineGraphicAttributes(value).points, attr);\n  },\n  _rotateConstantLine: function _rotateConstantLine(line, value) {\n    var _this$getCenter = this.getCenter(),\n        x = _this$getCenter.x,\n        y = _this$getCenter.y;\n\n    line.rotate(value + this.getAngles()[0], x, y);\n  },\n  _getConstantLineLabelsCoords: function _getConstantLineLabelsCoords(value) {\n    var cosSin = getCosAndSin(-value - this.getAngles()[0]);\n    var halfRad = this.getRadius() / 2;\n    var center = this.getCenter();\n    var x = round(center.x + halfRad * cosSin.cos);\n    var y = round(center.y - halfRad * cosSin.sin);\n    return {\n      x: x,\n      y: y\n    };\n  },\n  _checkAlignmentConstantLineLabels: _noop,\n  _adjustDivisionFactor: function _adjustDivisionFactor(val) {\n    return 180 * val / (this.getRadius() * PI);\n  },\n  _getScreenDelta: function _getScreenDelta() {\n    var angles = this.getAngles();\n    return abs(angles[0] - angles[1]);\n  },\n  _getTickMarkPoints: function _getTickMarkPoints(coords, length, _ref) {\n    var _ref$shift = _ref.shift,\n        shift = _ref$shift === void 0 ? 0 : _ref$shift;\n    var center = this.getCenter();\n    var radiusWithTicks = this.getRadius() + length * {\n      inside: -1,\n      center: -.5,\n      outside: 0\n    }[this._options.tickOrientation || \"center\"];\n    return [center.x + radiusWithTicks + shift, center.y, center.x + radiusWithTicks + length + shift, center.y];\n  },\n  _getLabelAdjustedCoord: function _getLabelAdjustedCoord(tick, _offset, _maxWidth, checkCanvas) {\n    var labelCoords = tick.labelCoords;\n    var labelY = labelCoords.y;\n    var labelAngle = labelCoords.angle;\n    var cosSin = getCosAndSin(labelAngle);\n    var cos = cosSin.cos;\n    var sin = cosSin.sin;\n    var box = tick.labelBBox;\n    var halfWidth = box.width / 2;\n    var halfHeight = box.height / 2;\n    var indentFromAxis = this._options.label.indentFromAxis || 0;\n    var x = labelCoords.x + indentFromAxis * cos;\n    var y = labelY + (labelY - box.y - halfHeight) + indentFromAxis * sin;\n    var shiftX = 0;\n    var shiftY = 0;\n\n    switch (getPolarQuarter(labelAngle)) {\n      case 1:\n        shiftX = halfWidth;\n        shiftY = halfHeight * sin;\n        break;\n\n      case 2:\n        shiftX = halfWidth * cos;\n        shiftY = halfHeight;\n        break;\n\n      case 3:\n        shiftX = -halfWidth;\n        shiftY = halfHeight * sin;\n        break;\n\n      case 4:\n        shiftX = halfWidth * cos;\n        shiftY = -halfHeight;\n    }\n\n    if (checkCanvas) {\n      var canvas = this._canvas;\n      var boxShiftX = x - labelCoords.x + shiftX;\n      var boxShiftY = y - labelCoords.y + shiftY;\n\n      if (box.x + boxShiftX < canvas.originalLeft) {\n        shiftX -= box.x + boxShiftX - canvas.originalLeft;\n      }\n\n      if (box.x + box.width + boxShiftX > canvas.width - canvas.originalRight) {\n        shiftX -= box.x + box.width + boxShiftX - (canvas.width - canvas.originalRight);\n      }\n\n      if (box.y + boxShiftY < canvas.originalTop) {\n        shiftY -= box.y + boxShiftY - canvas.originalTop;\n      }\n\n      if (box.y + box.height + boxShiftY > canvas.height - canvas.originalBottom) {\n        shiftY -= box.y + box.height + boxShiftY - (canvas.height - canvas.originalBottom);\n      }\n    }\n\n    return {\n      x: x + shiftX,\n      y: y + shiftY\n    };\n  },\n  _getGridLineDrawer: function _getGridLineDrawer() {\n    var that = this;\n    return function (tick, gridStyle) {\n      var center = that.getCenter();\n      return that._createPathElement(that._getGridPoints().points, gridStyle).rotate(tick.coords.angle, center.x, center.y);\n    };\n  },\n  _getGridPoints: function _getGridPoints() {\n    var r = this.getRadius();\n    var center = this.getCenter();\n    return {\n      points: [center.x, center.y, center.x + r, center.y]\n    };\n  },\n  _getTranslatedValue: function _getTranslatedValue(value, offset) {\n    var startAngle = this.getAngles()[0];\n\n    var angle = this._translator.translate(value, -offset);\n\n    var coords = convertPolarToXY(this.getCenter(), startAngle, angle, this.getRadius());\n    return {\n      x: coords.x,\n      y: coords.y,\n      angle: this.getTranslatedAngle(angle)\n    };\n  },\n  _getAdjustedStripLabelCoords: function _getAdjustedStripLabelCoords(strip) {\n    var box = strip.labelBBox;\n    return {\n      translateY: strip.label.attr(\"y\") - box.y - box.height / 2\n    };\n  },\n  coordsIn: function coordsIn(x, y) {\n    return convertXYToPolar(this.getCenter(), x, y).r > this.getRadius();\n  },\n  _rotateTick: function _rotateTick(element, coords) {\n    var center = this.getCenter();\n    element.rotate(coords.angle, center.x, center.y);\n  },\n  _validateOverlappingMode: function _validateOverlappingMode(mode) {\n    return constants.validateOverlappingMode(mode);\n  },\n  _validateDisplayMode: function _validateDisplayMode() {\n    return \"standard\";\n  },\n  _getStep: function _getStep(boxes) {\n    var radius = this.getRadius() + (this._options.label.indentFromAxis || 0);\n    var maxLabelBox = boxes.reduce(function (prevValue, box) {\n      var curValue = prevValue;\n\n      if (prevValue.width < box.width) {\n        curValue.width = box.width;\n      }\n\n      if (prevValue.height < box.height) {\n        curValue.height = box.height;\n      }\n\n      return curValue;\n    }, {\n      width: 0,\n      height: 0\n    });\n    var angle1 = abs(2 * atan(maxLabelBox.height / (2 * radius - maxLabelBox.width)) * 180 / PI);\n    var angle2 = abs(2 * atan(maxLabelBox.width / (2 * radius - maxLabelBox.height)) * 180 / PI);\n    return constants.getTicksCountInRange(this._majorTicks, \"angle\", _max(angle1, angle2));\n  },\n  _checkBoundedLabelsOverlapping: function _checkBoundedLabelsOverlapping(majorTicks, boxes, mode) {\n    var labelOpt = this._options.label;\n    mode = mode || this._validateOverlappingMode(labelOpt.overlappingBehavior);\n\n    if (\"hide\" !== mode) {\n      return;\n    }\n\n    var lastVisibleLabelIndex = majorTicks.reduce(function (lastVisibleLabelIndex, tick, index) {\n      return tick.label ? index : lastVisibleLabelIndex;\n    }, null);\n\n    if (!lastVisibleLabelIndex) {\n      return;\n    }\n\n    if (constants.areLabelsOverlap(boxes[0], boxes[lastVisibleLabelIndex], labelOpt.minSpacing, constants.center)) {\n      \"first\" === labelOpt.hideFirstOrLast ? majorTicks[0].removeLabel() : majorTicks[lastVisibleLabelIndex].removeLabel();\n    }\n  },\n  shift: function shift(margins) {\n    this._axisGroup.attr({\n      translateX: margins.right,\n      translateY: margins.bottom\n    });\n\n    this._axisElementsGroup.attr({\n      translateX: margins.right,\n      translateY: margins.bottom\n    });\n  },\n  getTranslatedAngle: function getTranslatedAngle(angle) {\n    var startAngle = this.getAngles()[0];\n    return angle + startAngle - HALF_PI_ANGLE;\n  }\n};\nexport var circular = circularAxes;\nexport var circularSpider = extend({}, circularAxes, {\n  _createAxisElement: function _createAxisElement() {\n    return this._renderer.path([], \"area\");\n  },\n  _updateAxisElementPosition: function _updateAxisElementPosition() {\n    this._axisElement.attr({\n      points: _map(this.getSpiderTicks(), function (tick) {\n        return {\n          x: tick.coords.x,\n          y: tick.coords.y\n        };\n      })\n    });\n  },\n  _getStick: function _getStick() {\n    return true;\n  },\n  _getSpiderCategoryOption: function _getSpiderCategoryOption() {\n    return true;\n  },\n  getSpiderTicks: function getSpiderTicks() {\n    var ticks = this.getFullTicks();\n    this._spiderTicks = ticks.map(tick(this, this.renderer, {}, {}, this._getSkippedCategory(ticks), true));\n\n    this._spiderTicks.forEach(function (tick) {\n      tick.initCoords();\n    });\n\n    return this._spiderTicks;\n  },\n  _getStripGraphicAttributes: function _getStripGraphicAttributes(fromAngle, toAngle) {\n    var center = this.getCenter();\n    var spiderTicks = this.getSpiderTicks();\n    var firstTick;\n    var lastTick;\n    var nextTick;\n    var tick;\n    var points = [];\n    var i = 0;\n    var len = spiderTicks.length;\n\n    while (i < len) {\n      tick = spiderTicks[i].coords;\n\n      if (tick.angle >= fromAngle && tick.angle <= toAngle) {\n        if (!firstTick) {\n          firstTick = (spiderTicks[i - 1] || spiderTicks[spiderTicks.length - 1]).coords;\n          points.push((tick.x + firstTick.x) / 2, (tick.y + firstTick.y) / 2);\n        }\n\n        points.push(tick.x, tick.y);\n        nextTick = (spiderTicks[i + 1] || spiderTicks[0]).coords;\n        lastTick = {\n          x: (tick.x + nextTick.x) / 2,\n          y: (tick.y + nextTick.y) / 2\n        };\n      }\n\n      i++;\n    }\n\n    points.push(lastTick.x, lastTick.y);\n    points.push(center.x, center.y);\n    return {\n      points: points\n    };\n  },\n  _createStrip: function _createStrip(_ref2) {\n    var points = _ref2.points;\n    return this._renderer.path(points, \"area\");\n  },\n  _getTranslatedCoord: function _getTranslatedCoord(value, offset) {\n    return this._translator.translate(value, offset) - HALF_PI_ANGLE;\n  },\n  _setTickOffset: function _setTickOffset() {\n    this._tickOffset = false;\n  }\n});\nexport var linear = {\n  _resetMargins: function _resetMargins() {\n    this._reinitTranslator(this._getViewportRange());\n  },\n  _getStick: xyAxesLinear._getStick,\n  _getSpiderCategoryOption: _noop,\n  _getTranslatorOptions: function _getTranslatorOptions() {\n    return {\n      isHorizontal: true,\n      stick: this._getStick()\n    };\n  },\n  getRadius: circularAxes.getRadius,\n  getCenter: circularAxes.getCenter,\n  getAngles: circularAxes.getAngles,\n  _updateRadius: circularAxes._updateRadius,\n  _updateCenter: circularAxes._updateCenter,\n  _processCanvas: function _processCanvas(canvas) {\n    this._updateRadius(canvas);\n\n    this._updateCenter(canvas);\n\n    return {\n      left: 0,\n      right: 0,\n      startPadding: canvas.startPadding,\n      endPadding: canvas.endPadding,\n      width: this.getRadius()\n    };\n  },\n  _createAxisElement: xyAxesLinear._createAxisElement,\n  _updateAxisElementPosition: function _updateAxisElementPosition() {\n    var centerCoord = this.getCenter();\n\n    this._axisElement.attr({\n      points: [centerCoord.x, centerCoord.y, centerCoord.x + this.getRadius(), centerCoord.y]\n    }).rotate(this.getAngles()[0] - HALF_PI_ANGLE, centerCoord.x, centerCoord.y);\n  },\n  _getScreenDelta: function _getScreenDelta() {\n    return this.getRadius();\n  },\n  _getTickMarkPoints: function _getTickMarkPoints(coords, length) {\n    return [coords.x - length / 2, coords.y, coords.x + length / 2, coords.y];\n  },\n  _getLabelAdjustedCoord: function _getLabelAdjustedCoord(tick) {\n    var labelCoords = tick.labelCoords;\n    var labelY = labelCoords.y;\n    var cosSin = getCosAndSin(labelCoords.angle);\n    var indentFromAxis = this._options.label.indentFromAxis || 0;\n    var box = tick.labelBBox;\n    var x = labelCoords.x - abs(indentFromAxis * cosSin.sin) + abs(box.width / 2 * cosSin.cos) - box.width / 2;\n    var y = labelY + (labelY - box.y) - abs(box.height / 2 * cosSin.sin) + abs(indentFromAxis * cosSin.cos);\n    return {\n      x: x,\n      y: y\n    };\n  },\n  _getGridLineDrawer: function _getGridLineDrawer() {\n    var that = this;\n    return function (tick, gridStyle) {\n      var grid = that._getGridPoints(tick.coords);\n\n      return that._renderer.circle(grid.cx, grid.cy, grid.r).attr(gridStyle).sharp();\n    };\n  },\n  _getGridPoints: function _getGridPoints(coords) {\n    var pos = this.getCenter();\n    var radius = getDistance(pos.x, pos.y, coords.x, coords.y);\n\n    if (radius > this.getRadius()) {\n      return {\n        cx: null,\n        cy: null,\n        r: null\n      };\n    }\n\n    return {\n      cx: pos.x,\n      cy: pos.y,\n      r: radius\n    };\n  },\n  _getTranslatedValue: function _getTranslatedValue(value, offset) {\n    var startAngle = this.getAngles()[0];\n    var xy = convertPolarToXY(this.getCenter(), startAngle, 0, this._translator.translate(value, offset));\n    return {\n      x: xy.x,\n      y: xy.y,\n      angle: startAngle - HALF_PI_ANGLE\n    };\n  },\n  _getTranslatedCoord: function _getTranslatedCoord(value, offset) {\n    return this._translator.translate(value, offset);\n  },\n  _getCanvasStartEnd: function _getCanvasStartEnd() {\n    var invert = this.getTranslator().getBusinessRange().invert;\n    var coords = [0, this.getRadius()];\n    invert && coords.reverse();\n    return {\n      start: coords[0],\n      end: coords[1]\n    };\n  },\n  _getStripGraphicAttributes: function _getStripGraphicAttributes(fromPoint, toPoint) {\n    var center = this.getCenter();\n    return {\n      x: center.x,\n      y: center.y,\n      innerRadius: fromPoint,\n      outerRadius: toPoint\n    };\n  },\n  _createStrip: function _createStrip(attrs) {\n    return this._renderer.arc(attrs.x, attrs.y, attrs.innerRadius, attrs.outerRadius, 0, 360);\n  },\n  _getAdjustedStripLabelCoords: circularAxes._getAdjustedStripLabelCoords,\n  _getStripLabelCoords: function _getStripLabelCoords(from, to) {\n    var labelPos = from + (to - from) / 2;\n    var center = this.getCenter();\n    var y = round(center.y - labelPos);\n    return {\n      x: center.x,\n      y: y,\n      align: constants.center\n    };\n  },\n  _getConstantLineGraphicAttributes: function _getConstantLineGraphicAttributes(value) {\n    var center = this.getCenter();\n    return {\n      cx: center.x,\n      cy: center.y,\n      r: value\n    };\n  },\n  _createConstantLine: function _createConstantLine(value, attr) {\n    var attrs = this._getConstantLineGraphicAttributes(value);\n\n    return this._renderer.circle(attrs.cx, attrs.cy, attrs.r).attr(attr).sharp();\n  },\n  _getConstantLineLabelsCoords: function _getConstantLineLabelsCoords(value) {\n    var center = this.getCenter();\n    var y = round(center.y - value);\n    return {\n      x: center.x,\n      y: y\n    };\n  },\n  _checkAlignmentConstantLineLabels: _noop,\n  _rotateTick: function _rotateTick(element, coords, isGridLine) {\n    !isGridLine && element.rotate(coords.angle + HALF_PI_ANGLE, coords.x, coords.y);\n  },\n  _validateOverlappingMode: circularAxes._validateOverlappingMode,\n  _validateDisplayMode: circularAxes._validateDisplayMode,\n  _getStep: function _getStep(boxes) {\n    var quarter = getPolarQuarter(this.getAngles()[0]);\n    var spacing = this._options.label.minSpacing;\n    var func = 2 === quarter || 4 === quarter ? function (box) {\n      return box.width + spacing;\n    } : function (box) {\n      return box.height;\n    };\n    var maxLabelLength = boxes.reduce(function (prevValue, box) {\n      return _max(prevValue, func(box));\n    }, 0);\n    return constants.getTicksCountInRange(this._majorTicks, 2 === quarter || 4 === quarter ? \"x\" : \"y\", maxLabelLength);\n  }\n};\nexport var linearSpider = extend({}, linear, {\n  _createPathElement: function _createPathElement(points, attr) {\n    return this._renderer.path(points, \"area\").attr(attr).sharp();\n  },\n  setSpiderTicks: function setSpiderTicks(ticks) {\n    this._spiderTicks = ticks;\n  },\n  _getGridLineDrawer: function _getGridLineDrawer() {\n    var that = this;\n    return function (tick, gridStyle) {\n      return that._createPathElement(that._getGridPoints(tick.coords).points, gridStyle);\n    };\n  },\n  _getGridPoints: function _getGridPoints(coords) {\n    var pos = this.getCenter();\n    var radius = getDistance(pos.x, pos.y, coords.x, coords.y);\n    return this._getGridPointsByRadius(radius);\n  },\n  _getGridPointsByRadius: function _getGridPointsByRadius(radius) {\n    var pos = this.getCenter();\n\n    if (radius > this.getRadius()) {\n      return {\n        points: null\n      };\n    }\n\n    return {\n      points: _map(this._spiderTicks, function (tick) {\n        var cosSin = getCosAndSin(tick.coords.angle);\n        return {\n          x: round(pos.x + radius * cosSin.cos),\n          y: round(pos.y + radius * cosSin.sin)\n        };\n      })\n    };\n  },\n  _getStripGraphicAttributes: function _getStripGraphicAttributes(fromPoint, toPoint) {\n    var innerPoints = this._getGridPointsByRadius(toPoint).points;\n\n    var outerPoints = this._getGridPointsByRadius(fromPoint).points;\n\n    return {\n      points: [outerPoints, innerPoints.reverse()]\n    };\n  },\n  _createStrip: circularSpider._createStrip,\n  _getConstantLineGraphicAttributes: function _getConstantLineGraphicAttributes(value) {\n    return this._getGridPointsByRadius(value);\n  },\n  _createConstantLine: function _createConstantLine(value, attr) {\n    return this._createPathElement(this._getConstantLineGraphicAttributes(value).points, attr);\n  }\n});","map":null,"metadata":{},"sourceType":"module"}