{"ast":null,"code":"/**\r\n * DevExtreme (esm/viz/chart_components/crosshair.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { patchFontOptions } from \"../core/utils\";\nimport { extend } from \"../../core/utils/extend\";\nvar math = Math;\nvar mathAbs = math.abs;\nvar mathMin = math.min;\nvar mathMax = math.max;\nvar mathFloor = math.floor;\nvar HORIZONTAL = \"horizontal\";\nvar VERTICAL = \"vertical\";\nvar LABEL_BACKGROUND_PADDING_X = 8;\nvar LABEL_BACKGROUND_PADDING_Y = 4;\nvar CENTER = \"center\";\nvar RIGHT = \"right\";\nvar LEFT = \"left\";\nvar TOP = \"top\";\nvar BOTTOM = \"bottom\";\nexport function getMargins() {\n  return {\n    x: LABEL_BACKGROUND_PADDING_X,\n    y: LABEL_BACKGROUND_PADDING_Y\n  };\n}\n\nfunction getRectangleBBox(bBox) {\n  return {\n    x: bBox.x - LABEL_BACKGROUND_PADDING_X,\n    y: bBox.y - LABEL_BACKGROUND_PADDING_Y,\n    width: bBox.width + 2 * LABEL_BACKGROUND_PADDING_X,\n    height: bBox.height + 2 * LABEL_BACKGROUND_PADDING_Y\n  };\n}\n\nfunction getLabelCheckerPosition(x, y, isHorizontal, canvas) {\n  var params = isHorizontal ? [\"x\", \"width\", \"y\", \"height\", y, 0] : [\"y\", \"height\", \"x\", \"width\", x, 1];\n  return function (bBox, position, coord) {\n    var labelCoord = {\n      x: coord.x,\n      y: coord.y\n    };\n    var rectangleBBox = getRectangleBBox(bBox);\n    var delta = isHorizontal ? coord.y - bBox.y - bBox.height / 2 : coord.y - bBox.y;\n    labelCoord.y = isHorizontal || !isHorizontal && position === BOTTOM ? coord.y + delta : coord.y;\n\n    if (rectangleBBox[params[0]] < 0) {\n      labelCoord[params[0]] -= rectangleBBox[params[0]];\n    } else if (rectangleBBox[params[0]] + rectangleBBox[params[1]] + delta * params[5] > canvas[params[1]]) {\n      labelCoord[params[0]] -= rectangleBBox[params[0]] + rectangleBBox[params[1]] + delta * params[5] - canvas[params[1]];\n    }\n\n    if (params[4] - rectangleBBox[params[3]] / 2 < 0) {\n      labelCoord[params[2]] -= params[4] - rectangleBBox[params[3]] / 2;\n    } else if (params[4] + rectangleBBox[params[3]] / 2 > canvas[params[3]]) {\n      labelCoord[params[2]] -= params[4] + rectangleBBox[params[3]] / 2 - canvas[params[3]];\n    }\n\n    return labelCoord;\n  };\n}\n\nexport function Crosshair(renderer, options, params, group) {\n  this._renderer = renderer;\n  this._crosshairGroup = group;\n  this._options = {};\n  this.update(options, params);\n}\nCrosshair.prototype = {\n  constructor: Crosshair,\n  update: function update(options, params) {\n    var canvas = params.canvas;\n    this._canvas = {\n      top: canvas.top,\n      bottom: canvas.height - canvas.bottom,\n      left: canvas.left,\n      right: canvas.width - canvas.right,\n      width: canvas.width,\n      height: canvas.height\n    };\n    this._axes = params.axes;\n    this._panes = params.panes;\n\n    this._prepareOptions(options, HORIZONTAL);\n\n    this._prepareOptions(options, VERTICAL);\n  },\n  dispose: function dispose() {\n    this._renderer = this._crosshairGroup = this._options = this._axes = this._canvas = this._horizontalGroup = this._verticalGroup = this._horizontal = this._vertical = this._circle = this._panes = null;\n  },\n  _prepareOptions: function _prepareOptions(options, direction) {\n    var lineOptions = options[direction + \"Line\"];\n    this._options[direction] = {\n      visible: lineOptions.visible,\n      line: {\n        stroke: lineOptions.color || options.color,\n        \"stroke-width\": lineOptions.width || options.width,\n        dashStyle: lineOptions.dashStyle || options.dashStyle,\n        opacity: lineOptions.opacity || options.opacity,\n        \"stroke-linecap\": \"butt\"\n      },\n      label: extend(true, {}, options.label, lineOptions.label)\n    };\n  },\n  _createLines: function _createLines(options, sharpParam, group) {\n    var lines = [];\n    var canvas = this._canvas;\n    var points = [canvas.left, canvas.top, canvas.left, canvas.top];\n\n    for (var i = 0; i < 2; i++) {\n      lines.push(this._renderer.path(points, \"line\").attr(options).sharp(sharpParam).append(group));\n    }\n\n    return lines;\n  },\n  render: function render() {\n    var renderer = this._renderer;\n    var options = this._options;\n    var verticalOptions = options.vertical;\n    var horizontalOptions = options.horizontal;\n    var extraOptions = horizontalOptions.visible ? horizontalOptions.line : verticalOptions.line;\n    var circleOptions = {\n      stroke: extraOptions.stroke,\n      \"stroke-width\": extraOptions[\"stroke-width\"],\n      dashStyle: extraOptions.dashStyle,\n      opacity: extraOptions.opacity\n    };\n    var canvas = this._canvas;\n    this._horizontal = {};\n    this._vertical = {};\n    this._circle = renderer.circle(canvas.left, canvas.top, 0).attr(circleOptions).append(this._crosshairGroup);\n    this._horizontalGroup = renderer.g().append(this._crosshairGroup);\n    this._verticalGroup = renderer.g().append(this._crosshairGroup);\n\n    if (verticalOptions.visible) {\n      this._vertical.lines = this._createLines(verticalOptions.line, \"h\", this._verticalGroup);\n      this._vertical.labels = this._createLabels(this._axes[0], verticalOptions, false, this._verticalGroup);\n    }\n\n    if (horizontalOptions.visible) {\n      this._horizontal.lines = this._createLines(horizontalOptions.line, \"v\", this._horizontalGroup);\n      this._horizontal.labels = this._createLabels(this._axes[1], horizontalOptions, true, this._horizontalGroup);\n    }\n\n    this.hide();\n  },\n  _createLabels: function _createLabels(axes, options, isHorizontal, group) {\n    var canvas = this._canvas;\n    var renderer = this._renderer;\n    var x;\n    var y;\n    var text;\n    var labels = [];\n    var background;\n    var currentLabelPos;\n    var labelOptions = options.label;\n\n    if (labelOptions.visible) {\n      axes.forEach(function (axis) {\n        var position = axis.getOptions().position;\n\n        if (axis.getTranslator().getBusinessRange().isEmpty()) {\n          return;\n        }\n\n        currentLabelPos = axis.getLabelsPosition();\n\n        if (isHorizontal) {\n          y = canvas.top;\n          x = currentLabelPos;\n        } else {\n          x = canvas.left;\n          y = currentLabelPos;\n        }\n\n        var align = position === TOP || position === BOTTOM ? CENTER : position === RIGHT ? LEFT : RIGHT;\n        background = renderer.rect(0, 0, 0, 0).attr({\n          fill: labelOptions.backgroundColor || options.line.stroke\n        }).append(group);\n        text = renderer.text(\"0\", 0, 0).css(patchFontOptions(options.label.font)).attr({\n          align: align,\n          class: labelOptions.cssClass\n        }).append(group);\n        labels.push({\n          text: text,\n          background: background,\n          axis: axis,\n          options: labelOptions,\n          pos: {\n            coord: currentLabelPos,\n            side: position\n          },\n          startXY: {\n            x: x,\n            y: y\n          }\n        });\n      });\n    }\n\n    return labels;\n  },\n  _updateText: function _updateText(value, axisName, labels, point, func) {\n    var that = this;\n    labels.forEach(function (label) {\n      var axis = label.axis;\n      var coord = label.startXY;\n      var textElement = label.text;\n      var backgroundElement = label.background;\n      var text = \"\";\n\n      if (!axis.name || axis.name === axisName) {\n        text = axis.getFormattedValue(value, label.options, point);\n      }\n\n      if (text) {\n        textElement.attr({\n          text: text,\n          x: coord.x,\n          y: coord.y\n        });\n        textElement.attr(func(textElement.getBBox(), label.pos.side, coord));\n\n        that._updateLinesCanvas(label);\n\n        backgroundElement.attr(getRectangleBBox(textElement.getBBox()));\n      } else {\n        textElement.attr({\n          text: \"\"\n        });\n        backgroundElement.attr({\n          x: 0,\n          y: 0,\n          width: 0,\n          height: 0\n        });\n      }\n    });\n  },\n  hide: function hide() {\n    this._crosshairGroup.attr({\n      visibility: \"hidden\"\n    });\n  },\n  _updateLinesCanvas: function _updateLinesCanvas(label) {\n    var position = label.pos.side;\n    var labelCoord = label.pos.coord;\n    var coords = this._linesCanvas;\n    var canvas = this._canvas;\n    coords[position] = coords[position] !== canvas[position] && mathAbs(coords[position] - canvas[position]) < mathAbs(labelCoord - canvas[position]) ? coords[position] : labelCoord;\n  },\n  _updateLines: function _updateLines(lines, x, y, r, isHorizontal) {\n    var coords = this._linesCanvas;\n    var canvas = this._canvas;\n    var points = isHorizontal ? [[mathMin(x - r, coords.left), canvas.top, x - r, canvas.top], [x + r, canvas.top, mathMax(coords.right, x + r), canvas.top]] : [[canvas.left, mathMin(coords.top, y - r), canvas.left, y - r], [canvas.left, y + r, canvas.left, mathMax(coords.bottom, y + r)]];\n\n    for (var i = 0; i < 2; i++) {\n      lines[i].attr({\n        points: points[i]\n      }).sharp(isHorizontal ? \"v\" : \"h\", isHorizontal ? y === canvas.bottom ? -1 : 1 : x === canvas.right ? -1 : 1);\n    }\n  },\n  _resetLinesCanvas: function _resetLinesCanvas() {\n    var canvas = this._canvas;\n    this._linesCanvas = {\n      left: canvas.left,\n      right: canvas.right,\n      top: canvas.top,\n      bottom: canvas.bottom\n    };\n  },\n  _getClipRectForPane: function _getClipRectForPane(x, y) {\n    var panes = this._panes;\n    var i;\n    var coords;\n\n    for (i = 0; i < panes.length; i++) {\n      coords = panes[i].coords;\n\n      if (coords.left <= x && coords.right >= x && coords.top <= y && coords.bottom >= y) {\n        return panes[i].clipRect;\n      }\n    }\n\n    return {\n      id: null\n    };\n  },\n  show: function show(data) {\n    var point = data.point;\n    var pointData = point.getCrosshairData(data.x, data.y);\n    var r = point.getPointRadius();\n    var horizontal = this._horizontal;\n    var vertical = this._vertical;\n    var rad = !r ? 0 : r + 3;\n    var canvas = this._canvas;\n    var x = mathFloor(pointData.x);\n    var y = mathFloor(pointData.y);\n\n    if (x >= canvas.left && x <= canvas.right && y >= canvas.top && y <= canvas.bottom) {\n      this._crosshairGroup.attr({\n        visibility: \"visible\"\n      });\n\n      this._resetLinesCanvas();\n\n      this._circle.attr({\n        cx: x,\n        cy: y,\n        r: rad,\n        \"clip-path\": this._getClipRectForPane(x, y).id\n      });\n\n      if (horizontal.lines) {\n        this._updateText(pointData.yValue, pointData.axis, horizontal.labels, point, getLabelCheckerPosition(x, y, true, canvas));\n\n        this._updateLines(horizontal.lines, x, y, rad, true);\n\n        this._horizontalGroup.attr({\n          translateY: y - canvas.top\n        });\n      }\n\n      if (vertical.lines) {\n        this._updateText(pointData.xValue, pointData.axis, vertical.labels, point, getLabelCheckerPosition(x, y, false, canvas));\n\n        this._updateLines(vertical.lines, x, y, rad, false);\n\n        this._verticalGroup.attr({\n          translateX: x - canvas.left\n        });\n      }\n    } else {\n      this.hide();\n    }\n  }\n};","map":null,"metadata":{},"sourceType":"module"}