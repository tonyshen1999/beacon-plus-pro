{"ast":null,"code":"import _defineProperty from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _classCallCheck from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n\n/**\r\n * DevExtreme (esm/ui/draggable.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { getWidth, getHeight, getOuterWidth, getOuterHeight } from \"../core/utils/size\";\nimport $ from \"../core/renderer\";\nimport domAdapter from \"../core/dom_adapter\";\nimport { getWindow } from \"../core/utils/window\";\nimport { getBoundingRect } from \"../core/utils/position\";\nimport eventsEngine from \"../events/core/events_engine\";\nimport { quadToObject } from \"../core/utils/string\";\nimport registerComponent from \"../core/component_registrator\";\nimport { locate, move } from \"../animation/translator\";\nimport Animator from \"./scroll_view/animator\";\nimport { dasherize } from \"../core/utils/inflector\";\nimport { extend } from \"../core/utils/extend\";\nimport DOMComponent from \"../core/dom_component\";\nimport { getPublicElement } from \"../core/element\";\nimport { addNamespace, needSkipEvent } from \"../events/utils/index\";\nimport pointerEvents from \"../events/pointer\";\nimport { start as dragEventStart, move as dragEventMove, end as dragEventEnd, enter as dragEventEnter, leave as dragEventLeave } from \"../events/drag\";\nimport positionUtils from \"../animation/position\";\nimport { isFunction, isObject } from \"../core/utils/type\";\nimport { noop, splitPair } from \"../core/utils/common\";\nimport { value as viewPort } from \"../core/utils/view_port\";\nimport { EmptyTemplate } from \"../core/templates/empty_template\";\nimport { when, fromPromise, Deferred } from \"../core/utils/deferred\";\nvar window = getWindow();\nvar DRAGGABLE = \"dxDraggable\";\nvar DRAGSTART_EVENT_NAME = addNamespace(dragEventStart, DRAGGABLE);\nvar DRAG_EVENT_NAME = addNamespace(dragEventMove, DRAGGABLE);\nvar DRAGEND_EVENT_NAME = addNamespace(dragEventEnd, DRAGGABLE);\nvar DRAG_ENTER_EVENT_NAME = addNamespace(dragEventEnter, DRAGGABLE);\nvar DRAGEND_LEAVE_EVENT_NAME = addNamespace(dragEventLeave, DRAGGABLE);\nvar POINTERDOWN_EVENT_NAME = addNamespace(pointerEvents.down, DRAGGABLE);\nvar CLONE_CLASS = \"clone\";\nvar targetDraggable;\nvar sourceDraggable;\nvar ANONYMOUS_TEMPLATE_NAME = \"content\";\n\nvar getMousePosition = function getMousePosition(event) {\n  return {\n    x: event.pageX - $(window).scrollLeft(),\n    y: event.pageY - $(window).scrollTop()\n  };\n};\n\nvar GESTURE_COVER_CLASS = \"dx-gesture-cover\";\nvar OVERLAY_WRAPPER_CLASS = \"dx-overlay-wrapper\";\nvar OVERLAY_CONTENT_CLASS = \"dx-overlay-content\";\n\nvar ScrollHelper = /*#__PURE__*/function () {\n  function ScrollHelper(orientation, component) {\n    _classCallCheck(this, ScrollHelper);\n\n    this._preventScroll = true;\n    this._component = component;\n\n    if (\"vertical\" === orientation) {\n      this._scrollValue = \"scrollTop\";\n      this._overFlowAttr = \"overflowY\";\n      this._sizeAttr = \"height\";\n      this._scrollSizeProp = \"scrollHeight\";\n      this._clientSizeProp = \"clientHeight\";\n      this._limitProps = {\n        start: \"top\",\n        end: \"bottom\"\n      };\n    } else {\n      this._scrollValue = \"scrollLeft\";\n      this._overFlowAttr = \"overflowX\";\n      this._sizeAttr = \"width\";\n      this._scrollSizeProp = \"scrollWidth\";\n      this._clientSizeProp = \"clientWidth\";\n      this._limitProps = {\n        start: \"left\",\n        end: \"right\"\n      };\n    }\n  }\n\n  _createClass(ScrollHelper, [{\n    key: \"updateScrollable\",\n    value: function updateScrollable(elements, mousePosition) {\n      var _this = this;\n\n      var isScrollableFound = false;\n      elements.some(function (element) {\n        var $element = $(element);\n        var isTargetOverOverlayWrapper = $element.hasClass(OVERLAY_WRAPPER_CLASS);\n        var isTargetOverOverlayContent = $element.hasClass(OVERLAY_CONTENT_CLASS);\n\n        if (isTargetOverOverlayWrapper || isTargetOverOverlayContent) {\n          return true;\n        }\n\n        isScrollableFound = _this._trySetScrollable(element, mousePosition);\n        return isScrollableFound;\n      });\n\n      if (!isScrollableFound) {\n        this._$scrollableAtPointer = null;\n        this._scrollSpeed = 0;\n      }\n    }\n  }, {\n    key: \"isScrolling\",\n    value: function isScrolling() {\n      return !!this._scrollSpeed;\n    }\n  }, {\n    key: \"isScrollable\",\n    value: function isScrollable($element) {\n      return (\"auto\" === $element.css(this._overFlowAttr) || $element.hasClass(\"dx-scrollable-container\")) && $element.prop(this._scrollSizeProp) > (\"width\" === this._sizeAttr ? getWidth($element) : getHeight($element));\n    }\n  }, {\n    key: \"_trySetScrollable\",\n    value: function _trySetScrollable(element, mousePosition) {\n      var $element = $(element);\n      var distanceToBorders;\n\n      var sensitivity = this._component.option(\"scrollSensitivity\");\n\n      var isScrollable = this.isScrollable($element);\n\n      if (isScrollable) {\n        distanceToBorders = this._calculateDistanceToBorders($element, mousePosition);\n\n        if (sensitivity > distanceToBorders[this._limitProps.start]) {\n          if (!this._preventScroll) {\n            this._scrollSpeed = -this._calculateScrollSpeed(distanceToBorders[this._limitProps.start]);\n            this._$scrollableAtPointer = $element;\n          }\n        } else if (sensitivity > distanceToBorders[this._limitProps.end]) {\n          if (!this._preventScroll) {\n            this._scrollSpeed = this._calculateScrollSpeed(distanceToBorders[this._limitProps.end]);\n            this._$scrollableAtPointer = $element;\n          }\n        } else {\n          isScrollable = false;\n          this._preventScroll = false;\n        }\n      }\n\n      return isScrollable;\n    }\n  }, {\n    key: \"_calculateDistanceToBorders\",\n    value: function _calculateDistanceToBorders($area, mousePosition) {\n      var area = $area.get(0);\n      var areaBoundingRect;\n\n      if (area) {\n        areaBoundingRect = getBoundingRect(area);\n        return {\n          left: mousePosition.x - areaBoundingRect.left,\n          top: mousePosition.y - areaBoundingRect.top,\n          right: areaBoundingRect.right - mousePosition.x,\n          bottom: areaBoundingRect.bottom - mousePosition.y\n        };\n      } else {\n        return {};\n      }\n    }\n  }, {\n    key: \"_calculateScrollSpeed\",\n    value: function _calculateScrollSpeed(distance) {\n      var component = this._component;\n      var sensitivity = component.option(\"scrollSensitivity\");\n      var maxSpeed = component.option(\"scrollSpeed\");\n      return Math.ceil(Math.pow((sensitivity - distance) / sensitivity, 2) * maxSpeed);\n    }\n  }, {\n    key: \"scrollByStep\",\n    value: function scrollByStep() {\n      if (this._$scrollableAtPointer && this._scrollSpeed) {\n        if (this._$scrollableAtPointer.hasClass(\"dx-scrollable-container\")) {\n          var $scrollable = this._$scrollableAtPointer.closest(\".dx-scrollable\");\n\n          var scrollableInstance = $scrollable.data(\"dxScrollable\") || $scrollable.data(\"dxScrollView\");\n\n          if (scrollableInstance) {\n            var nextScrollPosition = scrollableInstance.scrollOffset()[this._limitProps.start] + this._scrollSpeed;\n\n            scrollableInstance.scrollTo(_defineProperty({}, this._limitProps.start, nextScrollPosition));\n          }\n        } else {\n          var _nextScrollPosition = this._$scrollableAtPointer[this._scrollValue]() + this._scrollSpeed;\n\n          this._$scrollableAtPointer[this._scrollValue](_nextScrollPosition);\n        }\n\n        var dragMoveArgs = this._component._dragMoveArgs;\n\n        if (dragMoveArgs) {\n          this._component._dragMoveHandler(dragMoveArgs);\n        }\n      }\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this._$scrollableAtPointer = null;\n      this._scrollSpeed = 0;\n      this._preventScroll = true;\n    }\n  }, {\n    key: \"isOutsideScrollable\",\n    value: function isOutsideScrollable($scrollable, event) {\n      if (!$scrollable) {\n        return false;\n      }\n\n      var scrollableSize = getBoundingRect($scrollable.get(0));\n      var start = scrollableSize[this._limitProps.start];\n      var size = scrollableSize[this._sizeAttr];\n      var mousePosition = getMousePosition(event);\n      var location = \"width\" === this._sizeAttr ? mousePosition.x : mousePosition.y;\n      return location < start || location > start + size;\n    }\n  }]);\n\n  return ScrollHelper;\n}();\n\nvar ScrollAnimator = Animator.inherit({\n  ctor: function ctor(strategy) {\n    this.callBase();\n    this._strategy = strategy;\n  },\n  _step: function _step() {\n    var horizontalScrollHelper = this._strategy._horizontalScrollHelper;\n    var verticalScrollHelper = this._strategy._verticalScrollHelper;\n    horizontalScrollHelper && horizontalScrollHelper.scrollByStep();\n    verticalScrollHelper && verticalScrollHelper.scrollByStep();\n  }\n});\nvar Draggable = DOMComponent.inherit({\n  reset: noop,\n  dragMove: noop,\n  dragEnter: noop,\n  dragLeave: noop,\n  dragEnd: function dragEnd(sourceEvent) {\n    var sourceDraggable = this._getSourceDraggable();\n\n    sourceDraggable._fireRemoveEvent(sourceEvent);\n\n    return new Deferred().resolve();\n  },\n  _fireRemoveEvent: noop,\n  _getDefaultOptions: function _getDefaultOptions() {\n    return extend(this.callBase(), {\n      onDragStart: null,\n      onDragMove: null,\n      onDragEnd: null,\n      onDragEnter: null,\n      onDragLeave: null,\n      onDrop: null,\n      immediate: true,\n      dragDirection: \"both\",\n      boundary: void 0,\n      boundOffset: 0,\n      allowMoveByClick: false,\n      itemData: null,\n      container: void 0,\n      dragTemplate: void 0,\n      contentTemplate: \"content\",\n      handle: \"\",\n      filter: \"\",\n      clone: false,\n      autoScroll: true,\n      scrollSpeed: 30,\n      scrollSensitivity: 60,\n      group: void 0,\n      data: void 0\n    });\n  },\n  _setOptionsByReference: function _setOptionsByReference() {\n    this.callBase.apply(this, arguments);\n    extend(this._optionsByReference, {\n      component: true,\n      group: true,\n      itemData: true,\n      data: true\n    });\n  },\n  _init: function _init() {\n    this.callBase();\n\n    this._attachEventHandlers();\n\n    this._scrollAnimator = new ScrollAnimator(this);\n    this._horizontalScrollHelper = new ScrollHelper(\"horizontal\", this);\n    this._verticalScrollHelper = new ScrollHelper(\"vertical\", this);\n  },\n  _normalizeCursorOffset: function _normalizeCursorOffset(offset) {\n    if (isObject(offset)) {\n      offset = {\n        h: offset.x,\n        v: offset.y\n      };\n    }\n\n    offset = splitPair(offset).map(function (value) {\n      return parseFloat(value);\n    });\n    return {\n      left: offset[0],\n      top: 1 === offset.length ? offset[0] : offset[1]\n    };\n  },\n  _getNormalizedCursorOffset: function _getNormalizedCursorOffset(offset, options) {\n    if (isFunction(offset)) {\n      offset = offset.call(this, options);\n    }\n\n    return this._normalizeCursorOffset(offset);\n  },\n  _calculateElementOffset: function _calculateElementOffset(options) {\n    var elementOffset;\n    var dragElementOffset;\n    var event = options.event;\n    var $element = $(options.itemElement);\n    var $dragElement = $(options.dragElement);\n\n    var isCloned = this._dragElementIsCloned();\n\n    var cursorOffset = this.option(\"cursorOffset\");\n    var normalizedCursorOffset = {\n      left: 0,\n      top: 0\n    };\n    var currentLocate = this._initialLocate = locate($dragElement);\n\n    if (isCloned || options.initialOffset || cursorOffset) {\n      elementOffset = options.initialOffset || $element.offset();\n\n      if (cursorOffset) {\n        normalizedCursorOffset = this._getNormalizedCursorOffset(cursorOffset, options);\n\n        if (isFinite(normalizedCursorOffset.left)) {\n          elementOffset.left = event.pageX;\n        }\n\n        if (isFinite(normalizedCursorOffset.top)) {\n          elementOffset.top = event.pageY;\n        }\n      }\n\n      dragElementOffset = $dragElement.offset();\n      elementOffset.top -= dragElementOffset.top + (normalizedCursorOffset.top || 0) - currentLocate.top;\n      elementOffset.left -= dragElementOffset.left + (normalizedCursorOffset.left || 0) - currentLocate.left;\n    }\n\n    return elementOffset;\n  },\n  _initPosition: function _initPosition(options) {\n    var $dragElement = $(options.dragElement);\n\n    var elementOffset = this._calculateElementOffset(options);\n\n    if (elementOffset) {\n      this._move(elementOffset, $dragElement);\n    }\n\n    this._startPosition = locate($dragElement);\n  },\n  _startAnimator: function _startAnimator() {\n    if (!this._scrollAnimator.inProgress()) {\n      this._scrollAnimator.start();\n    }\n  },\n  _stopAnimator: function _stopAnimator() {\n    this._scrollAnimator.stop();\n  },\n  _addWidgetPrefix: function _addWidgetPrefix(className) {\n    var componentName = this.NAME;\n    return dasherize(componentName) + (className ? \"-\" + className : \"\");\n  },\n  _getItemsSelector: function _getItemsSelector() {\n    return this.option(\"filter\") || \"\";\n  },\n  _$content: function _$content() {\n    var $element = this.$element();\n    var $wrapper = $element.children(\".dx-template-wrapper\");\n    return $wrapper.length ? $wrapper : $element;\n  },\n  _attachEventHandlers: function _attachEventHandlers() {\n    var _this2 = this;\n\n    if (this.option(\"disabled\")) {\n      return;\n    }\n\n    var $element = this._$content();\n\n    var itemsSelector = this._getItemsSelector();\n\n    var allowMoveByClick = this.option(\"allowMoveByClick\");\n    var data = {\n      direction: this.option(\"dragDirection\"),\n      immediate: this.option(\"immediate\"),\n      checkDropTarget: function checkDropTarget($target, event) {\n        var targetGroup = _this2.option(\"group\");\n\n        var sourceGroup = _this2._getSourceDraggable().option(\"group\");\n\n        var $scrollable = _this2._getScrollable($target);\n\n        if (_this2._verticalScrollHelper.isOutsideScrollable($scrollable, event) || _this2._horizontalScrollHelper.isOutsideScrollable($scrollable, event)) {\n          return false;\n        }\n\n        return sourceGroup && sourceGroup === targetGroup;\n      }\n    };\n\n    if (allowMoveByClick) {\n      $element = this._getArea();\n      eventsEngine.on($element, POINTERDOWN_EVENT_NAME, data, this._pointerDownHandler.bind(this));\n    }\n\n    if (\">\" === itemsSelector[0]) {\n      itemsSelector = itemsSelector.slice(1);\n    }\n\n    eventsEngine.on($element, DRAGSTART_EVENT_NAME, itemsSelector, data, this._dragStartHandler.bind(this));\n    eventsEngine.on($element, DRAG_EVENT_NAME, data, this._dragMoveHandler.bind(this));\n    eventsEngine.on($element, DRAGEND_EVENT_NAME, data, this._dragEndHandler.bind(this));\n    eventsEngine.on($element, DRAG_ENTER_EVENT_NAME, data, this._dragEnterHandler.bind(this));\n    eventsEngine.on($element, DRAGEND_LEAVE_EVENT_NAME, data, this._dragLeaveHandler.bind(this));\n  },\n  _dragElementIsCloned: function _dragElementIsCloned() {\n    return this._$dragElement && this._$dragElement.hasClass(this._addWidgetPrefix(CLONE_CLASS));\n  },\n  _getDragTemplateArgs: function _getDragTemplateArgs($element, $container) {\n    return {\n      container: getPublicElement($container),\n      model: {\n        itemData: this.option(\"itemData\"),\n        itemElement: getPublicElement($element)\n      }\n    };\n  },\n  _createDragElement: function _createDragElement($element) {\n    var result = $element;\n    var clone = this.option(\"clone\");\n\n    var $container = this._getContainer();\n\n    var template = this.option(\"dragTemplate\");\n\n    if (template) {\n      template = this._getTemplate(template);\n      result = $(\"<div>\").appendTo($container);\n      template.render(this._getDragTemplateArgs($element, result));\n    } else if (clone) {\n      result = $(\"<div>\").appendTo($container);\n      $element.clone().css({\n        width: $element.css(\"width\"),\n        height: $element.css(\"height\")\n      }).appendTo(result);\n    }\n\n    return result.toggleClass(this._addWidgetPrefix(CLONE_CLASS), result.get(0) !== $element.get(0)).toggleClass(\"dx-rtl\", this.option(\"rtlEnabled\"));\n  },\n  _resetDragElement: function _resetDragElement() {\n    if (this._dragElementIsCloned()) {\n      this._$dragElement.remove();\n    } else {\n      this._toggleDraggingClass(false);\n    }\n\n    this._$dragElement = null;\n  },\n  _resetSourceElement: function _resetSourceElement() {\n    this._toggleDragSourceClass(false);\n\n    this._$sourceElement = null;\n  },\n  _detachEventHandlers: function _detachEventHandlers() {\n    eventsEngine.off(this._$content(), \".\" + DRAGGABLE);\n    eventsEngine.off(this._getArea(), \".\" + DRAGGABLE);\n  },\n  _move: function _move(position, $element) {\n    move($element || this._$dragElement, position);\n  },\n  _getDraggableElement: function _getDraggableElement(e) {\n    var $sourceElement = this._getSourceElement();\n\n    if ($sourceElement) {\n      return $sourceElement;\n    }\n\n    var allowMoveByClick = this.option(\"allowMoveByClick\");\n\n    if (allowMoveByClick) {\n      return this.$element();\n    }\n\n    var $target = $(e && e.target);\n\n    var itemsSelector = this._getItemsSelector();\n\n    if (\">\" === itemsSelector[0]) {\n      var $items = this._$content().find(itemsSelector);\n\n      if (!$items.is($target)) {\n        $target = $target.closest($items);\n      }\n    }\n\n    return $target;\n  },\n  _getSourceElement: function _getSourceElement() {\n    var draggable = this._getSourceDraggable();\n\n    return draggable._$sourceElement;\n  },\n  _pointerDownHandler: function _pointerDownHandler(e) {\n    if (needSkipEvent(e)) {\n      return;\n    }\n\n    var position = {};\n    var $element = this.$element();\n    var dragDirection = this.option(\"dragDirection\");\n\n    if (\"horizontal\" === dragDirection || \"both\" === dragDirection) {\n      position.left = e.pageX - $element.offset().left + locate($element).left - getWidth($element) / 2;\n    }\n\n    if (\"vertical\" === dragDirection || \"both\" === dragDirection) {\n      position.top = e.pageY - $element.offset().top + locate($element).top - getHeight($element) / 2;\n    }\n\n    this._move(position, $element);\n\n    this._getAction(\"onDragMove\")(this._getEventArgs(e));\n  },\n  _isValidElement: function _isValidElement(event, $element) {\n    var handle = this.option(\"handle\");\n    var $target = $(event.originalEvent && event.originalEvent.target);\n\n    if (handle && !$target.closest(handle).length) {\n      return false;\n    }\n\n    if (!$element.length) {\n      return false;\n    }\n\n    return !$element.is(\".dx-state-disabled, .dx-state-disabled *\");\n  },\n  _dragStartHandler: function _dragStartHandler(e) {\n    var $element = this._getDraggableElement(e);\n\n    if (!this._isValidElement(e, $element)) {\n      e.cancel = true;\n      return;\n    }\n\n    if (this._$sourceElement) {\n      return;\n    }\n\n    var dragStartArgs = this._getDragStartArgs(e, $element);\n\n    this._getAction(\"onDragStart\")(dragStartArgs);\n\n    if (dragStartArgs.cancel) {\n      e.cancel = true;\n      return;\n    }\n\n    this.option(\"itemData\", dragStartArgs.itemData);\n\n    this._setSourceDraggable();\n\n    this._$sourceElement = $element;\n    var initialOffset = $element.offset();\n\n    var $dragElement = this._$dragElement = this._createDragElement($element);\n\n    this._toggleDraggingClass(true);\n\n    this._toggleDragSourceClass(true);\n\n    this._setGestureCoverCursor($dragElement.children());\n\n    var isFixedPosition = \"fixed\" === $dragElement.css(\"position\");\n\n    this._initPosition(extend({}, dragStartArgs, {\n      dragElement: $dragElement.get(0),\n      initialOffset: isFixedPosition && initialOffset\n    }));\n\n    var $area = this._getArea();\n\n    var areaOffset = this._getAreaOffset($area);\n\n    var boundOffset = this._getBoundOffset();\n\n    var areaWidth = getOuterWidth($area);\n    var areaHeight = getOuterHeight($area);\n    var elementWidth = getWidth($dragElement);\n    var elementHeight = getHeight($dragElement);\n    var startOffset_left = $dragElement.offset().left - areaOffset.left,\n        startOffset_top = $dragElement.offset().top - areaOffset.top;\n\n    if ($area.length) {\n      e.maxLeftOffset = startOffset_left - boundOffset.left;\n      e.maxRightOffset = areaWidth - startOffset_left - elementWidth - boundOffset.right;\n      e.maxTopOffset = startOffset_top - boundOffset.top;\n      e.maxBottomOffset = areaHeight - startOffset_top - elementHeight - boundOffset.bottom;\n    }\n\n    if (this.option(\"autoScroll\")) {\n      this._startAnimator();\n    }\n  },\n  _getAreaOffset: function _getAreaOffset($area) {\n    var offset = $area && positionUtils.offset($area);\n    return offset ? offset : {\n      left: 0,\n      top: 0\n    };\n  },\n  _toggleDraggingClass: function _toggleDraggingClass(value) {\n    this._$dragElement && this._$dragElement.toggleClass(this._addWidgetPrefix(\"dragging\"), value);\n  },\n  _toggleDragSourceClass: function _toggleDragSourceClass(value, $element) {\n    var $sourceElement = $element || this._$sourceElement;\n    $sourceElement && $sourceElement.toggleClass(this._addWidgetPrefix(\"source\"), value);\n  },\n  _setGestureCoverCursor: function _setGestureCoverCursor($element) {\n    $(\".\".concat(GESTURE_COVER_CLASS)).css(\"cursor\", $element.css(\"cursor\"));\n  },\n  _getBoundOffset: function _getBoundOffset() {\n    var boundOffset = this.option(\"boundOffset\");\n\n    if (isFunction(boundOffset)) {\n      boundOffset = boundOffset.call(this);\n    }\n\n    return quadToObject(boundOffset);\n  },\n  _getArea: function _getArea() {\n    var area = this.option(\"boundary\");\n\n    if (isFunction(area)) {\n      area = area.call(this);\n    }\n\n    return $(area);\n  },\n  _getContainer: function _getContainer() {\n    var container = this.option(\"container\");\n\n    if (void 0 === container) {\n      container = viewPort();\n    }\n\n    return $(container);\n  },\n  _dragMoveHandler: function _dragMoveHandler(e, scrollBy) {\n    this._dragMoveArgs = e;\n\n    if (!this._$dragElement) {\n      e.cancel = true;\n      return;\n    }\n\n    var offset = e.offset;\n    var startPosition = this._startPosition;\n\n    this._move({\n      left: startPosition.left + offset.x,\n      top: startPosition.top + offset.y\n    });\n\n    if (!scrollBy) {\n      this._updateScrollable(e);\n    }\n\n    var eventArgs = this._getEventArgs(e);\n\n    this._getAction(\"onDragMove\")(eventArgs);\n\n    if (true === eventArgs.cancel) {\n      return;\n    }\n\n    var targetDraggable = this._getTargetDraggable();\n\n    targetDraggable.dragMove(e, scrollBy);\n  },\n  _updateScrollable: function _updateScrollable(e) {\n    if (this.option(\"autoScroll\")) {\n      var mousePosition = getMousePosition(e);\n      var allObjects = domAdapter.elementsFromPoint(mousePosition.x, mousePosition.y);\n\n      this._verticalScrollHelper.updateScrollable(allObjects, mousePosition);\n\n      this._horizontalScrollHelper.updateScrollable(allObjects, mousePosition);\n    }\n  },\n  _getScrollable: function _getScrollable($element) {\n    var _this3 = this;\n\n    var $scrollable;\n    $element.parents().toArray().some(function (parent) {\n      var $parent = $(parent);\n\n      if (_this3._horizontalScrollHelper.isScrollable($parent) || _this3._verticalScrollHelper.isScrollable($parent)) {\n        $scrollable = $parent;\n        return true;\n      }\n    });\n    return $scrollable;\n  },\n  _defaultActionArgs: function _defaultActionArgs() {\n    var args = this.callBase.apply(this, arguments);\n    var component = this.option(\"component\");\n\n    if (component) {\n      args.component = component;\n      args.element = component.element();\n    }\n\n    return args;\n  },\n  _getEventArgs: function _getEventArgs(e) {\n    var sourceDraggable = this._getSourceDraggable();\n\n    var targetDraggable = this._getTargetDraggable();\n\n    return {\n      event: e,\n      itemData: sourceDraggable.option(\"itemData\"),\n      itemElement: getPublicElement(sourceDraggable._$sourceElement),\n      fromComponent: sourceDraggable.option(\"component\") || sourceDraggable,\n      toComponent: targetDraggable.option(\"component\") || targetDraggable,\n      fromData: sourceDraggable.option(\"data\"),\n      toData: targetDraggable.option(\"data\")\n    };\n  },\n  _getDragStartArgs: function _getDragStartArgs(e, $itemElement) {\n    var args = this._getEventArgs(e);\n\n    return {\n      event: args.event,\n      itemData: args.itemData,\n      itemElement: $itemElement,\n      fromData: args.fromData\n    };\n  },\n  _revertItemToInitialPosition: function _revertItemToInitialPosition() {\n    !this._dragElementIsCloned() && this._move(this._initialLocate, this._$sourceElement);\n  },\n  _dragEndHandler: function _dragEndHandler(e) {\n    var _this4 = this;\n\n    var d = new Deferred();\n\n    var dragEndEventArgs = this._getEventArgs(e);\n\n    var dropEventArgs = this._getEventArgs(e);\n\n    var targetDraggable = this._getTargetDraggable();\n\n    var needRevertPosition = true;\n\n    try {\n      this._getAction(\"onDragEnd\")(dragEndEventArgs);\n    } finally {\n      when(fromPromise(dragEndEventArgs.cancel)).done(function (cancel) {\n        if (!cancel) {\n          if (targetDraggable !== _this4) {\n            targetDraggable._getAction(\"onDrop\")(dropEventArgs);\n          }\n\n          if (!dropEventArgs.cancel) {\n            needRevertPosition = false;\n            when(fromPromise(targetDraggable.dragEnd(dragEndEventArgs))).always(d.resolve);\n            return;\n          }\n        }\n\n        d.resolve();\n      }).fail(d.resolve);\n      d.done(function () {\n        if (needRevertPosition) {\n          _this4._revertItemToInitialPosition();\n        }\n\n        _this4.reset();\n\n        targetDraggable.reset();\n\n        _this4._stopAnimator();\n\n        _this4._horizontalScrollHelper.reset();\n\n        _this4._verticalScrollHelper.reset();\n\n        _this4._resetDragElement();\n\n        _this4._resetSourceElement();\n\n        _this4._resetTargetDraggable();\n\n        _this4._resetSourceDraggable();\n      });\n    }\n  },\n  _isTargetOverAnotherDraggable: function _isTargetOverAnotherDraggable(e) {\n    var _this5 = this;\n\n    var sourceDraggable = this._getSourceDraggable();\n\n    if (this === sourceDraggable) {\n      return false;\n    }\n\n    var $dragElement = sourceDraggable._$dragElement;\n    var $sourceDraggableElement = sourceDraggable.$element();\n    var $targetDraggableElement = this.$element();\n    var mousePosition = getMousePosition(e);\n    var elements = domAdapter.elementsFromPoint(mousePosition.x, mousePosition.y);\n    var firstWidgetElement = elements.filter(function (element) {\n      var $element = $(element);\n\n      if ($element.hasClass(_this5._addWidgetPrefix())) {\n        return !$element.closest($dragElement).length;\n      }\n    })[0];\n\n    var $sourceElement = this._getSourceElement();\n\n    var isTargetOverItself = firstWidgetElement === $sourceDraggableElement.get(0);\n    var isTargetOverNestedDraggable = $(firstWidgetElement).closest($sourceElement).length;\n    return !firstWidgetElement || firstWidgetElement === $targetDraggableElement.get(0) && !isTargetOverItself && !isTargetOverNestedDraggable;\n  },\n  _dragEnterHandler: function _dragEnterHandler(e) {\n    this._fireDragEnterEvent(e);\n\n    if (this._isTargetOverAnotherDraggable(e)) {\n      this._setTargetDraggable();\n    }\n\n    var sourceDraggable = this._getSourceDraggable();\n\n    sourceDraggable.dragEnter(e);\n  },\n  _dragLeaveHandler: function _dragLeaveHandler(e) {\n    this._fireDragLeaveEvent(e);\n\n    this._resetTargetDraggable();\n\n    if (this !== this._getSourceDraggable()) {\n      this.reset();\n    }\n\n    var sourceDraggable = this._getSourceDraggable();\n\n    sourceDraggable.dragLeave(e);\n  },\n  _getAction: function _getAction(name) {\n    return this[\"_\" + name + \"Action\"] || this._createActionByOption(name);\n  },\n  _getAnonymousTemplateName: function _getAnonymousTemplateName() {\n    return ANONYMOUS_TEMPLATE_NAME;\n  },\n  _initTemplates: function _initTemplates() {\n    if (!this.option(\"contentTemplate\")) {\n      return;\n    }\n\n    this._templateManager.addDefaultTemplates({\n      content: new EmptyTemplate()\n    });\n\n    this.callBase.apply(this, arguments);\n  },\n  _render: function _render() {\n    this.callBase();\n    this.$element().addClass(this._addWidgetPrefix());\n    var transclude = this._templateManager.anonymousTemplateName === this.option(\"contentTemplate\");\n\n    var template = this._getTemplateByOption(\"contentTemplate\");\n\n    if (template) {\n      $(template.render({\n        container: this.element(),\n        transclude: transclude\n      }));\n    }\n  },\n  _optionChanged: function _optionChanged(args) {\n    var name = args.name;\n\n    switch (name) {\n      case \"onDragStart\":\n      case \"onDragMove\":\n      case \"onDragEnd\":\n      case \"onDrop\":\n      case \"onDragEnter\":\n      case \"onDragLeave\":\n        this[\"_\" + name + \"Action\"] = this._createActionByOption(name);\n        break;\n\n      case \"dragTemplate\":\n      case \"contentTemplate\":\n      case \"container\":\n      case \"clone\":\n        break;\n\n      case \"allowMoveByClick\":\n      case \"dragDirection\":\n      case \"disabled\":\n      case \"boundary\":\n      case \"filter\":\n      case \"immediate\":\n        this._resetDragElement();\n\n        this._detachEventHandlers();\n\n        this._attachEventHandlers();\n\n        break;\n\n      case \"autoScroll\":\n        this._verticalScrollHelper.reset();\n\n        this._horizontalScrollHelper.reset();\n\n        break;\n\n      case \"scrollSensitivity\":\n      case \"scrollSpeed\":\n      case \"boundOffset\":\n      case \"handle\":\n      case \"group\":\n      case \"data\":\n      case \"itemData\":\n        break;\n\n      default:\n        this.callBase(args);\n    }\n  },\n  _getTargetDraggable: function _getTargetDraggable() {\n    return targetDraggable || this;\n  },\n  _getSourceDraggable: function _getSourceDraggable() {\n    return sourceDraggable || this;\n  },\n  _setTargetDraggable: function _setTargetDraggable() {\n    var currentGroup = this.option(\"group\");\n\n    var sourceDraggable = this._getSourceDraggable();\n\n    if (currentGroup && currentGroup === sourceDraggable.option(\"group\")) {\n      targetDraggable = this;\n    }\n  },\n  _setSourceDraggable: function _setSourceDraggable() {\n    sourceDraggable = this;\n  },\n  _resetSourceDraggable: function _resetSourceDraggable() {\n    sourceDraggable = null;\n  },\n  _resetTargetDraggable: function _resetTargetDraggable() {\n    targetDraggable = null;\n  },\n  _dispose: function _dispose() {\n    this.callBase();\n\n    this._detachEventHandlers();\n\n    this._resetDragElement();\n\n    this._resetTargetDraggable();\n\n    this._resetSourceDraggable();\n\n    this._$sourceElement = null;\n\n    this._stopAnimator();\n  },\n  _fireDragEnterEvent: function _fireDragEnterEvent(sourceEvent) {\n    var args = this._getEventArgs(sourceEvent);\n\n    this._getAction(\"onDragEnter\")(args);\n  },\n  _fireDragLeaveEvent: function _fireDragLeaveEvent(sourceEvent) {\n    var args = this._getEventArgs(sourceEvent);\n\n    this._getAction(\"onDragLeave\")(args);\n  }\n});\nregisterComponent(DRAGGABLE, Draggable);\nexport default Draggable;","map":null,"metadata":{},"sourceType":"module"}