{"ast":null,"code":"/**\r\n * DevExtreme (esm/viz/translators/interval_translator.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { isNumeric as isNumber, isDefined } from \"../../core/utils/type\";\nimport dateUtils from \"../../core/utils/date\";\nvar floor = Math.floor;\nimport { adjust } from \"../../core/utils/math\";\nexport default {\n  _intervalize: function _intervalize(value, interval) {\n    if (!isDefined(value)) {\n      return;\n    }\n\n    if (\"datetime\" === this._businessRange.dataType) {\n      if (isNumber(value)) {\n        value = new Date(value);\n      } else {\n        value = new Date(value.getTime());\n      }\n\n      value = dateUtils.correctDateWithUnitBeginning(value, interval, null, this._options.firstDayOfWeek);\n    } else {\n      value = adjust(floor(adjust(value / interval)) * interval, interval);\n    }\n\n    return value;\n  },\n  translate: function translate(bp, direction, interval) {\n    var specialValue = this.translateSpecialCase(bp);\n\n    if (isDefined(specialValue)) {\n      return Math.round(specialValue);\n    }\n\n    interval = interval || this._options.interval;\n\n    if (!this.isValid(bp, interval)) {\n      return null;\n    }\n\n    return this.to(bp, direction, interval);\n  },\n  getInterval: function getInterval() {\n    return Math.round(this._canvasOptions.ratioOfCanvasRange * (this._businessRange.interval || Math.abs(this._canvasOptions.rangeMax - this._canvasOptions.rangeMin)));\n  },\n  zoom: function zoom() {},\n  getMinScale: function getMinScale() {},\n  getScale: function getScale() {},\n  _parse: function _parse(value) {\n    return \"datetime\" === this._businessRange.dataType ? new Date(value) : Number(value);\n  },\n  fromValue: function fromValue(value) {\n    return this._parse(value);\n  },\n  toValue: function toValue(value) {\n    return this._parse(value);\n  },\n  isValid: function isValid(value, interval) {\n    var co = this._canvasOptions;\n    var rangeMin = co.rangeMin;\n    var rangeMax = co.rangeMax;\n    interval = interval || this._options.interval;\n\n    if (null === value || isNaN(value)) {\n      return false;\n    }\n\n    value = \"datetime\" === this._businessRange.dataType && isNumber(value) ? new Date(value) : value;\n\n    if (interval !== this._options.interval) {\n      rangeMin = this._intervalize(rangeMin, interval);\n      rangeMax = this._intervalize(rangeMax, interval);\n    }\n\n    if (value.valueOf() < rangeMin || value.valueOf() >= dateUtils.addInterval(rangeMax, interval)) {\n      return false;\n    }\n\n    return true;\n  },\n  to: function to(bp, direction, interval) {\n    interval = interval || this._options.interval;\n\n    var v1 = this._intervalize(bp, interval);\n\n    var v2 = dateUtils.addInterval(v1, interval);\n\n    var res = this._to(v1);\n\n    var p2 = this._to(v2);\n\n    if (!direction) {\n      res = floor((res + p2) / 2);\n    } else if (direction > 0) {\n      res = p2;\n    }\n\n    return res;\n  },\n  _to: function _to(value) {\n    var co = this._canvasOptions;\n    var rMin = co.rangeMinVisible;\n    var rMax = co.rangeMaxVisible;\n    var offset = value - rMin;\n\n    if (value < rMin) {\n      offset = 0;\n    } else if (value > rMax) {\n      offset = dateUtils.addInterval(rMax, this._options.interval) - rMin;\n    }\n\n    return this._conversionValue(this._calculateProjection(offset * this._canvasOptions.ratioOfCanvasRange));\n  },\n  from: function from(position, direction) {\n    var origInterval = this._options.interval;\n    var interval = origInterval;\n    var co = this._canvasOptions;\n    var rMin = co.rangeMinVisible;\n    var rMax = co.rangeMaxVisible;\n    var value;\n\n    if (\"datetime\" === this._businessRange.dataType) {\n      interval = dateUtils.dateToMilliseconds(origInterval);\n    }\n\n    value = this._calculateUnProjection((position - this._canvasOptions.startPoint) / this._canvasOptions.ratioOfCanvasRange);\n    value = this._intervalize(dateUtils.addInterval(value, interval / 2, direction > 0), origInterval);\n\n    if (value < rMin) {\n      value = rMin;\n    } else if (value > rMax) {\n      value = rMax;\n    }\n\n    return value;\n  },\n  _add: function _add() {\n    return NaN;\n  },\n  isValueProlonged: true\n};","map":null,"metadata":{},"sourceType":"module"}