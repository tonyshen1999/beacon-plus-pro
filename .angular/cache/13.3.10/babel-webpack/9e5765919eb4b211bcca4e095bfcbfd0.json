{"ast":null,"code":"/**\r\n * DevExtreme (esm/viz/series/pie_series.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { noop } from \"../../core/utils/common\";\nimport { each } from \"../../core/utils/iterator\";\nimport { chart } from \"./scatter_series\";\nimport { normalizeAngle, map } from \"../core/utils\";\nimport { extend } from \"../../core/utils/extend\";\nimport { chart as barChart } from \"./bar_series\";\nvar chartScatterSeries = chart;\nvar barSeries = barChart.bar;\nvar _extend = extend;\nvar _each = each;\nvar _noop = noop;\nvar _map = map;\nvar _isFinite = isFinite;\nvar _max = Math.max;\nvar ANIMATION_DURATION = .7;\nvar INSIDE = \"inside\";\nexport var pie = _extend({}, barSeries, {\n  _setGroupsSettings: function _setGroupsSettings() {\n    chartScatterSeries._setGroupsSettings.apply(this, arguments);\n\n    this._labelsGroup.attr({\n      \"pointer-events\": null\n    });\n  },\n  _createErrorBarGroup: _noop,\n  _drawPoint: function _drawPoint(options) {\n    var point = options.point;\n    var legendCallback = this._legendCallback;\n\n    chartScatterSeries._drawPoint.call(this, options);\n\n    !point.isVisible() && point.setInvisibility();\n    point.isSelected() && legendCallback();\n  },\n  _getOldPoint: function _getOldPoint(data, oldPointsByArgument, index) {\n    var point = (this._points || [])[index];\n\n    if (point) {\n      oldPointsByArgument[point.argument.valueOf()] = oldPointsByArgument[point.argument.valueOf()].filter(function (p) {\n        return p !== point;\n      });\n    }\n\n    return point;\n  },\n  adjustLabels: function adjustLabels(moveLabelsFromCenter) {\n    return (this._points || []).reduce(function (r, p) {\n      if (p._label.isVisible()) {\n        p.setLabelTrackerData();\n        r = p.applyWordWrap(moveLabelsFromCenter) || r;\n        p.updateLabelCoord(moveLabelsFromCenter);\n        return r;\n      }\n    }, false);\n  },\n  _applyElementsClipRect: _noop,\n  getColor: _noop,\n  areErrorBarsVisible: _noop,\n  drawLabelsWOPoints: function drawLabelsWOPoints() {\n    if (this._options.label.position === INSIDE) {\n      return false;\n    }\n\n    this._labelsGroup.append(this._extGroups.labelsGroup);\n\n    (this._points || []).forEach(function (point) {\n      point.drawLabel();\n    });\n    return true;\n  },\n  getPointsCount: function getPointsCount() {\n    var _this = this;\n\n    return this._data.filter(function (d) {\n      return _this._checkData(d);\n    }).length;\n  },\n  setMaxPointsCount: function setMaxPointsCount(count) {\n    this._pointsCount = count;\n  },\n  _getCreatingPointOptions: function _getCreatingPointOptions(data, dataIndex) {\n    return this._getPointOptions(data, dataIndex);\n  },\n  _updateOptions: function _updateOptions(options) {\n    this.labelSpace = 0;\n    this.innerRadius = \"pie\" === this.type ? 0 : options.innerRadius;\n  },\n  _checkData: function _checkData(data, skippedFields) {\n    var base = barSeries._checkData.call(this, data, skippedFields, {\n      value: this.getValueFields()[0]\n    });\n\n    return this._options.paintNullPoints ? base : base && null !== data.value;\n  },\n  _createGroups: chartScatterSeries._createGroups,\n  _setMarkerGroupSettings: function _setMarkerGroupSettings() {\n    this._markersGroup.attr({\n      class: \"dxc-markers\"\n    });\n  },\n  _getMainColor: function _getMainColor(data, point) {\n    var pointsByArg = this.getPointsByArg(data.argument);\n    var argumentIndex = point ? pointsByArg.indexOf(point) : pointsByArg.length;\n    return this._options.mainSeriesColor(data.argument, argumentIndex, this._pointsCount);\n  },\n  _getPointOptions: function _getPointOptions(data) {\n    return this._parsePointOptions(this._preparePointOptions(), this._options.label, data);\n  },\n  _getRangeData: function _getRangeData() {\n    return this._rangeData;\n  },\n  _createPointStyles: function _createPointStyles(pointOptions, data, point) {\n    var mainColor = pointOptions.color || this._getMainColor(data, point);\n\n    return {\n      normal: this._parsePointStyle(pointOptions, mainColor, mainColor),\n      hover: this._parsePointStyle(pointOptions.hoverStyle, mainColor, mainColor),\n      selection: this._parsePointStyle(pointOptions.selectionStyle, mainColor, mainColor),\n      legendStyles: {\n        normal: this._createLegendState(pointOptions, mainColor),\n        hover: this._createLegendState(pointOptions.hoverStyle, mainColor),\n        selection: this._createLegendState(pointOptions.selectionStyle, mainColor)\n      }\n    };\n  },\n  _getArrangeMinShownValue: function _getArrangeMinShownValue(points, total) {\n    var minSegmentSize = this._options.minSegmentSize;\n    var totalMinSegmentSize = 0;\n    var totalNotMinValues = 0;\n    total = total || points.length;\n\n    _each(points, function (_, point) {\n      if (point.isVisible()) {\n        if (point.normalInitialValue < minSegmentSize * total / 360) {\n          totalMinSegmentSize += minSegmentSize;\n        } else {\n          totalNotMinValues += point.normalInitialValue;\n        }\n      }\n    });\n\n    return totalMinSegmentSize < 360 ? minSegmentSize * totalNotMinValues / (360 - totalMinSegmentSize) : 0;\n  },\n  _applyArrangeCorrection: function _applyArrangeCorrection(points, minShownValue, total) {\n    var options = this._options;\n    var isClockWise = \"anticlockwise\" !== options.segmentsDirection;\n    var shiftedAngle = _isFinite(options.startAngle) ? normalizeAngle(options.startAngle) : 0;\n    var minSegmentSize = options.minSegmentSize;\n    var percent;\n    var correction = 0;\n    var zeroTotalCorrection = 0;\n\n    if (0 === total) {\n      total = points.filter(function (el) {\n        return el.isVisible();\n      }).length;\n      zeroTotalCorrection = 1;\n    }\n\n    _each(isClockWise ? points : points.concat([]).reverse(), function (_, point) {\n      var val = point.isVisible() ? zeroTotalCorrection || point.normalInitialValue : 0;\n      var updatedZeroValue;\n\n      if (minSegmentSize && point.isVisible() && val < minShownValue) {\n        updatedZeroValue = minShownValue;\n      }\n\n      percent = val / total;\n      point.correctValue(correction, percent, zeroTotalCorrection + (updatedZeroValue || 0));\n      point.shiftedAngle = shiftedAngle;\n      correction += updatedZeroValue || val;\n    });\n\n    this._rangeData = {\n      val: {\n        min: 0,\n        max: correction\n      }\n    };\n  },\n  _removePoint: function _removePoint(point) {\n    var points = this.getPointsByArg(point.argument);\n    points.splice(points.indexOf(point), 1);\n    point.dispose();\n  },\n  arrangePoints: function arrangePoints() {\n    var that = this;\n    var originalPoints = that._points || [];\n    var minSegmentSize = that._options.minSegmentSize;\n    var minShownValue;\n    var isAllPointsNegative = true;\n    var i = 0;\n    var len = originalPoints.length;\n\n    while (i < len && isAllPointsNegative) {\n      isAllPointsNegative = originalPoints[i].value <= 0;\n      i++;\n    }\n\n    var points = that._points = _map(originalPoints, function (point) {\n      if (null === point.value || !isAllPointsNegative && point.value < 0) {\n        that._removePoint(point);\n\n        return null;\n      } else {\n        return point;\n      }\n    });\n\n    var maxValue = points.reduce(function (max, p) {\n      return _max(max, Math.abs(p.initialValue));\n    }, 0);\n    points.forEach(function (p) {\n      p.normalInitialValue = p.initialValue / (0 !== maxValue ? maxValue : 1);\n    });\n    var total = points.reduce(function (total, point) {\n      return total + (point.isVisible() ? point.normalInitialValue : 0);\n    }, 0);\n\n    if (minSegmentSize) {\n      minShownValue = this._getArrangeMinShownValue(points, total);\n    }\n\n    that._applyArrangeCorrection(points, minShownValue, total);\n  },\n  correctPosition: function correctPosition(correction, canvas) {\n    _each(this._points, function (_, point) {\n      point.correctPosition(correction);\n    });\n\n    this.setVisibleArea(canvas);\n  },\n  correctRadius: function correctRadius(correction) {\n    this._points.forEach(function (point) {\n      point.correctRadius(correction);\n    });\n  },\n  correctLabelRadius: function correctLabelRadius(labelRadius) {\n    this._points.forEach(function (point) {\n      point.correctLabelRadius(labelRadius);\n    });\n  },\n  setVisibleArea: function setVisibleArea(canvas) {\n    this._visibleArea = {\n      minX: canvas.left,\n      maxX: canvas.width - canvas.right,\n      minY: canvas.top,\n      maxY: canvas.height - canvas.bottom\n    };\n  },\n  _applyVisibleArea: _noop,\n  _animate: function _animate(firstDrawing) {\n    var that = this;\n    var points = that._points;\n    var pointsCount = points && points.length;\n\n    var completeFunc = function completeFunc() {\n      that._animateComplete();\n    };\n\n    var animatePoint;\n\n    if (firstDrawing) {\n      animatePoint = function animatePoint(p, i) {\n        p.animate(i === pointsCount - 1 ? completeFunc : void 0, ANIMATION_DURATION, (1 - ANIMATION_DURATION) * i / (pointsCount - 1));\n      };\n    } else {\n      animatePoint = function animatePoint(p, i) {\n        p.animate(i === pointsCount - 1 ? completeFunc : void 0);\n      };\n    }\n\n    points.forEach(animatePoint);\n  },\n  getVisiblePoints: function getVisiblePoints() {\n    return _map(this._points, function (p) {\n      return p.isVisible() ? p : null;\n    });\n  },\n  getPointsByKeys: function getPointsByKeys(arg, argumentIndex) {\n    var pointsByArg = this.getPointsByArg(arg);\n    return pointsByArg[argumentIndex] && [pointsByArg[argumentIndex]] || [];\n  }\n});\nexport var doughnut = pie;\nexport var donut = pie;","map":null,"metadata":{},"sourceType":"module"}