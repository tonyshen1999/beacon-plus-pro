{"ast":null,"code":"/**\r\n * DevExtreme (esm/viz/series/stacked_series.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { noop as _noop } from \"../../core/utils/common\";\nimport { extend as _extend } from \"../../core/utils/extend\";\nimport { each } from \"../../core/utils/iterator\";\nimport { chart as areaSeries } from \"./area_series\";\nvar chartAreaSeries = areaSeries.area;\nimport { chart as _chart, polar as _polar } from \"./bar_series\";\nvar chartBarSeries = _chart.bar;\nimport { chart as lineSeries } from \"./line_series\";\nimport { map } from \"../core/utils\";\nimport { clone } from \"../../core/utils/object\";\nvar baseStackedSeries = {\n  _calculateErrorBars: _noop,\n  _updateOptions: function _updateOptions(options) {\n    this._stackName = \"axis_\" + (options.axis || \"default\");\n  }\n};\nvar chart = {};\nvar polar = {};\nchart.stackedline = _extend({}, lineSeries.line, baseStackedSeries, {});\nchart.stackedspline = _extend({}, lineSeries.spline, baseStackedSeries, {});\nchart.fullstackedline = _extend({}, lineSeries.line, baseStackedSeries, {\n  getValueRangeInitialValue: areaSeries.area.getValueRangeInitialValue\n});\nchart.fullstackedspline = _extend({}, lineSeries.spline, baseStackedSeries, {\n  getValueRangeInitialValue: areaSeries.area.getValueRangeInitialValue\n});\n\nvar stackedBar = chart.stackedbar = _extend({}, chartBarSeries, baseStackedSeries, {\n  _updateOptions: function _updateOptions(options) {\n    baseStackedSeries._updateOptions.call(this, options);\n\n    this._stackName = this._stackName + \"_stack_\" + (options.stack || \"default\");\n  }\n});\n\nchart.fullstackedbar = _extend({}, chartBarSeries, baseStackedSeries, {\n  _updateOptions: stackedBar._updateOptions\n});\n\nfunction clonePoint(point, value, minValue, position) {\n  point = clone(point);\n  point.value = value;\n  point.minValue = minValue;\n  point.translate();\n  point.argument = point.argument + position;\n  return point;\n}\n\nfunction preparePointsForStackedAreaSegment(points) {\n  var i = 0;\n  var p;\n  var result = [];\n  var array;\n  var len = points.length;\n\n  while (i < len) {\n    p = points[i];\n    array = [p];\n\n    if (p.leftHole) {\n      array = [clonePoint(p, p.leftHole, p.minLeftHole, \"left\"), p];\n    }\n\n    if (p.rightHole) {\n      array.push(clonePoint(p, p.rightHole, p.minRightHole, \"right\"));\n    }\n\n    result.push(array);\n    i++;\n  }\n\n  return [].concat.apply([], result);\n}\n\nchart.stackedarea = _extend({}, chartAreaSeries, baseStackedSeries, {\n  _prepareSegment: function _prepareSegment(points, rotated) {\n    return chartAreaSeries._prepareSegment.call(this, preparePointsForStackedAreaSegment(points), rotated);\n  },\n  _appendInGroup: function _appendInGroup() {\n    this._group.append(this._extGroups.seriesGroup).toBackground();\n  }\n});\n\nfunction getPointsByArgFromPrevSeries(prevSeries, argument) {\n  var result;\n\n  while (!result && prevSeries) {\n    result = prevSeries._segmentByArg && prevSeries._segmentByArg[argument];\n    prevSeries = prevSeries._prevSeries;\n  }\n\n  return result;\n}\n\nchart.stackedsplinearea = _extend({}, areaSeries.splinearea, baseStackedSeries, {\n  _prepareSegment: function _prepareSegment(points, rotated) {\n    var that = this;\n    var areaSegment;\n    points = preparePointsForStackedAreaSegment(points);\n\n    if (!this._prevSeries || 1 === points.length) {\n      areaSegment = areaSeries.splinearea._prepareSegment.call(this, points, rotated);\n    } else {\n      var forwardPoints = lineSeries.spline._calculateBezierPoints(points, rotated);\n\n      var backwardPoints = map(points, function (p) {\n        var point = p.getCoords(true);\n        point.argument = p.argument;\n        return point;\n      });\n      var prevSeriesForwardPoints = [];\n      var pointByArg = {};\n      var i = 0;\n      var len = that._prevSeries._segments.length;\n\n      while (i < len) {\n        prevSeriesForwardPoints = prevSeriesForwardPoints.concat(that._prevSeries._segments[i].line);\n        i++;\n      }\n\n      each(prevSeriesForwardPoints, function (_, p) {\n        if (null !== p.argument) {\n          var argument = p.argument.valueOf();\n\n          if (!pointByArg[argument]) {\n            pointByArg[argument] = [p];\n          } else {\n            pointByArg[argument].push(p);\n          }\n        }\n      });\n      that._prevSeries._segmentByArg = pointByArg;\n      backwardPoints = lineSeries.spline._calculateBezierPoints(backwardPoints, rotated);\n      each(backwardPoints, function (i, p) {\n        var argument = p.argument.valueOf();\n        var prevSeriesPoints;\n\n        if (i % 3 === 0) {\n          prevSeriesPoints = pointByArg[argument] || getPointsByArgFromPrevSeries(that._prevSeries, argument);\n\n          if (prevSeriesPoints) {\n            backwardPoints[i - 1] && prevSeriesPoints[0] && (backwardPoints[i - 1] = prevSeriesPoints[0]);\n            backwardPoints[i + 1] && (backwardPoints[i + 1] = prevSeriesPoints[2] || p);\n          }\n        }\n      });\n      areaSegment = {\n        line: forwardPoints,\n        area: forwardPoints.concat(backwardPoints.reverse())\n      };\n\n      that._areaPointsToSplineAreaPoints(areaSegment.area);\n    }\n\n    return areaSegment;\n  },\n  _appendInGroup: chart.stackedarea._appendInGroup\n});\nchart.fullstackedarea = _extend({}, chartAreaSeries, baseStackedSeries, {\n  _prepareSegment: chart.stackedarea._prepareSegment,\n  _appendInGroup: chart.stackedarea._appendInGroup\n});\nchart.fullstackedsplinearea = _extend({}, areaSeries.splinearea, baseStackedSeries, {\n  _prepareSegment: chart.stackedsplinearea._prepareSegment,\n  _appendInGroup: chart.stackedarea._appendInGroup\n});\npolar.stackedbar = _extend({}, _polar.bar, baseStackedSeries, {});\nexport { chart, polar };","map":null,"metadata":{},"sourceType":"module"}