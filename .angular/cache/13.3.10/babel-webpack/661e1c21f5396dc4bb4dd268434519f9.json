{"ast":null,"code":"import _classCallCheck from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n\n/**\r\n * DevExtreme (esm/ui/scheduler/appointments/rendering_strategies/strategy.base.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport AppointmentPositioningStrategy from \"./appointmentsPositioning_strategy_base\";\nimport AdaptivePositioningStrategy from \"./appointmentsPositioning_strategy_adaptive\";\nimport { extend } from \"../../../../core/utils/extend\";\nimport dateUtils from \"../../../../core/utils/date\";\nimport { isNumeric, isObject } from \"../../../../core/utils/type\";\nimport { current as currentTheme } from \"../../../themes\";\nimport { AppointmentSettingsGenerator } from \"../settingsGenerator\";\nimport timeZoneUtils from \"../../utils.timeZone\";\nimport { createAppointmentAdapter } from \"../../appointmentAdapter\";\nimport { getAppointmentTakesAllDay } from \"../dataProvider/utils\";\nvar toMs = dateUtils.dateToMilliseconds;\nvar APPOINTMENT_MIN_SIZE = 2;\nvar APPOINTMENT_DEFAULT_HEIGHT = 20;\nvar COMPACT_THEME_APPOINTMENT_DEFAULT_HEIGHT = 18;\nvar DROP_DOWN_BUTTON_ADAPTIVE_SIZE = 28;\nvar WEEK_VIEW_COLLECTOR_OFFSET = 5;\nvar COMPACT_THEME_WEEK_VIEW_COLLECTOR_OFFSET = 1;\n\nvar BaseRenderingStrategy = /*#__PURE__*/function () {\n  function BaseRenderingStrategy(options) {\n    _classCallCheck(this, BaseRenderingStrategy);\n\n    this.options = options;\n\n    this._initPositioningStrategy();\n  }\n\n  _createClass(BaseRenderingStrategy, [{\n    key: \"isAdaptive\",\n    get: function get() {\n      return this.options.adaptivityEnabled;\n    }\n  }, {\n    key: \"rtlEnabled\",\n    get: function get() {\n      return this.options.rtlEnabled;\n    }\n  }, {\n    key: \"startDayHour\",\n    get: function get() {\n      return this.options.startDayHour;\n    }\n  }, {\n    key: \"endDayHour\",\n    get: function get() {\n      return this.options.endDayHour;\n    }\n  }, {\n    key: \"maxAppointmentsPerCell\",\n    get: function get() {\n      return this.options.maxAppointmentsPerCell;\n    }\n  }, {\n    key: \"cellWidth\",\n    get: function get() {\n      return this.options.cellWidth;\n    }\n  }, {\n    key: \"cellHeight\",\n    get: function get() {\n      return this.options.cellHeight;\n    }\n  }, {\n    key: \"allDayHeight\",\n    get: function get() {\n      return this.options.allDayHeight;\n    }\n  }, {\n    key: \"resizableStep\",\n    get: function get() {\n      return this.options.resizableStep;\n    }\n  }, {\n    key: \"isGroupedByDate\",\n    get: function get() {\n      return this.options.isGroupedByDate;\n    }\n  }, {\n    key: \"visibleDayDuration\",\n    get: function get() {\n      return this.options.visibleDayDuration;\n    }\n  }, {\n    key: \"viewStartDayHour\",\n    get: function get() {\n      return this.options.viewStartDayHour;\n    }\n  }, {\n    key: \"viewEndDayHour\",\n    get: function get() {\n      return this.options.viewEndDayHour;\n    }\n  }, {\n    key: \"cellDuration\",\n    get: function get() {\n      return this.options.cellDuration;\n    }\n  }, {\n    key: \"cellDurationInMinutes\",\n    get: function get() {\n      return this.options.cellDurationInMinutes;\n    }\n  }, {\n    key: \"leftVirtualCellCount\",\n    get: function get() {\n      return this.options.leftVirtualCellCount;\n    }\n  }, {\n    key: \"topVirtualCellCount\",\n    get: function get() {\n      return this.options.topVirtualCellCount;\n    }\n  }, {\n    key: \"positionHelper\",\n    get: function get() {\n      return this.options.positionHelper;\n    }\n  }, {\n    key: \"showAllDayPanel\",\n    get: function get() {\n      return this.options.showAllDayPanel;\n    }\n  }, {\n    key: \"isGroupedAllDayPanel\",\n    get: function get() {\n      return this.options.isGroupedAllDayPanel;\n    }\n  }, {\n    key: \"groupOrientation\",\n    get: function get() {\n      return this.options.groupOrientation;\n    }\n  }, {\n    key: \"rowCount\",\n    get: function get() {\n      return this.options.rowCount;\n    }\n  }, {\n    key: \"groupCount\",\n    get: function get() {\n      return this.options.groupCount;\n    }\n  }, {\n    key: \"currentDate\",\n    get: function get() {\n      return this.options.currentDate;\n    }\n  }, {\n    key: \"appointmentCountPerCell\",\n    get: function get() {\n      return this.options.appointmentCountPerCell;\n    }\n  }, {\n    key: \"appointmentOffset\",\n    get: function get() {\n      return this.options.appointmentOffset;\n    }\n  }, {\n    key: \"allowResizing\",\n    get: function get() {\n      return this.options.allowResizing;\n    }\n  }, {\n    key: \"allowAllDayResizing\",\n    get: function get() {\n      return this.options.allowAllDayResizing;\n    }\n  }, {\n    key: \"viewDataProvider\",\n    get: function get() {\n      return this.options.viewDataProvider;\n    }\n  }, {\n    key: \"dataAccessors\",\n    get: function get() {\n      return this.options.dataAccessors;\n    }\n  }, {\n    key: \"timeZoneCalculator\",\n    get: function get() {\n      return this.options.timeZoneCalculator;\n    }\n  }, {\n    key: \"intervalCount\",\n    get: function get() {\n      return this.options.intervalCount;\n    }\n  }, {\n    key: \"isVirtualScrolling\",\n    get: function get() {\n      return this.options.isVirtualScrolling;\n    }\n  }, {\n    key: \"_correctCollectorCoordinatesInAdaptive\",\n    value: function _correctCollectorCoordinatesInAdaptive(coordinates, isAllDay) {\n      coordinates.top = coordinates.top + this.getCollectorTopOffset(isAllDay);\n      coordinates.left = coordinates.left + this.getCollectorLeftOffset();\n    }\n  }, {\n    key: \"_initPositioningStrategy\",\n    value: function _initPositioningStrategy() {\n      this._positioningStrategy = this.isAdaptive ? new AdaptivePositioningStrategy(this) : new AppointmentPositioningStrategy(this);\n    }\n  }, {\n    key: \"getPositioningStrategy\",\n    value: function getPositioningStrategy() {\n      return this._positioningStrategy;\n    }\n  }, {\n    key: \"getAppointmentMinSize\",\n    value: function getAppointmentMinSize() {\n      return APPOINTMENT_MIN_SIZE;\n    }\n  }, {\n    key: \"keepAppointmentSettings\",\n    value: function keepAppointmentSettings() {\n      return false;\n    }\n  }, {\n    key: \"getDeltaTime\",\n    value: function getDeltaTime() {}\n  }, {\n    key: \"getAppointmentGeometry\",\n    value: function getAppointmentGeometry(coordinates) {\n      return coordinates;\n    }\n  }, {\n    key: \"needCorrectAppointmentDates\",\n    value: function needCorrectAppointmentDates() {\n      return true;\n    }\n  }, {\n    key: \"getDirection\",\n    value: function getDirection() {\n      return \"horizontal\";\n    }\n  }, {\n    key: \"createTaskPositionMap\",\n    value: function createTaskPositionMap(items) {\n      var _this = this;\n\n      delete this._maxAppointmentCountPerCell;\n      var length = null === items || void 0 === items ? void 0 : items.length;\n\n      if (!length) {\n        return;\n      }\n\n      var map = [];\n\n      for (var i = 0; i < length; i++) {\n        var coordinates = this._getItemPosition(items[i]);\n\n        if (coordinates.length && this.rtlEnabled) {\n          coordinates = this._correctRtlCoordinates(coordinates);\n        }\n\n        coordinates.forEach(function (item) {\n          item.leftVirtualCellCount = _this.leftVirtualCellCount;\n          item.topVirtualCellCount = _this.topVirtualCellCount;\n          item.leftVirtualWidth = _this.leftVirtualCellCount * _this.cellWidth;\n          item.topVirtualHeight = _this.topVirtualCellCount * _this.cellHeight;\n        });\n        map.push(coordinates);\n      }\n\n      var positionArray = this._getSortedPositions(map);\n\n      var resultPositions = this._getResultPositions(positionArray);\n\n      return this._getExtendedPositionMap(map, resultPositions);\n    }\n  }, {\n    key: \"_getDeltaWidth\",\n    value: function _getDeltaWidth(args, initialSize) {\n      var intervalWidth = this.resizableStep || this.getAppointmentMinSize();\n      var initialWidth = initialSize.width;\n      return Math.round((args.width - initialWidth) / intervalWidth);\n    }\n  }, {\n    key: \"_correctRtlCoordinates\",\n    value: function _correctRtlCoordinates(coordinates) {\n      var width = coordinates[0].width || this._getAppointmentMaxWidth();\n\n      coordinates.forEach(function (coordinate) {\n        if (!coordinate.appointmentReduced) {\n          coordinate.left -= width;\n        }\n      });\n      return coordinates;\n    }\n  }, {\n    key: \"_getAppointmentMaxWidth\",\n    value: function _getAppointmentMaxWidth() {\n      return this.cellWidth;\n    }\n  }, {\n    key: \"_getItemPosition\",\n    value: function _getItemPosition(appointment) {\n      var position = this.generateAppointmentSettings(appointment);\n      var allDay = this.isAllDay(appointment);\n      var result = [];\n\n      for (var j = 0; j < position.length; j++) {\n        var height = this.calculateAppointmentHeight(appointment, position[j]);\n        var width = this.calculateAppointmentWidth(appointment, position[j]);\n        var resultWidth = width;\n        var appointmentReduced = null;\n        var multiWeekAppointmentParts = [];\n        var initialRowIndex = position[j].rowIndex;\n        var initialColumnIndex = position[j].columnIndex;\n\n        if (this._needVerifyItemSize() || allDay) {\n          var currentMaxAllowedPosition = position[j].hMax;\n\n          if (this.isAppointmentGreaterThan(currentMaxAllowedPosition, {\n            left: position[j].left,\n            width: width\n          })) {\n            appointmentReduced = \"head\";\n            initialRowIndex = position[j].rowIndex;\n            initialColumnIndex = position[j].columnIndex;\n            resultWidth = this._reduceMultiWeekAppointment(width, {\n              left: position[j].left,\n              right: currentMaxAllowedPosition\n            });\n            multiWeekAppointmentParts = this._getAppointmentParts({\n              sourceAppointmentWidth: width,\n              reducedWidth: resultWidth,\n              height: height\n            }, position[j]);\n\n            if (this.rtlEnabled) {\n              position[j].left = currentMaxAllowedPosition;\n            }\n          }\n        }\n\n        extend(position[j], {\n          height: height,\n          width: resultWidth,\n          allDay: allDay,\n          rowIndex: initialRowIndex,\n          columnIndex: initialColumnIndex,\n          appointmentReduced: appointmentReduced\n        });\n        result = this._getAppointmentPartsPosition(multiWeekAppointmentParts, position[j], result);\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_getAppointmentPartsPosition\",\n    value: function _getAppointmentPartsPosition(appointmentParts, position, result) {\n      if (appointmentParts.length) {\n        appointmentParts.unshift(position);\n        result = result.concat(appointmentParts);\n      } else {\n        result.push(position);\n      }\n\n      return result;\n    }\n  }, {\n    key: \"getAppointmentSettingsGenerator\",\n    value: function getAppointmentSettingsGenerator(rawAppointment) {\n      return new AppointmentSettingsGenerator(_extends({\n        rawAppointment: rawAppointment,\n        appointmentTakesAllDay: this.isAppointmentTakesAllDay(rawAppointment),\n        getPositionShiftCallback: this.getPositionShift.bind(this)\n      }, this.options));\n    }\n  }, {\n    key: \"generateAppointmentSettings\",\n    value: function generateAppointmentSettings(rawAppointment) {\n      return this.getAppointmentSettingsGenerator(rawAppointment).create();\n    }\n  }, {\n    key: \"isAppointmentTakesAllDay\",\n    value: function isAppointmentTakesAllDay(rawAppointment) {\n      var adapter = createAppointmentAdapter(rawAppointment, this.dataAccessors, this.timeZoneCalculator);\n      return getAppointmentTakesAllDay(adapter, this.viewStartDayHour, this.viewEndDayHour);\n    }\n  }, {\n    key: \"_getAppointmentParts\",\n    value: function _getAppointmentParts() {\n      return [];\n    }\n  }, {\n    key: \"_getCompactAppointmentParts\",\n    value: function _getCompactAppointmentParts(appointmentWidth) {\n      var cellWidth = this.cellWidth || this.getAppointmentMinSize();\n      return Math.round(appointmentWidth / cellWidth);\n    }\n  }, {\n    key: \"_reduceMultiWeekAppointment\",\n    value: function _reduceMultiWeekAppointment(sourceAppointmentWidth, bound) {\n      if (this.rtlEnabled) {\n        sourceAppointmentWidth = Math.floor(bound.left - bound.right);\n      } else {\n        sourceAppointmentWidth = bound.right - Math.floor(bound.left);\n      }\n\n      return sourceAppointmentWidth;\n    }\n  }, {\n    key: \"calculateAppointmentHeight\",\n    value: function calculateAppointmentHeight() {\n      return 0;\n    }\n  }, {\n    key: \"calculateAppointmentWidth\",\n    value: function calculateAppointmentWidth() {\n      return 0;\n    }\n  }, {\n    key: \"isAppointmentGreaterThan\",\n    value: function isAppointmentGreaterThan(etalon, comparisonParameters) {\n      var result = comparisonParameters.left + comparisonParameters.width - etalon;\n\n      if (this.rtlEnabled) {\n        result = etalon + comparisonParameters.width - comparisonParameters.left;\n      }\n\n      return result > this.cellWidth / 2;\n    }\n  }, {\n    key: \"isAllDay\",\n    value: function isAllDay() {\n      return false;\n    }\n  }, {\n    key: \"cropAppointmentWidth\",\n    value: function cropAppointmentWidth(width, cellWidth) {\n      return this.isGroupedByDate ? cellWidth : width;\n    }\n  }, {\n    key: \"_getSortedPositions\",\n    value: function _getSortedPositions(positionList) {\n      var _this2 = this;\n\n      var result = [];\n\n      var round = function round(value) {\n        return Math.round(100 * value) / 100;\n      };\n\n      var createItem = function createItem(rowIndex, columnIndex, top, left, bottom, right, position, allDay) {\n        return {\n          i: rowIndex,\n          j: columnIndex,\n          top: round(top),\n          left: round(left),\n          bottom: round(bottom),\n          right: round(right),\n          cellPosition: position,\n          allDay: allDay\n        };\n      };\n\n      for (var rowIndex = 0, rowCount = positionList.length; rowIndex < rowCount; rowIndex++) {\n        for (var columnIndex = 0, cellCount = positionList[rowIndex].length; columnIndex < cellCount; columnIndex++) {\n          var _positionList$rowInde = positionList[rowIndex][columnIndex],\n              top = _positionList$rowInde.top,\n              left = _positionList$rowInde.left,\n              height = _positionList$rowInde.height,\n              width = _positionList$rowInde.width,\n              cellPosition = _positionList$rowInde.cellPosition,\n              allDay = _positionList$rowInde.allDay;\n          result.push(createItem(rowIndex, columnIndex, top, left, top + height, left + width, cellPosition, allDay));\n        }\n      }\n\n      return result.sort(function (a, b) {\n        return _this2._sortCondition(a, b);\n      });\n    }\n  }, {\n    key: \"_sortCondition\",\n    value: function _sortCondition() {}\n  }, {\n    key: \"_getConditions\",\n    value: function _getConditions(a, b) {\n      var isSomeEdge = this._isSomeEdge(a, b);\n\n      return {\n        columnCondition: isSomeEdge || this._normalizeCondition(a.left, b.left),\n        rowCondition: isSomeEdge || this._normalizeCondition(a.top, b.top),\n        cellPositionCondition: isSomeEdge || this._normalizeCondition(a.cellPosition, b.cellPosition)\n      };\n    }\n  }, {\n    key: \"_rowCondition\",\n    value: function _rowCondition(a, b) {\n      var conditions = this._getConditions(a, b);\n\n      return conditions.columnCondition || conditions.rowCondition;\n    }\n  }, {\n    key: \"_columnCondition\",\n    value: function _columnCondition(a, b) {\n      var conditions = this._getConditions(a, b);\n\n      return conditions.rowCondition || conditions.columnCondition;\n    }\n  }, {\n    key: \"_isSomeEdge\",\n    value: function _isSomeEdge(a, b) {\n      return a.i === b.i && a.j === b.j;\n    }\n  }, {\n    key: \"_normalizeCondition\",\n    value: function _normalizeCondition(first, second) {\n      var result = first - second;\n      return Math.abs(result) > 1 ? result : 0;\n    }\n  }, {\n    key: \"_isItemsCross\",\n    value: function _isItemsCross(firstItem, secondItem) {\n      var areItemsInTheSameTable = !!firstItem.allDay === !!secondItem.allDay;\n      var areItemsAllDay = firstItem.allDay && secondItem.allDay;\n\n      if (areItemsInTheSameTable) {\n        var orientation = this._getOrientation(areItemsAllDay);\n\n        return this._checkItemsCrossing(firstItem, secondItem, orientation);\n      } else {\n        return false;\n      }\n    }\n  }, {\n    key: \"_checkItemsCrossing\",\n    value: function _checkItemsCrossing(firstItem, secondItem, orientation) {\n      var firstItemSide_1 = Math.floor(firstItem[orientation[0]]);\n      var firstItemSide_2 = Math.floor(firstItem[orientation[1]]);\n      var secondItemSide_1 = Math.ceil(secondItem[orientation[0]]);\n      var secondItemSide_2 = Math.ceil(secondItem[orientation[1]]);\n      var isItemCross = Math.abs(firstItem[orientation[2]] - secondItem[orientation[2]]) <= 1;\n      return isItemCross && (firstItemSide_1 <= secondItemSide_1 && firstItemSide_2 > secondItemSide_1 || firstItemSide_1 < secondItemSide_2 && firstItemSide_2 >= secondItemSide_2 || firstItemSide_1 === secondItemSide_1 && firstItemSide_2 === secondItemSide_2);\n    }\n  }, {\n    key: \"_getOrientation\",\n    value: function _getOrientation(isAllDay) {\n      return isAllDay ? [\"left\", \"right\", \"top\"] : [\"top\", \"bottom\", \"left\"];\n    }\n  }, {\n    key: \"_getResultPositions\",\n    value: function _getResultPositions(sortedArray) {\n      var _this3 = this;\n\n      var result = [];\n      var i;\n      var sortedIndex = 0;\n      var currentItem;\n      var indexes;\n      var itemIndex;\n      var maxIndexInStack = 0;\n      var stack = {};\n\n      var findFreeIndex = function findFreeIndex(indexes, index) {\n        var isFind = indexes.some(function (item) {\n          return item === index;\n        });\n\n        if (isFind) {\n          return findFreeIndex(indexes, ++index);\n        } else {\n          return index;\n        }\n      };\n\n      var createItem = function createItem(currentItem, index) {\n        var currentIndex = index || 0;\n        return {\n          index: currentIndex,\n          i: currentItem.i,\n          j: currentItem.j,\n          left: currentItem.left,\n          right: currentItem.right,\n          top: currentItem.top,\n          bottom: currentItem.bottom,\n          allDay: currentItem.allDay,\n          sortedIndex: _this3._skipSortedIndex(currentIndex) ? null : sortedIndex++\n        };\n      };\n\n      var startNewStack = function startNewStack(currentItem) {\n        stack.items = [createItem(currentItem)];\n        stack.left = currentItem.left;\n        stack.right = currentItem.right;\n        stack.top = currentItem.top;\n        stack.bottom = currentItem.bottom;\n        stack.allDay = currentItem.allDay;\n      };\n\n      var pushItemsInResult = function pushItemsInResult(items) {\n        items.forEach(function (item) {\n          result.push({\n            index: item.index,\n            count: maxIndexInStack + 1,\n            i: item.i,\n            j: item.j,\n            sortedIndex: item.sortedIndex\n          });\n        });\n      };\n\n      for (i = 0; i < sortedArray.length; i++) {\n        currentItem = sortedArray[i];\n        indexes = [];\n\n        if (!stack.items) {\n          startNewStack(currentItem);\n        } else if (this._isItemsCross(stack, currentItem)) {\n          stack.items.forEach(function (item, index) {\n            if (_this3._isItemsCross(item, currentItem)) {\n              indexes.push(item.index);\n            }\n          });\n          itemIndex = indexes.length ? findFreeIndex(indexes, 0) : 0;\n          stack.items.push(createItem(currentItem, itemIndex));\n          maxIndexInStack = Math.max(itemIndex, maxIndexInStack);\n          stack.left = Math.min(stack.left, currentItem.left);\n          stack.right = Math.max(stack.right, currentItem.right);\n          stack.top = Math.min(stack.top, currentItem.top);\n          stack.bottom = Math.max(stack.bottom, currentItem.bottom);\n          stack.allDay = currentItem.allDay;\n        } else {\n          pushItemsInResult(stack.items);\n          stack = {};\n          startNewStack(currentItem);\n          maxIndexInStack = 0;\n        }\n      }\n\n      if (stack.items) {\n        pushItemsInResult(stack.items);\n      }\n\n      return result.sort(function (a, b) {\n        var columnCondition = a.j - b.j;\n        var rowCondition = a.i - b.i;\n        return rowCondition ? rowCondition : columnCondition;\n      });\n    }\n  }, {\n    key: \"_skipSortedIndex\",\n    value: function _skipSortedIndex(index) {\n      return index > this._getMaxAppointmentCountPerCell() - 1;\n    }\n  }, {\n    key: \"_findIndexByKey\",\n    value: function _findIndexByKey(arr, iKey, jKey, iValue, jValue) {\n      var result = 0;\n\n      for (var i = 0, len = arr.length; i < len; i++) {\n        if (arr[i][iKey] === iValue && arr[i][jKey] === jValue) {\n          result = i;\n          break;\n        }\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_getExtendedPositionMap\",\n    value: function _getExtendedPositionMap(map, positions) {\n      var positionCounter = 0;\n      var result = [];\n\n      for (var i = 0, mapLength = map.length; i < mapLength; i++) {\n        var resultString = [];\n\n        for (var j = 0, itemLength = map[i].length; j < itemLength; j++) {\n          map[i][j].index = positions[positionCounter].index;\n          map[i][j].sortedIndex = positions[positionCounter].sortedIndex;\n          map[i][j].count = positions[positionCounter++].count;\n          resultString.push(map[i][j]);\n\n          this._checkLongCompactAppointment(map[i][j], resultString);\n        }\n\n        result.push(resultString);\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_checkLongCompactAppointment\",\n    value: function _checkLongCompactAppointment(item, result) {\n      this._splitLongCompactAppointment(item, result);\n\n      return result;\n    }\n  }, {\n    key: \"_splitLongCompactAppointment\",\n    value: function _splitLongCompactAppointment(item, result) {\n      var appointmentCountPerCell = this._getMaxAppointmentCountPerCellByType(item.allDay);\n\n      var compactCount = 0;\n\n      if (void 0 !== appointmentCountPerCell && item.index > appointmentCountPerCell - 1) {\n        item.isCompact = true;\n        compactCount = this._getCompactAppointmentParts(item.width);\n\n        for (var k = 1; k < compactCount; k++) {\n          var compactPart = extend(true, {}, item);\n          compactPart.left = this._getCompactLeftCoordinate(item.left, k);\n          compactPart.columnIndex = compactPart.columnIndex + k;\n          compactPart.sortedIndex = null;\n          result.push(compactPart);\n        }\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_adjustDurationByDaylightDiff\",\n    value: function _adjustDurationByDaylightDiff(duration, startDate, endDate) {\n      var daylightDiff = timeZoneUtils.getDaylightOffset(startDate, endDate);\n      return this._needAdjustDuration(daylightDiff) ? this._calculateDurationByDaylightDiff(duration, daylightDiff) : duration;\n    }\n  }, {\n    key: \"_needAdjustDuration\",\n    value: function _needAdjustDuration(diff) {\n      return 0 !== diff;\n    }\n  }, {\n    key: \"_calculateDurationByDaylightDiff\",\n    value: function _calculateDurationByDaylightDiff(duration, diff) {\n      return duration + diff * toMs(\"minute\");\n    }\n  }, {\n    key: \"_getCollectorLeftOffset\",\n    value: function _getCollectorLeftOffset(isAllDay) {\n      if (isAllDay || !this.isApplyCompactAppointmentOffset()) {\n        return 0;\n      }\n\n      var dropDownButtonWidth = this.getDropDownAppointmentWidth(this.intervalCount, isAllDay);\n      var rightOffset = this._isCompactTheme() ? COMPACT_THEME_WEEK_VIEW_COLLECTOR_OFFSET : WEEK_VIEW_COLLECTOR_OFFSET;\n      return this.cellWidth - dropDownButtonWidth - rightOffset;\n    }\n  }, {\n    key: \"_markAppointmentAsVirtual\",\n    value: function _markAppointmentAsVirtual(coordinates) {\n      var isAllDay = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : false;\n\n      var countFullWidthAppointmentInCell = this._getMaxAppointmentCountPerCellByType(isAllDay);\n\n      if (coordinates.count - countFullWidthAppointmentInCell > 0) {\n        var top = coordinates.top,\n            left = coordinates.left;\n        var compactRender = this.isAdaptive || !isAllDay && this.supportCompactDropDownAppointments();\n        coordinates.virtual = {\n          left: left + this._getCollectorLeftOffset(isAllDay),\n          top: top,\n          width: this.getDropDownAppointmentWidth(this.intervalCount, isAllDay),\n          height: this.getDropDownAppointmentHeight(),\n          index: this._generateAppointmentCollectorIndex(coordinates, isAllDay),\n          isAllDay: isAllDay,\n          isCompact: compactRender\n        };\n      }\n    }\n  }, {\n    key: \"isApplyCompactAppointmentOffset\",\n    value: function isApplyCompactAppointmentOffset() {\n      return this.supportCompactDropDownAppointments();\n    }\n  }, {\n    key: \"supportCompactDropDownAppointments\",\n    value: function supportCompactDropDownAppointments() {\n      return true;\n    }\n  }, {\n    key: \"_generateAppointmentCollectorIndex\",\n    value: function _generateAppointmentCollectorIndex(_ref, isAllDay) {\n      var groupIndex = _ref.groupIndex,\n          rowIndex = _ref.rowIndex,\n          columnIndex = _ref.columnIndex;\n      return \"\".concat(groupIndex, \"-\").concat(rowIndex, \"-\").concat(columnIndex, \"-\").concat(isAllDay);\n    }\n  }, {\n    key: \"_getMaxAppointmentCountPerCellByType\",\n    value: function _getMaxAppointmentCountPerCellByType(isAllDay) {\n      var appointmentCountPerCell = this._getMaxAppointmentCountPerCell();\n\n      if (isObject(appointmentCountPerCell)) {\n        return isAllDay ? appointmentCountPerCell.allDay : appointmentCountPerCell.simple;\n      } else {\n        return appointmentCountPerCell;\n      }\n    }\n  }, {\n    key: \"getDropDownAppointmentWidth\",\n    value: function getDropDownAppointmentWidth(intervalCount, isAllDay) {\n      return this.getPositioningStrategy().getDropDownAppointmentWidth(intervalCount, isAllDay);\n    }\n  }, {\n    key: \"getDropDownAppointmentHeight\",\n    value: function getDropDownAppointmentHeight() {\n      return this.getPositioningStrategy().getDropDownAppointmentHeight();\n    }\n  }, {\n    key: \"getDropDownButtonAdaptiveSize\",\n    value: function getDropDownButtonAdaptiveSize() {\n      return DROP_DOWN_BUTTON_ADAPTIVE_SIZE;\n    }\n  }, {\n    key: \"getCollectorTopOffset\",\n    value: function getCollectorTopOffset(allDay) {\n      return this.getPositioningStrategy().getCollectorTopOffset(allDay);\n    }\n  }, {\n    key: \"getCollectorLeftOffset\",\n    value: function getCollectorLeftOffset() {\n      return this.getPositioningStrategy().getCollectorLeftOffset();\n    }\n  }, {\n    key: \"getAppointmentDataCalculator\",\n    value: function getAppointmentDataCalculator() {}\n  }, {\n    key: \"_customizeCoordinates\",\n    value: function _customizeCoordinates(coordinates, height, appointmentCountPerCell, topOffset, isAllDay) {\n      var index = coordinates.index;\n      var appointmentHeight = height / appointmentCountPerCell;\n      var appointmentTop = coordinates.top + index * appointmentHeight;\n      var top = appointmentTop + topOffset;\n      var width = coordinates.width;\n      var left = coordinates.left;\n\n      if (coordinates.isCompact) {\n        this.isAdaptive && this._correctCollectorCoordinatesInAdaptive(coordinates, isAllDay);\n\n        this._markAppointmentAsVirtual(coordinates, isAllDay);\n      }\n\n      return {\n        height: appointmentHeight,\n        width: width,\n        top: top,\n        left: left,\n        empty: this._isAppointmentEmpty(height, width)\n      };\n    }\n  }, {\n    key: \"_isAppointmentEmpty\",\n    value: function _isAppointmentEmpty(height, width) {\n      return height < this._getAppointmentMinHeight() || width < this._getAppointmentMinWidth();\n    }\n  }, {\n    key: \"_calculateGeometryConfig\",\n    value: function _calculateGeometryConfig(coordinates) {\n      var overlappingMode = this.maxAppointmentsPerCell;\n\n      var offsets = this._getOffsets();\n\n      var appointmentDefaultOffset = this._getAppointmentDefaultOffset();\n\n      var appointmentCountPerCell = this._getAppointmentCount(overlappingMode, coordinates);\n\n      var ratio = this._getDefaultRatio(coordinates, appointmentCountPerCell);\n\n      var maxHeight = this._getMaxHeight();\n\n      if (!isNumeric(appointmentCountPerCell)) {\n        appointmentCountPerCell = coordinates.count;\n        ratio = (maxHeight - offsets.unlimited) / maxHeight;\n      }\n\n      var topOffset = (1 - ratio) * maxHeight;\n\n      if (\"auto\" === overlappingMode || isNumeric(overlappingMode)) {\n        ratio = 1;\n        maxHeight -= appointmentDefaultOffset;\n        topOffset = appointmentDefaultOffset;\n      }\n\n      return {\n        height: ratio * maxHeight,\n        appointmentCountPerCell: appointmentCountPerCell,\n        offset: topOffset\n      };\n    }\n  }, {\n    key: \"_getAppointmentCount\",\n    value: function _getAppointmentCount() {}\n  }, {\n    key: \"_getDefaultRatio\",\n    value: function _getDefaultRatio() {}\n  }, {\n    key: \"_getOffsets\",\n    value: function _getOffsets() {}\n  }, {\n    key: \"_getMaxHeight\",\n    value: function _getMaxHeight() {}\n  }, {\n    key: \"_needVerifyItemSize\",\n    value: function _needVerifyItemSize() {\n      return false;\n    }\n  }, {\n    key: \"_getMaxAppointmentCountPerCell\",\n    value: function _getMaxAppointmentCountPerCell() {\n      if (!this._maxAppointmentCountPerCell) {\n        var overlappingMode = this.maxAppointmentsPerCell;\n        var appointmentCountPerCell;\n\n        if (isNumeric(overlappingMode)) {\n          appointmentCountPerCell = overlappingMode;\n        }\n\n        if (\"auto\" === overlappingMode) {\n          appointmentCountPerCell = this._getDynamicAppointmentCountPerCell();\n        }\n\n        if (\"unlimited\" === overlappingMode) {\n          appointmentCountPerCell = void 0;\n        }\n\n        this._maxAppointmentCountPerCell = appointmentCountPerCell;\n      }\n\n      return this._maxAppointmentCountPerCell;\n    }\n  }, {\n    key: \"_getDynamicAppointmentCountPerCell\",\n    value: function _getDynamicAppointmentCountPerCell() {\n      return this.getPositioningStrategy().getDynamicAppointmentCountPerCell();\n    }\n  }, {\n    key: \"allDaySupported\",\n    value: function allDaySupported() {\n      return false;\n    }\n  }, {\n    key: \"_isCompactTheme\",\n    value: function _isCompactTheme() {\n      return \"compact\" === (currentTheme() || \"\").split(\".\").pop();\n    }\n  }, {\n    key: \"_getAppointmentDefaultOffset\",\n    value: function _getAppointmentDefaultOffset() {\n      return this.getPositioningStrategy().getAppointmentDefaultOffset();\n    }\n  }, {\n    key: \"_getAppointmentDefaultHeight\",\n    value: function _getAppointmentDefaultHeight() {\n      return this._getAppointmentHeightByTheme();\n    }\n  }, {\n    key: \"_getAppointmentMinHeight\",\n    value: function _getAppointmentMinHeight() {\n      return this._getAppointmentDefaultHeight();\n    }\n  }, {\n    key: \"_getAppointmentHeightByTheme\",\n    value: function _getAppointmentHeightByTheme() {\n      return this._isCompactTheme() ? COMPACT_THEME_APPOINTMENT_DEFAULT_HEIGHT : APPOINTMENT_DEFAULT_HEIGHT;\n    }\n  }, {\n    key: \"_getAppointmentDefaultWidth\",\n    value: function _getAppointmentDefaultWidth() {\n      return this.getPositioningStrategy()._getAppointmentDefaultWidth();\n    }\n  }, {\n    key: \"_getAppointmentMinWidth\",\n    value: function _getAppointmentMinWidth() {\n      return this._getAppointmentDefaultWidth();\n    }\n  }, {\n    key: \"_needVerticalGroupBounds\",\n    value: function _needVerticalGroupBounds() {\n      return false;\n    }\n  }, {\n    key: \"_needHorizontalGroupBounds\",\n    value: function _needHorizontalGroupBounds() {\n      return false;\n    }\n  }, {\n    key: \"getAppointmentDurationInMs\",\n    value: function getAppointmentDurationInMs(startDate, endDate, allDay) {\n      var appointmentDuration = endDate.getTime() - startDate.getTime();\n      var dayDuration = toMs(\"day\");\n      var visibleDayDuration = this.visibleDayDuration;\n      var result = 0;\n\n      if (allDay) {\n        var ceilQuantityOfDays = Math.ceil(appointmentDuration / dayDuration);\n        result = ceilQuantityOfDays * visibleDayDuration;\n      } else {\n        var isDifferentDates = !timeZoneUtils.isSameAppointmentDates(startDate, endDate);\n        var floorQuantityOfDays = Math.floor(appointmentDuration / dayDuration);\n        var tailDuration;\n\n        if (isDifferentDates) {\n          var startDateEndHour = new Date(new Date(startDate).setHours(this.endDayHour, 0, 0));\n          var hiddenDayDuration = dayDuration - visibleDayDuration - (startDate.getTime() > startDateEndHour.getTime() ? startDate.getTime() - startDateEndHour.getTime() : 0);\n          tailDuration = appointmentDuration - (floorQuantityOfDays ? floorQuantityOfDays * dayDuration : hiddenDayDuration);\n          var startDayTime = this.startDayHour * toMs(\"hour\");\n          var endPartDuration = endDate - dateUtils.trimTime(endDate);\n\n          if (endPartDuration < startDayTime) {\n            if (floorQuantityOfDays) {\n              tailDuration -= hiddenDayDuration;\n            }\n\n            tailDuration += startDayTime - endPartDuration;\n          }\n        } else {\n          tailDuration = appointmentDuration % dayDuration;\n        }\n\n        if (tailDuration > visibleDayDuration) {\n          tailDuration = visibleDayDuration;\n        }\n\n        result = floorQuantityOfDays * visibleDayDuration + tailDuration || toMs(\"minute\");\n      }\n\n      return result;\n    }\n  }, {\n    key: \"getPositionShift\",\n    value: function getPositionShift(timeShift, isAllDay) {\n      return {\n        top: timeShift * this.cellHeight,\n        left: 0,\n        cellPosition: 0\n      };\n    }\n  }]);\n\n  return BaseRenderingStrategy;\n}();\n\nexport default BaseRenderingStrategy;","map":null,"metadata":{},"sourceType":"module"}