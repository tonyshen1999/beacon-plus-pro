{"ast":null,"code":"/**\r\n * DevExtreme (esm/core/utils/common.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport config from \"../config\";\nimport Guid from \"../guid\";\nimport { when, Deferred } from \"../utils/deferred\";\nimport { toComparable } from \"./data\";\nimport { each } from \"./iterator\";\nimport { isDefined, isFunction, isString, isObject, type } from \"./type\";\nexport var ensureDefined = function ensureDefined(value, defaultValue) {\n  return isDefined(value) ? value : defaultValue;\n};\nexport var executeAsync = function executeAsync(action, context) {\n  var deferred = new Deferred();\n  var normalizedContext = context || this;\n  var task = {\n    promise: deferred.promise(),\n    abort: function abort() {\n      clearTimeout(timerId);\n      deferred.rejectWith(normalizedContext);\n    }\n  };\n\n  var callback = function callback() {\n    var result = action.call(normalizedContext);\n\n    if (result && result.done && isFunction(result.done)) {\n      result.done(function () {\n        deferred.resolveWith(normalizedContext);\n      });\n    } else {\n      deferred.resolveWith(normalizedContext);\n    }\n  };\n\n  var timerId = (arguments[2] || setTimeout)(callback, \"number\" === typeof context ? context : 0);\n  return task;\n};\nvar delayedFuncs = [];\nvar delayedNames = [];\nvar delayedDeferreds = [];\nvar executingName;\n\nvar deferExecute = function deferExecute(name, func, deferred) {\n  if (executingName && executingName !== name) {\n    delayedFuncs.push(func);\n    delayedNames.push(name);\n    deferred = deferred || new Deferred();\n    delayedDeferreds.push(deferred);\n    return deferred;\n  } else {\n    var oldExecutingName = executingName;\n    var currentDelayedCount = delayedDeferreds.length;\n    executingName = name;\n    var result = func();\n\n    if (!result) {\n      if (delayedDeferreds.length > currentDelayedCount) {\n        result = when.apply(this, delayedDeferreds.slice(currentDelayedCount));\n      } else if (deferred) {\n        deferred.resolve();\n      }\n    }\n\n    executingName = oldExecutingName;\n\n    if (deferred && result && result.done) {\n      result.done(deferred.resolve).fail(deferred.reject);\n    }\n\n    if (!executingName && delayedFuncs.length) {\n      (\"render\" === delayedNames.shift() ? deferRender : deferUpdate)(delayedFuncs.shift(), delayedDeferreds.shift());\n    }\n\n    return result || when();\n  }\n};\n\nexport var deferRender = function deferRender(func, deferred) {\n  return deferExecute(\"render\", func, deferred);\n};\nexport var deferUpdate = function deferUpdate(func, deferred) {\n  return deferExecute(\"update\", func, deferred);\n};\nexport var deferRenderer = function deferRenderer(func) {\n  return function () {\n    var that = this;\n    return deferExecute(\"render\", function () {\n      return func.call(that);\n    });\n  };\n};\nexport var deferUpdater = function deferUpdater(func) {\n  return function () {\n    var that = this;\n    return deferExecute(\"update\", function () {\n      return func.call(that);\n    });\n  };\n};\nexport var findBestMatches = function findBestMatches(targetFilter, items, mapFn) {\n  var bestMatches = [];\n  var maxMatchCount = 0;\n  each(items, function (index, itemSrc) {\n    var matchCount = 0;\n    var item = mapFn ? mapFn(itemSrc) : itemSrc;\n    each(targetFilter, function (paramName, targetValue) {\n      var value = item[paramName];\n\n      if (void 0 === value) {\n        return;\n      }\n\n      if (match(value, targetValue)) {\n        matchCount++;\n        return;\n      }\n\n      matchCount = -1;\n      return false;\n    });\n\n    if (matchCount < maxMatchCount) {\n      return;\n    }\n\n    if (matchCount > maxMatchCount) {\n      bestMatches.length = 0;\n      maxMatchCount = matchCount;\n    }\n\n    bestMatches.push(itemSrc);\n  });\n  return bestMatches;\n};\n\nvar match = function match(value, targetValue) {\n  if (Array.isArray(value) && Array.isArray(targetValue)) {\n    var mismatch = false;\n    each(value, function (index, valueItem) {\n      if (valueItem !== targetValue[index]) {\n        mismatch = true;\n        return false;\n      }\n    });\n\n    if (mismatch) {\n      return false;\n    }\n\n    return true;\n  }\n\n  if (value === targetValue) {\n    return true;\n  }\n\n  return false;\n};\n\nexport var splitPair = function splitPair(raw) {\n  var _raw$x, _raw$y;\n\n  switch (type(raw)) {\n    case \"string\":\n      return raw.split(/\\s+/, 2);\n\n    case \"object\":\n      return [null !== (_raw$x = raw.x) && void 0 !== _raw$x ? _raw$x : raw.h, null !== (_raw$y = raw.y) && void 0 !== _raw$y ? _raw$y : raw.v];\n\n    case \"number\":\n      return [raw];\n\n    case \"array\":\n      return raw;\n\n    default:\n      return null;\n  }\n};\nexport var normalizeKey = function normalizeKey(id) {\n  var key = isString(id) ? id : id.toString();\n  var arr = key.match(/[^a-zA-Z0-9_]/g);\n  arr && each(arr, function (_, sign) {\n    key = key.replace(sign, \"__\" + sign.charCodeAt() + \"__\");\n  });\n  return key;\n};\nexport var denormalizeKey = function denormalizeKey(key) {\n  var arr = key.match(/__\\d+__/g);\n  arr && arr.forEach(function (char) {\n    var charCode = parseInt(char.replace(\"__\", \"\"));\n    key = key.replace(char, String.fromCharCode(charCode));\n  });\n  return key;\n};\nexport var pairToObject = function pairToObject(raw, preventRound) {\n  var pair = splitPair(raw);\n  var h = preventRound ? parseFloat(pair && pair[0]) : parseInt(pair && pair[0], 10);\n  var v = preventRound ? parseFloat(pair && pair[1]) : parseInt(pair && pair[1], 10);\n\n  if (!isFinite(h)) {\n    h = 0;\n  }\n\n  if (!isFinite(v)) {\n    v = h;\n  }\n\n  return {\n    h: h,\n    v: v\n  };\n};\nexport var getKeyHash = function getKeyHash(key) {\n  if (key instanceof Guid) {\n    return key.toString();\n  } else if (isObject(key) || Array.isArray(key)) {\n    try {\n      var keyHash = JSON.stringify(key);\n      return \"{}\" === keyHash ? key : keyHash;\n    } catch (e) {\n      return key;\n    }\n  }\n\n  return key;\n};\nexport var escapeRegExp = function escapeRegExp(string) {\n  return string.replace(/[[\\]{}\\-()*+?.\\\\^$|\\s]/g, \"\\\\$&\");\n};\nexport var applyServerDecimalSeparator = function applyServerDecimalSeparator(value) {\n  var separator = config().serverDecimalSeparator;\n\n  if (isDefined(value)) {\n    value = value.toString().replace(\".\", separator);\n  }\n\n  return value;\n};\nexport var noop = function noop() {};\nexport var asyncNoop = function asyncNoop() {\n  return new Deferred().resolve().promise();\n};\nexport var grep = function grep(elements, checkFunction, invert) {\n  var result = [];\n  var check;\n  var expectedCheck = !invert;\n\n  for (var i = 0; i < elements.length; i++) {\n    check = !!checkFunction(elements[i], i);\n\n    if (check === expectedCheck) {\n      result.push(elements[i]);\n    }\n  }\n\n  return result;\n};\n\nvar arraysEqualByValue = function arraysEqualByValue(array1, array2, depth) {\n  if (array1.length !== array2.length) {\n    return false;\n  }\n\n  for (var i = 0; i < array1.length; i++) {\n    if (!equalByValue(array1[i], array2[i], depth + 1)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nvar objectsEqualByValue = function objectsEqualByValue(object1, object2, depth, strict) {\n  for (var propertyName in object1) {\n    if (Object.prototype.hasOwnProperty.call(object1, propertyName) && !equalByValue(object1[propertyName], object2[propertyName], depth + 1, strict)) {\n      return false;\n    }\n  }\n\n  for (var _propertyName in object2) {\n    if (!(_propertyName in object1)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nvar maxEqualityDepth = 3;\nexport var equalByValue = function equalByValue(object1, object2) {\n  var depth = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;\n  var strict = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : true;\n  object1 = toComparable(object1, true);\n  object2 = toComparable(object2, true);\n  var comparisonResult = strict ? object1 === object2 : object1 == object2;\n\n  if (comparisonResult || depth >= maxEqualityDepth) {\n    return true;\n  }\n\n  if (isObject(object1) && isObject(object2)) {\n    return objectsEqualByValue(object1, object2, depth, strict);\n  } else if (Array.isArray(object1) && Array.isArray(object2)) {\n    return arraysEqualByValue(object1, object2, depth);\n  }\n\n  return false;\n};","map":null,"metadata":{},"sourceType":"module"}