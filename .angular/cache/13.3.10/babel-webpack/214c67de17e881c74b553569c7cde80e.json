{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/tree_list/ui.tree_list.data_source_adapter.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport treeListCore from \"./ui.tree_list.core\";\nimport errors from \"../widget/ui.errors\";\nimport { equalByValue } from \"../../core/utils/common\";\nimport { isFunction, isDefined } from \"../../core/utils/type\";\nimport { each } from \"../../core/utils/iterator\";\nimport { compileGetter, compileSetter } from \"../../core/utils/data\";\nimport { extend } from \"../../core/utils/extend\";\nimport gridCoreUtils from \"../grid_core/ui.grid_core.utils\";\nimport { createObjectWithChanges } from \"../../data/array_utils\";\nimport ArrayStore from \"../../data/array_store\";\nimport query from \"../../data/query\";\nimport DataSourceAdapter from \"../grid_core/ui.grid_core.data_source_adapter\";\nimport { Deferred, when } from \"../../core/utils/deferred\";\nimport storeHelper from \"../../data/store_helper\";\nvar queryByOptions = storeHelper.queryByOptions;\nvar DEFAULT_KEY_EXPRESSION = \"id\";\n\nvar isFullBranchFilterMode = function isFullBranchFilterMode(that) {\n  return \"fullBranch\" === that.option(\"filterMode\");\n};\n\nvar DataSourceAdapterTreeList = DataSourceAdapter.inherit({\n  _createKeyGetter: function _createKeyGetter() {\n    var keyExpr = this.getKeyExpr();\n    return compileGetter(keyExpr);\n  },\n  _createKeySetter: function _createKeySetter() {\n    var keyExpr = this.getKeyExpr();\n\n    if (isFunction(keyExpr)) {\n      return keyExpr;\n    }\n\n    return compileSetter(keyExpr);\n  },\n  createParentIdGetter: function createParentIdGetter() {\n    return compileGetter(this.option(\"parentIdExpr\"));\n  },\n  createParentIdSetter: function createParentIdSetter() {\n    var parentIdExpr = this.option(\"parentIdExpr\");\n\n    if (isFunction(parentIdExpr)) {\n      return parentIdExpr;\n    }\n\n    return compileSetter(parentIdExpr);\n  },\n  _createItemsGetter: function _createItemsGetter() {\n    return compileGetter(this.option(\"itemsExpr\"));\n  },\n  _createHasItemsGetter: function _createHasItemsGetter() {\n    var hasItemsExpr = this.option(\"hasItemsExpr\");\n    return hasItemsExpr && compileGetter(hasItemsExpr);\n  },\n  _createHasItemsSetter: function _createHasItemsSetter() {\n    var hasItemsExpr = this.option(\"hasItemsExpr\");\n\n    if (isFunction(hasItemsExpr)) {\n      return hasItemsExpr;\n    }\n\n    return hasItemsExpr && compileSetter(hasItemsExpr);\n  },\n  _updateIndexByKeyObject: function _updateIndexByKeyObject(items) {\n    var that = this;\n    that._indexByKey = {};\n    each(items, function (index, item) {\n      that._indexByKey[item.key] = index;\n    });\n  },\n  _calculateHasItems: function _calculateHasItems(node, options) {\n    var parentIds = options.storeLoadOptions.parentIds;\n    var hasItems;\n    var isFullBranch = isFullBranchFilterMode(this);\n\n    if (this._hasItemsGetter && (parentIds || !options.storeLoadOptions.filter || isFullBranch)) {\n      hasItems = this._hasItemsGetter(node.data);\n    }\n\n    if (void 0 === hasItems) {\n      if (!this._isChildrenLoaded[node.key] && options.remoteOperations.filtering && (parentIds || isFullBranch)) {\n        hasItems = true;\n      } else if (options.loadOptions.filter && !options.remoteOperations.filtering && isFullBranch) {\n        hasItems = node.children.length;\n      } else {\n        hasItems = node.hasChildren;\n      }\n    }\n\n    return !!hasItems;\n  },\n  _fillVisibleItemsByNodes: function _fillVisibleItemsByNodes(nodes, options, result) {\n    for (var i = 0; i < nodes.length; i++) {\n      if (nodes[i].visible) {\n        result.push(nodes[i]);\n      }\n\n      if ((this.isRowExpanded(nodes[i].key, options) || !nodes[i].visible) && nodes[i].hasChildren && nodes[i].children.length) {\n        this._fillVisibleItemsByNodes(nodes[i].children, options, result);\n      }\n    }\n  },\n  _convertItemToNode: function _convertItemToNode(item, rootValue, nodeByKey) {\n    var key = this._keyGetter(item);\n\n    var parentId = this._parentIdGetter(item);\n\n    parentId = isDefined(parentId) ? parentId : rootValue;\n    var parentNode = nodeByKey[parentId] = nodeByKey[parentId] || {\n      key: parentId,\n      children: []\n    };\n    var node = nodeByKey[key] = nodeByKey[key] || {\n      key: key,\n      children: []\n    };\n    node.data = item;\n    node.parent = parentNode;\n    return node;\n  },\n  _createNodesByItems: function _createNodesByItems(items, visibleItems) {\n    var rootValue = this.option(\"rootValue\");\n    var visibleByKey = {};\n    var nodeByKey = this._nodeByKey = {};\n    var i;\n\n    if (visibleItems) {\n      for (i = 0; i < visibleItems.length; i++) {\n        visibleByKey[this._keyGetter(visibleItems[i])] = true;\n      }\n    }\n\n    for (i = 0; i < items.length; i++) {\n      var node = this._convertItemToNode(items[i], rootValue, nodeByKey);\n\n      if (void 0 === node.key) {\n        return;\n      }\n\n      node.visible = !visibleItems || !!visibleByKey[node.key];\n\n      if (node.parent) {\n        node.parent.children.push(node);\n      }\n    }\n\n    var rootNode = nodeByKey[rootValue] || {\n      key: rootValue,\n      children: []\n    };\n    rootNode.level = -1;\n    return rootNode;\n  },\n  _convertDataToPlainStructure: function _convertDataToPlainStructure(data, parentId, result) {\n    var key;\n\n    if (this._itemsGetter && !data.isConverted) {\n      result = result || [];\n\n      for (var i = 0; i < data.length; i++) {\n        var item = createObjectWithChanges(data[i]);\n        key = this._keyGetter(item);\n\n        if (void 0 === key) {\n          key = result.length + 1;\n\n          this._keySetter(item, key);\n        }\n\n        this._parentIdSetter(item, void 0 === parentId ? this.option(\"rootValue\") : parentId);\n\n        result.push(item);\n\n        var childItems = this._itemsGetter(item);\n\n        if (childItems && childItems.length) {\n          this._convertDataToPlainStructure(childItems, key, result);\n\n          var itemsExpr = this.option(\"itemsExpr\");\n\n          if (!isFunction(itemsExpr)) {\n            delete item[itemsExpr];\n          }\n        }\n      }\n\n      result.isConverted = true;\n      return result;\n    }\n\n    return data;\n  },\n  _createIdFilter: function _createIdFilter(field, keys) {\n    var parentIdFilters = [];\n\n    for (var i = 0; i < keys.length; i++) {\n      parentIdFilters.push([field, \"=\", keys[i]]);\n    }\n\n    return gridCoreUtils.combineFilters(parentIdFilters, \"or\");\n  },\n  _customizeRemoteOperations: function _customizeRemoteOperations(options, operationTypes) {\n    this.callBase.apply(this, arguments);\n    options.remoteOperations.paging = false;\n    var expandVisibleNodes = false;\n\n    if (this.option(\"autoExpandAll\")) {\n      options.remoteOperations.sorting = false;\n      options.remoteOperations.filtering = false;\n\n      if ((!this._lastLoadOptions || operationTypes.filtering && !options.storeLoadOptions.filter) && !options.isCustomLoading) {\n        expandVisibleNodes = true;\n      }\n    }\n\n    if (!options.isCustomLoading) {\n      this._isReload = this._isReload || operationTypes.reload;\n\n      if (!options.cachedStoreData) {\n        this._isChildrenLoaded = {};\n\n        if (this._isReload) {\n          this._nodeByKey = {};\n        }\n      }\n\n      if (this.option(\"expandNodesOnFiltering\") && (operationTypes.filtering || this._isReload && options.storeLoadOptions.filter)) {\n        if (options.storeLoadOptions.filter) {\n          expandVisibleNodes = true;\n        } else {\n          options.collapseVisibleNodes = true;\n        }\n      }\n    }\n\n    options.expandVisibleNodes = expandVisibleNodes;\n  },\n  _getParentIdsToLoad: function _getParentIdsToLoad(parentIds) {\n    var parentIdsToLoad = [];\n\n    for (var i = 0; i < parentIds.length; i++) {\n      var node = this.getNodeByKey(parentIds[i]);\n\n      if (!node || node.hasChildren && !node.children.length) {\n        parentIdsToLoad.push(parentIds[i]);\n      }\n    }\n\n    return parentIdsToLoad;\n  },\n  _handleCustomizeStoreLoadOptions: function _handleCustomizeStoreLoadOptions(options) {\n    var rootValue = this.option(\"rootValue\");\n    var parentIdExpr = this.option(\"parentIdExpr\");\n    var parentIds = options.storeLoadOptions.parentIds;\n\n    if (parentIds) {\n      options.isCustomLoading = false;\n    }\n\n    this.callBase.apply(this, arguments);\n\n    if (options.remoteOperations.filtering && !options.isCustomLoading) {\n      if (isFullBranchFilterMode(this) && options.cachedStoreData || !options.storeLoadOptions.filter) {\n        var expandedRowKeys = options.collapseVisibleNodes ? [] : this.option(\"expandedRowKeys\");\n        parentIds = [rootValue].concat(expandedRowKeys).concat(parentIds || []);\n        var parentIdsToLoad = options.data ? this._getParentIdsToLoad(parentIds) : parentIds;\n\n        if (parentIdsToLoad.length) {\n          options.cachedPagingData = void 0;\n          options.data = void 0;\n          options.mergeStoreLoadData = true;\n          options.delay = this.option(\"loadingTimeout\");\n        }\n\n        options.storeLoadOptions.parentIds = parentIdsToLoad;\n        options.storeLoadOptions.filter = this._createIdFilter(parentIdExpr, parentIdsToLoad);\n      }\n    }\n  },\n  _generateInfoToLoad: function _generateInfoToLoad(data, needChildren) {\n    var key;\n    var keyMap = {};\n    var resultKeyMap = {};\n    var resultKeys = [];\n    var rootValue = this.option(\"rootValue\");\n    var i;\n\n    for (i = 0; i < data.length; i++) {\n      key = needChildren ? this._parentIdGetter(data[i]) : this._keyGetter(data[i]);\n      keyMap[key] = true;\n    }\n\n    for (i = 0; i < data.length; i++) {\n      key = needChildren ? this._keyGetter(data[i]) : this._parentIdGetter(data[i]);\n      var needToLoad = needChildren ? this.isRowExpanded(key) : key !== rootValue;\n\n      if (!keyMap[key] && !resultKeyMap[key] && needToLoad) {\n        resultKeyMap[key] = true;\n        resultKeys.push(key);\n      }\n    }\n\n    return {\n      keyMap: resultKeyMap,\n      keys: resultKeys\n    };\n  },\n  _loadParentsOrChildren: function _loadParentsOrChildren(data, options, needChildren) {\n    var _this = this;\n\n    var that = this;\n    var filter;\n    var needLocalFiltering;\n\n    var _that$_generateInfoTo = that._generateInfoToLoad(data, needChildren),\n        keys = _that$_generateInfoTo.keys,\n        keyMap = _that$_generateInfoTo.keyMap;\n\n    var d = new Deferred();\n    var isRemoteFiltering = options.remoteOperations.filtering;\n    var maxFilterLengthInRequest = that.option(\"maxFilterLengthInRequest\");\n    var loadOptions = isRemoteFiltering ? options.storeLoadOptions : options.loadOptions;\n\n    function concatLoadedData(loadedData) {\n      if (isRemoteFiltering) {\n        that._cachedStoreData = that._cachedStoreData.concat(loadedData);\n      }\n\n      return data.concat(loadedData);\n    }\n\n    if (!keys.length) {\n      return d.resolve(data);\n    }\n\n    var cachedNodes = keys.map(function (id) {\n      return _this.getNodeByKey(id);\n    }).filter(function (node) {\n      return node && node.data;\n    });\n\n    if (cachedNodes.length === keys.length) {\n      if (needChildren) {\n        cachedNodes = cachedNodes.reduce(function (result, node) {\n          return result.concat(node.children);\n        }, []);\n      }\n\n      if (cachedNodes.length) {\n        return that._loadParentsOrChildren(concatLoadedData(cachedNodes.map(function (node) {\n          return node.data;\n        })), options, needChildren);\n      }\n    }\n\n    var keyExpr = needChildren ? that.option(\"parentIdExpr\") : that.getKeyExpr();\n    filter = that._createIdFilter(keyExpr, keys);\n    var filterLength = encodeURI(JSON.stringify(filter)).length;\n\n    if (filterLength > maxFilterLengthInRequest) {\n      filter = function filter(itemData) {\n        return keyMap[that._keyGetter(itemData)];\n      };\n\n      needLocalFiltering = isRemoteFiltering;\n    }\n\n    loadOptions = extend({}, loadOptions, {\n      filter: !needLocalFiltering ? filter : null\n    });\n    var store = options.fullData ? new ArrayStore(options.fullData) : that._dataSource.store();\n    that.loadFromStore(loadOptions, store).done(function (loadedData) {\n      if (loadedData.length) {\n        if (needLocalFiltering) {\n          loadedData = query(loadedData).filter(filter).toArray();\n        }\n\n        that._loadParentsOrChildren(concatLoadedData(loadedData), options, needChildren).done(d.resolve).fail(d.reject);\n      } else {\n        d.resolve(data);\n      }\n    }).fail(d.reject);\n    return d;\n  },\n  _loadParents: function _loadParents(data, options) {\n    return this._loadParentsOrChildren(data, options);\n  },\n  _loadChildrenIfNeed: function _loadChildrenIfNeed(data, options) {\n    if (isFullBranchFilterMode(this)) {\n      return this._loadParentsOrChildren(data, options, true);\n    }\n\n    return when(data);\n  },\n  _updateHasItemsMap: function _updateHasItemsMap(options) {\n    var parentIds = options.storeLoadOptions.parentIds;\n\n    if (parentIds) {\n      for (var i = 0; i < parentIds.length; i++) {\n        this._isChildrenLoaded[parentIds[i]] = true;\n      }\n    }\n  },\n  _getKeyInfo: function _getKeyInfo() {\n    return {\n      key: function key() {\n        return \"key\";\n      },\n      keyOf: function keyOf(data) {\n        return data.key;\n      }\n    };\n  },\n  _applyBatch: function _applyBatch(changes) {\n    var _this2 = this;\n\n    var baseChanges = [];\n    changes.forEach(function (change) {\n      if (\"insert\" === change.type) {\n        baseChanges = baseChanges.concat(_this2._applyInsert(change));\n      } else if (\"remove\" === change.type) {\n        baseChanges = baseChanges.concat(_this2._applyRemove(change));\n      } else if (\"update\" === change.type) {\n        baseChanges.push({\n          type: change.type,\n          key: change.key,\n          data: {\n            data: change.data\n          }\n        });\n      }\n    });\n    this.callBase(baseChanges);\n  },\n  _setHasItems: function _setHasItems(node, value) {\n    var hasItemsSetter = this._hasItemsSetter;\n    node.hasChildren = value;\n\n    if (hasItemsSetter && node.data) {\n      hasItemsSetter(node.data, value);\n    }\n  },\n  _applyInsert: function _applyInsert(change) {\n    var baseChanges = [];\n    var parentId = this.parentKeyOf(change.data);\n    var parentNode = this.getNodeByKey(parentId);\n\n    if (parentNode) {\n      var rootValue = this.option(\"rootValue\");\n\n      var node = this._convertItemToNode(change.data, rootValue, this._nodeByKey);\n\n      node.hasChildren = false;\n      node.level = parentNode.level + 1;\n      node.visible = true;\n      parentNode.children.push(node);\n      this._isChildrenLoaded[node.key] = true;\n\n      this._setHasItems(parentNode, true);\n\n      if ((!parentNode.parent || this.isRowExpanded(parentNode.key)) && void 0 !== change.index) {\n        var index = this.items().indexOf(parentNode) + 1;\n        index += change.index >= 0 ? Math.min(change.index, parentNode.children.length) : parentNode.children.length;\n        baseChanges.push({\n          type: change.type,\n          data: node,\n          index: index\n        });\n      }\n    }\n\n    return baseChanges;\n  },\n  _applyRemove: function _applyRemove(change) {\n    var baseChanges = [];\n    var node = this.getNodeByKey(change.key);\n    var parentNode = node && node.parent;\n\n    if (parentNode) {\n      var index = parentNode.children.indexOf(node);\n\n      if (index >= 0) {\n        parentNode.children.splice(index, 1);\n\n        if (!parentNode.children.length) {\n          this._setHasItems(parentNode, false);\n        }\n\n        baseChanges.push(change);\n        baseChanges = baseChanges.concat(this.getChildNodeKeys(change.key).map(function (key) {\n          return {\n            type: change.type,\n            key: key\n          };\n        }));\n      }\n    }\n\n    return baseChanges;\n  },\n  _handleDataLoaded: function _handleDataLoaded(options) {\n    var data = options.data = this._convertDataToPlainStructure(options.data);\n\n    if (!options.remoteOperations.filtering && options.loadOptions.filter) {\n      options.fullData = queryByOptions(query(options.data), {\n        sort: options.loadOptions && options.loadOptions.sort\n      }).toArray();\n    }\n\n    this._updateHasItemsMap(options);\n\n    this.callBase(options);\n\n    if (data.isConverted && this._cachedStoreData) {\n      this._cachedStoreData.isConverted = true;\n    }\n  },\n  _fillNodes: function _fillNodes(nodes, options, expandedRowKeys, level) {\n    var isFullBranch = isFullBranchFilterMode(this);\n    level = level || 0;\n\n    for (var i = 0; i < nodes.length; i++) {\n      var node = nodes[i];\n      var needToExpand = false;\n\n      this._fillNodes(nodes[i].children, options, expandedRowKeys, level + 1);\n\n      node.level = level;\n      node.hasChildren = this._calculateHasItems(node, options);\n\n      if (node.visible && node.hasChildren) {\n        if (isFullBranch) {\n          if (node.children.filter(function (node) {\n            return node.visible;\n          }).length) {\n            needToExpand = true;\n          } else if (node.children.length) {\n            treeListCore.foreachNodes(node.children, function (node) {\n              node.visible = true;\n            });\n          }\n        } else {\n          needToExpand = true;\n        }\n\n        if (options.expandVisibleNodes && needToExpand) {\n          expandedRowKeys.push(node.key);\n        }\n      }\n\n      if (node.visible || node.hasChildren) {\n        node.parent.hasChildren = true;\n      }\n    }\n  },\n  _processTreeStructure: function _processTreeStructure(options, visibleItems) {\n    var data = options.data;\n    var parentIds = options.storeLoadOptions.parentIds;\n    var expandedRowKeys = [];\n\n    if (parentIds && parentIds.length || this._isReload) {\n      if (options.fullData && options.fullData.length > options.data.length) {\n        data = options.fullData;\n        visibleItems = visibleItems || options.data;\n      }\n\n      this._rootNode = this._createNodesByItems(data, visibleItems);\n\n      if (!this._rootNode) {\n        options.data = new Deferred().reject(errors.Error(\"E1046\", this.getKeyExpr()));\n        return;\n      }\n\n      this._fillNodes(this._rootNode.children, options, expandedRowKeys);\n\n      this._isNodesInitializing = true;\n\n      if (options.collapseVisibleNodes || expandedRowKeys.length) {\n        this.option(\"expandedRowKeys\", expandedRowKeys);\n      }\n\n      this._isReload = false;\n      this.executeAction(\"onNodesInitialized\", {\n        root: this._rootNode\n      });\n      this._isNodesInitializing = false;\n    }\n\n    var resultData = [];\n\n    this._fillVisibleItemsByNodes(this._rootNode.children, options, resultData);\n\n    options.data = resultData;\n    this._totalItemsCount = resultData.length;\n  },\n  _handleDataLoadedCore: function _handleDataLoadedCore(options) {\n    var that = this;\n    var data = options.data;\n    var callBase = that.callBase;\n    var filter = options.storeLoadOptions.filter || options.loadOptions.filter;\n    var filterMode = that.option(\"filterMode\");\n    var visibleItems;\n    var parentIds = options.storeLoadOptions.parentIds;\n    var needLoadParents = filter && (!parentIds || !parentIds.length) && \"standard\" !== filterMode;\n\n    if (!options.isCustomLoading) {\n      if (needLoadParents) {\n        var d = options.data = new Deferred();\n\n        if (\"matchOnly\" === filterMode) {\n          visibleItems = data;\n        }\n\n        return that._loadParents(data, options).done(function (data) {\n          that._loadChildrenIfNeed(data, options).done(function (data) {\n            options.data = data;\n\n            that._processTreeStructure(options, visibleItems);\n\n            callBase.call(that, options);\n            d.resolve(options.data);\n          });\n        }).fail(d.reject);\n      } else {\n        that._processTreeStructure(options);\n      }\n    }\n\n    that.callBase(options);\n  },\n  _handlePush: function _handlePush(_ref) {\n    var changes = _ref.changes;\n    var reshapeOnPush = this._dataSource._reshapeOnPush;\n    var isNeedReshape = reshapeOnPush && !!changes.length;\n\n    if (isNeedReshape) {\n      this._isReload = true;\n    }\n\n    this.callBase.apply(this, arguments);\n  },\n  init: function init(dataSource, remoteOperations) {\n    this.callBase.apply(this, arguments);\n    var dataStructure = this.option(\"dataStructure\");\n    this._keyGetter = this._createKeyGetter();\n    this._parentIdGetter = this.createParentIdGetter();\n    this._hasItemsGetter = this._createHasItemsGetter();\n    this._hasItemsSetter = this._createHasItemsSetter();\n\n    if (\"tree\" === dataStructure) {\n      this._itemsGetter = this._createItemsGetter();\n      this._keySetter = this._createKeySetter();\n      this._parentIdSetter = this.createParentIdSetter();\n    }\n\n    this._nodeByKey = {};\n    this._isChildrenLoaded = {};\n    this._totalItemsCount = 0;\n    this.createAction(\"onNodesInitialized\");\n  },\n  getKeyExpr: function getKeyExpr() {\n    var store = this.store();\n    var key = store && store.key();\n    var keyExpr = this.option(\"keyExpr\");\n\n    if (isDefined(key) && isDefined(keyExpr)) {\n      if (!equalByValue(key, keyExpr)) {\n        throw errors.Error(\"E1044\");\n      }\n    }\n\n    return key || keyExpr || DEFAULT_KEY_EXPRESSION;\n  },\n  keyOf: function keyOf(data) {\n    return this._keyGetter && this._keyGetter(data);\n  },\n  parentKeyOf: function parentKeyOf(data) {\n    return this._parentIdGetter && this._parentIdGetter(data);\n  },\n  getRootNode: function getRootNode() {\n    return this._rootNode;\n  },\n  totalItemsCount: function totalItemsCount() {\n    return this._totalItemsCount;\n  },\n  isRowExpanded: function isRowExpanded(key, cache) {\n    if (cache) {\n      var isExpandedByKey = cache.isExpandedByKey;\n\n      if (!isExpandedByKey) {\n        isExpandedByKey = cache.isExpandedByKey = {};\n        this.option(\"expandedRowKeys\").forEach(function (key) {\n          isExpandedByKey[key] = true;\n        });\n      }\n\n      return !!isExpandedByKey[key];\n    }\n\n    var indexExpandedNodeKey = gridCoreUtils.getIndexByKey(key, this.option(\"expandedRowKeys\"), null);\n    return indexExpandedNodeKey >= 0;\n  },\n  _changeRowExpandCore: function _changeRowExpandCore(key) {\n    var expandedRowKeys = this.option(\"expandedRowKeys\").slice();\n    var indexExpandedNodeKey = gridCoreUtils.getIndexByKey(key, expandedRowKeys, null);\n\n    if (indexExpandedNodeKey < 0) {\n      expandedRowKeys.push(key);\n    } else {\n      expandedRowKeys.splice(indexExpandedNodeKey, 1);\n    }\n\n    this.option(\"expandedRowKeys\", expandedRowKeys);\n  },\n  changeRowExpand: function changeRowExpand(key) {\n    this._changeRowExpandCore(key);\n\n    return this._isNodesInitializing ? new Deferred().resolve() : this.load();\n  },\n  getNodeByKey: function getNodeByKey(key) {\n    if (this._nodeByKey) {\n      return this._nodeByKey[key];\n    }\n  },\n  getNodeLeafKeys: function getNodeLeafKeys() {\n    var that = this;\n    var result = [];\n    var keys = that._rootNode ? [that._rootNode.key] : [];\n    keys.forEach(function (key) {\n      var node = that.getNodeByKey(key);\n      node && treeListCore.foreachNodes([node], function (childNode) {\n        !childNode.children.length && result.push(childNode.key);\n      });\n    });\n    return result;\n  },\n  getChildNodeKeys: function getChildNodeKeys(parentKey) {\n    var node = this.getNodeByKey(parentKey);\n    var childrenKeys = [];\n    node && treeListCore.foreachNodes(node.children, function (childNode) {\n      childrenKeys.push(childNode.key);\n    });\n    return childrenKeys;\n  },\n  loadDescendants: function loadDescendants(keys, childrenOnly) {\n    var that = this;\n    var d = new Deferred();\n    var remoteOperations = that.remoteOperations();\n\n    if (isDefined(keys)) {\n      keys = Array.isArray(keys) ? keys : [keys];\n    } else {\n      keys = that.getNodeLeafKeys();\n    }\n\n    if (!remoteOperations.filtering || !keys.length) {\n      return d.resolve();\n    }\n\n    var loadOptions = that._dataSource._createStoreLoadOptions();\n\n    loadOptions.parentIds = keys;\n    that.load(loadOptions).done(function () {\n      if (!childrenOnly) {\n        var childKeys = function (that, keys) {\n          var childKeys = [];\n          keys.forEach(function (key) {\n            var node = that.getNodeByKey(key);\n            node && node.children.forEach(function (child) {\n              childKeys.push(child.key);\n            });\n          });\n          return childKeys;\n        }(that, keys);\n\n        if (childKeys.length) {\n          that.loadDescendants(childKeys, childrenOnly).done(d.resolve).fail(d.reject);\n          return;\n        }\n      }\n\n      d.resolve();\n    }).fail(d.reject);\n    return d.promise();\n  },\n  forEachNode: function forEachNode() {\n    var nodes = [];\n    var callback;\n\n    if (1 === arguments.length) {\n      callback = arguments[0];\n      var rootNode = this.getRootNode();\n      nodes = rootNode && rootNode.children || [];\n    } else if (2 === arguments.length) {\n      callback = arguments[1];\n      nodes = arguments[0];\n      nodes = Array.isArray(nodes) ? nodes : [nodes];\n    }\n\n    treeListCore.foreachNodes(nodes, callback);\n  }\n});\nexport default {\n  extend: function extend(extender) {\n    DataSourceAdapterTreeList = DataSourceAdapterTreeList.inherit(extender);\n  },\n  create: function create(component) {\n    return new DataSourceAdapterTreeList(component);\n  }\n};","map":null,"metadata":{},"sourceType":"module"}