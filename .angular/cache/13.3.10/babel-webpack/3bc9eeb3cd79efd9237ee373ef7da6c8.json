{"ast":null,"code":"/**\r\n * DevExtreme (esm/viz/axes/xy_axes.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { Range } from \"../translators/range\";\nimport formatHelper from \"../../format_helper\";\nimport dateUtils from \"../../core/utils/date\";\nimport { extend } from \"../../core/utils/extend\";\nimport { generateDateBreaks } from \"./datetime_breaks\";\nimport { noop } from \"../../core/utils/common\";\nimport { getLog, patchFontOptions, getCosAndSin } from \"../core/utils\";\nimport { isDefined } from \"../../core/utils/type\";\nimport constants from \"./axes_constants\";\nvar getNextDateUnit = dateUtils.getNextDateUnit;\nvar correctDateWithUnitBeginning = dateUtils.correctDateWithUnitBeginning;\nvar _math = Math;\nvar _max = _math.max;\nvar TOP = constants.top;\nvar BOTTOM = constants.bottom;\nvar LEFT = constants.left;\nvar RIGHT = constants.right;\nvar CENTER = constants.center;\nvar SCALE_BREAK_OFFSET = 3;\nvar RANGE_RATIO = .3;\nvar WAVED_LINE_CENTER = 2;\nvar WAVED_LINE_TOP = 0;\nvar WAVED_LINE_BOTTOM = 4;\nvar WAVED_LINE_LENGTH = 24;\nvar TICKS_CORRECTIONS = {\n  left: -1,\n  top: -1,\n  right: 0,\n  bottom: 0,\n  center: -.5\n};\n\nfunction prepareDatesDifferences(datesDifferences, tickInterval) {\n  var dateUnitInterval;\n  var i;\n\n  if (\"week\" === tickInterval) {\n    tickInterval = \"day\";\n  }\n\n  if (\"quarter\" === tickInterval) {\n    tickInterval = \"month\";\n  }\n\n  if (datesDifferences[tickInterval]) {\n    for (i = 0; i < dateUtils.dateUnitIntervals.length; i++) {\n      dateUnitInterval = dateUtils.dateUnitIntervals[i];\n\n      if (datesDifferences[dateUnitInterval]) {\n        datesDifferences[dateUnitInterval] = false;\n        datesDifferences.count--;\n      }\n\n      if (dateUnitInterval === tickInterval) {\n        break;\n      }\n    }\n  }\n}\n\nfunction sortingBreaks(breaks) {\n  return breaks.sort(function (a, b) {\n    return a.from - b.from;\n  });\n}\n\nfunction getMarkerDates(min, max, markerInterval) {\n  var origMin = min;\n  var dates;\n  min = correctDateWithUnitBeginning(min, markerInterval);\n  max = correctDateWithUnitBeginning(max, markerInterval);\n  dates = dateUtils.getSequenceByInterval(min, max, markerInterval);\n\n  if (dates.length && origMin > dates[0]) {\n    dates = dates.slice(1);\n  }\n\n  return dates;\n}\n\nfunction getStripHorizontalAlignmentPosition(alignment) {\n  var position = \"start\";\n\n  if (\"center\" === alignment) {\n    position = \"center\";\n  }\n\n  if (\"right\" === alignment) {\n    position = \"end\";\n  }\n\n  return position;\n}\n\nfunction getStripVerticalAlignmentPosition(alignment) {\n  var position = \"start\";\n\n  if (\"center\" === alignment) {\n    position = \"center\";\n  }\n\n  if (\"bottom\" === alignment) {\n    position = \"end\";\n  }\n\n  return position;\n}\n\nfunction getMarkerInterval(tickInterval) {\n  var markerInterval = getNextDateUnit(tickInterval);\n\n  if (\"quarter\" === markerInterval) {\n    markerInterval = getNextDateUnit(markerInterval);\n  }\n\n  return markerInterval;\n}\n\nfunction getMarkerFormat(curDate, prevDate, tickInterval, markerInterval) {\n  var format = markerInterval;\n  var datesDifferences = prevDate && dateUtils.getDatesDifferences(prevDate, curDate);\n\n  if (prevDate && \"year\" !== tickInterval) {\n    prepareDatesDifferences(datesDifferences, tickInterval);\n    format = formatHelper.getDateFormatByDifferences(datesDifferences);\n  }\n\n  return format;\n}\n\nfunction getMaxSide(act, boxes) {\n  return boxes.reduce(function (prevValue, box) {\n    return _max(prevValue, act(box));\n  }, 0);\n}\n\nfunction getDistanceByAngle(bBox, rotationAngle) {\n  rotationAngle = _math.abs(rotationAngle);\n  rotationAngle = rotationAngle % 180 >= 90 ? 90 - rotationAngle % 90 : rotationAngle % 90;\n  var a = rotationAngle * (_math.PI / 180);\n\n  if (a >= _math.atan(bBox.height / bBox.width)) {\n    return bBox.height / _math.abs(_math.sin(a));\n  } else {\n    return bBox.width;\n  }\n}\n\nfunction getMaxConstantLinePadding(constantLines) {\n  return constantLines.reduce(function (padding, options) {\n    return _max(padding, options.paddingTopBottom);\n  }, 0);\n}\n\nfunction getConstantLineLabelMarginForVerticalAlignment(constantLines, alignment, labelHeight) {\n  return constantLines.some(function (options) {\n    return options.label.verticalAlignment === alignment;\n  }) && labelHeight || 0;\n}\n\nfunction getLeftMargin(bBox) {\n  return _math.abs(bBox.x) || 0;\n}\n\nfunction getRightMargin(bBox) {\n  return _math.abs(bBox.width - _math.abs(bBox.x)) || 0;\n}\n\nfunction generateRangesOnPoints(points, edgePoints, getRange) {\n  var i;\n  var length;\n  var maxRange = null;\n  var ranges = [];\n  var curValue;\n  var prevValue;\n  var curRange;\n\n  for (i = 1, length = points.length; i < length; i++) {\n    curValue = points[i];\n    prevValue = points[i - 1];\n    curRange = getRange(curValue, prevValue);\n\n    if (edgePoints.indexOf(curValue) >= 0) {\n      if (!maxRange || curRange > maxRange.length) {\n        maxRange = {\n          start: curValue,\n          end: prevValue,\n          length: curRange\n        };\n      }\n    } else {\n      if (maxRange && curRange < maxRange.length) {\n        ranges.push(maxRange);\n      } else {\n        ranges.push({\n          start: curValue,\n          end: prevValue,\n          length: curRange\n        });\n      }\n\n      maxRange = null;\n    }\n  }\n\n  if (maxRange) {\n    ranges.push(maxRange);\n  }\n\n  return ranges;\n}\n\nfunction generateAutoBreaks(_ref, series, _ref2) {\n  var logarithmBase = _ref.logarithmBase,\n      type = _ref.type,\n      maxAutoBreakCount = _ref.maxAutoBreakCount;\n  var minVisible = _ref2.minVisible,\n      maxVisible = _ref2.maxVisible;\n  var breaks = [];\n  var getRange = \"logarithmic\" === type ? function (min, max) {\n    return getLog(max / min, logarithmBase);\n  } : function (min, max) {\n    return max - min;\n  };\n  var visibleRange = getRange(minVisible, maxVisible);\n  var points = series.reduce(function (result, s) {\n    var points = s.getPointsInViewPort();\n    result[0] = result[0].concat(points[0]);\n    result[1] = result[1].concat(points[1]);\n    return result;\n  }, [[], []]);\n  var sortedAllPoints = points[0].concat(points[1]).sort(function (a, b) {\n    return b - a;\n  });\n  var edgePoints = points[1].filter(function (p) {\n    return points[0].indexOf(p) < 0;\n  });\n  var minDiff = RANGE_RATIO * visibleRange;\n  var ranges = generateRangesOnPoints(sortedAllPoints, edgePoints, getRange).sort(function (a, b) {\n    return b.length - a.length;\n  });\n  var epsilon = _math.min.apply(null, ranges.map(function (r) {\n    return r.length;\n  })) / 1e3;\n\n  var _maxAutoBreakCount = isDefined(maxAutoBreakCount) ? _math.min(maxAutoBreakCount, ranges.length) : ranges.length;\n\n  for (var i = 0; i < _maxAutoBreakCount; i++) {\n    if (ranges[i].length >= minDiff) {\n      if (visibleRange <= ranges[i].length) {\n        break;\n      }\n\n      visibleRange -= ranges[i].length;\n\n      if (visibleRange > epsilon || visibleRange < -epsilon) {\n        breaks.push({\n          from: ranges[i].start,\n          to: ranges[i].end\n        });\n        minDiff = RANGE_RATIO * visibleRange;\n      }\n    } else {\n      break;\n    }\n  }\n\n  sortingBreaks(breaks);\n  return breaks;\n}\n\nexport default {\n  linear: {\n    _getStep: function _getStep(boxes, rotationAngle) {\n      var spacing = this._options.label.minSpacing;\n      var func = this._isHorizontal ? function (box) {\n        return box.width + spacing;\n      } : function (box) {\n        return box.height;\n      };\n      var maxLabelLength = getMaxSide(func, boxes);\n\n      if (rotationAngle) {\n        maxLabelLength = getDistanceByAngle({\n          width: maxLabelLength,\n          height: this._getMaxLabelHeight(boxes, 0)\n        }, rotationAngle);\n      }\n\n      return constants.getTicksCountInRange(this._majorTicks, this._isHorizontal ? \"x\" : \"y\", maxLabelLength);\n    },\n    _getMaxLabelHeight: function _getMaxLabelHeight(boxes, spacing) {\n      return getMaxSide(function (box) {\n        return box.height;\n      }, boxes) + spacing;\n    },\n    _validateOverlappingMode: function _validateOverlappingMode(mode, displayMode) {\n      if (this._isHorizontal && (\"rotate\" === displayMode || \"stagger\" === displayMode) || !this._isHorizontal) {\n        return constants.validateOverlappingMode(mode);\n      }\n\n      return mode;\n    },\n    _validateDisplayMode: function _validateDisplayMode(mode) {\n      return this._isHorizontal ? mode : \"standard\";\n    },\n    getMarkerTrackers: function getMarkerTrackers() {\n      return this._markerTrackers;\n    },\n    _getSharpParam: function _getSharpParam(opposite) {\n      return this._isHorizontal ^ opposite ? \"h\" : \"v\";\n    },\n    _createAxisElement: function _createAxisElement() {\n      return this._renderer.path([], \"line\");\n    },\n    _updateAxisElementPosition: function _updateAxisElementPosition() {\n      var axisCoord = this._axisPosition;\n\n      var canvas = this._getCanvasStartEnd();\n\n      this._axisElement.attr({\n        points: this._isHorizontal ? [canvas.start, axisCoord, canvas.end, axisCoord] : [axisCoord, canvas.start, axisCoord, canvas.end]\n      });\n    },\n    _getTranslatedCoord: function _getTranslatedCoord(value, offset) {\n      return this._translator.translate(value, offset);\n    },\n    _initAxisPositions: function _initAxisPositions() {\n      if (this.customPositionIsAvailable()) {\n        this._customBoundaryPosition = this.getCustomBoundaryPosition();\n      }\n\n      if (!this.customPositionIsAvailable() || this.customPositionIsBoundary()) {\n        this._axisPosition = this.getPredefinedPosition(this.getResolvedBoundaryPosition());\n      } else {\n        this._axisPosition = this.getCustomPosition();\n      }\n    },\n    _getTickMarkPoints: function _getTickMarkPoints(coords, length, tickOptions) {\n      var isHorizontal = this._isHorizontal;\n      var tickOrientation = this._options.tickOrientation;\n      var labelPosition = this._options.label.position;\n      var tickStartCoord;\n\n      if (isDefined(tickOrientation)) {\n        tickStartCoord = TICKS_CORRECTIONS[tickOrientation] * length;\n      } else {\n        var shift = tickOptions.shift || 0;\n\n        if (!isHorizontal && labelPosition === LEFT || isHorizontal && labelPosition !== BOTTOM) {\n          shift = -shift;\n        }\n\n        tickStartCoord = shift + this.getTickStartPositionShift(length);\n      }\n\n      return [coords.x + (isHorizontal ? 0 : tickStartCoord), coords.y + (isHorizontal ? tickStartCoord : 0), coords.x + (isHorizontal ? 0 : tickStartCoord + length), coords.y + (isHorizontal ? tickStartCoord + length : 0)];\n    },\n    getTickStartPositionShift: function getTickStartPositionShift(length) {\n      var width = this._options.width;\n      var position = this.getResolvedBoundaryPosition();\n      return length % 2 === 1 ? width % 2 === 0 && (position === LEFT || position === TOP) || width % 2 === 1 && (position === RIGHT || position === BOTTOM) && !this.hasNonBoundaryPosition() ? Math.floor(-length / 2) : -Math.floor(length / 2) : -length / 2 + (width % 2 === 0 ? 0 : position === BOTTOM || position === RIGHT ? -1 : 1);\n    },\n    _getTitleCoords: function _getTitleCoords() {\n      var horizontal = this._isHorizontal;\n      var x = this._axisPosition;\n      var y = this._axisPosition;\n      var align = this._options.title.alignment;\n\n      var canvas = this._getCanvasStartEnd();\n\n      var fromStartToEnd = horizontal || this._options.position === LEFT;\n      var canvasStart = fromStartToEnd ? canvas.start : canvas.end;\n      var canvasEnd = fromStartToEnd ? canvas.end : canvas.start;\n      var coord = align === LEFT ? canvasStart : align === RIGHT ? canvasEnd : canvas.start + (canvas.end - canvas.start) / 2;\n\n      if (horizontal) {\n        x = coord;\n      } else {\n        y = coord;\n      }\n\n      return {\n        x: x,\n        y: y\n      };\n    },\n    _drawTitleText: function _drawTitleText(group, coords) {\n      var options = this._options;\n      var titleOptions = options.title;\n      var attrs = {\n        opacity: titleOptions.opacity,\n        align: titleOptions.alignment,\n        class: titleOptions.cssClass\n      };\n\n      if (!titleOptions.text || !group) {\n        return;\n      }\n\n      coords = coords || this._getTitleCoords();\n\n      if (!this._isHorizontal) {\n        attrs.rotate = options.position === LEFT ? 270 : 90;\n      }\n\n      var text = this._renderer.text(titleOptions.text, coords.x, coords.y).css(patchFontOptions(titleOptions.font)).attr(attrs).append(group);\n\n      this._checkTitleOverflow(text);\n\n      return text;\n    },\n    _updateTitleCoords: function _updateTitleCoords() {\n      this._title && this._title.element.attr(this._getTitleCoords());\n    },\n    _drawTitle: function _drawTitle() {\n      var title = this._drawTitleText(this._axisTitleGroup);\n\n      if (title) {\n        this._title = {\n          element: title\n        };\n      }\n    },\n    _measureTitle: function _measureTitle() {\n      if (this._title) {\n        if (this._title.bBox && !this._title.originalSize) {\n          this._title.originalSize = this._title.bBox;\n        }\n\n        this._title.bBox = this._title.element.getBBox();\n      }\n    },\n    _drawDateMarker: function _drawDateMarker(date, options, range) {\n      var markerOptions = this._options.marker;\n\n      var invert = this._translator.getBusinessRange().invert;\n\n      var textIndent = markerOptions.width + markerOptions.textLeftIndent;\n      var pathElement;\n\n      if (null === options.x) {\n        return;\n      }\n\n      if (!options.withoutStick) {\n        pathElement = this._renderer.path([options.x, options.y, options.x, options.y + markerOptions.separatorHeight], \"line\").attr({\n          \"stroke-width\": markerOptions.width,\n          stroke: markerOptions.color,\n          \"stroke-opacity\": markerOptions.opacity,\n          sharp: \"h\"\n        }).append(this._axisElementsGroup);\n      }\n\n      var text = String(this.formatLabel(date, options.labelOptions, range));\n      return {\n        date: date,\n        x: options.x,\n        y: options.y,\n        cropped: options.withoutStick,\n        label: this._renderer.text(text, options.x, options.y).css(patchFontOptions(markerOptions.label.font)).append(this._axisElementsGroup),\n        line: pathElement,\n        getContentContainer: function getContentContainer() {\n          return this.label;\n        },\n        getEnd: function getEnd() {\n          return this.x + (invert ? -1 : 1) * (textIndent + this.labelBBox.width);\n        },\n        setTitle: function setTitle() {\n          this.title = text;\n        },\n        hideLabel: function hideLabel() {\n          this.label.dispose();\n          this.label = null;\n          this.title = text;\n        },\n        hide: function hide() {\n          if (pathElement) {\n            pathElement.dispose();\n            pathElement = null;\n          }\n\n          this.label.dispose();\n          this.label = null;\n          this.hidden = true;\n        }\n      };\n    },\n    _drawDateMarkers: function _drawDateMarkers() {\n      var that = this;\n      var options = that._options;\n      var translator = that._translator;\n\n      var viewport = that._getViewportRange();\n\n      var minBound = viewport.minVisible;\n      var dateMarkers = [];\n      var dateMarker;\n\n      function draw(markerDate, format, withoutStick) {\n        return that._drawDateMarker(markerDate, {\n          x: translator.translate(markerDate),\n          y: markersAreaTop,\n          labelOptions: that._getLabelFormatOptions(format),\n          withoutStick: withoutStick\n        }, viewport);\n      }\n\n      if (viewport.isEmpty() || !options.marker.visible || \"datetime\" !== options.argumentType || \"discrete\" === options.type || that._majorTicks.length <= 1) {\n        return [];\n      }\n\n      var markersAreaTop = that._axisPosition + options.marker.topIndent;\n      var tickInterval = dateUtils.getDateUnitInterval(this._tickInterval);\n      var markerInterval = getMarkerInterval(tickInterval);\n      var markerDates = getMarkerDates(minBound, viewport.maxVisible, markerInterval);\n\n      if (markerDates.length > 1 || 1 === markerDates.length && minBound < markerDates[0]) {\n        dateMarkers = markerDates.reduce(function (markers, curDate, i, dates) {\n          var marker = draw(curDate, getMarkerFormat(curDate, dates[i - 1] || minBound < curDate && minBound, tickInterval, markerInterval));\n          marker && markers.push(marker);\n          return markers;\n        }, []);\n\n        if (minBound < markerDates[0]) {\n          dateMarker = draw(minBound, getMarkerFormat(minBound, markerDates[0], tickInterval, markerInterval), true);\n          dateMarker && dateMarkers.unshift(dateMarker);\n        }\n      }\n\n      return dateMarkers;\n    },\n    _adjustDateMarkers: function _adjustDateMarkers(offset) {\n      offset = offset || 0;\n      var that = this;\n      var markerOptions = this._options.marker;\n      var textIndent = markerOptions.width + markerOptions.textLeftIndent;\n\n      var invert = this._translator.getBusinessRange().invert;\n\n      var canvas = that._getCanvasStartEnd();\n\n      var dateMarkers = this._dateMarkers;\n\n      if (!dateMarkers.length) {\n        return offset;\n      }\n\n      if (dateMarkers[0].cropped) {\n        if (!this._checkMarkersPosition(invert, dateMarkers[1], dateMarkers[0])) {\n          dateMarkers[0].hideLabel();\n        }\n      }\n\n      var prevDateMarker;\n      dateMarkers.forEach(function (marker, i, markers) {\n        if (marker.cropped) {\n          return;\n        }\n\n        if (invert ? marker.getEnd() < canvas.end : marker.getEnd() > canvas.end) {\n          marker.hideLabel();\n        } else if (that._checkMarkersPosition(invert, marker, prevDateMarker)) {\n          prevDateMarker = marker;\n        } else {\n          marker.hide();\n        }\n      });\n\n      this._dateMarkers.forEach(function (marker) {\n        if (marker.label) {\n          var labelBBox = marker.labelBBox;\n          var dy = marker.y + markerOptions.textTopIndent - labelBBox.y;\n          marker.label.attr({\n            translateX: invert ? marker.x - textIndent - labelBBox.x - labelBBox.width : marker.x + textIndent - labelBBox.x,\n            translateY: dy + offset\n          });\n        }\n\n        if (marker.line) {\n          marker.line.attr({\n            translateY: offset\n          });\n        }\n      });\n\n      that._initializeMarkersTrackers(offset);\n\n      return offset + markerOptions.topIndent + markerOptions.separatorHeight;\n    },\n    _checkMarkersPosition: function _checkMarkersPosition(invert, dateMarker, prevDateMarker) {\n      if (void 0 === prevDateMarker) {\n        return true;\n      }\n\n      return invert ? dateMarker.x < prevDateMarker.getEnd() : dateMarker.x > prevDateMarker.getEnd();\n    },\n    _initializeMarkersTrackers: function _initializeMarkersTrackers(offset) {\n      var separatorHeight = this._options.marker.separatorHeight;\n      var renderer = this._renderer;\n\n      var businessRange = this._translator.getBusinessRange();\n\n      var canvas = this._getCanvasStartEnd();\n\n      var group = this._axisElementsGroup;\n      this._markerTrackers = this._dateMarkers.filter(function (marker) {\n        return !marker.hidden;\n      }).map(function (marker, i, markers) {\n        var nextMarker = markers[i + 1] || {\n          x: canvas.end,\n          date: businessRange.max\n        };\n        var x = marker.x;\n        var y = marker.y + offset;\n        var markerTracker = renderer.path([x, y, x, y + separatorHeight, nextMarker.x, y + separatorHeight, nextMarker.x, y, x, y], \"area\").attr({\n          \"stroke-width\": 1,\n          stroke: \"grey\",\n          fill: \"grey\",\n          opacity: 1e-4\n        }).append(group);\n        markerTracker.data(\"range\", {\n          startValue: marker.date,\n          endValue: nextMarker.date\n        });\n\n        if (marker.title) {\n          markerTracker.setTitle(marker.title);\n        }\n\n        return markerTracker;\n      });\n    },\n    _getLabelFormatOptions: function _getLabelFormatOptions(formatString) {\n      var markerLabelOptions = this._markerLabelOptions;\n\n      if (!markerLabelOptions) {\n        this._markerLabelOptions = markerLabelOptions = extend(true, {}, this._options.marker.label);\n      }\n\n      if (!isDefined(this._options.marker.label.format)) {\n        markerLabelOptions.format = formatString;\n      }\n\n      return markerLabelOptions;\n    },\n    _adjustConstantLineLabels: function _adjustConstantLineLabels(constantLines) {\n      var that = this;\n      var axisPosition = that._options.position;\n      var canvas = that.getCanvas();\n      var canvasLeft = canvas.left;\n      var canvasRight = canvas.width - canvas.right;\n      var canvasTop = canvas.top;\n      var canvasBottom = canvas.height - canvas.bottom;\n      var verticalCenter = canvasTop + (canvasBottom - canvasTop) / 2;\n      var horizontalCenter = canvasLeft + (canvasRight - canvasLeft) / 2;\n      var maxLabel = 0;\n      constantLines.forEach(function (item) {\n        var isHorizontal = that._isHorizontal;\n        var linesOptions = item.options;\n        var paddingTopBottom = linesOptions.paddingTopBottom;\n        var paddingLeftRight = linesOptions.paddingLeftRight;\n        var labelOptions = linesOptions.label;\n        var labelVerticalAlignment = labelOptions.verticalAlignment;\n        var labelHorizontalAlignment = labelOptions.horizontalAlignment;\n        var labelIsInside = \"inside\" === labelOptions.position;\n        var label = item.label;\n        var box = item.labelBBox;\n        var translateX;\n        var translateY;\n\n        if (null === label || box.isEmpty) {\n          return;\n        }\n\n        if (isHorizontal) {\n          if (labelIsInside) {\n            if (labelHorizontalAlignment === LEFT) {\n              translateX = item.coord - paddingLeftRight - box.x - box.width;\n            } else {\n              translateX = item.coord + paddingLeftRight - box.x;\n            }\n\n            switch (labelVerticalAlignment) {\n              case CENTER:\n                translateY = verticalCenter - box.y - box.height / 2;\n                break;\n\n              case BOTTOM:\n                translateY = canvasBottom - paddingTopBottom - box.y - box.height;\n                break;\n\n              default:\n                translateY = canvasTop + paddingTopBottom - box.y;\n            }\n          } else {\n            if (axisPosition === labelVerticalAlignment) {\n              maxLabel = _max(maxLabel, box.height + paddingTopBottom);\n            }\n\n            translateX = item.coord - box.x - box.width / 2;\n\n            if (labelVerticalAlignment === BOTTOM) {\n              translateY = canvasBottom + paddingTopBottom - box.y;\n            } else {\n              translateY = canvasTop - paddingTopBottom - box.y - box.height;\n            }\n          }\n        } else if (labelIsInside) {\n          if (labelVerticalAlignment === BOTTOM) {\n            translateY = item.coord + paddingTopBottom - box.y;\n          } else {\n            translateY = item.coord - paddingTopBottom - box.y - box.height;\n          }\n\n          switch (labelHorizontalAlignment) {\n            case CENTER:\n              translateX = horizontalCenter - box.x - box.width / 2;\n              break;\n\n            case RIGHT:\n              translateX = canvasRight - paddingLeftRight - box.x - box.width;\n              break;\n\n            default:\n              translateX = canvasLeft + paddingLeftRight - box.x;\n          }\n        } else {\n          if (axisPosition === labelHorizontalAlignment) {\n            maxLabel = _max(maxLabel, box.width + paddingLeftRight);\n          }\n\n          translateY = item.coord - box.y - box.height / 2;\n\n          if (labelHorizontalAlignment === RIGHT) {\n            translateX = canvasRight + paddingLeftRight - box.x;\n          } else {\n            translateX = canvasLeft - paddingLeftRight - box.x - box.width;\n          }\n        }\n\n        label.attr({\n          translateX: translateX,\n          translateY: translateY\n        });\n      });\n      return maxLabel;\n    },\n    _drawConstantLinesForEstimating: function _drawConstantLinesForEstimating(constantLines) {\n      var that = this;\n      var renderer = this._renderer;\n      var group = renderer.g();\n      constantLines.forEach(function (options) {\n        that._drawConstantLineLabelText(options.label.text, 0, 0, options.label, group).attr({\n          align: \"center\"\n        });\n      });\n      return group.append(renderer.root);\n    },\n    _estimateLabelHeight: function _estimateLabelHeight(bBox, labelOptions) {\n      var height = bBox.height;\n      var drawingType = labelOptions.drawingType;\n\n      if (\"stagger\" === this._validateDisplayMode(drawingType) || \"stagger\" === this._validateOverlappingMode(labelOptions.overlappingBehavior, drawingType)) {\n        height = 2 * height + labelOptions.staggeringSpacing;\n      }\n\n      if (\"rotate\" === this._validateDisplayMode(drawingType) || \"rotate\" === this._validateOverlappingMode(labelOptions.overlappingBehavior, drawingType)) {\n        var sinCos = getCosAndSin(labelOptions.rotationAngle);\n        height = height * sinCos.cos + bBox.width * sinCos.sin;\n      }\n\n      return height && (height + labelOptions.indentFromAxis || 0) || 0;\n    },\n    estimateMargins: function estimateMargins(canvas) {\n      this.updateCanvas(canvas);\n\n      var range = this._getViewportRange();\n\n      var ticksData = this._createTicksAndLabelFormat(range);\n\n      var ticks = ticksData.ticks;\n      var tickInterval = ticksData.tickInterval;\n      var options = this._options;\n\n      var constantLineOptions = this._outsideConstantLines.filter(function (l) {\n        return l.labelOptions.visible;\n      }).map(function (l) {\n        return l.options;\n      });\n\n      var rootElement = this._renderer.root;\n      var labelIsVisible = options.label.visible && !range.isEmpty() && ticks.length;\n      var labelValue = labelIsVisible && this.formatLabel(ticks[ticks.length - 1], options.label, void 0, void 0, tickInterval, ticks);\n\n      var labelElement = labelIsVisible && this._renderer.text(labelValue, 0, 0).css(this._textFontStyles).attr(this._textOptions).append(rootElement);\n\n      var titleElement = this._drawTitleText(rootElement, {\n        x: 0,\n        y: 0\n      });\n\n      var constantLinesLabelsElement = this._drawConstantLinesForEstimating(constantLineOptions);\n\n      var labelBox = !options.label.template && labelElement && labelElement.getBBox() || {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0\n      };\n      var titleBox = titleElement && titleElement.getBBox() || {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0\n      };\n      var constantLinesBox = constantLinesLabelsElement.getBBox();\n      var titleHeight = titleBox.height ? titleBox.height + options.title.margin : 0;\n\n      var labelHeight = this._estimateLabelHeight(labelBox, options.label);\n\n      var constantLinesHeight = constantLinesBox.height ? constantLinesBox.height + getMaxConstantLinePadding(constantLineOptions) : 0;\n      var height = labelHeight + titleHeight;\n      var margins = {\n        left: _max(getLeftMargin(labelBox), getLeftMargin(constantLinesBox)),\n        right: _max(getRightMargin(labelBox), getRightMargin(constantLinesBox)),\n        top: (\"top\" === options.position ? height : 0) + getConstantLineLabelMarginForVerticalAlignment(constantLineOptions, \"top\", constantLinesHeight),\n        bottom: (\"top\" !== options.position ? height : 0) + getConstantLineLabelMarginForVerticalAlignment(constantLineOptions, \"bottom\", constantLinesHeight)\n      };\n      labelElement && labelElement.remove();\n      titleElement && titleElement.remove();\n      constantLinesLabelsElement && constantLinesLabelsElement.remove();\n      return margins;\n    },\n    _checkAlignmentConstantLineLabels: function _checkAlignmentConstantLineLabels(labelOptions) {\n      var position = labelOptions.position;\n      var verticalAlignment = (labelOptions.verticalAlignment || \"\").toLowerCase();\n      var horizontalAlignment = (labelOptions.horizontalAlignment || \"\").toLowerCase();\n\n      if (this._isHorizontal) {\n        if (\"outside\" === position) {\n          verticalAlignment = verticalAlignment === BOTTOM ? BOTTOM : TOP;\n          horizontalAlignment = CENTER;\n        } else {\n          verticalAlignment = verticalAlignment === CENTER ? CENTER : verticalAlignment === BOTTOM ? BOTTOM : TOP;\n          horizontalAlignment = horizontalAlignment === LEFT ? LEFT : RIGHT;\n        }\n      } else if (\"outside\" === position) {\n        verticalAlignment = CENTER;\n        horizontalAlignment = horizontalAlignment === LEFT ? LEFT : RIGHT;\n      } else {\n        verticalAlignment = verticalAlignment === BOTTOM ? BOTTOM : TOP;\n        horizontalAlignment = horizontalAlignment === RIGHT ? RIGHT : horizontalAlignment === CENTER ? CENTER : LEFT;\n      }\n\n      labelOptions.verticalAlignment = verticalAlignment;\n      labelOptions.horizontalAlignment = horizontalAlignment;\n    },\n    _getConstantLineLabelsCoords: function _getConstantLineLabelsCoords(value, lineLabelOptions) {\n      var x = value;\n      var y = value;\n\n      if (this._isHorizontal) {\n        y = this._orthogonalPositions[\"top\" === lineLabelOptions.verticalAlignment ? \"start\" : \"end\"];\n      } else {\n        x = this._orthogonalPositions[\"right\" === lineLabelOptions.horizontalAlignment ? \"end\" : \"start\"];\n      }\n\n      return {\n        x: x,\n        y: y\n      };\n    },\n    _getAdjustedStripLabelCoords: function _getAdjustedStripLabelCoords(strip) {\n      var stripOptions = strip.options;\n      var paddingTopBottom = stripOptions.paddingTopBottom;\n      var paddingLeftRight = stripOptions.paddingLeftRight;\n      var horizontalAlignment = stripOptions.label.horizontalAlignment;\n      var verticalAlignment = stripOptions.label.verticalAlignment;\n      var box = strip.labelBBox;\n      var labelHeight = box.height;\n      var labelWidth = box.width;\n      var labelCoords = strip.labelCoords;\n      var y = labelCoords.y - box.y;\n      var x = labelCoords.x - box.x;\n\n      if (verticalAlignment === TOP) {\n        y += paddingTopBottom;\n      } else if (verticalAlignment === CENTER) {\n        y -= labelHeight / 2;\n      } else if (verticalAlignment === BOTTOM) {\n        y -= paddingTopBottom + labelHeight;\n      }\n\n      if (horizontalAlignment === LEFT) {\n        x += paddingLeftRight;\n      } else if (horizontalAlignment === CENTER) {\n        x -= labelWidth / 2;\n      } else if (horizontalAlignment === RIGHT) {\n        x -= paddingLeftRight + labelWidth;\n      }\n\n      return {\n        translateX: x,\n        translateY: y\n      };\n    },\n    _adjustTitle: function _adjustTitle(offset) {\n      offset = offset || 0;\n\n      if (!this._title) {\n        return;\n      }\n\n      var options = this._options;\n      var position = options.position;\n      var margin = options.title.margin;\n      var title = this._title;\n      var boxTitle = title.bBox;\n      var x = boxTitle.x;\n      var y = boxTitle.y;\n      var width = boxTitle.width;\n      var height = boxTitle.height;\n      var axisPosition = this._axisPosition;\n      var loCoord = axisPosition - margin - offset;\n      var hiCoord = axisPosition + margin + offset;\n      var params = {};\n\n      if (this._isHorizontal) {\n        if (position === TOP) {\n          params.translateY = loCoord - (y + height);\n        } else {\n          params.translateY = hiCoord - y;\n        }\n      } else if (position === LEFT) {\n        params.translateX = loCoord - (x + width);\n      } else {\n        params.translateX = hiCoord - x;\n      }\n\n      title.element.attr(params);\n    },\n    _checkTitleOverflow: function _checkTitleOverflow(titleElement) {\n      if (!this._title && !titleElement) {\n        return;\n      }\n\n      var canvasLength = this._getScreenDelta();\n\n      var title = titleElement ? {\n        bBox: titleElement.getBBox(),\n        element: titleElement\n      } : this._title;\n      var titleOptions = this._options.title;\n      var boxTitle = title.bBox;\n\n      if ((this._isHorizontal ? boxTitle.width : boxTitle.height) > canvasLength) {\n        title.element.setMaxSize(canvasLength, void 0, {\n          wordWrap: titleOptions.wordWrap || \"none\",\n          textOverflow: titleOptions.textOverflow || \"ellipsis\"\n        });\n        this._wrapped = titleOptions.wordWrap && \"none\" !== titleOptions.wordWrap;\n      } else {\n        var moreThanOriginalSize = title.originalSize && canvasLength > (this._isHorizontal ? title.originalSize.width : title.originalSize.height);\n        !this._wrapped && moreThanOriginalSize && title.element.restoreText();\n      }\n    },\n    coordsIn: function coordsIn(x, y) {\n      var canvas = this.getCanvas();\n      var isHorizontal = this._options.isHorizontal;\n      var position = this._options.position;\n      var coord = isHorizontal ? y : x;\n\n      if (isHorizontal && (x < canvas.left || x > canvas.width - canvas.right) || !isHorizontal && (y < canvas.top || y > canvas.height - canvas.bottom)) {\n        return false;\n      }\n\n      if (isHorizontal && position === constants.top || !isHorizontal && position === constants.left) {\n        return coord < canvas[position];\n      }\n\n      return coord > canvas[isHorizontal ? \"height\" : \"width\"] - canvas[position];\n    },\n    _boundaryTicksVisibility: {\n      min: true,\n      max: true\n    },\n    adjust: function adjust() {\n      var seriesData = this._seriesData;\n\n      var viewport = this._series.filter(function (s) {\n        return s.isVisible();\n      }).reduce(function (range, s) {\n        var seriesRange = s.getViewport();\n        range.min = isDefined(seriesRange.min) ? range.min < seriesRange.min ? range.min : seriesRange.min : range.min;\n        range.max = isDefined(seriesRange.max) ? range.max > seriesRange.max ? range.max : seriesRange.max : range.max;\n\n        if (s.showZero) {\n          range = new Range(range);\n          range.correctValueZeroLevel();\n        }\n\n        return range;\n      }, {});\n\n      if (isDefined(viewport.min) && isDefined(viewport.max)) {\n        seriesData.minVisible = viewport.min;\n        seriesData.maxVisible = viewport.max;\n      }\n\n      seriesData.userBreaks = this._getScaleBreaks(this._options, {\n        minVisible: seriesData.minVisible,\n        maxVisible: seriesData.maxVisible\n      }, this._series, this.isArgumentAxis);\n\n      this._translator.updateBusinessRange(this._getViewportRange());\n    },\n    hasWrap: function hasWrap() {\n      return this._wrapped;\n    },\n    getAxisPosition: function getAxisPosition() {\n      return this._axisPosition;\n    },\n    _getStick: function _getStick() {\n      return !this._options.valueMarginsEnabled;\n    },\n    _getStripLabelCoords: function _getStripLabelCoords(from, to, stripLabelOptions) {\n      var orthogonalPositions = this._orthogonalPositions;\n      var isHorizontal = this._isHorizontal;\n      var horizontalAlignment = stripLabelOptions.horizontalAlignment;\n      var verticalAlignment = stripLabelOptions.verticalAlignment;\n      var x;\n      var y;\n\n      if (isHorizontal) {\n        if (horizontalAlignment === CENTER) {\n          x = from + (to - from) / 2;\n        } else if (horizontalAlignment === LEFT) {\n          x = from;\n        } else if (horizontalAlignment === RIGHT) {\n          x = to;\n        }\n\n        y = orthogonalPositions[getStripVerticalAlignmentPosition(verticalAlignment)];\n      } else {\n        x = orthogonalPositions[getStripHorizontalAlignmentPosition(horizontalAlignment)];\n\n        if (verticalAlignment === TOP) {\n          y = from;\n        } else if (verticalAlignment === CENTER) {\n          y = to + (from - to) / 2;\n        } else if (verticalAlignment === BOTTOM) {\n          y = to;\n        }\n      }\n\n      return {\n        x: x,\n        y: y\n      };\n    },\n    _getTranslatedValue: function _getTranslatedValue(value, offset) {\n      var pos1 = this._translator.translate(value, offset, \"semidiscrete\" === this._options.type && this._options.tickInterval);\n\n      var pos2 = this._axisPosition;\n      var isHorizontal = this._isHorizontal;\n      return {\n        x: isHorizontal ? pos1 : pos2,\n        y: isHorizontal ? pos2 : pos1\n      };\n    },\n    areCoordsOutsideAxis: function areCoordsOutsideAxis(coords) {\n      var coord = this._isHorizontal ? coords.x : coords.y;\n      var visibleArea = this.getVisibleArea();\n\n      if (coord < visibleArea[0] || coord > visibleArea[1]) {\n        return true;\n      }\n\n      return false;\n    },\n    _getSkippedCategory: function _getSkippedCategory(ticks) {\n      var skippedCategory;\n\n      if (this._options.type === constants.discrete && this._tickOffset && 0 !== ticks.length) {\n        skippedCategory = ticks[ticks.length - 1];\n      }\n\n      return skippedCategory;\n    },\n    _filterBreaks: function _filterBreaks(breaks, viewport, breakStyle) {\n      var minVisible = viewport.minVisible;\n      var maxVisible = viewport.maxVisible;\n      var breakSize = breakStyle ? breakStyle.width : 0;\n      return breaks.reduce(function (result, currentBreak) {\n        var from = currentBreak.from;\n        var to = currentBreak.to;\n        var lastResult = result[result.length - 1];\n        var newBreak;\n\n        if (!isDefined(from) || !isDefined(to)) {\n          return result;\n        }\n\n        if (from > to) {\n          to = [from, from = to][0];\n        }\n\n        if (result.length && from < lastResult.to) {\n          if (to > lastResult.to) {\n            lastResult.to = to > maxVisible ? maxVisible : to;\n\n            if (lastResult.gapSize) {\n              lastResult.gapSize = void 0;\n              lastResult.cumulativeWidth += breakSize;\n            }\n          }\n        } else if (from >= minVisible && from < maxVisible || to <= maxVisible && to > minVisible) {\n          from = from >= minVisible ? from : minVisible;\n          to = to <= maxVisible ? to : maxVisible;\n\n          if (to - from < maxVisible - minVisible) {\n            var _lastResult$cumulativ;\n\n            newBreak = {\n              from: from,\n              to: to,\n              cumulativeWidth: (null !== (_lastResult$cumulativ = null === lastResult || void 0 === lastResult ? void 0 : lastResult.cumulativeWidth) && void 0 !== _lastResult$cumulativ ? _lastResult$cumulativ : 0) + breakSize\n            };\n\n            if (currentBreak.gapSize) {\n              var _lastResult$cumulativ2;\n\n              newBreak.gapSize = dateUtils.convertMillisecondsToDateUnits(to - from);\n              newBreak.cumulativeWidth = null !== (_lastResult$cumulativ2 = null === lastResult || void 0 === lastResult ? void 0 : lastResult.cumulativeWidth) && void 0 !== _lastResult$cumulativ2 ? _lastResult$cumulativ2 : 0;\n            }\n\n            result.push(newBreak);\n          }\n        }\n\n        return result;\n      }, []);\n    },\n    _getScaleBreaks: function _getScaleBreaks(axisOptions, viewport, series, isArgumentAxis) {\n      var that = this;\n      var breaks = (axisOptions.breaks || []).map(function (b) {\n        return {\n          from: that.parser(b.startValue),\n          to: that.parser(b.endValue)\n        };\n      });\n\n      if (\"discrete\" !== axisOptions.type && \"datetime\" === axisOptions.dataType && axisOptions.workdaysOnly) {\n        breaks = breaks.concat(generateDateBreaks(viewport.minVisible, viewport.maxVisible, axisOptions.workWeek, axisOptions.singleWorkdays, axisOptions.holidays));\n      }\n\n      if (!isArgumentAxis && \"discrete\" !== axisOptions.type && \"datetime\" !== axisOptions.dataType && axisOptions.autoBreaksEnabled && 0 !== axisOptions.maxAutoBreakCount) {\n        breaks = breaks.concat(generateAutoBreaks(axisOptions, series, viewport));\n      }\n\n      return sortingBreaks(breaks);\n    },\n    _drawBreak: function _drawBreak(translatedEnd, positionFrom, positionTo, width, options, group) {\n      var breakStart = translatedEnd - (!this._translator.isInverted() ? width + 1 : 0);\n      var attr = {\n        \"stroke-width\": 1,\n        stroke: options.borderColor,\n        sharp: !options.isWaved ? options.isHorizontal ? \"h\" : \"v\" : void 0\n      };\n      var spaceAttr = {\n        stroke: options.color,\n        \"stroke-width\": width\n      };\n      var getPoints = this._isHorizontal ? rotateLine : function (p) {\n        return p;\n      };\n      var drawer = getLineDrawer(this._renderer, group, getPoints, positionFrom, breakStart, positionTo, options.isWaved);\n      drawer(width / 2, spaceAttr);\n      drawer(0, attr);\n      drawer(width, attr);\n    },\n    _createBreakClipRect: function _createBreakClipRect(from, to) {\n      var canvas = this._canvas;\n      var clipWidth = to - from;\n      var clipRect;\n\n      if (this._isHorizontal) {\n        clipRect = this._renderer.clipRect(canvas.left, from, canvas.width, clipWidth);\n      } else {\n        clipRect = this._renderer.clipRect(from, canvas.top, clipWidth, canvas.height);\n      }\n\n      this._breaksElements = this._breaksElements || [];\n\n      this._breaksElements.push(clipRect);\n\n      return clipRect.id;\n    },\n    _createBreaksGroup: function _createBreaksGroup(clipFrom, clipTo) {\n      var group = this._renderer.g().attr({\n        class: this._axisCssPrefix + \"breaks\",\n        \"clip-path\": this._createBreakClipRect(clipFrom, clipTo)\n      }).append(this._scaleBreaksGroup);\n\n      this._breaksElements = this._breaksElements || [];\n\n      this._breaksElements.push(group);\n\n      return group;\n    },\n    _disposeBreaksGroup: function _disposeBreaksGroup() {\n      (this._breaksElements || []).forEach(function (clipRect) {\n        clipRect.dispose();\n      });\n      this._breaksElements = null;\n    },\n    drawScaleBreaks: function drawScaleBreaks(customCanvas) {\n      var that = this;\n      var options = that._options;\n      var breakStyle = options.breakStyle;\n      var position = options.position;\n      var positionFrom;\n      var positionTo;\n      var breaks = that._translator.getBusinessRange().breaks || [];\n      var additionGroup;\n      var additionBreakFrom;\n      var additionBreakTo;\n\n      that._disposeBreaksGroup();\n\n      if (!(breaks && breaks.length)) {\n        return;\n      }\n\n      var breakOptions = {\n        color: that._options.containerColor,\n        borderColor: breakStyle.color,\n        isHorizontal: that._isHorizontal,\n        isWaved: \"straight\" !== breakStyle.line.toLowerCase()\n      };\n\n      if (customCanvas) {\n        positionFrom = customCanvas.start;\n        positionTo = customCanvas.end;\n      } else {\n        positionFrom = that._orthogonalPositions.start - (options.visible && !that._axisShift && (position === LEFT || position === TOP) ? SCALE_BREAK_OFFSET : 0);\n        positionTo = that._orthogonalPositions.end + (options.visible && (position === RIGHT || position === BOTTOM) ? SCALE_BREAK_OFFSET : 0);\n      }\n\n      var mainGroup = that._createBreaksGroup(positionFrom, positionTo);\n\n      if (that._axisShift && options.visible) {\n        additionBreakFrom = that._axisPosition - that._axisShift - SCALE_BREAK_OFFSET;\n        additionBreakTo = additionBreakFrom + 2 * SCALE_BREAK_OFFSET;\n        additionGroup = that._createBreaksGroup(additionBreakFrom, additionBreakTo);\n      }\n\n      breaks.forEach(function (br) {\n        if (!br.gapSize) {\n          var breakCoord = that._getTranslatedCoord(br.to);\n\n          that._drawBreak(breakCoord, positionFrom, positionTo, breakStyle.width, breakOptions, mainGroup);\n\n          if (that._axisShift && options.visible) {\n            that._drawBreak(breakCoord, additionBreakFrom, additionBreakTo, breakStyle.width, breakOptions, additionGroup);\n          }\n        }\n      });\n    },\n    _getSpiderCategoryOption: noop,\n    shift: function shift(margins) {\n      var options = this._options;\n      var isHorizontal = options.isHorizontal;\n      var axesSpacing = this.getMultipleAxesSpacing();\n      var constantLinesGroups = this._axisConstantLineGroups;\n\n      function shiftGroup(side, group) {\n        var attr = {\n          translateX: 0,\n          translateY: 0\n        };\n        var shift = margins[side] ? margins[side] + axesSpacing : 0;\n        attr[isHorizontal ? \"translateY\" : \"translateX\"] = (side === LEFT || side === TOP ? -1 : 1) * shift;\n        (group[side] || group).attr(attr);\n        return shift;\n      }\n\n      this._axisShift = shiftGroup(options.position, this._axisGroup);\n      shiftGroup(options.position, this._axisElementsGroup);\n      (isHorizontal ? [TOP, BOTTOM] : [LEFT, RIGHT]).forEach(function (side) {\n        shiftGroup(side, constantLinesGroups.above);\n        shiftGroup(side, constantLinesGroups.under);\n      });\n    },\n    getCustomPosition: function getCustomPosition(position) {\n      var orthogonalAxis = this.getOrthogonalAxis();\n      var resolvedPosition = null !== position && void 0 !== position ? position : this.getResolvedPositionOption();\n      var offset = this.getOptions().offset;\n      var orthogonalTranslator = orthogonalAxis.getTranslator();\n      var orthogonalAxisType = orthogonalAxis.getOptions().type;\n      var validPosition = orthogonalAxis.validateUnit(resolvedPosition);\n      var currentPosition;\n\n      if (\"discrete\" === orthogonalAxisType && (!orthogonalTranslator._categories || orthogonalTranslator._categories.indexOf(validPosition) < 0)) {\n        validPosition = void 0;\n      }\n\n      if (this.positionIsBoundary(resolvedPosition)) {\n        currentPosition = this.getPredefinedPosition(resolvedPosition);\n      } else if (!isDefined(validPosition)) {\n        currentPosition = this.getPredefinedPosition(this.getOptions().position);\n      } else {\n        currentPosition = orthogonalTranslator.to(validPosition, -1);\n      }\n\n      if (isFinite(currentPosition) && isFinite(offset)) {\n        currentPosition += offset;\n      }\n\n      return currentPosition;\n    },\n    getCustomBoundaryPosition: function getCustomBoundaryPosition(position) {\n      var _this$getOptions = this.getOptions(),\n          customPosition = _this$getOptions.customPosition,\n          offset = _this$getOptions.offset;\n\n      var resolvedPosition = null !== position && void 0 !== position ? position : this.getResolvedPositionOption();\n      var orthogonalAxis = this.getOrthogonalAxis();\n      var orthogonalTranslator = orthogonalAxis.getTranslator();\n      var visibleArea = orthogonalTranslator.getCanvasVisibleArea();\n\n      if (!isDefined(orthogonalAxis._orthogonalPositions) || 0 === orthogonalTranslator.canvasLength) {\n        return;\n      }\n\n      var currentPosition = this.getCustomPosition(resolvedPosition);\n\n      if (!isDefined(currentPosition)) {\n        return this.getResolvedBoundaryPosition();\n      } else if (isDefined(customPosition)) {\n        if (currentPosition <= visibleArea.min) {\n          return this._isHorizontal ? TOP : LEFT;\n        } else if (currentPosition >= visibleArea.max) {\n          return this._isHorizontal ? BOTTOM : RIGHT;\n        }\n      } else if (isDefined(offset)) {\n        if (currentPosition <= this._orthogonalPositions.start) {\n          return this._isHorizontal ? TOP : LEFT;\n        } else if (currentPosition >= this._orthogonalPositions.end) {\n          return this._isHorizontal ? BOTTOM : RIGHT;\n        }\n      }\n\n      return currentPosition;\n    },\n    getResolvedPositionOption: function getResolvedPositionOption() {\n      var _options$customPositi;\n\n      var options = this.getOptions();\n      return null !== (_options$customPositi = options.customPosition) && void 0 !== _options$customPositi ? _options$customPositi : options.position;\n    },\n    customPositionIsAvailable: function customPositionIsAvailable() {\n      var options = this.getOptions();\n      return isDefined(this.getOrthogonalAxis()) && (isDefined(options.customPosition) || isFinite(options.offset));\n    },\n    hasNonBoundaryPosition: function hasNonBoundaryPosition() {\n      return this.customPositionIsAvailable() && !this.customPositionIsBoundary();\n    },\n    getResolvedBoundaryPosition: function getResolvedBoundaryPosition() {\n      return this.customPositionIsBoundary() ? this._customBoundaryPosition : this.getOptions().position;\n    },\n    customPositionEqualsToPredefined: function customPositionEqualsToPredefined() {\n      return this.customPositionIsBoundary() && this._customBoundaryPosition === this.getOptions().position;\n    },\n    customPositionIsBoundary: function customPositionIsBoundary() {\n      return this.positionIsBoundary(this._customBoundaryPosition);\n    },\n    positionIsBoundary: function positionIsBoundary(position) {\n      return [TOP, LEFT, BOTTOM, RIGHT].indexOf(position) >= 0;\n    },\n    getPredefinedPosition: function getPredefinedPosition(position) {\n      var _this$_orthogonalPosi;\n\n      return null === (_this$_orthogonalPosi = this._orthogonalPositions) || void 0 === _this$_orthogonalPosi ? void 0 : _this$_orthogonalPosi[position === TOP || position === LEFT ? \"start\" : \"end\"];\n    },\n    resolveOverlappingForCustomPositioning: function resolveOverlappingForCustomPositioning(oppositeAxes) {\n      var that = this;\n\n      if (!that.hasNonBoundaryPosition() && !that.customPositionIsBoundary() && !oppositeAxes.some(function (a) {\n        return a.hasNonBoundaryPosition();\n      })) {\n        return;\n      }\n\n      var overlappingObj = {\n        axes: [],\n        ticks: []\n      };\n      oppositeAxes.filter(function (orthogonalAxis) {\n        return orthogonalAxis.pane === that.pane;\n      }).forEach(function (orthogonalAxis) {\n        for (var i = 0; i < that._majorTicks.length; i++) {\n          var tick = that._majorTicks[i];\n          var label = tick.label;\n\n          if (label) {\n            if (overlappingObj.axes.indexOf(orthogonalAxis) < 0 && that._detectElementsOverlapping(label, orthogonalAxis._axisElement)) {\n              overlappingObj.axes.push(orthogonalAxis);\n\n              that._shiftThroughOrthogonalAxisOverlappedTick(label, orthogonalAxis);\n            }\n\n            for (var j = 0; j < orthogonalAxis._majorTicks.length; j++) {\n              var oppositeTick = orthogonalAxis._majorTicks[j];\n              var oppositeLabel = oppositeTick.label;\n\n              if (oppositeLabel && that._detectElementsOverlapping(label, oppositeLabel)) {\n                overlappingObj.ticks.push(tick);\n\n                that._shiftThroughAxisOverlappedTick(tick);\n\n                i = that._majorTicks.length;\n                break;\n              }\n            }\n          }\n\n          if (tick.mark && overlappingObj.ticks.indexOf(tick) < 0) {\n            if (that._isHorizontal && tick.mark.attr(\"translateY\")) {\n              tick.mark.attr({\n                translateY: 0\n              });\n            } else if (!that._isHorizontal && tick.mark.attr(\"translateX\")) {\n              tick.mark.attr({\n                translateX: 0\n              });\n            }\n          }\n        }\n      });\n    },\n    _shiftThroughOrthogonalAxisOverlappedTick: function _shiftThroughOrthogonalAxisOverlappedTick(label, orthogonalAxis) {\n      var labelBBox = label.getBBox();\n      var orthogonalAxisPosition = orthogonalAxis.getAxisPosition();\n      var orthogonalAxisLabelOptions = orthogonalAxis.getOptions().label;\n      var orthogonalAxisLabelPosition = orthogonalAxisLabelOptions.position;\n      var orthogonalAxisLabelIndent = orthogonalAxisLabelOptions.indentFromAxis / 2;\n      var translateCoordName = this._isHorizontal ? \"translateX\" : \"translateY\";\n      var defaultOrthogonalAxisLabelPosition = this._isHorizontal ? LEFT : TOP;\n      var translate = label.attr(translateCoordName);\n      var labelCoord = (this._isHorizontal ? labelBBox.x : labelBBox.y) + translate;\n      var labelSize = this._isHorizontal ? labelBBox.width : labelBBox.height;\n      var outsidePart = orthogonalAxisPosition - labelCoord;\n      var insidePart = labelCoord + labelSize - orthogonalAxisPosition;\n      var attr = {};\n      attr[translateCoordName] = translate;\n\n      if (outsidePart > 0 && insidePart > 0) {\n        if (insidePart - outsidePart > 1) {\n          attr[translateCoordName] += outsidePart + orthogonalAxisLabelIndent;\n        } else if (outsidePart - insidePart > 1) {\n          attr[translateCoordName] -= insidePart + orthogonalAxisLabelIndent;\n        } else {\n          attr[translateCoordName] += orthogonalAxisLabelPosition === defaultOrthogonalAxisLabelPosition ? outsidePart + orthogonalAxisLabelIndent : -(insidePart + orthogonalAxisLabelIndent);\n        }\n\n        label.attr(attr);\n      }\n    },\n    _shiftThroughAxisOverlappedTick: function _shiftThroughAxisOverlappedTick(tick) {\n      var _tick$mark;\n\n      var label = tick.label;\n\n      if (!label) {\n        return;\n      }\n\n      var labelBBox = label.getBBox();\n      var tickMarkBBox = null === (_tick$mark = tick.mark) || void 0 === _tick$mark ? void 0 : _tick$mark.getBBox();\n      var axisPosition = this.getAxisPosition();\n      var labelOptions = this.getOptions().label;\n      var labelIndent = labelOptions.indentFromAxis;\n      var labelPosition = labelOptions.position;\n      var defaultLabelPosition = this._isHorizontal ? TOP : LEFT;\n      var translateCoordName = this._isHorizontal ? \"translateY\" : \"translateX\";\n      var translate = label.attr(translateCoordName);\n      var labelCoord = (this._isHorizontal ? labelBBox.y : labelBBox.x) + translate;\n      var labelSize = this._isHorizontal ? labelBBox.height : labelBBox.width;\n      var attr = {};\n      attr[translateCoordName] = translate + (labelPosition === defaultLabelPosition ? axisPosition - labelCoord + labelIndent : -(labelCoord - axisPosition + labelSize + labelIndent));\n      label.attr(attr);\n\n      if (tick.mark) {\n        var markerSize = this._isHorizontal ? tickMarkBBox.height : tickMarkBBox.width;\n        var dir = labelPosition === defaultLabelPosition ? 1 : -1;\n        attr[translateCoordName] = dir * (markerSize - 1);\n        tick.mark.attr(attr);\n      }\n    },\n    _detectElementsOverlapping: function _detectElementsOverlapping(element1, element2) {\n      if (!element1 || !element2) {\n        return false;\n      }\n\n      var bBox1 = element1.getBBox();\n      var x1 = bBox1.x + element1.attr(\"translateX\");\n      var y1 = bBox1.y + element1.attr(\"translateY\");\n      var bBox2 = element2.getBBox();\n      var x2 = bBox2.x + element2.attr(\"translateX\");\n      var y2 = bBox2.y + element2.attr(\"translateY\");\n      return (x2 >= x1 && x2 <= x1 + bBox1.width || x1 >= x2 && x1 <= x2 + bBox2.width) && (y2 >= y1 && y2 <= y1 + bBox1.height || y1 >= y2 && y1 <= y2 + bBox2.height);\n    }\n  }\n};\n\nfunction getLineDrawer(renderer, root, rotatePoints, positionFrom, breakStart, positionTo, isWaved) {\n  var elementType = isWaved ? \"bezier\" : \"line\";\n  var group = renderer.g().append(root);\n  return function (offset, attr) {\n    renderer.path(rotatePoints(getPoints(positionFrom, breakStart, positionTo, offset, isWaved)), elementType).attr(attr).append(group);\n  };\n}\n\nfunction getPoints(positionFrom, breakStart, positionTo, offset, isWaved) {\n  if (!isWaved) {\n    return [positionFrom, breakStart + offset, positionTo, breakStart + offset];\n  }\n\n  breakStart += offset;\n  var currentPosition;\n  var topPoint = breakStart + WAVED_LINE_TOP;\n  var centerPoint = breakStart + WAVED_LINE_CENTER;\n  var bottomPoint = breakStart + WAVED_LINE_BOTTOM;\n  var points = [[positionFrom, centerPoint]];\n\n  for (currentPosition = positionFrom; currentPosition < positionTo + WAVED_LINE_LENGTH; currentPosition += WAVED_LINE_LENGTH) {\n    points.push([currentPosition + 6, topPoint, currentPosition + 6, topPoint, currentPosition + 12, centerPoint, currentPosition + 18, bottomPoint, currentPosition + 18, bottomPoint, currentPosition + 24, centerPoint]);\n  }\n\n  return [].concat.apply([], points);\n}\n\nfunction rotateLine(lineCoords) {\n  var points = [];\n  var i;\n\n  for (i = 0; i < lineCoords.length; i += 2) {\n    points.push(lineCoords[i + 1]);\n    points.push(lineCoords[i]);\n  }\n\n  return points;\n}","map":null,"metadata":{},"sourceType":"module"}