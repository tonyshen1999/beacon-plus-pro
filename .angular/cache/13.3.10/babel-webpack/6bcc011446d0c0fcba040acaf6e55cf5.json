{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/pivot_grid/local_store.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { when, Deferred } from \"../../core/utils/deferred\";\nimport { aggregators } from \"../../data/utils\";\nimport dataQuery from \"../../data/query\";\nimport dateSerialization from \"../../core/utils/date_serialization\";\nimport { DataSource } from \"../../data/data_source/data_source\";\nimport CustomStore from \"../../data/custom_store\";\nimport { compileGetter, toComparable } from \"../../core/utils/data\";\nimport Class from \"../../core/class\";\nimport { noop } from \"../../core/utils/common\";\nimport { isNumeric, isDefined, isString } from \"../../core/utils/type\";\nimport { each } from \"../../core/utils/iterator\";\nimport { getFiltersByPath, setFieldProperty, setDefaultFieldValueFormatting, storeDrillDownMixin, discoverObjectFields } from \"./ui.pivot_grid.utils\";\nimport ArrayStore from \"../../data/array_store\";\nvar PATH_DELIMETER = \"/./\";\nexport var LocalStore = Class.inherit(function () {\n  var DATE_INTERVAL_SELECTORS = {\n    year: function year(date) {\n      return date && date.getFullYear();\n    },\n    quarter: function quarter(date) {\n      return date && Math.floor(date.getMonth() / 3) + 1;\n    },\n    month: function month(date) {\n      return date && date.getMonth() + 1;\n    },\n    day: function day(date) {\n      return date && date.getDate();\n    },\n    dayOfWeek: function dayOfWeek(date) {\n      return date && date.getDay();\n    }\n  };\n\n  function getDataSelector(dataField) {\n    return -1 !== dataField.indexOf(\".\") ? compileGetter(dataField) : function (data) {\n      return data[dataField];\n    };\n  }\n\n  function getDateValue(dataSelector) {\n    return function (data) {\n      var value = dataSelector(data);\n\n      if (value && !(value instanceof Date)) {\n        value = dateSerialization.deserializeDate(value);\n      }\n\n      return value;\n    };\n  }\n\n  function prepareFields(fields) {\n    each(fields || [], function (_, field) {\n      var fieldSelector;\n      var intervalSelector;\n      var dataField = field.dataField;\n      var groupInterval;\n      var levels = field.levels;\n      var dataSelector;\n\n      if (!field.selector) {\n        if (!dataField) {\n          dataSelector = function dataSelector(data) {\n            return data;\n          };\n        } else {\n          dataSelector = getDataSelector(dataField);\n        }\n\n        if (levels) {\n          prepareFields(levels);\n        }\n\n        if (\"date\" === field.dataType) {\n          intervalSelector = DATE_INTERVAL_SELECTORS[field.groupInterval];\n          var valueSelector = getDateValue(dataSelector);\n\n          fieldSelector = function fieldSelector(data) {\n            var value = valueSelector(data);\n            return intervalSelector ? intervalSelector(value) : value;\n          };\n        } else if (\"number\" === field.dataType) {\n          groupInterval = isNumeric(field.groupInterval) && field.groupInterval > 0 && field.groupInterval;\n\n          fieldSelector = function fieldSelector(data) {\n            var value = dataSelector(data);\n\n            if (isString(value)) {\n              value = Number(value);\n            }\n\n            return groupInterval ? Math.floor(value / groupInterval) * groupInterval : value;\n          };\n        } else {\n          fieldSelector = dataSelector;\n        }\n\n        setDefaultFieldValueFormatting(field);\n        setFieldProperty(field, \"selector\", fieldSelector);\n      }\n    });\n  }\n\n  function generateHierarchyItems(data, loadOptions, headers, headerName) {\n    var result = [0];\n    var expandIndex = loadOptions.headerName === headerName ? loadOptions.path.length : 0;\n    var expandedPaths = \"rows\" === headerName ? loadOptions.rowExpandedPaths : loadOptions.columnExpandedPaths;\n    var options = {\n      data: data,\n      childrenHash: headers[headerName + \"Hash\"],\n      dimensions: loadOptions[headerName],\n      expandedPathsHash: loadOptions.headerName !== headerName && expandedPaths && expandedPaths.hash\n    };\n    !function fillHierarchyItemIndexesCore(indexes, options, children, expandIndex, pathHash) {\n      var dimension = options.dimensions[expandIndex];\n      var expandedPathsHash = options.expandedPathsHash;\n      var dimensionValue;\n      var hierarchyItem;\n\n      if (dimension) {\n        dimensionValue = dimension.selector(options.data);\n        pathHash = void 0 !== pathHash ? pathHash + PATH_DELIMETER + dimensionValue : dimensionValue + \"\";\n\n        hierarchyItem = function (value, hierarchyItems, pathHash, childrenHash) {\n          var hierarchyItem = childrenHash[pathHash];\n\n          if (!hierarchyItem) {\n            hierarchyItem = {\n              value: value,\n              index: childrenHash.length++\n            };\n            childrenHash[pathHash] = hierarchyItem;\n            hierarchyItems.push(hierarchyItem);\n          }\n\n          return hierarchyItem;\n        }(dimensionValue, children, pathHash, options.childrenHash);\n\n        indexes.push(hierarchyItem.index);\n\n        if (expandedPathsHash && expandedPathsHash[pathHash] || dimension.expanded) {\n          if (!hierarchyItem.children) {\n            hierarchyItem.children = [];\n          }\n\n          fillHierarchyItemIndexesCore(indexes, options, hierarchyItem.children, expandIndex + 1, pathHash);\n        }\n      }\n    }(result, options, headers[headerName], expandIndex);\n    return result;\n  }\n\n  function generateAggregationCells(data, cells, headers, options) {\n    var cellSet = [];\n    var x;\n    var y;\n    var rowIndex;\n    var columnIndex;\n    var rowIndexes = generateHierarchyItems(data, options, headers, \"rows\");\n    var columnIndexes = generateHierarchyItems(data, options, headers, \"columns\");\n\n    for (y = 0; y < rowIndexes.length; y++) {\n      rowIndex = rowIndexes[y];\n      cells[rowIndex] = cells[rowIndex] || [];\n\n      for (x = 0; x < columnIndexes.length; x++) {\n        columnIndex = columnIndexes[x];\n        cellSet.push(cells[rowIndex][columnIndex] = cells[rowIndex][columnIndex] || []);\n      }\n    }\n\n    return cellSet;\n  }\n\n  function fillHashExpandedPath(expandedPaths) {\n    if (expandedPaths) {\n      var hash = expandedPaths.hash = {};\n      expandedPaths.forEach(function (path) {\n        var pathValue = path.map(function (value) {\n          return value + \"\";\n        }).join(PATH_DELIMETER);\n        hash[pathValue] = true;\n      });\n    }\n  }\n\n  function prepareLoadOption(options) {\n    options.rows = options.rows || [];\n    options.columns = options.columns || [];\n    options.filters = options.filters || [];\n    fillHashExpandedPath(options.columnExpandedPaths);\n    fillHashExpandedPath(options.rowExpandedPaths);\n    prepareFields(options.columns);\n    prepareFields(options.rows);\n    prepareFields(options.values);\n    prepareFields(options.filters);\n  }\n\n  function getAggregator(field) {\n    if (\"custom\" === field.summaryType) {\n      field.calculateCustomSummary = field.calculateCustomSummary || noop;\n      return {\n        seed: function seed() {\n          var options = {\n            summaryProcess: \"start\",\n            totalValue: void 0\n          };\n          field.calculateCustomSummary(options);\n          return options;\n        },\n        step: function step(options, value) {\n          options.summaryProcess = \"calculate\";\n          options.value = value;\n          field.calculateCustomSummary(options);\n          return options;\n        },\n        finalize: function finalize(options) {\n          options.summaryProcess = \"finalize\";\n          delete options.value;\n          field.calculateCustomSummary(options);\n          return options.totalValue;\n        }\n      };\n    }\n\n    return aggregators[field.summaryType] || aggregators.count;\n  }\n\n  function aggregationStep(measures, aggregationCells, data) {\n    for (var aggregatorIndex = 0; aggregatorIndex < measures.length; aggregatorIndex++) {\n      var cellField = measures[aggregatorIndex];\n      var cellValue = cellField.selector(data);\n      var aggregator = getAggregator(cellField);\n      var isAggregatorSeedFunction = \"function\" === typeof aggregator.seed;\n\n      for (var cellSetIndex = 0; cellSetIndex < aggregationCells.length; cellSetIndex++) {\n        var cell = aggregationCells[cellSetIndex];\n\n        if (cell.length <= aggregatorIndex) {\n          cell[aggregatorIndex] = isAggregatorSeedFunction ? aggregator.seed() : aggregator.seed;\n        }\n\n        if (void 0 === cell[aggregatorIndex]) {\n          cell[aggregatorIndex] = cellValue;\n        } else if (isDefined(cellValue)) {\n          cell[aggregatorIndex] = aggregator.step(cell[aggregatorIndex], cellValue);\n        }\n      }\n    }\n  }\n\n  function areValuesEqual(filterValue, fieldValue) {\n    var valueOfFilter = filterValue && filterValue.valueOf();\n    var valueOfField = fieldValue && fieldValue.valueOf();\n\n    if (Array.isArray(filterValue)) {\n      fieldValue = fieldValue || [];\n\n      for (var i = 0; i < filterValue.length; i++) {\n        valueOfFilter = filterValue[i] && filterValue[i].valueOf();\n        valueOfField = fieldValue[i] && fieldValue[i].valueOf();\n\n        if (valueOfFilter !== valueOfField) {\n          return false;\n        }\n      }\n\n      return true;\n    } else {\n      return valueOfFilter === valueOfField;\n    }\n  }\n\n  function createDimensionFilters(dimension) {\n    var filters = [];\n    each(dimension, function (_, field) {\n      var filterValues = field.filterValues || [];\n      var groupName = field.groupName;\n\n      if (groupName && isNumeric(field.groupIndex)) {\n        return;\n      }\n\n      filterValues.length && filters.push(function (dataItem) {\n        var value = field.levels ? function (levels, data) {\n          var value = [];\n          each(levels, function (_, field) {\n            value.push(field.selector(data));\n          });\n          return value;\n        }(field.levels, dataItem) : field.selector(dataItem);\n        var result = false;\n\n        for (var i = 0; i < filterValues.length; i++) {\n          if (areValuesEqual(filterValues[i], value)) {\n            result = true;\n            break;\n          }\n        }\n\n        return \"exclude\" === field.filterType ? !result : result;\n      });\n    });\n    return filters;\n  }\n\n  function createFilter(options) {\n    var filters = createDimensionFilters(options.rows).concat(createDimensionFilters(options.columns)).concat(createDimensionFilters(options.filters));\n    var expandedDimensions = options[options.headerName];\n    var path = options.path;\n\n    if (expandedDimensions) {\n      filters.push(function (dataItem) {\n        var expandValue;\n\n        for (var i = 0; i < path.length; i++) {\n          expandValue = expandedDimensions[i].selector(dataItem);\n\n          if (toComparable(expandValue, true) !== toComparable(path[i], true)) {\n            return false;\n          }\n        }\n\n        return true;\n      });\n    }\n\n    return function (dataItem) {\n      for (var i = 0; i < filters.length; i++) {\n        if (!filters[i](dataItem)) {\n          return false;\n        }\n      }\n\n      return true;\n    };\n  }\n\n  function loadCore(items, options, notifyProgress) {\n    var headers = {\n      columns: [],\n      rows: [],\n      columnsHash: {\n        length: 1\n      },\n      rowsHash: {\n        length: 1\n      }\n    };\n    var values = [];\n    var aggregationCells;\n    var data;\n    var d = new Deferred();\n    var i = 0;\n    var filter = createFilter(options);\n    !function processData() {\n      var t = new Date();\n      var startIndex = i;\n\n      for (; i < items.length; i++) {\n        if (i > startIndex && i % 1e4 === 0) {\n          if (new Date() - t >= 300) {\n            notifyProgress(i / items.length);\n            setTimeout(processData, 0);\n            return;\n          }\n        }\n\n        data = items[i];\n\n        if (filter(data)) {\n          aggregationCells = generateAggregationCells(data, values, headers, options);\n          aggregationStep(options.values, aggregationCells, data);\n        }\n      }\n\n      measures = options.values, cells = values, void each(measures, function (aggregatorIndex, cellField) {\n        var aggregator = getAggregator(cellField);\n\n        if (aggregator.finalize) {\n          each(cells, function (_, row) {\n            each(row, function (_, cell) {\n              if (cell && void 0 !== cell[aggregatorIndex]) {\n                cell[aggregatorIndex] = aggregator.finalize(cell[aggregatorIndex]);\n              }\n            });\n          });\n        }\n      });\n      var measures, cells;\n      notifyProgress(1);\n      d.resolve({\n        rows: headers.rows,\n        columns: headers.columns,\n        values: values,\n        grandTotalRowIndex: 0,\n        grandTotalColumnIndex: 0\n      });\n    }();\n    return d;\n  }\n\n  function filterDataSource(dataSource, fieldSelectors) {\n    var filter = dataSource.filter();\n\n    if (dataSource.store() instanceof CustomStore && filter) {\n      filter = processFilter(filter, fieldSelectors);\n      return dataQuery(dataSource.items()).filter(filter).toArray();\n    }\n\n    return dataSource.items();\n  }\n\n  function loadDataSource(dataSource, fieldSelectors, reload) {\n    var d = new Deferred();\n\n    var customizeStoreLoadOptionsHandler = function customizeStoreLoadOptionsHandler(options) {\n      if (dataSource.store() instanceof ArrayStore) {\n        options.storeLoadOptions.filter = processFilter(options.storeLoadOptions.filter, fieldSelectors);\n      }\n    };\n\n    dataSource.on(\"customizeStoreLoadOptions\", customizeStoreLoadOptionsHandler);\n\n    if (!dataSource.isLoaded() || reload) {\n      var loadDeferred = reload ? dataSource.load() : dataSource.reload();\n      when(loadDeferred).done(function () {\n        loadDataSource(dataSource, fieldSelectors).done(function () {\n          d.resolve(filterDataSource(dataSource, fieldSelectors));\n        }).fail(d.reject);\n      }).fail(d.reject);\n    } else {\n      d.resolve(filterDataSource(dataSource, fieldSelectors));\n    }\n\n    return d.always(function () {\n      dataSource.off(\"customizeStoreLoadOptions\", customizeStoreLoadOptionsHandler);\n    });\n  }\n\n  function fillSelectorsByFields(selectors, fields) {\n    fields.forEach(function (field) {\n      if (field.dataField && \"date\" === field.dataType) {\n        var valueSelector = getDateValue(getDataSelector(field.dataField));\n\n        selectors[field.dataField] = function (data) {\n          return valueSelector(data);\n        };\n      }\n    });\n  }\n\n  function getFieldSelectors(options) {\n    var selectors = {};\n\n    if (Array.isArray(options)) {\n      fillSelectorsByFields(selectors, options);\n    } else if (options) {\n      [\"rows\", \"columns\", \"filters\"].forEach(function (area) {\n        options[area] && fillSelectorsByFields(selectors, options[area]);\n      });\n    }\n\n    return selectors;\n  }\n\n  function processFilter(filter, fieldSelectors) {\n    if (!Array.isArray(filter)) {\n      return filter;\n    }\n\n    filter = filter.slice(0);\n\n    if (isString(filter[0]) && (filter[1] instanceof Date || filter[2] instanceof Date)) {\n      filter[0] = fieldSelectors[filter[0]];\n    }\n\n    for (var i = 0; i < filter.length; i++) {\n      filter[i] = processFilter(filter[i], fieldSelectors);\n    }\n\n    return filter;\n  }\n\n  return {\n    ctor: function ctor(options) {\n      this._progressChanged = options.onProgressChanged || noop;\n      this._dataSource = new DataSource(options);\n\n      this._dataSource.paginate(false);\n    },\n    getFields: function getFields(fields) {\n      var dataSource = this._dataSource;\n      var d = new Deferred();\n      loadDataSource(dataSource, getFieldSelectors(fields)).done(function (data) {\n        d.resolve(discoverObjectFields(data, fields));\n      }).fail(d.reject);\n      return d;\n    },\n    key: function key() {\n      return this._dataSource.key();\n    },\n    load: function load(options) {\n      var that = this;\n      var dataSource = that._dataSource;\n      var d = new Deferred();\n      prepareLoadOption(options);\n      loadDataSource(dataSource, getFieldSelectors(options), options.reload).done(function (data) {\n        when(loadCore(data, options, that._progressChanged)).done(d.resolve);\n      }).fail(d.reject);\n      return d;\n    },\n    filter: function filter() {\n      var dataSource = this._dataSource;\n      return dataSource.filter.apply(dataSource, arguments);\n    },\n    supportPaging: function supportPaging() {\n      return false;\n    },\n    getDrillDownItems: function getDrillDownItems(loadOptions, params) {\n      loadOptions = loadOptions || {};\n      params = params || {};\n      prepareLoadOption(loadOptions);\n      var drillDownItems = [];\n\n      var items = this._dataSource.items();\n\n      var item;\n      var maxRowCount = params.maxRowCount;\n      var customColumns = params.customColumns;\n      var filter = createFilter(loadOptions);\n      var pathFilter = createFilter({\n        rows: getFiltersByPath(loadOptions.rows, params.rowPath),\n        columns: getFiltersByPath(loadOptions.columns, params.columnPath),\n        filters: []\n      });\n\n      for (var i = 0; i < items.length; i++) {\n        if (pathFilter(items[i]) && filter(items[i])) {\n          if (customColumns) {\n            item = {};\n\n            for (var j = 0; j < customColumns.length; j++) {\n              item[customColumns[j]] = items[i][customColumns[j]];\n            }\n          } else {\n            item = items[i];\n          }\n\n          drillDownItems.push(item);\n        }\n\n        if (maxRowCount > 0 && drillDownItems.length === maxRowCount) {\n          break;\n        }\n      }\n\n      return drillDownItems;\n    }\n  };\n}()).include(storeDrillDownMixin);","map":null,"metadata":{},"sourceType":"module"}