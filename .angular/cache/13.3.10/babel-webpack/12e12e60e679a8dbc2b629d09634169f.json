{"ast":null,"code":"import _slicedToArray from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\n\n/**\r\n * DevExtreme (esm/viz/axes/tick_generator.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { getLogExt as getLog, getCategoriesInfo, raiseToExt, getLog as mathLog, raiseTo as mathRaise } from \"../core/utils\";\nimport dateUtils from \"../../core/utils/date\";\nimport { isDefined, isString } from \"../../core/utils/type\";\nimport { adjust, sign } from \"../../core/utils/math\";\nimport { extend } from \"../../core/utils/extend\";\nvar convertDateUnitToMilliseconds = dateUtils.convertDateUnitToMilliseconds;\nvar dateToMilliseconds = dateUtils.dateToMilliseconds;\nvar math = Math;\nvar mathAbs = math.abs;\nvar mathFloor = math.floor;\nvar mathCeil = math.ceil;\nvar mathPow = math.pow;\nvar NUMBER_MULTIPLIERS = [1, 2, 2.5, 5];\nvar LOGARITHMIC_MULTIPLIERS = [1, 2, 3, 5];\nvar DATETIME_MULTIPLIERS = {\n  millisecond: [1, 2, 5, 10, 25, 50, 100, 250, 500],\n  second: [1, 2, 3, 5, 10, 15, 20, 30],\n  minute: [1, 2, 3, 5, 10, 15, 20, 30],\n  hour: [1, 2, 3, 4, 6, 8, 12],\n  day: [1, 2],\n  week: [1, 2],\n  month: [1, 2, 3, 6]\n};\nvar DATETIME_MULTIPLIERS_WITH_BIG_WEEKEND = extend({}, DATETIME_MULTIPLIERS, {\n  day: [1]\n});\nvar DATETIME_MINOR_MULTIPLIERS = {\n  millisecond: [1, 2, 5, 10, 25, 50, 100, 250, 500],\n  second: [1, 2, 3, 5, 10, 15, 20, 30],\n  minute: [1, 2, 3, 5, 10, 15, 20, 30],\n  hour: [1, 2, 3, 4, 6, 8, 12],\n  day: [1, 2, 3, 7, 14],\n  month: [1, 2, 3, 6]\n};\nvar MINOR_DELIMITERS = [2, 4, 5, 8, 10];\nvar VISIBILITY_DELIMITER = 3;\nvar MINUTE = 6e4;\n\nfunction dummyGenerator(options) {\n  return function (data, screenDelta, tickInterval, forceTickInterval) {\n    var count = mathFloor(screenDelta / options.axisDivisionFactor);\n    count = count < 1 ? 1 : count;\n    var interval = screenDelta / count;\n    return {\n      ticks: interval > 0 ? Array.apply(null, new Array(count + 1)).map(function (_, i) {\n        return interval * i;\n      }) : [],\n      tickInterval: interval\n    };\n  };\n}\n\nfunction discreteGenerator(options) {\n  return function (data, screenDelta, tickInterval, forceTickInterval) {\n    var categories = getCategoriesInfo(data.categories, data.min, data.max).categories;\n    return {\n      ticks: categories,\n      tickInterval: mathCeil(categories.length * options.axisDivisionFactor / screenDelta)\n    };\n  };\n}\n\nvar getValue = function getValue(value) {\n  return value;\n};\n\nvar getLogValue = function getLogValue(base, allowNegatives, linearThreshold) {\n  return function (value) {\n    return getLog(value, base, allowNegatives, linearThreshold);\n  };\n};\n\nvar raiseTo = function raiseTo(base, allowNegatives, linearThreshold) {\n  return function (value) {\n    return raiseToExt(value, base, allowNegatives, linearThreshold);\n  };\n};\n\nvar mathRaiseTo = function mathRaiseTo(base) {\n  return function (value) {\n    return mathRaise(value, base);\n  };\n};\n\nvar logAbsValue = function logAbsValue(base) {\n  return function (value) {\n    return 0 === value ? 0 : mathLog(mathAbs(value), base);\n  };\n};\n\nvar correctValueByInterval = function correctValueByInterval(post, round, getValue) {\n  return function (value, interval) {\n    return adjust(post(round(adjust(getValue(value) / interval)) * interval));\n  };\n};\n\nfunction correctMinValueByEndOnTick(floorFunc, ceilFunc, resolveEndOnTick, endOnTick) {\n  if (isDefined(endOnTick)) {\n    return endOnTick ? floorFunc : ceilFunc;\n  }\n\n  return function (value, interval, businessViewInfo, forceEndOnTick) {\n    var floorTickValue = floorFunc(value, interval);\n\n    if (value - floorTickValue === 0 || !isDefined(businessViewInfo) || resolveEndOnTick(value, floorTickValue, interval, businessViewInfo) || forceEndOnTick) {\n      return floorTickValue;\n    }\n\n    return ceilFunc(value, interval);\n  };\n}\n\nfunction resolveEndOnTick(curValue, tickValue, interval, businessViewInfo) {\n  var prevTickDataDiff = interval - mathAbs(tickValue - curValue);\n  var intervalCount = math.max(mathCeil(businessViewInfo.businessDelta / interval), 2);\n  var businessRatio = businessViewInfo.screenDelta / (intervalCount * interval);\n  var potentialTickScreenDiff = math.round(businessRatio * prevTickDataDiff);\n  var delimiterFactor = getLog(businessRatio * interval / businessViewInfo.axisDivisionFactor, 2) + 1;\n  var delimiterMultiplier = (businessViewInfo.isSpacedMargin ? 2 : 1) * delimiterFactor;\n  var screenDelimiter = math.round(VISIBILITY_DELIMITER * delimiterMultiplier);\n  return businessViewInfo.businessDelta > businessViewInfo.interval && potentialTickScreenDiff >= screenDelimiter;\n}\n\nfunction resolveEndOnTickLog(base) {\n  return function (curValue, tickValue, interval, businessViewInfo) {\n    return resolveEndOnTick(getLog(curValue, base), getLog(tickValue, base), interval, businessViewInfo);\n  };\n}\n\nfunction resolveEndOnTickDate(curValue, tickValue, interval, businessViewInfo) {\n  return resolveEndOnTick(curValue.valueOf(), tickValue.valueOf(), dateToMilliseconds(interval), businessViewInfo);\n}\n\nfunction getBusinessDelta(data, breaks) {\n  var spacing = 0;\n\n  if (breaks) {\n    spacing = breaks.reduce(function (prev, item) {\n      return prev + (item.to - item.from);\n    }, 0);\n  }\n\n  return mathAbs(data.max - data.min - spacing);\n}\n\nfunction getBusinessDeltaLog(base, allowNegatives, linearThreshold) {\n  var getLog = getLogValue(base, allowNegatives, linearThreshold);\n  return function (data, breaks) {\n    var spacing = 0;\n\n    if (breaks) {\n      spacing = breaks.reduce(function (prev, item) {\n        return prev + mathAbs(getLog(item.to / item.from));\n      }, 0);\n    }\n\n    return mathCeil(mathAbs(getLog(data.max) - getLog(data.min)) - spacing);\n  };\n}\n\nfunction getIntervalByFactor(businessDelta, screenDelta, axisDivisionFactor, addTickCount) {\n  var count = screenDelta / axisDivisionFactor - (addTickCount || 0);\n  count = count < 1 ? 1 : count;\n  return businessDelta / count;\n}\n\nfunction getMultiplierFactor(interval, factorDelta) {\n  return mathPow(10, mathFloor(getLog(interval, 10)) + (factorDelta || 0));\n}\n\nfunction calculateTickInterval(businessDelta, screenDelta, tickInterval, forceTickInterval, axisDivisionFactor, multipliers, allowDecimals, addTickCount, _, minTickInterval) {\n  var interval = getIntervalByFactor(businessDelta, screenDelta, axisDivisionFactor, addTickCount);\n  var result = 1;\n  var onlyIntegers = false === allowDecimals;\n\n  if (!forceTickInterval || !tickInterval) {\n    if (interval >= 1 || !onlyIntegers && interval > 0) {\n      result = adjustInterval(interval, multipliers, onlyIntegers);\n    }\n\n    if (!tickInterval || !forceTickInterval && tickInterval < result) {\n      tickInterval = result;\n    }\n  }\n\n  if (!forceTickInterval && minTickInterval) {\n    minTickInterval = adjustInterval(minTickInterval, multipliers, onlyIntegers);\n\n    if (minTickInterval > tickInterval) {\n      tickInterval = minTickInterval;\n    }\n  }\n\n  return tickInterval;\n}\n\nfunction adjustInterval(interval, multipliers, onlyIntegers) {\n  var factor = getMultiplierFactor(interval, -1);\n  var result = 1;\n  multipliers = multipliers || NUMBER_MULTIPLIERS;\n\n  if (interval > 0) {\n    interval /= factor;\n    result = multipliers.concat(10 * multipliers[0]).map(function (m) {\n      return 10 * m;\n    }).reduce(function (r, m) {\n      if (.1 === factor && onlyIntegers && 25 === m) {\n        return r;\n      }\n\n      return r < interval ? m : r;\n    }, 0);\n    result = adjust(result * factor, factor);\n  }\n\n  return result;\n}\n\nfunction calculateMinorTickInterval(businessDelta, screenDelta, tickInterval, axisDivisionFactor) {\n  var interval = getIntervalByFactor(businessDelta, screenDelta, axisDivisionFactor);\n  return tickInterval || MINOR_DELIMITERS.reduce(function (r, d) {\n    var cur = businessDelta / d;\n    return cur >= interval ? cur : r;\n  }, 0);\n}\n\nfunction getCalculateTickIntervalLog(skipCalculationLimits) {\n  return function (businessDelta, screenDelta, tickInterval, forceTickInterval, axisDivisionFactor, multipliers, allowDecimals, _, __, minTickInterval) {\n    var interval = getIntervalByFactor(businessDelta, screenDelta, axisDivisionFactor);\n    var result = 0;\n    var adjustInterval = getAdjustIntervalLog(skipCalculationLimits);\n\n    if (!forceTickInterval || !tickInterval) {\n      if (interval > 0) {\n        result = adjustInterval(interval, multipliers);\n      }\n\n      if (!tickInterval || !forceTickInterval && tickInterval < result) {\n        tickInterval = result;\n      }\n    }\n\n    if (!forceTickInterval && minTickInterval) {\n      minTickInterval = adjustInterval(minTickInterval, multipliers);\n\n      if (minTickInterval > tickInterval) {\n        tickInterval = minTickInterval;\n      }\n    }\n\n    return tickInterval;\n  };\n}\n\nfunction getAdjustIntervalLog(skipCalculationLimits) {\n  return function (interval, multipliers) {\n    var factor = getMultiplierFactor(interval);\n    multipliers = multipliers || LOGARITHMIC_MULTIPLIERS;\n\n    if (!skipCalculationLimits && factor < 1) {\n      factor = 1;\n    }\n\n    return multipliers.concat(10 * multipliers[0]).reduce(function (r, m) {\n      return r < interval ? m * factor : r;\n    }, 0);\n  };\n}\n\nfunction getDataTimeMultipliers(gapSize) {\n  if (gapSize && gapSize > 2) {\n    return DATETIME_MULTIPLIERS_WITH_BIG_WEEKEND;\n  } else {\n    return DATETIME_MULTIPLIERS;\n  }\n}\n\nfunction numbersReducer(interval, key) {\n  return function (r, m) {\n    if (!r && interval <= convertDateUnitToMilliseconds(key, m)) {\n      r = {};\n      r[key + \"s\"] = m;\n    }\n\n    return r;\n  };\n}\n\nfunction yearsReducer(interval, factor) {\n  return function (r, m) {\n    var years = factor * m;\n\n    if (!r && interval <= convertDateUnitToMilliseconds(\"year\", years) && 2.5 !== years) {\n      r = {\n        years: years\n      };\n    }\n\n    return r;\n  };\n}\n\nfunction calculateTickIntervalDateTime(businessDelta, screenDelta, tickInterval, forceTickInterval, axisDivisionFactor, multipliers, allowDecimals, addTickCount, gapSize, minTickInterval) {\n  if (!forceTickInterval || !tickInterval) {\n    var result = adjustIntervalDateTime(getIntervalByFactor(businessDelta, screenDelta, axisDivisionFactor), multipliers, null, gapSize);\n\n    if (!tickInterval || !forceTickInterval && dateToMilliseconds(tickInterval) <= dateToMilliseconds(result)) {\n      tickInterval = result;\n    }\n  }\n\n  if (!forceTickInterval && minTickInterval) {\n    minTickInterval = adjustIntervalDateTime(minTickInterval, multipliers, null, gapSize);\n\n    if (dateToMilliseconds(minTickInterval) > dateToMilliseconds(tickInterval)) {\n      tickInterval = minTickInterval;\n    }\n  }\n\n  return tickInterval;\n}\n\nfunction adjustIntervalDateTime(interval, multipliers, _, gapSize) {\n  var result;\n  multipliers = multipliers || getDataTimeMultipliers(gapSize);\n\n  for (var key in multipliers) {\n    result = multipliers[key].reduce(numbersReducer(interval, key), result);\n\n    if (result) {\n      break;\n    }\n  }\n\n  if (!result) {\n    for (var factor = 1;; factor *= 10) {\n      result = NUMBER_MULTIPLIERS.reduce(yearsReducer(interval, factor), result);\n\n      if (result) {\n        break;\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction calculateMinorTickIntervalDateTime(businessDelta, screenDelta, tickInterval, axisDivisionFactor) {\n  return calculateTickIntervalDateTime(businessDelta, screenDelta, tickInterval, true, axisDivisionFactor, DATETIME_MINOR_MULTIPLIERS);\n}\n\nfunction getTickIntervalByCustomTicks(getValue, postProcess) {\n  return function (ticks) {\n    return ticks ? postProcess(mathAbs(adjust(getValue(ticks[1]) - getValue(ticks[0])))) || void 0 : void 0;\n  };\n}\n\nfunction addInterval(value, interval, isNegative) {\n  return dateUtils.addInterval(value, interval, isNegative);\n}\n\nfunction addIntervalLog(log, raise) {\n  return function (value, interval, isNegative) {\n    return raise(addInterval(log(value), interval, isNegative));\n  };\n}\n\nfunction addIntervalDate(value, interval, isNegative) {\n  return addInterval(value, interval, isNegative);\n}\n\nfunction addIntervalWithBreaks(addInterval, breaks, correctValue) {\n  breaks = breaks.filter(function (b) {\n    return !b.gapSize;\n  });\n  return function (value, interval, isNegative) {\n    var breakSize;\n    value = addInterval(value, interval, isNegative);\n\n    if (!breaks.every(function (item) {\n      if (value >= addInterval(item.from, interval) && addInterval(value, interval) < item.to) {\n        breakSize = item.to - item.from - 2 * (addInterval(item.from, interval) - item.from);\n      }\n\n      return !breakSize;\n    })) {\n      value = correctValue(addInterval(value, breakSize), interval);\n    }\n\n    return value;\n  };\n}\n\nfunction calculateTicks(addInterval, correctMinValue, adjustInterval, resolveEndOnTick) {\n  return function (data, tickInterval, endOnTick, gaps, breaks, businessDelta, screenDelta, axisDivisionFactor, generateExtraTick) {\n    var correctTickValue = correctTickValueOnGapSize(addInterval, gaps);\n    var min = data.min;\n    var max = data.max;\n    var businessViewInfo = {\n      screenDelta: screenDelta,\n      businessDelta: businessDelta,\n      axisDivisionFactor: axisDivisionFactor,\n      isSpacedMargin: data.isSpacedMargin,\n      interval: tickInterval\n    };\n    var cur = correctMinValue(min, tickInterval, businessViewInfo);\n    var ticks = [];\n\n    if (null !== breaks && void 0 !== breaks && breaks.length) {\n      addInterval = addIntervalWithBreaks(addInterval, breaks, correctMinValue);\n    }\n\n    if (cur > max) {\n      cur = correctMinValue(min, adjustInterval(businessDelta / 2), businessViewInfo);\n\n      if (cur > max) {\n        endOnTick = true;\n        cur = correctMinValue(min, tickInterval, businessViewInfo, endOnTick);\n      }\n    }\n\n    cur = correctTickValue(cur);\n    var prev;\n\n    while (cur < max && cur !== prev || generateExtraTick && cur <= max) {\n      ticks.push(cur);\n      prev = cur;\n      cur = correctTickValue(addInterval(cur, tickInterval));\n    }\n\n    if (endOnTick || cur - max === 0 || !isDefined(endOnTick) && resolveEndOnTick(max, cur, tickInterval, businessViewInfo)) {\n      ticks.push(cur);\n    }\n\n    return ticks;\n  };\n}\n\nfunction calculateMinorTicks(updateTickInterval, addInterval, correctMinValue, correctTickValue, ceil) {\n  return function (min, max, majorTicks, minorTickInterval, tickInterval, breaks, maxCount) {\n    var factor = tickInterval / minorTickInterval;\n    var lastMajor = majorTicks[majorTicks.length - 1];\n    var firstMajor = majorTicks[0];\n    var tickBalance = maxCount - 1;\n\n    if (null !== breaks && void 0 !== breaks && breaks.length) {\n      addInterval = addIntervalWithBreaks(addInterval, breaks, correctMinValue);\n    }\n\n    minorTickInterval = updateTickInterval(minorTickInterval, firstMajor, firstMajor, factor);\n\n    if (0 === minorTickInterval) {\n      return [];\n    }\n\n    var cur = correctTickValue(correctMinValue(min, tickInterval, min), minorTickInterval);\n    minorTickInterval = updateTickInterval(minorTickInterval, firstMajor, cur, factor);\n    var ticks = [];\n\n    while (cur < firstMajor && (!tickBalance || tickBalance > 0)) {\n      cur >= min && ticks.push(cur);\n      tickBalance--;\n      cur = addInterval(cur, minorTickInterval);\n    }\n\n    var middleTicks = majorTicks.reduce(function (r, tick) {\n      tickBalance = maxCount - 1;\n\n      if (null === r.prevTick) {\n        r.prevTick = tick;\n        return r;\n      }\n\n      minorTickInterval = updateTickInterval(minorTickInterval, tick, r.prevTick, factor);\n      var cur = correctTickValue(r.prevTick, minorTickInterval);\n\n      while (cur < tick && (!tickBalance || tickBalance > 0)) {\n        cur !== r.prevTick && r.minors.push(cur);\n        tickBalance--;\n        cur = addInterval(cur, minorTickInterval);\n      }\n\n      r.prevTick = tick;\n      return r;\n    }, {\n      prevTick: null,\n      minors: []\n    });\n    ticks = ticks.concat(middleTicks.minors);\n    var maxValue = ceil(max, tickInterval, min);\n    minorTickInterval = updateTickInterval(minorTickInterval, maxValue, maxValue, factor);\n    cur = correctTickValue(lastMajor, minorTickInterval);\n    var prev;\n\n    while (cur < max && cur !== prev) {\n      ticks.push(cur);\n      prev = cur;\n      cur = addInterval(cur, minorTickInterval);\n    }\n\n    if (lastMajor - max !== 0 && cur - max === 0) {\n      ticks.push(cur);\n    }\n\n    return ticks;\n  };\n}\n\nfunction filterTicks(ticks, breaks) {\n  if (breaks.length) {\n    var result = breaks.reduce(function (result, b) {\n      var tmpTicks = [];\n      var i;\n\n      for (i = result[1]; i < ticks.length; i++) {\n        var tickValue = ticks[i];\n\n        if (tickValue < b.from) {\n          tmpTicks.push(tickValue);\n        }\n\n        if (tickValue >= b.to) {\n          break;\n        }\n      }\n\n      return [result[0].concat(tmpTicks), i];\n    }, [[], 0]);\n    return result[0].concat(ticks.slice(result[1]));\n  }\n\n  return ticks;\n}\n\nfunction correctTickValueOnGapSize(addInterval, breaks) {\n  return function (value) {\n    var gapSize;\n\n    if (!breaks.every(function (item) {\n      if (value >= item.from && value < item.to) {\n        gapSize = item.gapSize;\n      }\n\n      return !gapSize;\n    })) {\n      value = addInterval(value, gapSize);\n    }\n\n    return value;\n  };\n}\n\nfunction generator(options, getBusinessDelta, calculateTickInterval, calculateMinorTickInterval, getMajorTickIntervalByCustomTicks, getMinorTickIntervalByCustomTicks, convertTickInterval, calculateTicks, calculateMinorTicks, processScaleBreaks) {\n  function correctUserTickInterval(tickInterval, businessDelta, limit) {\n    if (tickInterval && businessDelta / convertTickInterval(tickInterval) >= limit + 1) {\n      options.incidentOccurred(\"W2003\");\n      tickInterval = void 0;\n    }\n\n    return tickInterval;\n  }\n\n  return function (data, screenDelta, tickInterval, forceTickInterval, customTicks, minorTickInterval, minorTickCount, breaks) {\n    customTicks = customTicks || {};\n    var businessDelta = getBusinessDelta(data, breaks);\n\n    var result = function (customTicks) {\n      return {\n        tickInterval: getMajorTickIntervalByCustomTicks(customTicks.majors),\n        ticks: customTicks.majors || [],\n        minorTickInterval: getMinorTickIntervalByCustomTicks(customTicks.minors),\n        minorTicks: customTicks.minors || []\n      };\n    }(customTicks);\n\n    if (!isNaN(businessDelta)) {\n      if (0 === businessDelta && !customTicks.majors) {\n        result.ticks = [data.min];\n      } else {\n        result = function (ticks, data, businessDelta, screenDelta, tickInterval, forceTickInterval, customTicks, breaks) {\n          if (customTicks.majors) {\n            ticks.breaks = breaks;\n            return ticks;\n          }\n\n          var gaps = breaks.filter(function (b) {\n            return b.gapSize;\n          });\n          var majorTicks;\n          tickInterval = options.skipCalculationLimits ? tickInterval : correctUserTickInterval(tickInterval, businessDelta, screenDelta);\n          tickInterval = calculateTickInterval(businessDelta, screenDelta, tickInterval, forceTickInterval, options.axisDivisionFactor, options.numberMultipliers, options.allowDecimals, breaks.length, gaps[0] && gaps[0].gapSize.days, options.minTickInterval);\n\n          if (!options.skipTickGeneration) {\n            majorTicks = calculateTicks(data, tickInterval, options.endOnTick, gaps, breaks, businessDelta, screenDelta, options.axisDivisionFactor, options.generateExtraTick);\n            breaks = processScaleBreaks(breaks, majorTicks, tickInterval);\n            majorTicks = filterTicks(majorTicks, breaks);\n            ticks.breaks = breaks;\n            ticks.ticks = ticks.ticks.concat(majorTicks);\n          }\n\n          ticks.tickInterval = tickInterval;\n          return ticks;\n        }(result, data, businessDelta, screenDelta, tickInterval, forceTickInterval, customTicks, breaks || []);\n\n        if (!options.skipTickGeneration && businessDelta > 0) {\n          result = function (ticks, data, businessDelta, screenDelta, minorTickInterval, minorTickCount, customTicks) {\n            if (!options.calculateMinors) {\n              return ticks;\n            }\n\n            if (customTicks.minors) {\n              return ticks;\n            }\n\n            var minorBusinessDelta = convertTickInterval(ticks.tickInterval);\n            var minorScreenDelta = screenDelta * minorBusinessDelta / businessDelta;\n            var breaks = ticks.breaks;\n\n            if (!minorTickInterval && minorTickCount) {\n              minorTickInterval = getMinorTickIntervalByCustomTicks([minorBusinessDelta / (minorTickCount + 1), minorBusinessDelta / (minorTickCount + 1) * 2]);\n            } else {\n              minorTickCount = void 0;\n            }\n\n            minorTickInterval = correctUserTickInterval(minorTickInterval, minorBusinessDelta, minorScreenDelta);\n            minorTickInterval = calculateMinorTickInterval(minorBusinessDelta, minorScreenDelta, minorTickInterval, options.minorAxisDivisionFactor);\n            ticks.minorTicks = filterTicks(ticks.minorTicks.concat(calculateMinorTicks(data.min, data.max, ticks.ticks, minorTickInterval, ticks.tickInterval, breaks, minorTickCount)), breaks);\n            ticks.minorTickInterval = minorTickInterval;\n            return ticks;\n          }(result, data, businessDelta, screenDelta, minorTickInterval, minorTickCount, customTicks);\n        }\n      }\n    }\n\n    return result;\n  };\n}\n\nfunction getBaseTick(breakValue, _ref, interval, getValue) {\n  var _ref2 = _slicedToArray(_ref, 2),\n      tick = _ref2[0],\n      insideTick = _ref2[1];\n\n  if (!isDefined(tick) || mathAbs(getValue(breakValue) - getValue(tick)) / interval > .25) {\n    if (isDefined(insideTick) && mathAbs(getValue(insideTick) - getValue(tick)) / interval < 2) {\n      tick = insideTick;\n    } else if (!isDefined(tick)) {\n      tick = breakValue;\n    }\n  }\n\n  return tick;\n}\n\nfunction getScaleBreaksProcessor(convertTickInterval, getValue, addCorrection) {\n  return function (breaks, ticks, tickInterval) {\n    var interval = convertTickInterval(tickInterval);\n    var correction = .5 * interval;\n    return breaks.reduce(function (result, b) {\n      var breakTicks = ticks.filter(function (tick) {\n        return tick <= b.from;\n      });\n      var from = addCorrection(getBaseTick(b.from, [].concat(breakTicks[breakTicks.length - 1], ticks[breakTicks.length]), interval, getValue), correction);\n      breakTicks = ticks.filter(function (tick) {\n        return tick >= b.to;\n      });\n      var to = addCorrection(getBaseTick(b.to, [].concat(breakTicks[0], ticks[ticks.length - breakTicks.length - 1]), interval, getValue), -correction);\n\n      if (getValue(to) - getValue(from) < interval && !b.gapSize) {\n        return result;\n      }\n\n      if (b.gapSize) {\n        return result.concat([b]);\n      }\n\n      return result.concat([{\n        from: from,\n        to: to,\n        cumulativeWidth: b.cumulativeWidth\n      }]);\n    }, []);\n  };\n}\n\nfunction numericGenerator(options) {\n  var floor = correctValueByInterval(getValue, mathFloor, getValue);\n  var ceil = correctValueByInterval(getValue, mathCeil, getValue);\n  var calculateTickIntervalByCustomTicks = getTickIntervalByCustomTicks(getValue, getValue);\n  return generator(options, getBusinessDelta, calculateTickInterval, calculateMinorTickInterval, calculateTickIntervalByCustomTicks, calculateTickIntervalByCustomTicks, getValue, calculateTicks(addInterval, correctMinValueByEndOnTick(floor, ceil, resolveEndOnTick, options.endOnTick), adjustInterval, resolveEndOnTick), calculateMinorTicks(getValue, addInterval, floor, addInterval, getValue), getScaleBreaksProcessor(getValue, getValue, function (value, correction) {\n    return value + correction;\n  }));\n}\n\nvar correctValueByIntervalLog = function correctValueByIntervalLog(post, getRound, getValue) {\n  return function (value, interval) {\n    return sign(value) * adjust(post(getRound(value)(adjust(getValue(value) / interval)) * interval));\n  };\n};\n\nfunction logarithmicGenerator(options) {\n  var base = options.logBase;\n  var raise = raiseTo(base, options.allowNegatives, options.linearThreshold);\n  var log = getLogValue(base, options.allowNegatives, options.linearThreshold);\n  var absLog = logAbsValue(base);\n  var absRaise = mathRaiseTo(base);\n  var floor = correctValueByIntervalLog(absRaise, function (value) {\n    return value < 0 ? mathCeil : mathFloor;\n  }, absLog);\n  var ceil = correctValueByIntervalLog(absRaise, function (value) {\n    return value < 0 ? mathFloor : mathCeil;\n  }, absLog);\n  var ceilNumber = correctValueByInterval(getValue, mathCeil, getValue);\n  return generator(options, getBusinessDeltaLog(base, options.allowNegatives, options.linearThreshold), getCalculateTickIntervalLog(options.skipCalculationLimits), calculateMinorTickInterval, getTickIntervalByCustomTicks(log, getValue), getTickIntervalByCustomTicks(getValue, getValue), getValue, calculateTicks(addIntervalLog(log, raise), correctMinValueByEndOnTick(floor, ceil, resolveEndOnTickLog(base), options.endOnTick), getAdjustIntervalLog(options.skipCalculationLimits), resolveEndOnTickLog(base)), calculateMinorTicks(function (_, tick, prevTick, factor) {\n    return Math.max(Math.abs(tick), Math.abs(prevTick)) / factor;\n  }, addInterval, floor, ceilNumber, ceil), getScaleBreaksProcessor(getValue, log, function (value, correction) {\n    return raise(log(value) + correction);\n  }));\n}\n\nfunction dateGenerator(options) {\n  function floor(value, interval) {\n    var floorNumber = correctValueByInterval(getValue, mathFloor, getValue);\n    var intervalObject = isString(interval) ? dateUtils.getDateIntervalByString(interval.toLowerCase()) : interval;\n    var divider = dateToMilliseconds(interval);\n\n    if (intervalObject.days % 7 === 0 || interval.quarters) {\n      intervalObject = adjustIntervalDateTime(divider);\n    }\n\n    var correctDateWithUnitBeginning = function correctDateWithUnitBeginning(v) {\n      return dateUtils.correctDateWithUnitBeginning(v, intervalObject, null, options.firstDayOfWeek);\n    };\n\n    var floorAtStartDate = function floorAtStartDate(v) {\n      return new Date(mathFloor((v.getTime() - v.getTimezoneOffset() * MINUTE) / divider) * divider + v.getTimezoneOffset() * MINUTE);\n    };\n\n    value = correctDateWithUnitBeginning(value);\n\n    if (\"years\" in intervalObject) {\n      value.setFullYear(floorNumber(value.getFullYear(), intervalObject.years));\n    } else if (\"quarters\" in intervalObject) {\n      value = correctDateWithUnitBeginning(floorAtStartDate(value));\n    } else if (\"months\" in intervalObject) {\n      value.setMonth(floorNumber(value.getMonth(), intervalObject.months));\n    } else if (\"weeks\" in intervalObject || \"days\" in intervalObject) {\n      value = correctDateWithUnitBeginning(floorAtStartDate(value));\n    } else if (\"hours\" in intervalObject) {\n      value.setHours(floorNumber(value.getHours(), intervalObject.hours));\n    } else if (\"minutes\" in intervalObject) {\n      value.setMinutes(floorNumber(value.getMinutes(), intervalObject.minutes));\n    } else if (\"seconds\" in intervalObject) {\n      value.setSeconds(floorNumber(value.getSeconds(), intervalObject.seconds));\n    } else if (\"milliseconds\" in intervalObject) {\n      value = floorAtStartDate(value);\n    }\n\n    return value;\n  }\n\n  var calculateTickIntervalByCustomTicks = getTickIntervalByCustomTicks(getValue, dateUtils.convertMillisecondsToDateUnits);\n  return generator(options, getBusinessDelta, calculateTickIntervalDateTime, calculateMinorTickIntervalDateTime, calculateTickIntervalByCustomTicks, calculateTickIntervalByCustomTicks, dateToMilliseconds, calculateTicks(addIntervalDate, correctMinValueByEndOnTick(floor, function (value, interval) {\n    var newValue = floor(value, interval);\n\n    while (value - newValue > 0) {\n      newValue = addIntervalDate(newValue, interval);\n    }\n\n    return newValue;\n  }, resolveEndOnTickDate, options.endOnTick), adjustIntervalDateTime, resolveEndOnTickDate), calculateMinorTicks(getValue, addIntervalDate, floor, addIntervalDate, getValue), getScaleBreaksProcessor(dateToMilliseconds, getValue, function (value, correction) {\n    return new Date(value.getTime() + correction);\n  }));\n}\n\nexport var tickGenerator = function tickGenerator(options) {\n  var result;\n\n  if (options.rangeIsEmpty) {\n    result = dummyGenerator(options);\n  } else if (\"discrete\" === options.axisType) {\n    result = discreteGenerator(options);\n  } else if (\"logarithmic\" === options.axisType) {\n    result = logarithmicGenerator(options);\n  } else if (\"datetime\" === options.dataType) {\n    result = dateGenerator(options);\n  } else {\n    result = numericGenerator(options);\n  }\n\n  return result;\n};","map":null,"metadata":{},"sourceType":"module"}