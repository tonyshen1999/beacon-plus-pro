{"ast":null,"code":"/**\r\n * DevExtreme (esm/viz/series/points/symbol_point.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { extend } from \"../../../core/utils/extend\";\nimport { each } from \"../../../core/utils/iterator\";\nimport { noop } from \"../../../core/utils/common\";\nimport { getWindow, hasProperty } from \"../../../core/utils/window\";\nvar window = getWindow();\nimport { Label } from \"./label\";\nvar _extend = extend;\nimport { isDefined as _isDefined } from \"../../../core/utils/type\";\nimport { normalizeEnum as _normalizeEnum } from \"../../core/utils\";\nvar _math = Math;\nvar _round = _math.round;\nvar _floor = _math.floor;\nvar _ceil = _math.ceil;\nvar DEFAULT_IMAGE_WIDTH = 20;\nvar DEFAULT_IMAGE_HEIGHT = 20;\nvar LABEL_OFFSET = 10;\nvar CANVAS_POSITION_DEFAULT = \"canvas_position_default\";\n\nfunction getSquareMarkerCoords(radius) {\n  return [-radius, -radius, radius, -radius, radius, radius, -radius, radius, -radius, -radius];\n}\n\nfunction getPolygonMarkerCoords(radius) {\n  var r = _ceil(radius);\n\n  return [-r, 0, 0, -r, r, 0, 0, r, -r, 0];\n}\n\nfunction getCrossMarkerCoords(radius) {\n  var r = _ceil(radius);\n\n  var floorHalfRadius = _floor(r / 2);\n\n  var ceilHalfRadius = _ceil(r / 2);\n\n  return [-r, -floorHalfRadius, -floorHalfRadius, -r, 0, -ceilHalfRadius, floorHalfRadius, -r, r, -floorHalfRadius, ceilHalfRadius, 0, r, floorHalfRadius, floorHalfRadius, r, 0, ceilHalfRadius, -floorHalfRadius, r, -r, floorHalfRadius, -ceilHalfRadius, 0];\n}\n\nfunction getTriangleDownMarkerCoords(radius) {\n  return [-radius, -radius, radius, -radius, 0, radius, -radius, -radius];\n}\n\nfunction getTriangleUpMarkerCoords(radius) {\n  return [-radius, radius, radius, radius, 0, -radius, -radius, radius];\n}\n\nexport default {\n  deleteLabel: function deleteLabel() {\n    this._label.dispose();\n\n    this._label = null;\n  },\n  _hasGraphic: function _hasGraphic() {\n    return this.graphic;\n  },\n  clearVisibility: function clearVisibility() {\n    var graphic = this.graphic;\n\n    if (graphic && graphic.attr(\"visibility\")) {\n      graphic.attr({\n        visibility: null\n      });\n    }\n  },\n  isVisible: function isVisible() {\n    return this.inVisibleArea && this.series.isVisible();\n  },\n  setInvisibility: function setInvisibility() {\n    var graphic = this.graphic;\n\n    if (graphic && \"hidden\" !== graphic.attr(\"visibility\")) {\n      graphic.attr({\n        visibility: \"hidden\"\n      });\n    }\n\n    this._errorBar && this._errorBar.attr({\n      visibility: \"hidden\"\n    });\n\n    this._label.draw(false);\n  },\n  clearMarker: function clearMarker() {\n    var graphic = this.graphic;\n    graphic && graphic.attr(this._emptySettings);\n  },\n  _createLabel: function _createLabel() {\n    this._label = new Label({\n      renderer: this.series._renderer,\n      labelsGroup: this.series._labelsGroup,\n      point: this\n    });\n  },\n  _updateLabelData: function _updateLabelData() {\n    this._label.setData(this._getLabelFormatObject());\n  },\n  _updateLabelOptions: function _updateLabelOptions() {\n    !this._label && this._createLabel();\n\n    this._label.setOptions(this._options.label);\n  },\n  _checkImage: function _checkImage(image) {\n    return _isDefined(image) && (\"string\" === typeof image || _isDefined(image.url));\n  },\n  _fillStyle: function _fillStyle() {\n    this._styles = this._options.styles;\n  },\n  _checkSymbol: function _checkSymbol(oldOptions, newOptions) {\n    var oldSymbol = oldOptions.symbol;\n    var newSymbol = newOptions.symbol;\n    var symbolChanged = \"circle\" === oldSymbol && \"circle\" !== newSymbol || \"circle\" !== oldSymbol && \"circle\" === newSymbol;\n\n    var imageChanged = this._checkImage(oldOptions.image) !== this._checkImage(newOptions.image);\n\n    return !!(symbolChanged || imageChanged);\n  },\n  _populatePointShape: function _populatePointShape(symbol, radius) {\n    switch (symbol) {\n      case \"square\":\n        return getSquareMarkerCoords(radius);\n\n      case \"polygon\":\n        return getPolygonMarkerCoords(radius);\n\n      case \"triangle\":\n      case \"triangleDown\":\n        return getTriangleDownMarkerCoords(radius);\n\n      case \"triangleUp\":\n        return getTriangleUpMarkerCoords(radius);\n\n      case \"cross\":\n        return getCrossMarkerCoords(radius);\n    }\n  },\n  hasCoords: function hasCoords() {\n    return null !== this.x && null !== this.y;\n  },\n  correctValue: function correctValue(correction) {\n    var axis = this.series.getValueAxis();\n\n    if (this.hasValue()) {\n      this.value = this.properValue = axis.validateUnit(this.initialValue.valueOf() + correction.valueOf());\n      this.minValue = axis.validateUnit(correction);\n    }\n  },\n  resetCorrection: function resetCorrection() {\n    this.value = this.properValue = this.initialValue;\n    this.minValue = CANVAS_POSITION_DEFAULT;\n  },\n  resetValue: function resetValue() {\n    if (this.hasValue()) {\n      this.value = this.properValue = this.initialValue = 0;\n      this.minValue = 0;\n\n      this._label.setDataField(\"value\", this.value);\n    }\n  },\n  _getTranslates: function _getTranslates(animationEnabled) {\n    var translateX = this.x;\n    var translateY = this.y;\n\n    if (animationEnabled) {\n      if (this._options.rotated) {\n        translateX = this.defaultX;\n      } else {\n        translateY = this.defaultY;\n      }\n    }\n\n    return {\n      x: translateX,\n      y: translateY\n    };\n  },\n  _createImageMarker: function _createImageMarker(renderer, settings, options) {\n    var width = options.width || DEFAULT_IMAGE_WIDTH;\n    var height = options.height || DEFAULT_IMAGE_HEIGHT;\n    return renderer.image(-_round(.5 * width), -_round(.5 * height), width, height, options.url ? options.url.toString() : options.toString(), \"center\").attr({\n      translateX: settings.translateX,\n      translateY: settings.translateY,\n      visibility: settings.visibility\n    });\n  },\n  _createSymbolMarker: function _createSymbolMarker(renderer, pointSettings) {\n    var marker;\n    var symbol = this._options.symbol;\n\n    if (\"circle\" === symbol) {\n      delete pointSettings.points;\n      marker = renderer.circle().attr(pointSettings);\n    } else if (\"square\" === symbol || \"polygon\" === symbol || \"triangle\" === symbol || \"triangleDown\" === symbol || \"triangleUp\" === symbol || \"cross\" === symbol) {\n      marker = renderer.path([], \"area\").attr(pointSettings).sharp();\n    }\n\n    return marker;\n  },\n  _createMarker: function _createMarker(renderer, group, image, settings) {\n    var marker = this._checkImage(image) ? this._createImageMarker(renderer, settings, image) : this._createSymbolMarker(renderer, settings);\n\n    if (marker) {\n      marker.data({\n        \"chart-data-point\": this\n      }).append(group);\n    }\n\n    return marker;\n  },\n  _getSymbolBBox: function _getSymbolBBox(x, y, r) {\n    return {\n      x: x - r,\n      y: y - r,\n      width: 2 * r,\n      height: 2 * r\n    };\n  },\n  _getImageBBox: function _getImageBBox(x, y) {\n    var image = this._options.image;\n    var width = image.width || DEFAULT_IMAGE_WIDTH;\n    var height = image.height || DEFAULT_IMAGE_HEIGHT;\n    return {\n      x: x - _round(width / 2),\n      y: y - _round(height / 2),\n      width: width,\n      height: height\n    };\n  },\n  _getGraphicBBox: function _getGraphicBBox() {\n    var options = this._options;\n    var x = this.x;\n    var y = this.y;\n    var bBox;\n\n    if (options.visible) {\n      bBox = this._checkImage(options.image) ? this._getImageBBox(x, y) : this._getSymbolBBox(x, y, options.styles.normal.r);\n    } else {\n      bBox = {\n        x: x,\n        y: y,\n        width: 0,\n        height: 0\n      };\n    }\n\n    return bBox;\n  },\n  hideInsideLabel: noop,\n  _getShiftLabelCoords: function _getShiftLabelCoords(label) {\n    var coord = this._addLabelAlignmentAndOffset(label, this._getLabelCoords(label));\n\n    return this._checkLabelPosition(label, coord);\n  },\n  _drawLabel: function _drawLabel() {\n    var customVisibility = this._getCustomLabelVisibility();\n\n    var label = this._label;\n    var isVisible = this._showForZeroValues() && this.hasValue() && false !== customVisibility && (this.series.getLabelVisibility() || customVisibility);\n    label.draw(!!isVisible);\n  },\n  correctLabelPosition: function correctLabelPosition(label) {\n    var coord = this._getShiftLabelCoords(label);\n\n    if (!this.hideInsideLabel(label, coord)) {\n      label.setFigureToDrawConnector(this._getLabelConnector(label.pointPosition));\n      label.shift(_round(coord.x), _round(coord.y));\n    }\n  },\n  _showForZeroValues: function _showForZeroValues() {\n    return true;\n  },\n  _getLabelConnector: function _getLabelConnector(pointPosition) {\n    var bBox = this._getGraphicBBox(pointPosition);\n\n    var w2 = bBox.width / 2;\n    var h2 = bBox.height / 2;\n    return {\n      x: bBox.x + w2,\n      y: bBox.y + h2,\n      r: this._options.visible ? Math.max(w2, h2) : 0\n    };\n  },\n  _getPositionFromLocation: function _getPositionFromLocation() {\n    return {\n      x: this.x,\n      y: this.y\n    };\n  },\n  _isPointInVisibleArea: function _isPointInVisibleArea(visibleArea, graphicBBox) {\n    return visibleArea.minX <= graphicBBox.x + graphicBBox.width && visibleArea.maxX >= graphicBBox.x && visibleArea.minY <= graphicBBox.y + graphicBBox.height && visibleArea.maxY >= graphicBBox.y;\n  },\n  _checkLabelPosition: function _checkLabelPosition(label, coord) {\n    var visibleArea = this._getVisibleArea();\n\n    var labelBBox = label.getBoundingRect();\n\n    var graphicBBox = this._getGraphicBBox(label.pointPosition);\n\n    var fullGraphicBBox = this._getGraphicBBox();\n\n    var isInside = \"inside\" === label.getLayoutOptions().position;\n    var offset = LABEL_OFFSET;\n\n    if (this._isPointInVisibleArea(visibleArea, fullGraphicBBox)) {\n      if (!this._options.rotated) {\n        if (visibleArea.minX > coord.x) {\n          coord.x = visibleArea.minX;\n        }\n\n        if (visibleArea.maxX < coord.x + labelBBox.width) {\n          coord.x = visibleArea.maxX - labelBBox.width;\n        }\n\n        if (visibleArea.minY > coord.y) {\n          coord.y = isInside ? visibleArea.minY : graphicBBox.y + graphicBBox.height + offset;\n        }\n\n        if (visibleArea.maxY < coord.y + labelBBox.height) {\n          coord.y = isInside ? visibleArea.maxY - labelBBox.height : graphicBBox.y - labelBBox.height - offset;\n        }\n      } else {\n        if (visibleArea.minX > coord.x) {\n          coord.x = isInside ? visibleArea.minX : graphicBBox.x + graphicBBox.width + offset;\n        }\n\n        if (visibleArea.maxX < coord.x + labelBBox.width) {\n          coord.x = isInside ? visibleArea.maxX - labelBBox.width : graphicBBox.x - offset - labelBBox.width;\n        }\n\n        if (visibleArea.minY > coord.y) {\n          coord.y = visibleArea.minY;\n        }\n\n        if (visibleArea.maxY < coord.y + labelBBox.height) {\n          coord.y = visibleArea.maxY - labelBBox.height;\n        }\n      }\n    }\n\n    return coord;\n  },\n  _addLabelAlignmentAndOffset: function _addLabelAlignmentAndOffset(label, coord) {\n    var labelBBox = label.getBoundingRect();\n    var labelOptions = label.getLayoutOptions();\n\n    if (!this._options.rotated) {\n      if (\"left\" === labelOptions.alignment) {\n        coord.x += labelBBox.width / 2;\n      } else if (\"right\" === labelOptions.alignment) {\n        coord.x -= labelBBox.width / 2;\n      }\n    }\n\n    coord.x += labelOptions.horizontalOffset;\n    coord.y += labelOptions.verticalOffset;\n    return coord;\n  },\n  _getLabelCoords: function _getLabelCoords(label) {\n    return this._getLabelCoordOfPosition(label, this._getLabelPosition(label.pointPosition));\n  },\n  _getLabelCoordOfPosition: function _getLabelCoordOfPosition(label, position) {\n    var labelBBox = label.getBoundingRect();\n\n    var graphicBBox = this._getGraphicBBox(label.pointPosition);\n\n    var offset = LABEL_OFFSET;\n    var centerY = graphicBBox.height / 2 - labelBBox.height / 2;\n    var centerX = graphicBBox.width / 2 - labelBBox.width / 2;\n    var x = graphicBBox.x;\n    var y = graphicBBox.y;\n\n    switch (position) {\n      case \"left\":\n        x -= labelBBox.width + offset;\n        y += centerY;\n        break;\n\n      case \"right\":\n        x += graphicBBox.width + offset;\n        y += centerY;\n        break;\n\n      case \"top\":\n        x += centerX;\n        y -= labelBBox.height + offset;\n        break;\n\n      case \"bottom\":\n        x += centerX;\n        y += graphicBBox.height + offset;\n        break;\n\n      case \"inside\":\n        x += centerX;\n        y += centerY;\n    }\n\n    return {\n      x: x,\n      y: y\n    };\n  },\n  _drawMarker: function _drawMarker(renderer, group, animationEnabled) {\n    var options = this._options;\n\n    var translates = this._getTranslates(animationEnabled);\n\n    var style = this._getStyle();\n\n    this.graphic = this._createMarker(renderer, group, options.image, _extend({\n      translateX: translates.x,\n      translateY: translates.y,\n      points: this._populatePointShape(options.symbol, style.r)\n    }, style));\n  },\n  _getErrorBarSettings: function _getErrorBarSettings() {\n    return {\n      visibility: \"visible\"\n    };\n  },\n  _getErrorBarBaseEdgeLength: function _getErrorBarBaseEdgeLength() {\n    return 2 * this.getPointRadius();\n  },\n  _drawErrorBar: function _drawErrorBar(renderer, group) {\n    if (!this._options.errorBars) {\n      return;\n    }\n\n    var options = this._options;\n    var errorBarOptions = options.errorBars;\n    var points = [];\n    var settings;\n    var pos = this._errorBarPos;\n    var high = this._highErrorCoord;\n    var low = this._lowErrorCoord;\n\n    var displayMode = _normalizeEnum(errorBarOptions.displayMode);\n\n    var isHighDisplayMode = \"high\" === displayMode;\n    var isLowDisplayMode = \"low\" === displayMode;\n    var highErrorOnly = (isHighDisplayMode || !_isDefined(low)) && _isDefined(high) && !isLowDisplayMode;\n    var lowErrorOnly = (isLowDisplayMode || !_isDefined(high)) && _isDefined(low) && !isHighDisplayMode;\n    var edgeLength = errorBarOptions.edgeLength;\n\n    if (edgeLength <= 1 && edgeLength > 0) {\n      edgeLength = this._getErrorBarBaseEdgeLength() * errorBarOptions.edgeLength;\n    }\n\n    edgeLength = _floor(parseInt(edgeLength) / 2);\n    highErrorOnly && (low = this._baseErrorBarPos);\n    lowErrorOnly && (high = this._baseErrorBarPos);\n\n    if (\"none\" !== displayMode && _isDefined(high) && _isDefined(low) && _isDefined(pos)) {\n      !lowErrorOnly && points.push([pos - edgeLength, high, pos + edgeLength, high]);\n      points.push([pos, high, pos, low]);\n      !highErrorOnly && points.push([pos + edgeLength, low, pos - edgeLength, low]);\n      options.rotated && each(points, function (_, p) {\n        p.reverse();\n      });\n      settings = this._getErrorBarSettings(errorBarOptions);\n\n      if (!this._errorBar) {\n        this._errorBar = renderer.path(points, \"line\").attr(settings).append(group);\n      } else {\n        settings.points = points;\n\n        this._errorBar.attr(settings);\n      }\n    } else {\n      this._errorBar && this._errorBar.attr({\n        visibility: \"hidden\"\n      });\n    }\n  },\n  getTooltipParams: function getTooltipParams() {\n    var graphic = this.graphic;\n    return {\n      x: this.x,\n      y: this.y,\n      offset: graphic ? graphic.getBBox().height / 2 : 0\n    };\n  },\n  setPercentValue: function setPercentValue(absTotal, total, leftHoleTotal, rightHoleTotal) {\n    var valuePercent = this.value / absTotal || 0;\n    var minValuePercent = this.minValue / absTotal || 0;\n    var percent = valuePercent - minValuePercent;\n\n    this._label.setDataField(\"percent\", percent);\n\n    this._label.setDataField(\"total\", total);\n\n    if (this.series.isFullStackedSeries() && this.hasValue()) {\n      if (this.leftHole) {\n        this.leftHole /= absTotal - leftHoleTotal;\n        this.minLeftHole /= absTotal - leftHoleTotal;\n      }\n\n      if (this.rightHole) {\n        this.rightHole /= absTotal - rightHoleTotal;\n        this.minRightHole /= absTotal - rightHoleTotal;\n      }\n\n      this.value = this.properValue = valuePercent;\n      this.minValue = !minValuePercent ? this.minValue : minValuePercent;\n    }\n  },\n  _storeTrackerR: function _storeTrackerR() {\n    var navigator = window.navigator;\n    var r = this._options.styles.normal.r;\n    var minTrackerSize = hasProperty(\"ontouchstart\") || navigator.msPointerEnabled && navigator.msMaxTouchPoints || navigator.pointerEnabled && navigator.maxTouchPoints ? 20 : 6;\n    this._options.trackerR = r < minTrackerSize ? minTrackerSize : r;\n    return this._options.trackerR;\n  },\n  _translateErrorBars: function _translateErrorBars() {\n    var options = this._options;\n    var rotated = options.rotated;\n    var errorBars = options.errorBars;\n\n    var translator = this._getValTranslator();\n\n    if (!errorBars) {\n      return;\n    }\n\n    _isDefined(this.lowError) && (this._lowErrorCoord = translator.translate(this.lowError));\n    _isDefined(this.highError) && (this._highErrorCoord = translator.translate(this.highError));\n    this._errorBarPos = _floor(rotated ? this.vy : this.vx);\n    this._baseErrorBarPos = \"stdDeviation\" === errorBars.type ? this._lowErrorCoord + (this._highErrorCoord - this._lowErrorCoord) / 2 : rotated ? this.vx : this.vy;\n  },\n  _translate: function _translate() {\n    var valTranslator = this._getValTranslator();\n\n    var argTranslator = this._getArgTranslator();\n\n    if (this._options.rotated) {\n      this.vx = this.x = valTranslator.translate(this.value);\n      this.vy = this.y = argTranslator.translate(this.argument);\n      this.minX = valTranslator.translate(this.minValue);\n      this.defaultX = valTranslator.translate(CANVAS_POSITION_DEFAULT);\n    } else {\n      this.vy = this.y = valTranslator.translate(this.value);\n      this.vx = this.x = argTranslator.translate(this.argument);\n      this.minY = valTranslator.translate(this.minValue);\n      this.defaultY = valTranslator.translate(CANVAS_POSITION_DEFAULT);\n    }\n\n    this._translateErrorBars();\n\n    this._calculateVisibility(this.x, this.y);\n  },\n  _updateData: function _updateData(data) {\n    this.value = this.properValue = this.initialValue = this.originalValue = data.value;\n    this.minValue = this.initialMinValue = this.originalMinValue = _isDefined(data.minValue) ? data.minValue : CANVAS_POSITION_DEFAULT;\n  },\n  _getImageSettings: function _getImageSettings(image) {\n    return {\n      href: image.url || image.toString(),\n      width: image.width || DEFAULT_IMAGE_WIDTH,\n      height: image.height || DEFAULT_IMAGE_HEIGHT\n    };\n  },\n  getCrosshairData: function getCrosshairData() {\n    var r = this._options.rotated;\n    var value = this.properValue;\n    var argument = this.argument;\n    return {\n      x: this.vx,\n      y: this.vy,\n      xValue: r ? value : argument,\n      yValue: r ? argument : value,\n      axis: this.series.axis\n    };\n  },\n  getPointRadius: function getPointRadius() {\n    var style = this._getStyle();\n\n    var options = this._options;\n    var r = style.r;\n    var extraSpace;\n    var symbol = options.symbol;\n    var isSquare = \"square\" === symbol;\n    var isTriangle = \"triangle\" === symbol || \"triangleDown\" === symbol || \"triangleUp\" === symbol;\n\n    if (options.visible && !options.image && r) {\n      extraSpace = style[\"stroke-width\"] / 2;\n      return (isSquare || isTriangle ? 1.4 * r : r) + extraSpace;\n    }\n\n    return 0;\n  },\n  _updateMarker: function _updateMarker(animationEnabled, style) {\n    var options = this._options;\n    var settings;\n    var image = options.image;\n    var visibility = !this.isVisible() ? {\n      visibility: \"hidden\"\n    } : {};\n\n    if (this._checkImage(image)) {\n      settings = _extend({}, {\n        visibility: style.visibility\n      }, visibility, this._getImageSettings(image));\n    } else {\n      settings = _extend({}, style, visibility, {\n        points: this._populatePointShape(options.symbol, style.r)\n      });\n    }\n\n    if (!animationEnabled) {\n      settings.translateX = this.x;\n      settings.translateY = this.y;\n    }\n\n    this.graphic.attr(settings).sharp();\n  },\n  _getLabelFormatObject: function _getLabelFormatObject() {\n    return {\n      argument: this.initialArgument,\n      value: this.initialValue,\n      originalArgument: this.originalArgument,\n      originalValue: this.originalValue,\n      seriesName: this.series.name,\n      lowErrorValue: this.lowError,\n      highErrorValue: this.highError,\n      point: this\n    };\n  },\n  _getLabelPosition: function _getLabelPosition() {\n    var rotated = this._options.rotated;\n\n    if (this.initialValue > 0) {\n      return rotated ? \"right\" : \"top\";\n    } else {\n      return rotated ? \"left\" : \"bottom\";\n    }\n  },\n  _getFormatObject: function _getFormatObject(tooltip) {\n    var labelFormatObject = this._label.getData();\n\n    return _extend({}, labelFormatObject, {\n      argumentText: tooltip.formatValue(this.initialArgument, \"argument\"),\n      valueText: tooltip.formatValue(this.initialValue)\n    }, _isDefined(labelFormatObject.percent) ? {\n      percentText: tooltip.formatValue(labelFormatObject.percent, \"percent\")\n    } : {}, _isDefined(labelFormatObject.total) ? {\n      totalText: tooltip.formatValue(labelFormatObject.total)\n    } : {});\n  },\n  getMarkerVisibility: function getMarkerVisibility() {\n    return this._options.visible;\n  },\n  coordsIn: function coordsIn(x, y) {\n    var trackerRadius = this._storeTrackerR();\n\n    return x >= this.x - trackerRadius && x <= this.x + trackerRadius && y >= this.y - trackerRadius && y <= this.y + trackerRadius;\n  },\n  getMinValue: function getMinValue(noErrorBar) {\n    var errorBarOptions = this._options.errorBars;\n\n    if (errorBarOptions && !noErrorBar) {\n      var displayMode = errorBarOptions.displayMode;\n      var lowValue = \"high\" !== displayMode && _isDefined(this.lowError) ? this.lowError : this.value;\n      var highValue = \"low\" !== displayMode && _isDefined(this.highError) ? this.highError : this.value;\n      return lowValue < highValue ? lowValue : highValue;\n    } else {\n      return this.value;\n    }\n  },\n  getMaxValue: function getMaxValue(noErrorBar) {\n    var errorBarOptions = this._options.errorBars;\n\n    if (errorBarOptions && !noErrorBar) {\n      var displayMode = errorBarOptions.displayMode;\n      var lowValue = \"high\" !== displayMode && _isDefined(this.lowError) ? this.lowError : this.value;\n      var highValue = \"low\" !== displayMode && _isDefined(this.highError) ? this.highError : this.value;\n      return lowValue > highValue ? lowValue : highValue;\n    } else {\n      return this.value;\n    }\n  }\n};","map":null,"metadata":{},"sourceType":"module"}