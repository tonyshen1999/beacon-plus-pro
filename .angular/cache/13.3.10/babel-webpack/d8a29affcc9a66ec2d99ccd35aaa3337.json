{"ast":null,"code":"import _toConsumableArray from \"/Users/tonyshen/beacon-pro/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\n\n/**\r\n * DevExtreme (esm/renovation/ui/common/utils/get_updated_options.js)\r\n * Version: 21.2.6\r\n * Build date: Tue Mar 01 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { isPlainObject, type } from \"../../../../core/utils/type\";\nvar defaultNotDeepCopyArrays = [\"dataSource\", \"selectedRowKeys\"];\nvar propsToIgnore = {\n  integrationOptions: true\n};\n\nfunction getDiffItem(key, value, previousValue) {\n  return {\n    path: key,\n    value: value,\n    previousValue: previousValue\n  };\n}\n\nfunction compare(resultPaths, item1, item2, key, fullPropName, notDeepCopyArrays) {\n  if (propsToIgnore[key]) {\n    return;\n  }\n\n  var type1 = type(item1);\n  var type2 = type(item2);\n\n  if (item1 === item2) {\n    return;\n  }\n\n  if (type1 !== type2) {\n    resultPaths.push(getDiffItem(key, item2, item1));\n  } else if (\"object\" === type1) {\n    if (!isPlainObject(item2)) {\n      resultPaths.push(getDiffItem(key, item2, item1));\n    } else {\n      var diffPaths = objectDiffs(item1, item2, fullPropName, notDeepCopyArrays);\n      resultPaths.push.apply(resultPaths, _toConsumableArray(diffPaths.map(function (item) {\n        return _extends({}, item, {\n          path: \"\".concat(key, \".\").concat(item.path)\n        });\n      })));\n    }\n  } else if (\"array\" === type1) {\n    var notDeepCopy = notDeepCopyArrays.some(function (prop) {\n      return fullPropName.includes(prop);\n    });\n\n    if (notDeepCopy && item1 !== item2) {\n      resultPaths.push(getDiffItem(key, item2, item1));\n    } else if (item1.length !== item2.length) {\n      resultPaths.push(getDiffItem(key, item2, item1));\n    } else {\n      var _diffPaths = objectDiffs(item1, item2, fullPropName, notDeepCopyArrays);\n\n      [].push.apply(resultPaths, _diffPaths.map(function (item) {\n        return _extends({}, item, {\n          path: \"\".concat(key).concat(item.path)\n        });\n      }));\n    }\n  } else {\n    resultPaths.push(getDiffItem(key, item2, item1));\n  }\n}\n\nvar objectDiffsFiltered = function objectDiffsFiltered(propsEnumerator) {\n  return function (oldProps, props, fullPropName, notDeepCopyArrays) {\n    var resultPaths = [];\n    var processItem = !Array.isArray(oldProps) ? function (propName) {\n      compare(resultPaths, oldProps[propName], props[propName], propName, \"\".concat(fullPropName, \".\").concat(propName), notDeepCopyArrays);\n    } : function (propName) {\n      compare(resultPaths, oldProps[propName], props[propName], \"[\".concat(propName, \"]\"), \"\".concat(fullPropName, \".\").concat(propName), notDeepCopyArrays);\n    };\n    propsEnumerator(oldProps).forEach(processItem);\n    Object.keys(props).filter(function (propName) {\n      return !Object.prototype.hasOwnProperty.call(oldProps, propName) && oldProps[propName] !== props[propName];\n    }).forEach(function (propName) {\n      resultPaths.push({\n        path: propName,\n        value: props[propName],\n        previousValue: oldProps[propName]\n      });\n    });\n    return resultPaths;\n  };\n};\n\nvar objectDiffs = objectDiffsFiltered(function (oldProps) {\n  return Object.keys(oldProps);\n});\nvar reactProps = {\n  key: true,\n  ref: true,\n  children: true,\n  style: true\n};\nvar objectDiffsWithoutReactProps = objectDiffsFiltered(function (prop) {\n  return Object.keys(prop).filter(function (p) {\n    return !reactProps[p];\n  });\n});\nexport function getUpdatedOptions(oldProps, props) {\n  var notDeepCopyArrays = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : defaultNotDeepCopyArrays;\n  return objectDiffsWithoutReactProps(oldProps, props, \"\", notDeepCopyArrays);\n}","map":null,"metadata":{},"sourceType":"module"}